"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6283],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>s,MDXProvider:()=>p,mdx:()=>f,useMDXComponents:()=>m,withMDXComponents:()=>u});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(){return l=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},l.apply(this,arguments)}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function d(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)t=l[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),u=function(e){return function(n){var t=m(n.components);return r.createElement(e,l({},n,{components:t}))}},m=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=m(e.components);return r.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},x=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,i=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),u=m(t),p=a,x=u["".concat(i,".").concat(p)]||u[p]||c[p]||l;return t?r.createElement(x,o(o({ref:n},s),{},{components:t})):r.createElement(x,o({ref:n},s))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,i=new Array(l);i[0]=x;var o={};for(var d in n)hasOwnProperty.call(n,d)&&(o[d]=n[d]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var s=2;s<l;s++)i[s]=t[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}x.displayName="MDXCreateElement"},85162:(e,n,t)=>{t.r(n),t.d(n,{default:()=>i});var r=t(67294),a=t(86010);const l="tabItem_Ymn6";function i(e){let{children:n,hidden:t,className:i}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.default)(l,i),hidden:t},n)}},74866:(e,n,t)=>{t.r(n),t.d(n,{default:()=>C});var r=t(83117),a=t(67294),l=t(86010),i=t(12466),o=t(76775),d=t(91980),s=t(67392),u=t(50012);function m(e){return function(e){var n,t;return null!=(n=null==(t=a.Children.map(e,(e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:a}}=e;return{value:n,label:t,attributes:r,default:a}}))}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:m(t);return function(e){const n=(0,s.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function c(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function x(e){let{queryString:n=!1,groupId:t}=e;const r=(0,o.k6)(),l=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,d._X)(l),(0,a.useCallback)((e=>{if(!l)return;const n=new URLSearchParams(r.location.search);n.set(l,e),r.replace({...r.location,search:n.toString()})}),[l,r])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,l=p(e),[i,o]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!c({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=r.find((e=>e.default)))?n:r[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:l}))),[d,s]=x({queryString:t,groupId:r}),[m,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,l]=(0,u.Nk)(t);return[r,(0,a.useCallback)((e=>{t&&l.set(e)}),[t,l])]}({groupId:r}),h=(()=>{const e=null!=d?d:m;return c({value:e,tabValues:l})?e:null})();(0,a.useLayoutEffect)((()=>{h&&o(h)}),[h]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!c({value:e,tabValues:l}))throw new Error("Can't select invalid tab value="+e);o(e),s(e),f(e)}),[s,f,l]),tabValues:l}}var h=t(72389);const v="tabList__CuJ",b="tabItem_LNqP";function g(e){let{className:n,block:t,selectedValue:o,selectValue:d,tabValues:s}=e;const u=[],{blockElementScrollPositionUntilNextRender:m}=(0,i.o5)(),p=e=>{const n=e.currentTarget,t=u.indexOf(n),r=s[t].value;r!==o&&(m(n),d(r))},c=e=>{var n;let t=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{var r;const n=u.indexOf(e.currentTarget)+1;t=null!=(r=u[n])?r:u[0];break}case"ArrowLeft":{var a;const n=u.indexOf(e.currentTarget)-1;t=null!=(a=u[n])?a:u[u.length-1];break}}null==(n=t)||n.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.default)("tabs",{"tabs--block":t},n)},s.map((e=>{let{value:n,label:t,attributes:i}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:o===n?0:-1,"aria-selected":o===n,key:n,ref:e=>u.push(e),onKeyDown:c,onClick:p},i,{className:(0,l.default)("tabs__item",b,null==i?void 0:i.className,{"tabs__item--active":o===n})}),null!=t?t:n)})))}function N(e){let{lazy:n,children:t,selectedValue:r}=e;const l=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=l.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},l.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r}))))}function y(e){const n=f(e);return a.createElement("div",{className:(0,l.default)("tabs-container",v)},a.createElement(g,(0,r.Z)({},e,n)),a.createElement(N,(0,r.Z)({},e,n)))}function C(e){const n=(0,h.default)();return a.createElement(y,(0,r.Z)({key:String(n)},e))}},97882:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>m});var r=t(83117),a=(t(67294),t(3905)),l=t(74866),i=t(85162);const o={},d="LineLog",s={unversionedId:"internals/linelog",id:"internals/linelog",title:"LineLog",description:"LineLog is an implementation of interleaved deltas.",source:"@site/docs/internals/linelog.md",sourceDirName:"internals",slug:"/internals/linelog",permalink:"/docs/internals/linelog",draft:!1,editUrl:"https://github.com/facebookexperimental/eden/tree/main/website/docs/internals/linelog.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Internal differences from Mercurial",permalink:"/docs/internals/internal-difference-hg"},next:{title:"MetaLog",permalink:"/docs/internals/metalog"}},u={},m=[{value:"Bytecode",id:"bytecode",level:2},{value:"Interpretation",id:"interpretation",level:2},{value:"Example",id:"example",level:3},{value:"Checkout and annotate",id:"checkout-and-annotate",level:3},{value:"Range of revisions",id:"range-of-revisions",level:3},{value:"Linear history",id:"linear-history",level:3},{value:"Editing LineLog",id:"editing-linelog",level:2}],p={toc:m};function c(e){let{components:n,...t}=e;return(0,a.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("h1",{id:"linelog"},"LineLog"),(0,a.mdx)("p",null,"LineLog is an implementation of ",(0,a.mdx)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Interleaved_deltas"},"interleaved deltas"),".\nIt provides conflict-free stack editing ability. It is used by the ",(0,a.mdx)("inlineCode",{parentName:"p"},"absorb"),"\ncommand."),(0,a.mdx)("h2",{id:"bytecode"},"Bytecode"),(0,a.mdx)("p",null,"LineLog uses a bytecode format that is interpreted to produce content.\nThere are 5 instructions:"),(0,a.mdx)("table",null,(0,a.mdx)("thead",{parentName:"table"},(0,a.mdx)("tr",{parentName:"thead"},(0,a.mdx)("th",{parentName:"tr",align:null},"Name"),(0,a.mdx)("th",{parentName:"tr",align:null},"Operand 1"),(0,a.mdx)("th",{parentName:"tr",align:null},"Operand 2"),(0,a.mdx)("th",{parentName:"tr",align:null},"Meaning"))),(0,a.mdx)("tbody",{parentName:"table"},(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"JGE"),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Rev")),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")),(0,a.mdx)("td",{parentName:"tr",align:null},"Jump to ",(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")," if ",(0,a.mdx)("inlineCode",{parentName:"td"},"Current Rev")," >= ",(0,a.mdx)("inlineCode",{parentName:"td"},"Rev"))),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"J"),(0,a.mdx)("td",{parentName:"tr",align:null},"0"),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")),(0,a.mdx)("td",{parentName:"tr",align:null},"Jump to ",(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")," unconditionally")),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"JL"),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Rev")),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")),(0,a.mdx)("td",{parentName:"tr",align:null},"Jump to ",(0,a.mdx)("inlineCode",{parentName:"td"},"Addr")," if ",(0,a.mdx)("inlineCode",{parentName:"td"},"Current Rev")," < ",(0,a.mdx)("inlineCode",{parentName:"td"},"Rev"))),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"LINE"),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Rev")),(0,a.mdx)("td",{parentName:"tr",align:null},(0,a.mdx)("inlineCode",{parentName:"td"},"Line")),(0,a.mdx)("td",{parentName:"tr",align:null},"Append the ",(0,a.mdx)("inlineCode",{parentName:"td"},"Line + 1"),"-th line in ",(0,a.mdx)("inlineCode",{parentName:"td"},"Rev"))),(0,a.mdx)("tr",{parentName:"tbody"},(0,a.mdx)("td",{parentName:"tr",align:null},"END"),(0,a.mdx)("td",{parentName:"tr",align:null},"-"),(0,a.mdx)("td",{parentName:"tr",align:null},"-"),(0,a.mdx)("td",{parentName:"tr",align:null},"Stop execution")))),(0,a.mdx)("p",null,"Instructions are fixed-sized. The opcode takes 2 bits. ",(0,a.mdx)("inlineCode",{parentName:"p"},"J")," and ",(0,a.mdx)("inlineCode",{parentName:"p"},"JGE")," share the\nsame opcode (",(0,a.mdx)("inlineCode",{parentName:"p"},"J Addr")," is just ",(0,a.mdx)("inlineCode",{parentName:"p"},"JGE 0 Addr"),"). Operand 1 takes 30 bits. Operand 2\ntakes 32 bits."),(0,a.mdx)("h2",{id:"interpretation"},"Interpretation"),(0,a.mdx)("h3",{id:"example"},"Example"),(0,a.mdx)("p",null,"It is easier to understand with an example. Given a file with 3 revisions:"),(0,a.mdx)("div",{className:"row"},(0,a.mdx)("div",{className:"col col--4"},"Rev 1",(0,a.mdx)("pre",null,"a",(0,a.mdx)("br",null),"b",(0,a.mdx)("br",null),"c")),(0,a.mdx)("div",{className:"col col--4"},"Rev 2: Inserted 2 lines.",(0,a.mdx)("pre",null,"a",(0,a.mdx)("br",null),"b",(0,a.mdx)("br",null),"1",(0,a.mdx)("br",null),"2",(0,a.mdx)("br",null),"c")),(0,a.mdx)("div",{className:"col col--4"},"Rev 3: Deleted 2 lines.",(0,a.mdx)("pre",null,"a",(0,a.mdx)("br",null),"2",(0,a.mdx)("br",null),"c"))),(0,a.mdx)("p",null,"It can be encoded in LineLog bytecode like:"),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"# Addr: Instruction\n     0: JL   1 8\n     1: LINE 1 0\n     2: JGE  3 6\n     3: LINE 1 1\n     4: JL   2 7\n     5: LINE 2 2\n     6: LINE 2 3\n     7: LINE 1 2\n     8: END\n")),(0,a.mdx)("p",null,"To check out a specified revision, set ",(0,a.mdx)("inlineCode",{parentName:"p"},"Current Rev")," to the revision to check\nout, then execute the instructions from the beginning."),(0,a.mdx)("p",null,"Here are the steps to check out each revision:"),(0,a.mdx)(l.default,{mdxType:"Tabs"},(0,a.mdx)(i.default,{value:"r0",label:"Rev 0",mdxType:"TabItem"},(0,a.mdx)("ul",null,(0,a.mdx)("li",null,"Address 0: JL 1 8: Jump to address 8, because Current Rev (0) < 1."),(0,a.mdx)("li",null,"Address 8: END: Stop execution. The content is empty."))),(0,a.mdx)(i.default,{value:"r1",label:"Rev 1",default:!0,mdxType:"TabItem"},(0,a.mdx)("ul",null,(0,a.mdx)("li",null,"Address 0: JL 1 8: Do nothing, because Current Rev (1) is not < 1."),(0,a.mdx)("li",null,'Address 1: LINE 1 0: Append the first line from rev 1 ("a").'),(0,a.mdx)("li",null,"Address 2: JGE 3 6: Do nothing, because 1 is not \u2265 3."),(0,a.mdx)("li",null,'Address 3: LINE 1 1: Append the second line from rev 1 ("b").'),(0,a.mdx)("li",null,"Address 4: JL 2 7: Jump to address 7, because 1 < 2."),(0,a.mdx)("li",null,'Address 7: LINE 1 2: Append the third line from rev 1 ("c").'),(0,a.mdx)("li",null,'Address 8: END: Stop. The final content is "abc".'))),(0,a.mdx)(i.default,{value:"r2",label:"Rev 2",mdxType:"TabItem"},(0,a.mdx)("ul",null,(0,a.mdx)("li",null,"Address 0: JL 1 8: Do nothing, because Current Rev (2) is not < 1."),(0,a.mdx)("li",null,'Address 1: LINE 1 0: Append the first line from rev 1 ("a").'),(0,a.mdx)("li",null,"Address 2: JGE 3 6: Do nothing, because 2 is not \u2265 3."),(0,a.mdx)("li",null,'Address 3: LINE 1 1: Append the second line from rev 1 ("b").'),(0,a.mdx)("li",null,"Address 4: JL 2 7: Do nothing, because 2 is not < 2."),(0,a.mdx)("li",null,'Address 5: LINE 2 2: Append the 3rd line from rev 2 ("1").'),(0,a.mdx)("li",null,'Address 6: LINE 2 3: Append the 4th line from rev 2 ("2").'),(0,a.mdx)("li",null,'Address 7: LINE 1 2: Append the third line from rev 1 ("c").'),(0,a.mdx)("li",null,'Address 8: END: Stop. The final content is "ab12c".'))),(0,a.mdx)(i.default,{value:"r3",label:"Rev 3",mdxType:"TabItem"},(0,a.mdx)("ul",null,(0,a.mdx)("li",null,"Address 0: JL 1 8: Do nothing, because Current Rev (3) is not < 1."),(0,a.mdx)("li",null,'Address 1: LINE 1 0: Append the first line from rev 1 ("a").'),(0,a.mdx)("li",null,"Address 2: JGE 3 6: Jump to address 6, because 3 \u2265 3."),(0,a.mdx)("li",null,'Address 6: LINE 2 3: Append the 4th line from rev 2 ("2").'),(0,a.mdx)("li",null,'Address 7: LINE 1 2: Append the third line from rev 1 ("c").'),(0,a.mdx)("li",null,'Address 8: END: Stop. The final content is "a2c".')))),(0,a.mdx)("h3",{id:"checkout-and-annotate"},"Checkout and annotate"),(0,a.mdx)("p",null,'Note the lines that are not changed across multiple revisions, such as "a" only\noccurs once as ',(0,a.mdx)("inlineCode",{parentName:"p"},"LINE 1 0")," in the bytecode. The ",(0,a.mdx)("inlineCode",{parentName:"p"},"LINE")," instruction points to the\nrevision and line that introduces the line. By tracking the operands of ",(0,a.mdx)("inlineCode",{parentName:"p"},"LINE"),"\ninstructions in addition to line contents, LineLog could also produce the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"annotate")," (also called ",(0,a.mdx)("inlineCode",{parentName:"p"},"blame"),") result at the same time."),(0,a.mdx)("p",null,"In LineLog, the checkout and annotate operation are basically the same."),(0,a.mdx)("h3",{id:"range-of-revisions"},"Range of revisions"),(0,a.mdx)("p",null,'A variation of the interpretation is to treat "Current Rev" as a range, not a\nsingle fixed revision number. More specifically, given an inclusive range from\n',(0,a.mdx)("inlineCode",{parentName:"p"},"minRev")," to ",(0,a.mdx)("inlineCode",{parentName:"p"},"maxRev"),", treat ",(0,a.mdx)("inlineCode",{parentName:"p"},"JL"),' as "< ',(0,a.mdx)("inlineCode",{parentName:"p"},"maxRev"),'", ',(0,a.mdx)("inlineCode",{parentName:"p"},"JGE"),' as ">= ',(0,a.mdx)("inlineCode",{parentName:"p"},"minRev"),'". This\ncan produce all lines that existed in the revision range, in a reasonable order,\nlike:'),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"rev 1: a\nrev 1: b\nrev 2: 1\nrev 2: 2\nrev 1: c\n")),(0,a.mdx)("h3",{id:"linear-history"},"Linear history"),(0,a.mdx)("p",null,"LineLog assumes linear history. The revision comparisons are done using direct\ninteger comparisons. It might be not too difficult to support non-linear\nhistory (i.e.  with merges) by changing the revision comparisons to consider\nthe graph topology. But that hasn't been attempted due to lack of use-cases so\nfar."),(0,a.mdx)("h2",{id:"editing-linelog"},"Editing LineLog"),(0,a.mdx)("p",null,"LineLog provides a method for editing: ",(0,a.mdx)("inlineCode",{parentName:"p"},"replace_lines(brev, a1, a2, b1, b2)"),".\nIt means replacing the line range ",(0,a.mdx)("inlineCode",{parentName:"p"},"[a1, a2)")," from the current checkout to line\nrange ",(0,a.mdx)("inlineCode",{parentName:"p"},"[b1, b2)")," in the given ",(0,a.mdx)("inlineCode",{parentName:"p"},"brev")," revision. This covers insertion and\ndeletion too. If ",(0,a.mdx)("inlineCode",{parentName:"p"},"a1")," equals to ",(0,a.mdx)("inlineCode",{parentName:"p"},"a2"),", it is an insertion. If ",(0,a.mdx)("inlineCode",{parentName:"p"},"b1")," equals to\n",(0,a.mdx)("inlineCode",{parentName:"p"},"b2"),", it means lines from ",(0,a.mdx)("inlineCode",{parentName:"p"},"a1")," to ",(0,a.mdx)("inlineCode",{parentName:"p"},"a2")," are deleted in revision ",(0,a.mdx)("inlineCode",{parentName:"p"},"brev"),"."),(0,a.mdx)("p",null,"This is implemented by appending a block that appends the lines from the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"brev"),", and removes lines from ",(0,a.mdx)("inlineCode",{parentName:"p"},"a"),". Then change the ",(0,a.mdx)("inlineCode",{parentName:"p"},"LINE")," instruction for the\n",(0,a.mdx)("inlineCode",{parentName:"p"},"a1")," line to point to the added block."),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre"},"# Before             # After\n# Addr: Instruction  # Addr: Instruction\n      : ...                : ...\n    a1: <a1's LINE>     a1 : J len\n  a1+1: ...           a1+1 : ...\n      : ...                : ...\n    a2: ...             a2 : ...\n      : ...                : ...\n   len: N/A            len : JL brev p\n                           : LINE brev b1\n                           : LINE brev b1+1\n                           : ...\n                           : LINE brev b2-1\n                         p : JGE brev a2\n                           : <a1's LINE> (copied)\n                           : J a1+1\n")),(0,a.mdx)("p",null,"To construct LineLog for a file, one needs to run through the contents of revisions\nof the file in commit order, calculate diffs for adjacent revisions, and then\nfeed LineLog the diffs using the ",(0,a.mdx)("inlineCode",{parentName:"p"},"replace_lines")," method."),(0,a.mdx)("p",null,"Usually ",(0,a.mdx)("inlineCode",{parentName:"p"},"replace_lines")," is used to edit the latest revision. However, it can\nalso be used to edit past revisions, if past revisions are checked out. This\nis how the ",(0,a.mdx)("inlineCode",{parentName:"p"},"absorb")," command works under the hood."))}c.isMDXComponent=!0}}]);