{"version":3,"file":"static/js/20.cae28d90.chunk.js","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,kBAAZC,SAA0C,kBAAXC,OACxCA,OAAOD,QAAUD,IACQ,oBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,kBAAZC,QACdA,QAAqB,YAAID,IAEzBD,EAAkB,YAAIC,GACvB,CATD,CASGK,YAAY,I,uCCFR,MCIDC,EAA2C,CAC/C,iCAAkC,CAChCC,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,iDACVC,WAAY,QAEd,6BAA8B,CAC5BL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6CACVC,WAAY,QAEd,2BAA4B,CAC1BL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CAAC,4BAA6B,SACjDC,SAAU,2CACVC,WAAY,QAEd,0BAA2B,CACzBL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CAAC,2BAA4B,QAChDC,SAAU,0CACVC,WAAY,QAEd,6BAA8B,CAC5BL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CAAC,8BAA+B,WACnDC,SAAU,6CACVC,WAAY,QAEd,4BAA6B,CAC3BL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CAAC,6BAA8B,UAClDC,SAAU,4CACVC,WAAY,QAEd,8BAA+B,CAC7BL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CAAC,+BAAgC,YACpDC,SAAU,8CACVC,WAAY,QAEd,sCAAuC,CACrCL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,sDACVC,WAAY,SAEd,oBAAqB,CACnBL,SAAU,KACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,oCACVC,WAAY,QAEd,mBAAoB,CAClBL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,mCACVC,WAAY,QAEd,WAAY,CACVL,SAAU,IACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,2BACVC,WAAY,QAEd,oBAAqB,CACnBL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,oCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,eAAgB,CACdL,SAAU,QACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,+BACVC,WAAY,QAEd,iBAAkB,CAChBL,SAAU,UACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,iCACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,eACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,aAAc,CACZL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,4BAA6B,CAC3BL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,4CACVC,WAAY,QAEd,YAAa,CACXL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,4BACVC,WAAY,QAEd,aAAc,CACZL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,WACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,oBAAqB,CACnBL,SAAU,aACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,oCACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,WACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,YAAa,CACXL,SAAU,KACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,4BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,iBAAkB,CAChBL,SAAU,UACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,iCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,aAAc,CACZL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,aAAc,CACZL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,YAAa,CACXL,SAAU,aACVE,WAAY,CAAC,kCACbC,kBAAmB,CACjB,cAAe,WACf,iCAAkC,WAClC,yBAA0B,aAC1B,8BAA+B,cAEjCC,SAAU,4BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,kBACVE,WAAY,CAAC,kCACbC,kBAAmB,CACjB,cAAe,WACf,iCAAkC,WAClC,6BAA8B,kBAC9B,8BAA+B,mBAEjCC,SAAU,gCACVC,WAAY,QAEd,mBAAoB,CAClBL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,mCACVC,WAAY,SAEd,eAAgB,CACdL,SAAU,QACVE,WAAY,GACZC,kBAAmB,CACjB,2BAA4B,MAC5B,kCAAmC,aACnC,8BAA+B,SAC/B,yBAA0B,IAC1B,2BAA4B,OAE9BC,SAAU,+BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,SAEd,aAAc,CACZL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,WACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,cACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,gBACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,QACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,oBAAqB,CACnBL,SAAU,aACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,oCACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,QAEd,WAAY,CACVL,SAAU,IACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,2BACVC,WAAY,QAEd,uBAAwB,CACtBL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,uCACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,iBAAkB,CAChBL,cAAUC,EACVC,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,iCACVC,WAAY,QAEd,eAAgB,CACdL,SAAU,cACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,+BACVC,WAAY,QAEd,aAAc,CACZL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,6BACVC,WAAY,QAEd,eAAgB,CACdL,SAAU,QACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,+BACVC,WAAY,QAEd,gBAAiB,CACfL,SAAU,SACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,gCACVC,WAAY,SAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,SAEd,YAAa,CACXL,SAAU,aACVE,WAAY,CAAC,8BACbC,uBAAmBF,EACnBG,SAAU,4BACVC,WAAY,QAEd,aAAc,CACZL,SAAU,kBACVE,WAAY,CAAC,8BACbC,kBAAmB,CACjB,eAAgB,WAChB,kCAAmC,WACnC,0BAA2B,kBAC3B,+BAAgC,mBAElCC,SAAU,6BACVC,WAAY,QAEd,cAAe,CACbL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,8BACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,aACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,kBAAmB,CACjBL,SAAU,aACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,kCACVC,WAAY,QAEd,kBAAmB,CACjBL,cAAUC,EACVC,WAAY,GACZC,kBAAmB,CACjB,YAAa,OACb,aAAc,MACd,YAAa,aACb,gBAAiB,SACjB,gBAAiB,UAEnBC,SAAU,kCACVC,WAAY,QAEd,mBAAoB,CAClBL,SAAU,QACVE,WAAY,GACZC,kBAAmB,CACjB,iCAAkC,SAClC,aAAc,MACd,YAAa,cAEfC,SAAU,mCACVC,WAAY,QAEd,uBAAwB,CACtBL,SAAU,OACVE,WAAY,GACZC,kBAAmB,CACjB,YAAa,OACb,aAAc,MACd,YAAa,aACb,gBAAiB,SACjB,gBAAiB,UAEnBC,SAAU,uCACVC,WAAY,QAEd,uBAAwB,CACtBL,SAAU,aACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,uCACVC,WAAY,QAEd,qBAAsB,CACpBL,SAAU,WACVE,WAAY,CACV,2BACA,0BACA,6BACA,4BACA,8BACA,uCAEFC,kBAAmB,CACjB,2BAA4B,OAC5B,YAAa,aACb,aAAc,MACd,kCAAmC,OACnC,0BAA2B,MAC3B,0BAA2B,MAC3B,2BAA4B,OAC5B,0BAA2B,MAC3B,+BAAgC,WAChC,2BAA4B,OAC5B,wBAAyB,IACzB,2BAA4B,OAC5B,0BAA2B,MAC3B,0BAA2B,MAC3B,6BAA8B,SAC9B,0BAA2B,MAC3B,0BAA2B,MAC3B,2BAA4B,OAC5B,+BAAgC,WAChC,8BAA+B,UAC/B,6BAA8B,SAC9B,wBAAyB,IACzB,0BAA2B,MAC3B,2BAA4B,OAC5B,iCAAkC,aAClC,yBAA0B,KAC1B,6BAA8B,SAC9B,0BAA2B,OAC3B,iCAAkC,aAClC,2BAA4B,OAC5B,4BAA6B,QAC7B,2BAA4B,OAC5B,2BAA4B,OAC5B,2BAA4B,OAC5B,4BAA6B,QAC7B,iCAAkC,aAClC,6BAA8B,SAC9B,2BAA4B,OAC5B,4BAA6B,QAC7B,kCAAmC,cACnC,iCAAkC,aAClC,sCAAuC,kBACvC,6BAA8B,SAC9B,6BAA8B,UAEhCC,SAAU,qCACVC,WAAY,QAEd,WAAY,CACVL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,2BACVC,WAAY,QAEd,WAAY,CACVL,SAAU,OACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,2BACVC,WAAY,QAEd,yBAA0B,CACxBL,SAAU,mBACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,yCACVC,WAAY,QAEd,WAAY,CACVL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,2BACVC,WAAY,QAEd,eAAgB,CACdL,SAAU,MACVE,WAAY,GACZC,uBAAmBF,EACnBG,SAAU,+BACVC,WAAY,SClmBHC,EAAmB,CAC9BC,eAAgB,EAChBC,eAAgB,EAChBC,iBAAkB,EAElBC,iBAAkB,EAClBC,iBAAkB,EAClBC,mBAAoB,EAEpBC,cAAe,EACfC,cAAe,EACfC,gBAAiB,EACjBC,0BAA2B,EAC3BC,qBAAsB,EACtBC,sBAAuB,GASzBpB,WAAWqB,yBAA2B,IAAMb,EAE5CR,WAAWsB,2BAA6B,KAEtCC,QAAQC,IAAI,oCACZD,QAAQC,IAAI,UAAUhB,EAAiBC,kBACvCc,QAAQC,IAAI,UAAUhB,EAAiBE,kBACvCa,QAAQC,IAAI,YAAYhB,EAAiBG,oBAEzCY,QAAQC,IAAI,oCACZD,QAAQC,IAAI,UAAUhB,EAAiBI,oBACvCW,QAAQC,IAAI,UAAUhB,EAAiBK,oBACvCU,QAAQC,IAAI,YAAYhB,EAAiBM,sBAEzCS,QAAQC,IAAI,0BACZD,QAAQC,IAAI,cAAchB,EAAiBO,iBAC3CQ,QAAQC,IAAI,cAAchB,EAAiBQ,iBAC3CO,QAAQC,IAAI,gBAAgBhB,EAAiBS,mBAC7CM,QAAQC,IAAI,0BAA0BhB,EAAiBU,6BACvDK,QAAQC,IAAI,qBAAqBhB,EAAiBW,wBAClDI,QAAQC,IAAI,sBAAsBhB,EAAiBY,wBAAwB,ECpCtE,MAKMK,EAAU,oBCKjBC,EAA6B,iCAE7BC,EAAyB,IAAIC,iBAHP,sBAgBtBC,EAAmB,IAAIC,YAStB,SAASC,EACdC,EACAC,GAAoC,GAEpC,MAAMC,EAAsC,GAEtCC,EAAkB,EAAEC,YACe,IAAlCA,EAAuBC,QAC1BL,G,EAQJ,GALAL,EAAuBW,iBAAiB,UAAWH,GACnDD,EAAiBK,MAAK,IACpBZ,EAAuBa,oBAAoB,UAAWL,KAGpDF,EAAmC,CAErC,MAAMQ,EAA4BC,IAChCV,GAAU,EAEZH,EAAiBS,iBAAiBZ,EAA4Be,GAC9DP,EAAiBK,MAAK,IACpBV,EAAiBW,oBAAoBd,EAA4Be,I,CAIrE,MAAO,IAAMP,EAAiBS,SAAQX,GAAYA,KACpD,CCtCA,MAAMY,EAAuB,SACvBC,EAAqB,OACrBC,EAAqB,OACrBC,EAAyB,cAiD/B,MAAMC,EAKJC,YAAYC,EAAyBC,GAAA,KAAAA,UAAAA,EACnCC,KAAKC,GAAKH,EAAGI,YAAYH,EAAW,aACpCC,KAAKG,MAAQH,KAAKC,GAAGG,YAAYL,GACjCC,KAAKK,SAAW,IAAIC,SAAQ,CAACC,EAASC,KACpCR,KAAKC,GAAGQ,WAAa,IAAMF,IAC3BP,KAAKC,GAAGS,QAAUC,IAChB,GAAkD,oBAA7CA,GAAOC,OAAsBC,OAAOC,KAA4B,CACnE,OAAQd,KAAKD,WACX,KAAKL,IACDtC,EAAiBI,iBACnB,MAEF,KAAKiC,IACDrC,EAAiBK,iBACnB,MAEF,KAAK+B,IACDpC,EAAiBM,mBAIvB6C,G,MAEAC,G,CAEH,GAEL,CAEAO,IAAIC,GACF,OAAO,IAAIV,SAAQ,CAACC,EAASC,KAC3B,IAAIS,EACJ,IACEA,EAAUjB,KAAKG,MAAMY,IAAIC,E,CACzB,MAAOE,GACP,OAAOV,EAAOU,E,CAGhBD,EAAQE,UAAY7B,GAAUiB,IAC9BU,EAAQP,QAAUC,IAChB,GAAkD,oBAA7CA,GAAOC,OAAsBC,OAAOC,KAA4B,CACnE,IAAIM,EAAa,UACjB,GA0BV,SAA6BJ,GAC3B,MAAsB,kBAARA,GAA4B,OAARA,GAAgB,QAASA,CAC7D,CA5BcK,CAAoBL,GACtBI,EAAaJ,EAAIM,QACZ,CACL,MAAMC,EAAKP,EACXI,EAAa,GAAGG,EAAGC,SAASD,EAAGT,QAAQS,EAAGE,Q,CAG5CtD,QAAQuD,KAAK,GAAGN,4BAAqCpB,KAAKG,MAAMW,QAChEP,G,MAEAC,EAAOG,E,CAEV,GAEL,CAMAgB,SAEE,OADA3B,KAAKC,GAAG0B,SACD3B,KAAKK,QACd,EAUa,MAAMuB,EAKnB/B,YACUC,EACA+B,EACAL,EACAV,GAHA,KAAAhB,GAAAA,EACA,KAAA+B,OAAAA,EACA,KAAAL,MAAAA,EACA,KAAAV,KAAAA,CACP,CAEHgB,gBAAgBR,GACd,MAAMS,QAAqB/B,KAAKgC,gBAAgBV,GAChD,GAAoB,MAAhBS,EAEF,QADE3E,EAAiBG,iBACZwE,EAGT,MAAMJ,QAAe3B,KAAK6B,OAAOI,UAAUX,GAC3C,GAAc,MAAVK,EAAgB,CAmBL,IAAI/B,EAAgBI,KAAKF,GAAIL,GACrCsB,IAAIY,EAAOO,MAEhB,CACE,MAAMjC,EAAK,IAAIL,EAAgBI,KAAKF,GAAIN,GAClC2C,EAmYd,SAAyBR,GACvB,MAAM,IACJL,EAAG,GACHc,EAAE,IACFC,EAAG,QACHC,EAAO,gBACPC,EAAe,oBACfC,EAAmB,YACnBC,EAAW,gBACXC,EAAe,QACfC,EAAO,cACPC,GACEjB,EACJ,MAAO,CACLL,MACAc,KACAC,MACAC,UACAC,kBACAC,sBACAC,cACAC,kBACAC,UACAE,SAAUlB,EAAOO,KAAKZ,IACtBsB,gBAEJ,CA7ZiCE,CAAgBnB,GACzC1B,EAAGc,IAAIoB,E,EAGX,OAAOR,CACT,CAEAoB,oBAAoBC,EAAmBC,GAErC,OAAOjD,KAAK6B,OAAOkB,oBAAoBC,EAAMC,EAC/C,CAEAnB,cAAcR,GACZ,MAAM4B,QAAmBlD,KAAKmD,cAAc7B,GAC5C,GAAkB,MAAd4B,EAEF,QADE9F,EAAiBE,eACZ4F,EAGT,MAAMhB,QAAalC,KAAK6B,OAAOuB,QAAQ9B,GAIvC,GAAY,MAARY,EAAc,CAKL,IAAItC,EAAgBI,KAAKF,GAAIL,GACrCsB,IAAImB,E,CAET,OAAOA,CACT,CAEAJ,cAAcR,GACZ,MAAM+B,QAAmBrD,KAAKsD,cAAchC,GAC5C,GAAkB,MAAd+B,EAEF,QADEjG,EAAiBC,eACZgG,EAGT,MAAME,QAAavD,KAAK6B,OAAO2B,QAAQlC,GAIvC,GAAY,MAARiC,EAAc,CAIhB,MAAMtD,EAAK,IAAIL,EAAgBI,KAAKF,GAAIJ,SAClCO,EAAGc,IAAIwC,SACPtD,EAAG0B,Q,CAEX,OAAO4B,CACT,CAEAE,eAAelC,GAGb,OAAOvB,KAAK6B,OAAO4B,eAAelC,EACpC,CAEAmC,gBAAgBC,GACd,OAAO3D,KAAK6B,OAAO6B,gBAAgBC,EACrC,CAEAC,uBAAuBC,GACrB,OAAO7D,KAAK6B,OAAO+B,uBAAuBC,EAC5C,CAEAC,cAAcD,GACZ,OAAO7D,KAAK6B,OAAOiC,cAAcD,EACnC,CAIA/B,2BAA2BiC,GAEzB,MAAMC,QAAwBhE,KAAKiE,qBAAqBF,GAIlDG,EAAuB,GACvBC,EAA4B,GAClCH,EAAgBzE,SAAQ,CAAC6E,EAAUC,KACjB,MAAZD,IACFF,EAAW/E,KAAK4E,EAAIM,IACpBF,EAAgBhF,KAAKkF,G,IAMzB,MAAMC,QAAyBtE,KAAK6B,OAAO0C,qBAAqBL,IAC1D,MAAC1C,EAAK,KAAEV,GAAQd,KAAKwE,kBAErBvE,EAAK,IAAIL,EAAgBI,KAAKF,GAAIH,GAkBxC,aAjBMW,QAAQmE,IACZH,EAAiBI,KAAI,CAACN,EAAUC,KAC9B,MAAMM,EAAgBR,EAAgBE,GACtCL,EAAgBW,GAAiBP,EACjC,MAAMQ,EA0Td,SACEpD,EACAV,EACAsD,GAEA,MAAM,OAAC3C,EAAM,MAAEoD,EAAK,UAAEC,EAAS,MAAEC,EAAK,eAAEC,EAAc,WAAEC,EAAU,SAAEC,GAAYd,EAChF,MAAO,CACL5C,QACAV,OACAW,SACAoD,QACAC,YACAC,QACAC,iBACAC,aACAE,YAAaD,EAASE,WAE1B,CA3UmCC,CAA6B7D,EAAOV,EAAMsD,GASrE,OAAOnE,EAAGc,IAAI6D,EAAmB,WAG/B3E,EAAG0B,SACFqC,CACT,CAEAsB,WAAWlD,EAAQmD,GACjB,OAAOvF,KAAK6B,OAAOyD,WAAWlD,EAAImD,EACpC,CAEAC,UAAU7B,GACR,OAAO3D,KAAK6B,OAAO2D,UAAU7B,EAC/B,CAEA8B,qBACE9B,GAEA,OAAO3D,KAAK6B,OAAO4D,qBAAqB9B,EAC1C,CAEA+B,4BACE/B,GAEA,OAAO3D,KAAK6B,OAAO6D,4BAA4B/B,EACjD,CAEAgC,aACEhC,GAEA,OAAO3D,KAAK6B,OAAO8D,aAAahC,EAClC,CAEAiC,eAAejC,GACb,OAAO3D,KAAK6B,OAAO+D,eAAejC,EACpC,CAEAkC,wBACElC,GAEA,OAAO3D,KAAK6B,OAAOgE,wBAAwBlC,EAC7C,CAOQ3B,gBAAgBV,GACtB,MAEML,EAFKjB,KAAKF,GAAGI,YAAYV,EAAsB,YACpCY,YAAYZ,GACPsG,IAAIxE,GAC1B,OAAO,IAAIhB,SAAQ,CAACC,EAASC,KAC3BS,EAAQE,UAAYW,MAAMxC,IACxB,MAAOyG,OAAQ5D,GAAoBlB,EACnC,GAAwB,MAApBkB,EACF,OAAO5B,EAAQ,MAGjB,MAAM,IACJe,EAAG,GACHc,EAAE,IACFC,EAAG,QACHC,EAAO,gBACPC,EAAe,oBACfC,EAAmB,YACnBC,EAAW,gBACXC,EAAe,QACfC,EAAO,SACPE,EAAQ,cACRD,GACET,EACED,QAAalC,KAAKoD,QAAQP,GAChC,GAAY,MAARX,EACF,OAAO1B,EAAO,QAAQqC,0BAAiCvB,KAgBzDf,EAbe,CACbe,IAAKA,EACLc,GAAIA,EACJC,MACAC,QAASA,EACTC,gBAAiBA,EACjBC,sBACAC,cACAC,kBACAC,QAASA,EACTT,OACAU,iBAEa,EAEjB3B,EAAQP,QAAUF,CAAM,GAE5B,CAOQ2C,cAAc7B,GACpB,MAEML,EAFKjB,KAAKF,GAAGI,YAAYT,EAAoB,YAClCW,YAAYX,GACPqG,IAAIxE,GAC1B,OAAO,IAAIhB,SAAQ,CAACC,EAASC,KAC3BS,EAAQE,UAAY7B,IAClBiB,EAAQU,EAAQ8E,QAAU,KAAK,EAEjC9E,EAAQP,QAAUF,CAAM,GAE5B,CAOQ8C,cAAchC,GACpB,MAEML,EAFKjB,KAAKF,GAAGI,YAAYR,EAAoB,YAClCU,YAAYV,GACPoG,IAAIxE,GAC1B,OAAO,IAAIhB,SAAQ,CAACC,EAASC,KAC3BS,EAAQE,UAAY7B,IAClBiB,EAAQU,EAAQ8E,QAAU,KAAK,EAEjC9E,EAAQP,QAAUF,CAAM,GAE5B,CAEQyD,qBAAqBF,GAC3B,MACM5D,EADKH,KAAKF,GAAGI,YAAYP,EAAwB,YACtCS,YAAYT,IACvB,MAAC6B,EAAK,KAAEV,GAAQd,KAAKwE,kBAE3B,OAAOlE,QAAQmE,IACbV,EAAIW,KAAInD,IACN,MAAMyE,EAAM,CAACxE,EAAOV,EAAMS,GACpBN,EAAUd,EAAM2F,IAAIE,GAC1B,OAAO,IAAI1F,SAAyC,CAACC,EAASC,KAC5DS,EAAQE,UAAY7B,IAClB,MAAM,OAACyG,GAAU9E,EACjB,GAAc,MAAV8E,EAEF,YADAxF,EAAQ,MAIV,MAAM,MAACsE,EAAK,UAAEC,EAAS,MAAEC,EAAK,eAAEC,EAAc,WAAEC,EAAU,YAAEE,GAAeY,EAC3ExF,EAAQ,CACN0F,WAAY,cACZxE,OAAQF,EACRsD,QACAC,YACAC,QACAC,iBACAC,aACAC,SAAU,CACRe,WAAY,yBACZb,WAAYD,IAEd,EAEJlE,EAAQP,QAAUF,CAAM,GACxB,IAGR,CAEQgE,kBACN,MAAM,MAAChD,EAAK,KAAEV,GAAQd,KACtB,GAAa,MAATwB,GAAyB,MAARV,EACnB,MAAM,IAAIoF,MAAM,qDAElB,MAAO,CAAC1E,QAAOV,OACjB,EAGF,MAAMqF,EAA2B,IAM1B,SAASC,IACd,OASFtE,iBACE,MAAMuE,EAAsB,IAAI/F,SAAQ,CAACC,EAASC,KAChD,MAAMS,EAAUqF,KAAKC,UAAUC,KAAKnI,EFtfd,GEuftB4C,EAAQE,UAAY7B,IAClBiB,EAAQU,EAAQ8E,OAAO,EAEzB9E,EAAQP,QAAUC,GAASH,EAAOG,EAAMC,QACxCK,EAAQwF,UAAY9F,GAElBxC,QAAQ0C,MACN,0CAA0CxC,oBAC1CsC,GAEJM,EAAQyF,gBAAmBpH,IACzB,MAAOyG,OAAQjG,GAAMmB,EACf0F,EAAc7G,EAAG8G,kBAAkBpH,EAAsB,CAC7DqH,QAAS,MACTC,eAAe,IAEjBH,EAAYI,YAAY,KAAM,KAAM,CAACC,QAAQ,IAC7CL,EAAYI,YAAY,MAAO,MAAO,CAACC,QAAQ,IAC/CL,EAAYI,YAAY,UAAW,UAAW,CAACC,QAAQ,IACvDL,EAAYI,YAAY,kBAAmB,kBAAmB,CAACC,QAAQ,IACvEL,EAAYI,YAAY,sBAAuB,sBAAuB,CAACC,QAAQ,IAC/EL,EAAYI,YAAY,cAAe,cAAe,CAACC,QAAQ,IAC/DL,EAAYI,YAAY,kBAAmB,kBAAmB,CAACC,QAAQ,IACvEL,EAAYI,YAAY,UAAW,UAAW,CAACC,QAAQ,IACvDL,EAAYI,YAAY,WAAY,WAAY,CAACC,QAAQ,IACzDL,EAAYI,YAAY,gBAAiB,gBAAiB,CAACC,QAAQ,IAEnE,MAAMC,EAAYnH,EAAG8G,kBAAkBnH,EAAoB,CACzDoH,QAAS,MACTC,eAAe,IAEjBG,EAAUF,YAAY,KAAM,KAAM,CAACC,QAAQ,IAC3CC,EAAUF,YAAY,UAAW,UAAW,CAACC,QAAQ,IAErD,MAAME,EAAYpH,EAAG8G,kBAAkBlH,EAAoB,CACzDmH,QAAS,MACTC,eAAe,IAEjBI,EAAUH,YAAY,KAAM,KAAM,CAACC,QAAQ,IAC3CE,EAAUH,YAAY,WAAY,WAAY,CAACC,QAAQ,IACvDE,EAAUH,YAAY,WAAY,WAAY,CAACC,QAAQ,IACvDE,EAAUH,YAAY,cAAe,cAAe,CAACC,QAAQ,IAC7DE,EAAUH,YAAY,OAAQ,OAAQ,CAACC,QAAQ,IAE/C,MAAMG,EAA2BrH,EAAG8G,kBAAkBjH,EAAwB,CAC5EkH,QAAS,CAAC,QAAS,OAAQ,UAC3BC,eAAe,IAEjBK,EAAyBJ,YAAY,QAAS,QAAS,CAACC,QAAQ,IAChEG,EAAyBJ,YAAY,YAAa,YAAa,CAACC,QAAQ,IACxEG,EAAyBJ,YAAY,QAAS,QAAS,CAACC,QAAQ,IAChEG,EAAyBJ,YAAY,aAAc,aAAc,CAACC,QAAQ,IAC1EG,EAAyBJ,YAAY,cAAe,cAAe,CAACC,QAAQ,GAAO,CACpF,IAcGI,QCzjBNC,ED0jBEhB,ECzjBFiB,ED0jBEnB,ECzjBF7D,ED0jBE,yCCxjBKhC,QAAQiH,KAAK,CAClBF,EACA,IAAI/G,SAAW,CAACkH,EAAUhH,KACxBiH,YAAW,IAAMjH,EAAO8B,IAAUgF,EAAgB,OARzC,IACbD,EACAC,EACAhF,ED4jBA,GAAI8E,aAAoBM,YACtB,OAAON,EACF,MAAIA,aAAoBlB,MACvBkB,EAEAlB,MAAM,0CAA0CkB,IAE1D,CA3FSO,GAAgBC,MAAK9H,IAI1BnB,GAAkB,IAAMmB,EAAG+H,UAAiD,GACrE/H,IAEX,CE/de,MAAMgI,EACnB7F,UAAU8F,GACR,OAAOzH,QAAQE,OAAO,0BACxB,CAEAuC,oBAAoBiF,EAAoBC,GACtC,OAAO3H,QAAQE,OAAO,0BACxB,CAEA4C,QAAQ2E,GACN,OAAOzH,QAAQE,OAAO,0BACxB,CAEAgD,QAAQlC,GACN,OAAOhB,QAAQE,OAAO,WAAWc,qBACnC,CAEAmC,eAAeyE,GACb,OAAO5H,QAAQE,OAAO,0BACxB,CAEAkD,gBAAgByE,GACd,OAAO7H,QAAQE,OAAO,0BACxB,CAEAoD,uBAAuBwE,GACrB,OAAO9H,QAAQE,OAAO,0BACxB,CAEAsD,cAAcsE,GACZ,OAAO9H,QAAQE,OAAO,0BACxB,CAEA+D,qBAAqB8D,GACnB,OAAO/H,QAAQE,OAAO,0BACxB,CAEA8E,WAAWgD,EAASC,GAClB,OAAOjI,QAAQE,OAAO,0BACxB,CAEAgF,UAAU2C,GACR,OAAO7H,QAAQE,OAAO,0BACxB,CAEAiF,qBACE0C,GAEA,OAAO7H,QAAQE,OAAO,0BACxB,CAEAkF,4BACEyC,GAEA,OAAO7H,QAAQE,OAAO,0BACxB,CAEAmF,aACEwC,GAEA,OAAO7H,QAAQE,OAAO,0BACxB,CAEAoF,eAAeuC,GACb,OAAO7H,QAAQE,OAAO,0BACxB,CAEAqF,wBACEsC,GAEA,OAAO7H,QAAQE,OAAO,0BACxB,ECuBF,IAAYgI,EA0rBAC,EAgtBAC,EAwCAC,EAwKAC,EAyCAC,EAQAC,EA6WAC,EAoDAC,EAoBAC,EAqbAC,EAyLAC,EAqGAC,EA6+CAC,EAigBAC,EAgOAC,EAkDAC,EAqGAC,EAiCAC,EAwEAC,EAqCAC,EA8NAC,EA6KAC,EAgFAC,EAQAC,EAQAC,EA+BAC,EAqUAC,EAMAC,EAQAC,EAmDAC,EAcAC,EAUAC,EA2GAC,EAQAC,EAcAC,GAqrBAC,GAgHAC,GAcAC,GAwDAC,GAMAC,GAoEAC,GAaAC,GAyRAC,GA+EAC,GA6PAC,GAUAC,GA0GAC,GA4KAC,GA0DAC,GAwDAC,GAQAC,GAoSAC,GAmIAC,GA2FAC,GAUAC,GAQAC,GAwGAC,GA0KAC,GAgFAC,GAiKAC,GA8FAC,GAwdAC,GAUAC,GAwIAC,GAcAC,GAQAC,GAuBAC,GAwEAC,GAUAC,GAwHAC,GAYAC,GAu8DAC,GA0CAC,GAsEAC,GAUAC,GAkBAC,GA4FAC,GAkLAC,GAsRAC,GAoRAC,GAsDAC,GA4BAC,GA0DAC,GAiBAC,GAoMAC,GAwDAC,GAoDAC,GAmxBAC,GAYAC,GAUAC,GAkCAC,GAQAC,GAoCAC,GAmCAC,GAuKAC,GAcAC,GA2CAC,GAiGAC,GA0BAC,GAwEAC,GAkEAC,GAcAC,GAsWAC,GAyCAC,GA4EAC,GAwCAC,GA8DAC,GAQAC,GAsMAC,GA+GAC,GAUAC,GAoXAC,GAcAC,GAMAC,GAoEAC,GAqDAC,GA2CAC,GA4FAC,GA8JAC,GAkBAC,GA4DAC,GAsoBAC,GAkBAC,GAiSAC,GAwCAC,GAmBAC,GAYAC,GAwFAC,GAmBAC,GAyHAC,GAwHAC,GAqZAC,GA2EAC,GAkJAC,GAqSAC,GA+YAC,GA4DAC,GAgHAC,GA8DAC,GAgiBAC,GA4DAC,GA4DAC,GA8DAC,GAqtBAC,GAsGAC,GA8IAC,GAYAC,GAcAC,GA0DAC,GAMAC,GAyEAC,GAQAC,GA+CAC,GA2DAC,GAiBAC,GAmEAC,GA6IAC,GA0CAC,GA2JAC,GAiBAC,GAuCAC,GA8ZAC,GAUAC,GAgBAC,GAyCAC,GAYAC,GA0DAC,GAqEAC,GA2EAC,GAqBAC,GAoDAC,GAgBAC,GA+BAC,GAmEAC,GAuJAC,GAyDAC,GAmLAC,GA0BAC,GA8CAC,GAMAC,GAYAC,GAkgBAC,GAwHAC,GAmHAC,GAkIAC,GAcAC,GAMAC,GAQAC,GAUAC,GAwCAC,GA6RAC,GA6HAC,GAyqBAC,GAoCAC,GAkDAC,GAQAC,GAQAC,GAUAC,GAgBAC,GAMAC,GAmJAC,GAgBAC,GAQAC,GA0FAC,GAYAC,GAk9EAC,GA6JAC,GAsEAC,GAqLAC,GAMAC,IAvg5BZ,SAAYlN,GAEV,cAEA,aACD,CALD,CAAYA,IAAAA,EAAS,KA0rBrB,SAAYC,GAEV,wBACD,CAHD,CAAYA,IAAAA,EAAkB,KAgtB9B,SAAYC,GAEV,oBAEA,kBAEA,mBACD,CAPD,CAAYA,IAAAA,EAAoB,KAwChC,SAAYC,GAEV,mCAEA,wBAEA,oBAEA,oBAEA,oBAEA,gBAEA,mCAEA,oBAEA,sBACD,CAnBD,CAAYA,IAAAA,EAAoB,KAwKhC,SAAYC,GAEV,mCAEA,wBAEA,wBAEA,oBAEA,2BAEA,oBAEA,oBAEA,kBAEA,oBAEA,gBAEA,mCAEA,oBAEA,uBAEA,mBACD,CA7BD,CAAYA,IAAAA,EAAa,KAyCzB,SAAYC,GAEV,YAEA,iBACD,CALD,CAAYA,IAAAA,EAAY,KAQxB,SAAYC,GAEV,wBAEA,2BAEA,oBAEA,kBAEA,wBAEA,mBACD,CAbD,CAAYA,IAAAA,EAAgB,KA6W5B,SAAYC,GAEV,YAEA,kBAEA,mBACD,CAPD,CAAYA,IAAAA,EAAuB,KAoDnC,SAAYC,GAEV,8BAEA,4BAEA,2BAEA,gDAEA,wBAEA,kBAEA,cAEA,eACD,CAjBD,CAAYA,IAAAA,EAAwB,KAoBpC,SAAYC,GAEV,sBAEA,kBAEA,2CAEA,kBAEA,iCAEA,4BAEA,iDACD,CAfD,CAAYA,IAAAA,EAAyB,KAqbrC,SAAYC,GAEV,6BAEA,0BACD,CALD,CAAYA,IAAAA,EAA4B,KAyLxC,SAAYC,GAEV,gBAEA,kBAEA,sBAEA,uBACD,CATD,CAAYA,IAAAA,EAAgB,KAqG5B,SAAYC,GAEV,iCAEA,mCAEA,cAEA,mCAEA,gCACD,CAXD,CAAYA,IAAAA,EAAiB,KA6+C7B,SAAYC,GAEV,gBAEA,cAEA,cAEA,eACD,CATD,CAAYA,IAAAA,EAAgC,KAigB5C,SAAYC,GAEV,oBAEA,sBAEA,UAEA,gBAEA,YAEA,gBAEA,YAEA,YAEA,sBAEA,aACD,CArBD,CAAYA,IAAAA,EAAwB,KAgOpC,SAAYC,GAEV,wBACD,CAHD,CAAYA,IAAAA,EAAoB,KAkDhC,SAAYC,GAEV,yCAEA,wBACD,CALD,CAAYA,IAAAA,EAA4B,KAqGxC,SAAYC,GAEV,sBAEA,qBACD,CALD,CAAYA,IAAAA,EAAqB,KAiCjC,SAAYC,GAEV,wBAEA,kBAEA,wBAEA,gBAEA,oBAEA,sBAEA,2BAEA,oBAEA,kBAEA,oBAEA,mBACD,CAvBD,CAAYA,IAAAA,EAAe,KAwE3B,SAAYC,GAEV,gBAEA,oBAEA,sBAEA,2BAEA,oBAEA,kBAEA,oBAEA,mBACD,CAjBD,CAAYA,IAAAA,EAAqB,KAqCjC,SAAYC,GAEV,cAEA,eACD,CALD,CAAYA,IAAAA,EAAQ,KA8NpB,SAAYC,GAEV,wBAEA,sBAEA,qBACD,CAPD,CAAYA,IAAAA,EAAqB,KA6KjC,SAAYC,GAEV,yBAEA,wBACD,CALD,CAAYA,IAAAA,EAAoB,KAgFhC,SAAYC,GAEV,iCAEA,wBACD,CALD,CAAYA,IAAAA,EAA8B,KAQ1C,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,IAAAA,EAAe,KAQ3B,SAAYC,GAEV,wBAEA,sBAEA,sBAEA,qBACD,CATD,CAAYA,IAAAA,EAAqB,KA+BjC,SAAYC,GAEV,2BAEA,0BAEA,qBAEA,6BAEA,gCACD,CAXD,CAAYA,IAAAA,EAAa,KAqUzB,SAAYC,GAEV,wBACD,CAHD,CAAYA,IAAAA,EAA2C,KAMvD,SAAYC,GAEV,mCAEA,eACD,CALD,CAAYA,IAAAA,EAA2B,KAQvC,SAAYC,GAEV,qDAEA,+EAEA,0BAEA,uCAEA,iEAEA,8BACD,CAbD,CAAYA,IAAAA,EAAkD,KAmD9D,SAAYC,GAEV,gBAEA,cAEA,uBAEA,cAEA,eACD,CAXD,CAAYA,IAAAA,EAAiD,KAc7D,SAAYC,GAEV,sBAEA,oBAEA,sBACD,CAPD,CAAYA,IAAAA,EAAqC,KAUjD,SAAYC,GAEV,oBAEA,sBACD,CALD,CAAYA,IAAAA,EAA6B,KA2GzC,SAAYC,GAEV,yBAEA,eACD,CALD,CAAYA,IAAAA,EAA0B,KAQtC,SAAYC,GAEV,YAEA,sBAEA,uBAEA,oBAEA,iBACD,CAXD,CAAYA,IAAAA,EAAkD,KAc9D,SAAYC,GAEV,sBAEA,mBACD,CALD,CAAYA,KAAAA,GAA6C,KAqrBzD,SAAYC,GAEV,yBAEA,+BAEA,sBACD,CAPD,CAAYA,KAAAA,GAAsC,KAgHlD,SAAYC,GAEV,eACD,CAHD,CAAYA,KAAAA,GAA0C,KActD,SAAYC,GAEV,gBAEA,qCACD,CALD,CAAYA,KAAAA,GAAqC,KAwDjD,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAA4C,KAMxD,SAAYC,GAEV,oBAEA,oBAEA,mBACD,CAPD,CAAYA,KAAAA,GAA2C,KAoEvD,SAAYC,GAEV,kBAEA,gBAKA,6BACD,CAVD,CAAYA,KAAAA,GAAmC,KAa/C,SAAYC,GAEV,gBAEA,iBACD,CALD,CAAYA,KAAAA,GAAwB,KAyRpC,SAAYC,GAEV,wBAEA,sBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAe,KA+E3B,SAAYC,GAEV,qCAEA,kBAEA,kBAEA,wBAEA,eAEA,qCAEA,wBAEA,mCAEA,oBAEA,oBAEA,qBACD,CAvBD,CAAYA,KAAAA,GAAe,KA6P3B,SAAYC,GAEV,yBAEA,uBAEA,wBACD,CAPD,CAAYA,KAAAA,GAAc,KAU1B,SAAYC,GAEV,YAEA,kBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAW,KA0GvB,SAAYC,GAEV,qBAEA,uBAEA,2BAEA,mCAEA,+CAEA,oBAEA,+BAEA,kCAEA,mBAEA,yBAEA,6BAEA,6BAEA,2BAEA,oCAEA,sBAEA,qCAEA,eACD,CAnCD,CAAYA,KAAAA,GAAiB,KA4K7B,SAAYC,GAEV,0BAEA,sBAEA,6BACD,CAPD,CAAYA,KAAAA,GAAkC,KA0D9C,SAAYC,GAEV,sBAEA,mBACD,CALD,CAAYA,KAAAA,GAA8B,KAwD1C,SAAYC,GAEV,oCAEA,wBACD,CALD,CAAYA,KAAAA,GAA0B,KAQtC,SAAYC,GAEV,sBAEA,mBACD,CALD,CAAYA,KAAAA,GAA8C,KAoS1D,SAAYC,GAEV,wBAEA,0BACD,CALD,CAAYA,KAAAA,GAAsB,KAmIlC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAsB,KA2FlC,SAAYC,GAEV,sBAEA,yBAEA,wBACD,CAPD,CAAYA,KAAAA,GAAe,KAU3B,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAU,KAQtB,SAAYC,GAEV,wBAEA,2BAEA,qBACD,CAPD,CAAYA,KAAAA,GAAgB,KAwG5B,SAAYC,GAEV,+CAEA,iCAEA,6BAEA,8CAEA,mCAEA,4DAEA,6DAEA,gDAEA,yCAEA,yCAEA,+BAEA,+BAEA,6BAEA,qDAEA,mCAEA,qCAEA,8DAEA,6BAEA,qCAEA,uDAEA,0CAEA,iCAEA,qCAEA,uCAEA,qCAEA,mCAEA,iCAEA,yDAEA,iCAEA,yCAEA,uCACD,CA/DD,CAAYA,KAAAA,GAA0B,KA0KtC,SAAYC,GAEV,yBAEA,aACD,CALD,CAAYA,KAAAA,GAAe,KAgF3B,SAAYC,GAEV,aACD,CAHD,CAAYA,KAAAA,GAAkB,KAiK9B,SAAYC,GAEV,uBAEA,sBAEA,cAEA,wBACD,CATD,CAAYA,KAAAA,GAAU,KA8FtB,SAAYC,GAEV,yBAEA,eACD,CALD,CAAYA,KAAAA,GAAmB,KAwd/B,SAAYC,GAEV,gBAEA,mBAEA,oBACD,CAPD,CAAYA,KAAAA,GAAkB,KAU9B,SAAYC,GAEV,+BAEA,oBACD,CALD,CAAYA,KAAAA,GAAgB,KAwI5B,SAAYC,GAEV,mCAEA,kBAEA,wBAEA,kBAEA,2BACD,CAXD,CAAYA,KAAAA,GAAoB,KAchC,SAAYC,GAEV,sBAEA,uBACD,CALD,CAAYA,KAAAA,GAAyB,KAQrC,SAAYC,GAEV,kBAEA,oBAEA,gBAEA,gBAKA,gBAEA,uBAEA,oBAEA,qBACD,CApBD,CAAYA,KAAAA,GAAgB,KAuB5B,SAAYC,GAEV,4BAEA,wBAEA,mBACD,CAPD,CAAYA,KAAAA,GAAc,KAwE1B,SAAYC,GAEV,6BAEA,qCAEA,gCACD,CAPD,CAAYA,KAAAA,GAAmB,KAU/B,SAAYC,GAEV,kBAEA,uCAEA,2BAEA,2BAEA,yCAEA,kBAEA,uBACD,CAfD,CAAYA,KAAAA,GAAc,KAwH1B,SAAYC,GAEV,yBAEA,qBAEA,kBAEA,wBACD,CATD,CAAYA,KAAAA,GAAmB,KAY/B,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAc,KAu8D1B,SAAYC,GAEV,sBAEA,mBACD,CALD,CAAYA,KAAAA,GAAmC,KA0C/C,SAAYC,GAEV,WACD,CAHD,CAAYA,KAAAA,GAAgB,KAsE5B,SAAYC,GAEV,kBAEA,qCAEA,uBACD,CAPD,CAAYA,KAAAA,GAAqC,KAUjD,SAAYC,GAEV,kBAEA,kCAEA,kBAEA,kBAEA,kBAEA,oBAEA,qBACD,CAfD,CAAYA,KAAAA,GAAa,KAkBzB,SAAYC,GAEV,YAEA,aACD,CALD,CAAYA,KAAAA,GAAc,KA4F1B,SAAYC,GAEV,gBAEA,aACD,CALD,CAAYA,KAAAA,GAAgC,KAkL5C,SAAYC,GAEV,sBAEA,+BAEA,cAEA,kCAEA,uBACD,CAXD,CAAYA,KAAAA,GAA8B,KAsR1C,SAAYC,GAEV,eACD,CAHD,CAAYA,KAAAA,GAA4B,KAoRxC,SAAYC,GAEV,+DAEA,+FAEA,2EACD,CAPD,CAAYA,KAAAA,GAAuC,KAsDnD,SAAYC,GAOV,gBAEA,mCAEA,+BAMA,6CAEA,wBAKA,6BACD,CAzBD,CAAYA,KAAAA,GAAuC,KA4BnD,SAAYC,GAEV,+DAEA,+FAEA,yDAEA,4EAEA,2CACD,CAXD,CAAYA,KAAAA,GAA+B,KA0D3C,SAAYC,GAEV,mCAMA,6CAKA,6BACD,CAdD,CAAYA,KAAAA,GAAoD,KAiBhE,SAAYC,GAEV,+DAEA,2EACD,CALD,CAAYA,KAAAA,GAA4C,KAoMxD,SAAYC,GAEV,gBAEA,cAEA,cAEA,eACD,CATD,CAAYA,KAAAA,GAAwD,KAwDpE,SAAYC,GAEV,gBAEA,aACD,CALD,CAAYA,KAAAA,GAAmC,KAoD/C,SAAYC,GAEV,YAEA,sBAEA,cAEA,oBAEA,qCAEA,kBAEA,mCAEA,gCACD,CAjBD,CAAYA,KAAAA,GAA+D,KAmxB3E,SAAYC,GAEV,gBAEA,mCAEA,+BAEA,uBACD,CATD,CAAYA,KAAAA,GAA0B,KAYtC,SAAYC,GAEV,kBAEA,cAEA,mBACD,CAPD,CAAYA,KAAAA,GAA4B,KAUxC,SAAYC,GAEV,gBAEA,aACD,CALD,CAAYA,KAAAA,GAA0B,KAkCtC,SAAYC,GAEV,gBAEA,iBACD,CALD,CAAYA,KAAAA,GAAsB,KAQlC,SAAYC,GAEV,YAEA,sBAEA,sBAEA,mBACD,CATD,CAAYA,KAAAA,GAAoD,KAoChE,SAAYC,GAEV,kBAEA,uCAEA,2BAEA,2BAEA,yCAEA,0CAEA,wCAEA,kBAEA,iCAEA,uBACD,CArBD,CAAYA,KAAAA,GAA0B,KAmCtC,SAAYC,GAEV,yBAEA,eACD,CALD,CAAYA,KAAAA,GAAsB,KAuKlC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAqB,KAcjC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAiB,KA2C7B,SAAYC,GAEV,kBAKA,kBAKA,gBAKA,YAKA,gBAEA,cAKA,qBACD,CA9BD,CAAYA,KAAAA,GAAW,KAiGvB,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAwB,KA0BpC,SAAYC,GAEV,gBAEA,oBAEA,kBAEA,oBAEA,sBAEA,mBACD,CAbD,CAAYA,KAAAA,GAAW,KAwEvB,SAAYC,GAEV,cAEA,gBAEA,8BAEA,oBAEA,6BAEA,0BAEA,cAEA,aACD,CAjBD,CAAYA,KAAAA,GAAgB,KAkE5B,SAAYC,GAEV,uBAEA,2BAEA,uBAEA,6BAEA,wBACD,CAXD,CAAYA,KAAAA,GAAwB,KAcpC,SAAYC,GAEV,yBAEA,YAEA,qBAEA,yBAEA,cAEA,WACD,CAbD,CAAYA,KAAAA,GAAuB,KAsWnC,SAAYC,GAEV,sBAEA,4BACD,CALD,CAAYA,KAAAA,GAAwB,KAyCpC,SAAYC,GAEV,6BAEA,uBAEA,qBACD,CAPD,CAAYA,KAAAA,GAAgB,KA4E5B,SAAYC,GAEV,cAEA,2BAEA,aACD,CAPD,CAAYA,KAAAA,GAAoB,KAwChC,SAAYC,GAEV,yBAEA,cAEA,wBACD,CAPD,CAAYA,KAAAA,GAAiB,KA8D7B,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAY,KAQxB,SAAYC,GAEV,0CAEA,oDAEA,6BAEA,wBACD,CATD,CAAYA,KAAAA,GAAe,KAsM3B,SAAYC,GAEV,cAEA,kBAEA,+BAEA,aACD,CATD,CAAYA,KAAAA,GAAwB,KA+GpC,SAAYC,GAEV,yBAEA,cAEA,qBACD,CAPD,CAAYA,KAAAA,GAAwB,KAUpC,SAAYC,GAEV,wBAEA,cAEA,wBAEA,kBAEA,4CAEA,wBAEA,kBAEA,0BAEA,wBAEA,+BAEA,cAEA,gBAEA,yBAEA,iBACD,CA7BD,CAAYA,KAAAA,GAAkB,KAoX9B,SAAYC,GAEV,qBACD,CAHD,CAAYA,KAAAA,GAAiC,KAc7C,SAAYC,GAEV,qBACD,CAHD,CAAYA,KAAAA,GAAuB,KAMnC,SAAYC,GAEV,2BAEA,gBAEA,6BAEA,qBACD,CATD,CAAYA,KAAAA,GAAiB,KAoE7B,SAAYC,GAEV,yBAEA,kBAEA,gBAEA,wBACD,CATD,CAAYA,KAAAA,GAAmB,KAqD/B,SAAYC,GAEV,gBAEA,cAEA,kBAEA,iBACD,CATD,CAAYA,KAAAA,GAAc,KA2C1B,SAAYC,GAEV,cAEA,cAEA,gBAEA,kBAEA,cAEA,kBAEA,YAEA,iBACD,CAjBD,CAAYA,KAAAA,GAAqC,KA4FjD,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAc,KA8J1B,SAAYC,GAEV,6BAEA,iCAEA,4BACD,CAPD,CAAYA,KAAAA,GAAmB,KAkB/B,SAAYC,GAEV,yBAEA,cAEA,qBACD,CAPD,CAAYA,KAAAA,GAAuB,KA4DnC,SAAYC,GAEV,yBAEA,cAEA,kBAEA,wBACD,CATD,CAAYA,KAAAA,GAA4B,KAsoBxC,SAAYC,GAEV,gBAEA,kBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAsB,KAkBlC,SAAYC,GAEV,yBAEA,wBACD,CALD,CAAYA,KAAAA,GAAqB,KAiSjC,SAAYC,GAEV,oBAEA,uBACD,CALD,CAAYA,KAAAA,GAA6B,KAwCzC,SAAYC,GAEV,sBAEA,uCAEA,kCACD,CAPD,CAAYA,KAAAA,GAAyB,KAmBrC,SAAYC,GAEV,oBAEA,oBAEA,oBAEA,kCACD,CATD,CAAYA,KAAAA,GAAsB,KAYlC,SAAYC,GAEV,sBAEA,uCAEA,wBAEA,wBAEA,mBACD,CAXD,CAAYA,KAAAA,GAAsB,KAwFlC,SAAYC,GAEV,cAEA,aACD,CALD,CAAYA,KAAAA,GAAkC,KAmB9C,SAAYC,GAEV,kBAEA,kBAEA,aACD,CAPD,CAAYA,KAAAA,GAAgB,KAyH5B,SAAYC,GAEV,sDAEA,+CAEA,iCAEA,sEAEA,4EAEA,qDAEA,mDAEA,qDAEA,qDAEA,+CAEA,+CAEA,wDAEA,6BAEA,8CAEA,mCAEA,4DAEA,6DAEA,+CAEA,gDAEA,yCAEA,iCAEA,2EAEA,yCAEA,+CAEA,wDAEA,iDAEA,+BAEA,+BAEA,6BAEA,qDAEA,mCAEA,6BAEA,qCAEA,8DAEA,6BAEA,0CAEA,sEAEA,0CAEA,uDAEA,2DAEA,+CAEA,qCAEA,8DAEA,uDAEA,0CAEA,iCAEA,gDAEA,gDAEA,2DAEA,qCAEA,uCAEA,qCAEA,mCAEA,iCAEA,yDAEA,iCAEA,yCAEA,uCACD,CArHD,CAAYA,KAAAA,GAAgC,KAwH5C,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAsB,KAqZlC,SAAYC,GAEV,sBAEA,cAEA,gBAEA,kBAEA,gBAEA,kBAEA,2BAEA,sBACD,CAjBD,CAAYA,KAAAA,GAAe,KA2E3B,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAkB,KAkJ9B,SAAYC,GAEV,8BAEA,iCACD,CALD,CAAYA,KAAAA,GAAa,KAqSzB,SAAYC,GAEV,yBAEA,aACD,CALD,CAAYA,KAAAA,GAAiB,KA+Y7B,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAA8B,KA4D1C,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAiC,KAgH7C,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAgC,KA8D5C,SAAYC,GAEV,gBAEA,kBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAyC,KAgiBrD,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAA8B,KA4D1C,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAA+B,KA4D3C,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAoC,KA8DhD,SAAYC,GAEV,gBAEA,wBAEA,uBAEA,sBAEA,sBAEA,aACD,CAbD,CAAYA,KAAAA,GAA0B,KAqtBtC,SAAYC,GAEV,8BAKA,2CAEA,eACD,CAVD,CAAYA,KAAAA,GAAqB,KAsGjC,SAAYC,GAEV,kBAEA,gBAEA,6BAEA,0CAEA,yBACD,CAXD,CAAYA,KAAAA,GAA0B,KA8ItC,SAAYC,GAEV,yCAEA,uCAEA,iCAEA,oBACD,CATD,CAAYA,KAAAA,GAA0B,KAYtC,SAAYC,GAEV,mBAEA,uBAEA,qBAEA,yBAEA,wBACD,CAXD,CAAYA,KAAAA,GAAgC,KAc5C,SAAYC,GAEV,8BAEA,0BAEA,aACD,CAPD,CAAYA,KAAAA,GAAgC,KA0D5C,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAA8B,KAM1C,SAAYC,GAEV,oBAEA,wBAEA,kBAEA,kBAEA,sCACD,CAXD,CAAYA,KAAAA,GAAoB,KAyEhC,SAAYC,GAEV,YAEA,aACD,CALD,CAAYA,KAAAA,GAAiC,KAQ7C,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAA6B,KA+CzC,SAAYC,GAEV,yBAEA,cAEA,uBAEA,0BAEA,wBACD,CAXD,CAAYA,KAAAA,GAAoB,KA2DhC,SAAYC,GAKV,gBAEA,sBAEA,cAEA,kBAEA,eACD,CAdD,CAAYA,KAAAA,GAAoB,KAiBhC,SAAYC,GAEV,oBAEA,iBACD,CALD,CAAYA,KAAAA,GAAiB,KAmE7B,SAAYC,GAEV,0CAEA,kDAEA,yDAEA,gDAEA,sBAEA,sBAEA,oCAEA,6BAKA,6CAEA,kDAEA,2CAOA,gDAEA,oCAEA,iBACD,CArCD,CAAYA,KAAAA,GAAkB,KA6I9B,SAAYC,GAEV,kBAEA,WACD,CALD,CAAYA,KAAAA,GAAuB,KA0CnC,SAAYC,GAEV,sBAEA,oBAEA,iBACD,CAPD,CAAYA,KAAAA,GAAoB,KA2JhC,SAAYC,GAEV,4BAEA,mBACD,CALD,CAAYA,KAAAA,GAA2C,KAiBvD,SAAYC,GAEV,iCAEA,wBAEA,gBAEA,aACD,CATD,CAAYA,KAAAA,GAAiC,KAuC7C,SAAYC,GAEV,wBAEA,2BAEA,oBAEA,kBAEA,mBACD,CAXD,CAAYA,KAAAA,GAA2B,KA8ZvC,SAAYC,GAEV,+BAEA,gBAEA,6BACD,CAPD,CAAYA,KAAAA,GAAkB,KAU9B,SAAYC,GAEV,cAEA,8BAEA,2CAEA,uCAEA,8CAEA,yBACD,CAbD,CAAYA,KAAAA,GAAc,KAgB1B,SAAYC,GAEV,kBAEA,sBAKA,qBACD,CAVD,CAAYA,KAAAA,GAAe,KAyC3B,SAAYC,GAEV,cAEA,kBAEA,kBAEA,iBACD,CATD,CAAYA,KAAAA,GAAmB,KAY/B,SAAYC,GAEV,qBAEA,yBAEA,yBAEA,wBACD,CATD,CAAYA,KAAAA,GAAsB,KA0DlC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAoB,KAqEhC,SAAYC,GAEV,0BAEA,gBAEA,0BAEA,aACD,CATD,CAAYA,KAAAA,GAAU,KA2EtB,SAAYC,GAEV,oBAEA,mBACD,CALD,CAAYA,KAAAA,GAA8B,KAqB1C,SAAYC,GAEV,oBAEA,sBAEA,kBAEA,UAEA,gBAEA,YAEA,gBAEA,YAEA,YAEA,sBAEA,aACD,CAvBD,CAAYA,KAAAA,GAAyB,KAoDrC,SAAYC,GAEV,YAEA,aACD,CALD,CAAYA,KAAAA,GAA8B,KAgB1C,SAAYC,GAEV,6BAEA,wBACD,CALD,CAAYA,KAAAA,GAA0B,KA+BtC,SAAYC,GAEV,sBAEA,cAEA,YAEA,qBACD,CATD,CAAYA,KAAAA,GAAwB,KAmEpC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAA+B,KAuJ3C,SAAYC,GAEV,sBAEA,oBAEA,sBAEA,wBAEA,sBAEA,sBAEA,kBAEA,kBAEA,oBAEA,mBACD,CArBD,CAAYA,KAAAA,GAAqB,KAyDjC,SAAYC,GAEV,gBAEA,uBACD,CALD,CAAYA,KAAAA,GAAiB,KAmL7B,SAAYC,GAEV,eACD,CAHD,CAAYA,KAAAA,GAAqB,KA0BjC,SAAYC,GAEV,+CAEA,mCAEA,iCAEA,kBAEA,gDAEA,0BACD,CAbD,CAAYA,KAAAA,GAAsB,KA8ClC,SAAYC,GAEV,uBACD,CAHD,CAAYA,KAAAA,GAA0B,KAMtC,SAAYC,GAEV,YAEA,YAEA,gBAEA,aACD,CATD,CAAYA,KAAAA,GAAsB,KAYlC,SAAYC,GAEV,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,UAEA,SACD,CA7eD,CAAYA,KAAAA,GAA2B,KAkgBvC,SAAYC,GAEV,wDAEA,2CACD,CALD,CAAYA,KAAAA,GAAgB,KAwH5B,SAAYC,GAEV,0BAEA,aACD,CALD,CAAYA,KAAAA,GAA0C,KAmHtD,SAAYC,GAEV,yBAEA,8CACD,CALD,CAAYA,KAAAA,GAAsB,KAkIlC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAA+B,KAc3C,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAqB,KAMjC,SAAYC,GAEV,oBAEA,iBACD,CALD,CAAYA,KAAAA,GAAkB,KAQ9B,SAAYC,GAEV,gBAEA,mCAEA,kBACD,CAPD,CAAYA,KAAAA,GAAwB,KAUpC,SAAYC,GAEV,uCAEA,oBACD,CALD,CAAYA,KAAAA,GAAsB,KAwClC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAc,KA6R1B,SAAYC,GAEV,gBAEA,sBAEA,oBAEA,oBAEA,mBACD,CAXD,CAAYA,KAAAA,GAAW,KA6HvB,SAAYC,GAEV,oBAEA,0BAEA,6BACD,CAPD,CAAYA,KAAAA,GAAiB,KAyqB7B,SAAYC,GAEV,iBACD,CAHD,CAAYA,KAAAA,GAA+B,KAoC3C,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAwB,KAkDpC,SAAYC,GAEV,yBAEA,eACD,CALD,CAAYA,KAAAA,GAAoB,KAQhC,SAAYC,GAEV,0BAEA,iBACD,CALD,CAAYA,KAAAA,GAAc,KAQ1B,SAAYC,GAEV,YAEA,yBAEA,uBACD,CAPD,CAAYA,KAAAA,GAAkB,KAU9B,SAAYC,GAEV,iDAEA,8CACD,CALD,CAAYA,KAAAA,GAAuB,KAgBnC,SAAYC,GAEV,aACD,CAHD,CAAYA,KAAAA,GAAc,KAM1B,SAAYC,GAEV,kBAEA,mBACD,CALD,CAAYA,KAAAA,GAAW,KAmJvB,SAAYC,GAEV,yBAEA,cAEA,0BAEA,uBAEA,0BAEA,wBACD,CAbD,CAAYA,KAAAA,GAAwB,KAgBpC,SAAYC,GAEV,6BAEA,0BACD,CALD,CAAYA,KAAAA,GAA6B,KAQzC,SAAYC,GAEV,gBAEA,iBACD,CALD,CAAYA,KAAAA,GAAQ,KA0FpB,SAAYC,GAEV,6BAEA,2CAEA,2BAEA,4BACD,CATD,CAAYA,KAAAA,GAA4B,KAYxC,SAAYC,GAEV,kBAEA,aACD,CALD,CAAYA,KAAAA,GAAkB,KAk9E9B,SAAYC,GAEV,mBAEA,uBAEA,qBAEA,wBAEA,wBACD,CAXD,CAAYA,KAAAA,GAAiB,KA6J7B,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAoB,KAsEhC,SAAYC,GAEV,yBAEA,iBACD,CALD,CAAYA,KAAAA,GAA0B,KAqLtC,SAAYC,GAEV,wBACD,CAHD,CAAYA,KAAAA,GAAqB,KAMjC,SAAYC,GAEV,kBAEA,oBAEA,+BAEA,2CAEA,sCACD,CAXD,CAAYA,KAAAA,GAAa,K,eC7n5BzB,MA+gBA,GA/gByB,CACvB5U,KAAM,uBACN6U,SAAU,CACR,CACEA,SAAU,CACRC,WAAY,UACZC,WAAY,YAGhB,CACE/U,KAAM,wBACNgV,MAAO,CACL,uBACA,mBACA,8BACA,0CACA,uCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mCACNgV,MAAO,CACL,mBACA,gBACA,eACA,mBACA,wBACA,yBACA,+BACA,oBACA,0BACA,uBACA,0BACA,yBACA,0BACA,wBACA,uBACA,kBACA,0BACA,2BACA,2BACA,+BACA,4BACA,oBACA,iCACA,oCACA,8BACA,0BACA,sBACA,iCACA,iCACA,8BACA,mCACA,sCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,wDACNgV,MAAO,CACL,sBACA,qBACA,wBACA,uBACA,wBACA,gCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,kCACNgV,MAAO,CACL,kBACA,kCACA,0BACA,sBACA,yBACA,wBAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,8BACNgV,MAAO,CACL,WACA,gCACA,mBACA,wBAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,sBACNgV,MAAO,CAAC,0BAA2B,6BACnCH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mCACNgV,MAAO,0BACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,qBACNgV,MAAO,CACL,kCACA,6BACA,8BACA,yBACA,iCACA,2BACA,0BAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,4BACNgV,MAAO,CACL,sCACA,gDACA,gDACA,yCACA,uCACA,mCACA,oCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,4CACA,4CACA,wCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,6BAA8B,iCACtCH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qCACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,4BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,gBAAiB,0BACzBH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,WACPH,SAAU,CACRI,UAAW,WAGf,CACED,MAAO,SACPH,SAAU,CACRI,UAAW,SAGf,CACED,MAAO,SACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,mBACA,6CACA,iCACA,mCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,sBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,8BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,wCACA,8CACA,qCACA,kDACA,+CACA,iDACA,iDACA,6CACA,oCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,mBACPH,SAAU,CACRI,UAAW,cAGf,CACED,MAAO,cACPH,SAAU,CACRI,UAAW,OACXH,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRI,UAAW,OACXH,WAAY,YAGhB,CACEE,MAAO,gBACPH,SAAU,CACRI,UAAW,WAGf,CACED,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,8CACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,6CACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,4BACNgV,MAAO,6BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,oBAAqB,qCAC7BH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,2BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,4BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,uCACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,mBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,eACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,mBAAoB,6BAC5BH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,SAAU,6CAA8C,0BAChEH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,aACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,eACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,gBACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,uBACNgV,MAAO,CACL,mDACA,iDACA,gCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mDACNgV,MAAO,2BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,sCACA,6BACA,eACA,gBACA,sBACA,0BAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,mBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,uBACA,8BACA,wBACA,0BACA,2BACA,0BACA,2BACA,8BACA,kCACA,6BAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,yCAA0C,wCAClDH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,8BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,0BACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,sDACNgV,MAAO,CACL,+BACA,kCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,YACNgV,MAAO,oBACPH,SAAU,CACRC,WAAY,cCcpB,GAvhByB,CACvB9U,KAAM,yBACN6U,SAAU,CACR,CACEA,SAAU,CACRC,WAAY,UACZC,WAAY,YAGhB,CACE/U,KAAM,wBACNgV,MAAO,CACL,uBACA,mBACA,8BACA,0CACA,uCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mCACNgV,MAAO,CACL,mBACA,gBACA,eACA,mBACA,wBACA,yBACA,+BACA,oBACA,0BACA,uBACA,0BACA,yBACA,0BACA,wBACA,uBACA,kBACA,0BACA,2BACA,2BACA,+BACA,4BACA,oBACA,iCACA,oCACA,8BACA,0BACA,sBACA,iCACA,iCACA,8BACA,mCACA,sCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,wDACNgV,MAAO,CACL,sBACA,qBACA,wBACA,uBACA,wBACA,gCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,kCACNgV,MAAO,CACL,kBACA,kCACA,qCACA,sBACA,yBACA,wBAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,8BACNgV,MAAO,CACL,WACA,gCACA,mBACA,wBAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,sBACNgV,MAAO,CAAC,0BAA2B,6BACnCH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mCACNgV,MAAO,0BACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,qBACNgV,MAAO,CACL,kCACA,6BACA,8BACA,yBACA,iCACA,2BACA,0BAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,4BACNgV,MAAO,CACL,sCACA,gDACA,gDACA,yCACA,uCACA,mCACA,oCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,4CACA,4CACA,wCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qCACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,6BAA8B,iCACtCH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,4BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,gBAAiB,0BACzBH,SAAU,CACRC,WAAY,cAGhB,CACEE,MAAO,WACPH,SAAU,CACRI,UAAW,WAGf,CACED,MAAO,SACPH,SAAU,CACRI,UAAW,SAGf,CACED,MAAO,mBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,mBACA,6CACA,iCACA,mCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,kCACNgV,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,uBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,8BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,wCACA,8CACA,qCACA,kDACA,+CACA,iDACA,iDACA,6CACA,oCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,mBACPH,SAAU,CACRI,UAAW,cAGf,CACED,MAAO,cACPH,SAAU,CACRI,UAAW,OACXH,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRI,UAAW,OACXH,WAAY,YAGhB,CACEE,MAAO,gBACPH,SAAU,CACRI,UAAW,WAGf,CACED,MAAO,kBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,iBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,8CACA,8CAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,oBACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,4BACNgV,MAAO,6BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,oBAAqB,qCAC7BH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,2BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,4BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,uCACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,eACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,mBAAoB,6BAC5BH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,SAAU,6CAA8C,0BAChEH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,oCACA,oBACA,0BACA,gCACA,iCACA,6BACA,4BACA,2BACA,2BACA,4BACA,4BACA,4BACA,uBACA,kCACA,mCAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,gBACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,uBACNgV,MAAO,CACL,mDACA,iDACA,gCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,mDACNgV,MAAO,2BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,sCACA,6BACA,eACA,gBACA,sBACA,0BAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,kCACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,UACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,mBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CACL,uBACA,8BACA,wBACA,0BACA,2BACA,0BACA,2BACA,8BACA,kCACA,6BAEFH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,qBACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,CAAC,yCAA0C,wCAClDH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,8BACPH,SAAU,CACRC,WAAY,YAGhB,CACEE,MAAO,0BACPH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,sDACNgV,MAAO,CACL,+BACA,kCACA,iCAEFH,SAAU,CACRC,WAAY,YAGhB,CACE9U,KAAM,YACNgV,MAAO,oBACPH,SAAU,CACRC,WAAY,cCphBL9T,eAAekU,GAC5BC,EACAC,GAEA,MAAMC,EAAM,uBAAuBF,KAAcC,IAC3CE,QAAiBC,MAAMF,GAE7B,MAAO,CAACD,OAAMI,cADQF,EAASG,OAEjC,CCRe,MAAMC,GAInB3W,YAAoB4W,GAAA,KAAAA,SAAAA,CAAqB,CAMzCC,YAAYC,GACV,OAAO3W,KAAKyW,SAASC,YAAYC,EACnC,CAKAC,cACE,OAAO5W,KAAKyW,SAASG,aACvB,E,yBCTF,MAAMC,GAAmB,gCAEV/U,eAAegV,GAC5BC,EACAla,SASF,WAC8B,OAAxBma,KACFA,GAMJlV,iBACE,MAAMmV,EAAuBZ,MAAMQ,IAC7BT,QAAiBa,EAEjBC,EAAcd,EAASe,QAAQrR,IAAI,gBAGzC,GAF2C,qBAAhBoR,QAGnB,KAAAE,UAAShB,OACV,CACL,MAAMiB,EAAgB,CACpBrY,WAAYoX,EAASkB,cACrBC,MAAMC,GAEJrZ,QAAQuD,KAAK8V,EACf,SAEI,KAAAJ,UAASC,E,CAEnB,CAzB0BI,IAGxB,OAAOT,EACT,CAbQU,GACN,MAAMjB,ECTO,SACbM,EACAla,EACAmZ,GAEA,OAAO,IAAI,GAAA2B,SAAS,CAClBZ,QACAa,QAAStX,QAAQC,QAAQ,CACvBsX,kBAAiB,qBACjBC,iBAAgB,sBAGlBhW,kBAAkBiW,GAChB,MAAMC,EAASnb,EAASkb,GACxB,GAAc,MAAVC,EAAgB,CAClB,MAAM,KAAC9B,EAAI,QAAEI,SAAiBN,EAAagC,EAAO9a,SAAU8a,EAAO7a,YAI7D8a,EAAW,WAAW/B,IAC5B,OAAO,KAAAgC,iBAAgB5B,EAAS2B,E,CAMhC,OAAO3X,QAAQC,QAAQ,KAE3B,EAaA4X,cAAcJ,GACIlb,EAASkb,IACT/a,iBAAcD,GAGpC,CDrCmBqb,CAAuBrB,EAAOla,EAAUmZ,IACzD,OAAO,IAAIQ,GAAaC,EAC1B,CAEA,IAAIO,GAA4C,KEhBhD,MAAMqB,GAAkB,QAqBjB,SAASC,GACdC,EACAjC,EACAkC,EAhBkC,KAuBlC,OAGK,SACLC,EACAnC,EACAkC,EA7BkC,KA+BlC,IAAIzT,EAAQ,GAAA2T,QACZ,OAAOD,EAAM/T,KAAKiU,IAGhB,MAAM5S,EAASuQ,EAAQsC,cAAcD,EAAM5T,EAAOyT,GAK5CK,EAAe9S,EAAO+S,OAAOC,QAAU,EACvCC,EAAa,GACnB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAcI,IAAK,CACrC,MAAMC,EAAanT,EAAO+S,OAAO,EAAIG,GAC/BE,EAAiBF,EAAI,EAAIJ,EAAe9S,EAAO+S,OAAO,EAAIG,EAAI,GAAKN,EAAKI,OAE9E,GAAkB,KADAJ,EAAKS,UAAUF,EAAYC,GAE3C,SAGF,MAQME,GARWtT,EAAO+S,OAAO,EAAIG,EAAI,GAQLZ,MAjEd,GAmEpBW,EAAW7Z,KAAK,CACdma,MAAOJ,EACPK,IAAKJ,EACLK,MAAOH,G,CAQX,OADAtU,EAAQgB,EAAO0T,aAAe1U,EAAQgB,EAAO2T,UACtCV,CAAU,GAErB,CAlDSW,CAAcpB,EAAaqB,MAAM,MAAOtD,EAASkC,EAC1D,CC8FA,MAAMqB,GAAcvT,KAIpB3H,GAAkB,IAAMkb,GAAYhS,UAUpC,MAAMiS,GC1HS,SAAqBC,GAClC,IAAI1S,EAA6B,KACjC,MAAO,IAAOA,EAAUA,GAAW0S,GACrC,CDuHqDC,EAASlY,UAC5D,MAAMhC,QAAWsG,IACjB,OAAO,IAAIxE,EACT9B,EACA,IAAIgI,EACQ,KACD,KACZ,IAGGmS,GEzIG,IAAIzb,iBAAiB,gBF2I9B,IAAI0b,GAAoB,EAExB,SAASC,KACP,MAAM7X,EAA4B,CAChC8X,OE7J+B,4BF8J/BC,WAAYR,GAAY/Y,KACxBwZ,UAAgC,GAArBJ,IAEbD,GAAiBM,YAAYjY,EAC/B,CAEA,SAASkY,GAAmBC,GAC1BP,IAAqBO,GACK,IAAtBP,IAAkD,IAAtBA,IAAqC,IAAVO,IACzDN,IAEJ,CAEA,SAASO,GAAUC,GAAmB,KAAC3b,IACrC,MAAM,GAACoD,EAAE,OAAEgY,EAAM,OAAEQ,GAAU5b,EAC7B,OAAQob,GACN,IAAK,iBACHI,GAAmB,GAoFzB1Y,gBAAmC,OACjC+Y,EAAM,OACNC,IAEA,MAAOC,EAAYC,SAAmBC,GAAYJ,EAAQC,GAG1D,OG7Oa,SAAwBI,EAAcC,GACnD,MAAMC,EAAuC,CAAC,EACxCC,EAAwC,CAAC,EAIzCC,GAAQ,SACZ,GACA,GACAJ,EACAC,OACApe,OACAA,EACA,CACEwe,QnBzC8B,ImB6ClC,IAAIC,EAAW,EA+Bf,OA9BAF,EAAMG,MAAMlc,SAAQ,EAAEkZ,QAAOiD,WAAUC,eACrC,MAAMC,ECpCK,SAAiCnD,GAC9C,MAAMmD,EAAS,GACf,IAAIC,EA4BG,CACLC,OAAQ,GACRC,QAAS,GACTC,MAAO,IAXT,OAnBAvD,EAAMlZ,SAAQ0c,IACZ,MAAMC,EAAYD,EAASE,OAAO,GAC5BxD,EAAOsD,EAASG,MAAM,GACV,MAAdF,GAmBR,SAAmBL,GACjB,OAAgC,IAAzBA,EAAME,QAAQhD,QAAuC,IAAvB8C,EAAMG,MAAMjD,MACnD,CApBUsD,CAAUR,KAEZD,EAAOzc,KAAK0c,GACZA,EAoBC,CACLC,OAAQ,GACRC,QAAS,GACTC,MAAO,KArBLH,EAAMC,OAAO3c,KAAKwZ,IACK,MAAduD,EACTL,EAAME,QAAQ5c,KAAKwZ,GACI,MAAduD,GACTL,EAAMG,MAAM7c,KAAKwZ,E,IAIrBiD,EAAOzc,KAAK0c,GAELD,CACT,CDamBU,CAAwB7D,GACvC,IAAI8D,EAAWb,EACXc,EAAYb,IACdH,EAEFI,EAAOrc,SAAQ,EAAEuc,SAAQC,UAASC,YAChC,IAAIS,EAAQX,EAAO/C,OACnB,OAAS0D,GAAS,GAChBrB,EAAYmB,GAAYf,EACxBH,EAAamB,GAAahB,IACxBe,IACAC,IACAhB,EAGJ,IADAiB,EAAQV,EAAQhD,SACP0D,GAAS,GAChBrB,EAAYmB,GAAYf,IACtBe,IACAf,EAGJ,IADAiB,EAAQT,EAAMjD,SACL0D,GAAS,GAChBpB,EAAamB,GAAahB,IACxBgB,IACAhB,C,GAEJ,IAGG,CACL,CAAC5R,EAAS8S,MAAOtB,EACjB,CAACxR,EAAS+S,OAAQtB,EAEtB,CHwLSuB,CAFgB7B,GAAYxE,MAAQ,GACrByE,GAAWzE,MAAQ,GAE3C,CA3FMsG,CAAoBjC,GACjBhT,MAAKkV,GAAMnC,EAAKJ,YAAY,CAACnY,KAAI0a,SACjCC,SAAQ,IAAMvC,IAAoB,KACrC,MAEF,IAAK,WAAY,CACfA,GAAmB,GACnB,MAAM,UAACwC,GAAapC,EACpBqC,GAAgBD,GACbpV,MAAKzH,IACJ,MAAM+c,EAAW/c,EAAMyW,cACvB+D,EAAKJ,YAAY,CAACnY,KAAI0a,GAAII,GAAU,IAErCH,SAAQ,IAAMvC,IAAoB,KACrC,K,CAEF,IAAK,kBACHA,GAAmB,GA2BzB1Y,gBAA+B,KAC7Bqb,EAAI,UACJpF,EAAS,UACTiF,EAAS,OACTI,EAAM,MACNC,IAEA,MAAOtC,EAAYC,SAAmBC,GAAYmC,EAAQC,GACpDC,EAAiBvC,GAAYxE,MAAQ,GACrCgH,EAAgBvC,GAAWzE,MAAQ,GACnC+E,GAAQ,SAAgB6B,EAAMA,EAAMG,EAAgBC,OAAexgB,OAAWA,EAAW,CAC7Fwe,QhBrOgC,IgBwO5BiC,EACS,MAAbzF,EACI,CAACqF,OAAQ,KAAMC,MAAO,YAK9Bvb,eACEiW,EACAiF,EACAM,EACAC,GAEA,MAAMpd,QAAc8c,GAAgBD,GAC9B1G,QAAgBnW,EAAMuW,YAAYqB,GACxC,GAAe,MAAXzB,EACF,MAAO,CAAC8G,OAAQ,KAAMC,MAAO,MAG/B,MAAO,CACLD,OAAQ9E,GAAqBgF,EAAgBhH,GAC7C+G,MAAO/E,GAAqBiF,EAAejH,GAE/C,CApBcmH,CAAkB1F,EAAWiF,EAAWM,EAAgBC,GACpE,MAAO,CAACjC,QAAOkC,eACjB,CA7CME,CAAgB9C,GACbhT,MAAKkV,GAAMnC,EAAKJ,YAAY,CAACnY,KAAI0a,SACjCC,SAAQ,IAAMvC,IAAoB,KACrC,MAEF,IAAK,YACHA,GAAmB,GA8FzB1Y,gBAA6B,IAACR,EAAG,MAAEgY,EAAK,SAAEqE,IACxC,MAAM9b,QAAeiY,KACfvW,QAAa1B,EAAO2B,QAAQlC,GAC5Bsc,EAAmB,MAARra,EAEXsa,EAAWta,GAAMsa,WAAY,EAOnC,MAAO,CAACC,aAJNva,GAAMgT,MACFqD,MAAM,OACNwC,MAAM9C,EAAQ,EAAGA,EAAQqE,EAAW,GACrCI,KAAK,OAAS,KACGH,WAAUC,WAClC,CA1GMG,CAAcpD,GACXhT,MAAKkV,GAAMnC,EAAKJ,YAAY,CAACnY,KAAI0a,SACjCC,SAAQ,IAAMvC,IAAoB,KACrC,MAEF,IAAK,qBACHL,KAIN,CA0DArY,eAAemZ,GACbC,EACAC,GAEA,MAAMtZ,QAAeiY,KACrB,OAAOxZ,QAAQmE,IAAI,CACT,MAARyW,EAAerZ,EAAO2B,QAAQ0X,GAAQ,KAC7B,MAATC,EAAgBtZ,EAAO2B,QAAQ2X,GAAS,MAE5C,CAjEAtB,GAAY3a,iBAAiB,WAAYyB,IACvC,MAAMga,EAAOha,EAAMsd,MAAM,GACzBtD,EAAKuD,UAAavd,GAAwB+Z,GAAUC,EAAMha,EAAM,IAGlEwZ,KA8DA,MAAMgE,GAA0B,IAAIC,IAEpC,SAASnB,GAAgBD,GACvB,MAAMqB,EAAkBF,GAAwBrY,IAAIkX,GACpD,GAAuB,MAAnBqB,EACF,OAAOA,EAGT,MACMle,EAAQ2W,GADc,QAAdkG,EAAsBsB,GAAuBC,GACnB1hB,GAExC,OADAshB,GAAwBK,IAAIxB,EAAW7c,GAChCA,CACT,C,GKhTIse,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqB5hB,IAAjB6hB,EACH,OAAOA,EAAapiB,QAGrB,IAAIC,EAASgiB,EAAyBE,GAAY,CAGjDniB,QAAS,CAAC,GAOX,OAHAqiB,EAAoBF,GAAUG,KAAKriB,EAAOD,QAASC,EAAQA,EAAOD,QAASkiB,GAGpEjiB,EAAOD,OACf,C,OAGAkiB,EAAoBK,EAAIF,EAGxBH,EAAoBM,EAAI,KAGvB,IAAIC,EAAsBP,EAAoBQ,OAAEniB,EAAW,CAAC,MAAM,IAAO2hB,EAAoB,MAE7F,OADAO,EAAsBP,EAAoBQ,EAAED,EAClB,E,MCjC3B,IAAIE,EAAW,GACfT,EAAoBQ,EAAI,CAACnZ,EAAQqZ,EAAUC,EAAIC,KAC9C,IAAGF,EAAH,CAMA,IAAIG,EAAeC,IACnB,IAASC,EAAI,EAAGA,EAAIN,EAASpG,OAAQ0G,IAAK,CAGzC,IAFA,IAAKL,EAAUC,EAAIC,GAAYH,EAASM,GACpCC,GAAY,EACPzG,EAAI,EAAGA,EAAImG,EAASrG,OAAQE,MACpB,EAAXqG,GAAsBC,GAAgBD,IAAaK,OAAOC,KAAKlB,EAAoBQ,GAAGW,OAAO7Z,GAAS0Y,EAAoBQ,EAAElZ,GAAKoZ,EAASnG,MAC9ImG,EAASU,OAAO7G,IAAK,IAErByG,GAAY,EACTJ,EAAWC,IAAcA,EAAeD,IAG7C,GAAGI,EAAW,CACbP,EAASW,OAAOL,IAAK,GACrB,IAAIM,EAAIV,SACEtiB,IAANgjB,IAAiBha,EAASga,EAC/B,CACD,CACA,OAAOha,CAnBP,CAJCuZ,EAAWA,GAAY,EACvB,IAAI,IAAIG,EAAIN,EAASpG,OAAQ0G,EAAI,GAAKN,EAASM,EAAI,GAAG,GAAKH,EAAUG,IAAKN,EAASM,GAAKN,EAASM,EAAI,GACrGN,EAASM,GAAK,CAACL,EAAUC,EAAIC,EAqBjB,C,KCzBdZ,EAAoBsB,EAAI,CAACxjB,EAASyjB,KACjC,IAAI,IAAIja,KAAOia,EACXvB,EAAoBwB,EAAED,EAAYja,KAAS0Y,EAAoBwB,EAAE1jB,EAASwJ,IAC5E2Z,OAAOQ,eAAe3jB,EAASwJ,EAAK,CAAEoa,YAAY,EAAMta,IAAKma,EAAWja,IAE1E,ECND0Y,EAAoB2B,EAAI,CAAC,EAGzB3B,EAAoBxd,EAAKof,GACjBhgB,QAAQmE,IAAIkb,OAAOC,KAAKlB,EAAoB2B,GAAGE,QAAO,CAACC,EAAUxa,KACvE0Y,EAAoB2B,EAAEra,GAAKsa,EAASE,GAC7BA,IACL,KCNJ9B,EAAoB+B,EAAKH,GAEjB,aAAeA,EAAf,qBCFR5B,EAAoBgC,SAAYJ,IAEf,ECHjB5B,EAAoBwB,EAAI,CAAClf,EAAK2f,IAAUhB,OAAOiB,UAAUC,eAAe/B,KAAK9d,EAAK2f,GCAlFjC,EAAoBoC,EAAI,I,MCIxB,IAAIC,EAAkB,CACrB,GAAI,GAgBLrC,EAAoB2B,EAAEZ,EAAI,CAACa,EAASE,KAE/BO,EAAgBT,IAElBU,cAActC,EAAoBoC,EAAIpC,EAAoB+B,EAAEH,GAE9D,EAGD,IAAIW,EAAqBrkB,WAAoC,wBAAIA,WAAoC,yBAAK,GACtGskB,EAA6BD,EAAmB9hB,KAAKgiB,KAAKF,GAC9DA,EAAmB9hB,KAvBCH,IACnB,IAAKogB,EAAUgC,EAAaC,GAAWriB,EACvC,IAAI,IAAI2f,KAAYyC,EAChB1C,EAAoBwB,EAAEkB,EAAazC,KACrCD,EAAoBK,EAAEJ,GAAYyC,EAAYzC,IAIhD,IADG0C,GAASA,EAAQ3C,GACdU,EAASrG,QACdgI,EAAgB3B,EAASkC,OAAS,EACnCJ,EAA2BliB,EAAK,C,WCnBjC,IAAIuiB,EAAO7C,EAAoBM,EAC/BN,EAAoBM,EAAI,IAChBN,EAAoBxd,EAAE,KAAK0G,KAAK2Z,E,KCDd7C,EAAoBM,G","sources":["../webpack/universalModuleDefinition","../../reviewstack/src/constants.ts","../../reviewstack/src/generated/textmate/TextMateGrammarManifest.ts","../../reviewstack/src/github/GitHubClientStats.ts","../../reviewstack/src/github/databaseInfo.ts","../../reviewstack/src/github/logoutBroadcastChannel.ts","../../reviewstack/src/github/CachingGitHubClient.ts","../../shared/rejectAfterTimeout.ts","../../reviewstack/src/github/RejectingGitHubClient.ts","../../reviewstack/src/generated/graphql.ts","../../reviewstack/src/textmate/VSCodeDarkPlusTheme.ts","../../reviewstack/src/textmate/VSCodeLightPlusTheme.ts","../../reviewstack/src/textmate/fetchGrammar.ts","../../shared/textmate-lib/GrammarStore.ts","../../reviewstack/src/textmate/createGrammarStore.ts","../../shared/textmate-lib/createTextMateRegistry.ts","../../shared/textmate-lib/tokenize.ts","../../reviewstack/src/diffServiceWorker.ts","../../shared/lazyInit.ts","../../reviewstack/src/broadcast.ts","../../reviewstack/src/lineToPosition.ts","../../shared/SplitDiffView/organizeLinesIntoGroups.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReviewStack\"] = factory();\n\telse\n\t\troot[\"ReviewStack\"] = factory();\n})(globalThis, () => {\nreturn ","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport const APP_HEADER_HEIGHT = 60;\n\nexport const CURSOR_POINTER = {cursor: 'pointer'};\n\n/**\n * GitHub diffs appear to include 3 lines of context. This is especially\n * important when mapping line number to \"position\".\n */\nexport const NUM_LINES_OF_CONTEXT = 3;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @generated\n */\n\nimport type {Grammar, LanguageConfiguration} from 'shared/textmate-lib/types';\n\nconst grammars: {[scopeName: string]: Grammar} = {\n  'documentation.injection.js.jsx': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'documentation_injection_js_jsx_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'documentation.injection.ts': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'documentation_injection_ts_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.cabal.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {'meta.embedded.block.cabal': 'cabal'},\n    fileName: 'markdown_cabal_codeblock_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.hack.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {'meta.embedded.block.hack': 'hack'},\n    fileName: 'markdown_hack_codeblock_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.haskell.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {'meta.embedded.block.haskell': 'haskell'},\n    fileName: 'markdown_haskell_codeblock_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.kotlin.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {'meta.embedded.block.kotlin': 'kotlin'},\n    fileName: 'markdown_kotlin_codeblock_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.lhaskell.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {'meta.embedded.block.lhaskell': 'lhaskell'},\n    fileName: 'markdown_lhaskell_codeblock_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'markdown.toml.frontmatter.codeblock': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'markdown_toml_frontmatter_codeblock_TextMateGrammar',\n    fileFormat: 'plist',\n  },\n  'source.asp.vb.net': {\n    language: 'vb',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_asp_vb_net_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.batchfile': {\n    language: 'bat',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_batchfile_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.c': {\n    language: 'c',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_c_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.c.platform': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_c_platform_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.c2hs': {\n    language: 'C2Hs',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_c2hs_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.cabal': {\n    language: 'cabal',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_cabal_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.clojure': {\n    language: 'clojure',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_clojure_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.coffee': {\n    language: 'coffeescript',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_coffee_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.cpp': {\n    language: 'cpp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_cpp_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.cpp.embedded.macro': {\n    language: 'cpp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_cpp_embedded_macro_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.cs': {\n    language: 'csharp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_cs_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.css': {\n    language: 'css',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_css_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.css.less': {\n    language: 'less',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_css_less_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.css.scss': {\n    language: 'scss',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_css_scss_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.cuda-cpp': {\n    language: 'cuda-cpp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_cuda-cpp_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.dart': {\n    language: 'dart',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_dart_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.dockerfile': {\n    language: 'dockerfile',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_dockerfile_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.fsharp': {\n    language: 'fsharp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_fsharp_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.gdscript': {\n    language: 'gdscript',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_gdscript_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.go': {\n    language: 'go',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_go_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.groovy': {\n    language: 'groovy',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_groovy_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.hack': {\n    language: 'hack',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_hack_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.haskell': {\n    language: 'haskell',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_haskell_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.hlsl': {\n    language: 'hlsl',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_hlsl_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.hsc': {\n    language: 'Hsc2Hs',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_hsc_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.ignore': {\n    language: 'ignore',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_ignore_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.ini': {\n    language: 'ini',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_ini_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.java': {\n    language: 'java',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_java_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.js': {\n    language: 'javascript',\n    injections: ['documentation.injection.js.jsx'],\n    embeddedLanguages: {\n      'meta.tag.js': 'jsx-tags',\n      'meta.tag.without-attributes.js': 'jsx-tags',\n      'meta.tag.attributes.js': 'javascript',\n      'meta.embedded.expression.js': 'javascript',\n    },\n    fileName: 'source_js_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.js.jsx': {\n    language: 'javascriptreact',\n    injections: ['documentation.injection.js.jsx'],\n    embeddedLanguages: {\n      'meta.tag.js': 'jsx-tags',\n      'meta.tag.without-attributes.js': 'jsx-tags',\n      'meta.tag.attributes.js.jsx': 'javascriptreact',\n      'meta.embedded.expression.js': 'javascriptreact',\n    },\n    fileName: 'source_js_jsx_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.js.regexp': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_js_regexp_TextMateGrammar',\n    fileFormat: 'plist',\n  },\n  'source.julia': {\n    language: 'julia',\n    injections: [],\n    embeddedLanguages: {\n      'meta.embedded.inline.cpp': 'cpp',\n      'meta.embedded.inline.javascript': 'javascript',\n      'meta.embedded.inline.python': 'python',\n      'meta.embedded.inline.r': 'r',\n      'meta.embedded.inline.sql': 'sql',\n    },\n    fileName: 'source_julia_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.kotlin': {\n    language: 'kotlin',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_kotlin_TextMateGrammar',\n    fileFormat: 'plist',\n  },\n  'source.lua': {\n    language: 'lua',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_lua_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.makefile': {\n    language: 'makefile',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_makefile_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.objc': {\n    language: 'objective-c',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_objc_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.objcpp': {\n    language: 'objective-cpp',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_objcpp_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.perl': {\n    language: 'perl',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_perl_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.perl.6': {\n    language: 'perl6',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_perl_6_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.powershell': {\n    language: 'powershell',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_powershell_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.python': {\n    language: 'python',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_python_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.r': {\n    language: 'r',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_r_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.regexp.python': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_regexp_python_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.ruby': {\n    language: 'ruby',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_ruby_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.rust': {\n    language: 'rust',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_rust_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.sassdoc': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_sassdoc_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.shell': {\n    language: 'shellscript',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_shell_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.sql': {\n    language: 'sql',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_sql_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.swift': {\n    language: 'swift',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_swift_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.thrift': {\n    language: 'thrift',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_thrift_TextMateGrammar',\n    fileFormat: 'plist',\n  },\n  'source.toml': {\n    language: 'toml',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_toml_TextMateGrammar',\n    fileFormat: 'plist',\n  },\n  'source.ts': {\n    language: 'typescript',\n    injections: ['documentation.injection.ts'],\n    embeddedLanguages: undefined,\n    fileName: 'source_ts_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.tsx': {\n    language: 'typescriptreact',\n    injections: ['documentation.injection.ts'],\n    embeddedLanguages: {\n      'meta.tag.tsx': 'jsx-tags',\n      'meta.tag.without-attributes.tsx': 'jsx-tags',\n      'meta.tag.attributes.tsx': 'typescriptreact',\n      'meta.embedded.expression.tsx': 'typescriptreact',\n    },\n    fileName: 'source_tsx_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'source.yaml': {\n    language: 'yaml',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'source_yaml_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.git-commit': {\n    language: 'git-commit',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_git-commit_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.git-rebase': {\n    language: 'git-rebase',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_git-rebase_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.html.basic': {\n    language: undefined,\n    injections: [],\n    embeddedLanguages: {\n      'text.html': 'html',\n      'source.css': 'css',\n      'source.js': 'javascript',\n      'source.python': 'python',\n      'source.smarty': 'smarty',\n    },\n    fileName: 'text_html_basic_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.html.cshtml': {\n    language: 'razor',\n    injections: [],\n    embeddedLanguages: {\n      'section.embedded.source.cshtml': 'csharp',\n      'source.css': 'css',\n      'source.js': 'javascript',\n    },\n    fileName: 'text_html_cshtml_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.html.derivative': {\n    language: 'html',\n    injections: [],\n    embeddedLanguages: {\n      'text.html': 'html',\n      'source.css': 'css',\n      'source.js': 'javascript',\n      'source.python': 'python',\n      'source.smarty': 'smarty',\n    },\n    fileName: 'text_html_derivative_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.html.handlebars': {\n    language: 'handlebars',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_html_handlebars_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.html.markdown': {\n    language: 'markdown',\n    injections: [\n      'markdown.cabal.codeblock',\n      'markdown.hack.codeblock',\n      'markdown.haskell.codeblock',\n      'markdown.kotlin.codeblock',\n      'markdown.lhaskell.codeblock',\n      'markdown.toml.frontmatter.codeblock',\n    ],\n    embeddedLanguages: {\n      'meta.embedded.block.html': 'html',\n      'source.js': 'javascript',\n      'source.css': 'css',\n      'meta.embedded.block.frontmatter': 'yaml',\n      'meta.embedded.block.css': 'css',\n      'meta.embedded.block.ini': 'ini',\n      'meta.embedded.block.java': 'java',\n      'meta.embedded.block.lua': 'lua',\n      'meta.embedded.block.makefile': 'makefile',\n      'meta.embedded.block.perl': 'perl',\n      'meta.embedded.block.r': 'r',\n      'meta.embedded.block.ruby': 'ruby',\n      'meta.embedded.block.php': 'php',\n      'meta.embedded.block.sql': 'sql',\n      'meta.embedded.block.vs_net': 'vs_net',\n      'meta.embedded.block.xml': 'xml',\n      'meta.embedded.block.xsl': 'xsl',\n      'meta.embedded.block.yaml': 'yaml',\n      'meta.embedded.block.dosbatch': 'dosbatch',\n      'meta.embedded.block.clojure': 'clojure',\n      'meta.embedded.block.coffee': 'coffee',\n      'meta.embedded.block.c': 'c',\n      'meta.embedded.block.cpp': 'cpp',\n      'meta.embedded.block.diff': 'diff',\n      'meta.embedded.block.dockerfile': 'dockerfile',\n      'meta.embedded.block.go': 'go',\n      'meta.embedded.block.groovy': 'groovy',\n      'meta.embedded.block.pug': 'jade',\n      'meta.embedded.block.javascript': 'javascript',\n      'meta.embedded.block.json': 'json',\n      'meta.embedded.block.jsonc': 'jsonc',\n      'meta.embedded.block.less': 'less',\n      'meta.embedded.block.objc': 'objc',\n      'meta.embedded.block.scss': 'scss',\n      'meta.embedded.block.perl6': 'perl6',\n      'meta.embedded.block.powershell': 'powershell',\n      'meta.embedded.block.python': 'python',\n      'meta.embedded.block.rust': 'rust',\n      'meta.embedded.block.scala': 'scala',\n      'meta.embedded.block.shellscript': 'shellscript',\n      'meta.embedded.block.typescript': 'typescript',\n      'meta.embedded.block.typescriptreact': 'typescriptreact',\n      'meta.embedded.block.csharp': 'csharp',\n      'meta.embedded.block.fsharp': 'fsharp',\n    },\n    fileName: 'text_html_markdown_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.log': {\n    language: 'log',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_log_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.pug': {\n    language: 'jade',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_pug_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.tex.latex.haskell': {\n    language: 'literate haskell',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_tex_latex_haskell_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.xml': {\n    language: 'xml',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_xml_TextMateGrammar',\n    fileFormat: 'json',\n  },\n  'text.xml.xsl': {\n    language: 'xsl',\n    injections: [],\n    embeddedLanguages: undefined,\n    fileName: 'text_xml_xsl_TextMateGrammar',\n    fileFormat: 'json',\n  },\n};\n\nconst languages: {[language: string]: LanguageConfiguration} = {\n  C2Hs: {\n    id: 'C2Hs',\n    aliases: ['C2Hs', 'c2hs'],\n    extensions: ['.chs'],\n  },\n  Hsc2Hs: {\n    id: 'Hsc2Hs',\n    aliases: ['Hsc2Hs', 'HsC2Hs', 'hsc2hs'],\n    extensions: ['.hsc'],\n  },\n  bat: {\n    id: 'bat',\n    extensions: ['.bat', '.cmd'],\n    aliases: ['Batch', 'bat'],\n  },\n  c: {\n    id: 'c',\n    extensions: ['.c', '.i'],\n    aliases: ['C', 'c'],\n  },\n  cabal: {\n    id: 'cabal',\n    aliases: ['Cabal', 'cabal'],\n    extensions: ['.cabal'],\n  },\n  clojure: {\n    id: 'clojure',\n    aliases: ['Clojure', 'clojure'],\n    extensions: ['.clj', '.cljs', '.cljc', '.cljx', '.clojure', '.edn'],\n  },\n  coffeescript: {\n    id: 'coffeescript',\n    extensions: ['.coffee', '.cson', '.iced'],\n    aliases: ['CoffeeScript', 'coffeescript', 'coffee'],\n  },\n  cpp: {\n    id: 'cpp',\n    extensions: [\n      '.cpp',\n      '.cc',\n      '.cxx',\n      '.c++',\n      '.hpp',\n      '.hh',\n      '.hxx',\n      '.h++',\n      '.h',\n      '.ii',\n      '.ino',\n      '.inl',\n      '.ipp',\n      '.ixx',\n      '.tpp',\n      '.txx',\n      '.hpp.in',\n      '.h.in',\n      '.cu',\n      '.cuh',\n    ],\n    aliases: ['C++', 'Cpp', 'cpp', 'c++'],\n  },\n  csharp: {\n    id: 'csharp',\n    extensions: ['.cs', '.csx', '.cake'],\n    aliases: ['C#', 'csharp'],\n  },\n  css: {\n    id: 'css',\n    aliases: ['CSS', 'css'],\n    extensions: ['.css'],\n    mimetypes: ['text/css'],\n  },\n  'cuda-cpp': {\n    id: 'cuda-cpp',\n    extensions: ['.cu', '.cuh'],\n    aliases: ['CUDA C++'],\n  },\n  dart: {\n    id: 'dart',\n    extensions: ['.dart'],\n    aliases: ['Dart'],\n  },\n  dockercompose: {\n    id: 'dockercompose',\n    aliases: ['Compose', 'compose'],\n    filenamePatterns: [\n      'compose.yml',\n      'compose.yaml',\n      'compose.*.yml',\n      'compose.*.yaml',\n      '*docker*compose*.yml',\n      '*docker*compose*.yaml',\n    ],\n  },\n  dockerfile: {\n    id: 'dockerfile',\n    extensions: ['.dockerfile', '.containerfile'],\n    filenames: ['Dockerfile', 'Containerfile'],\n    filenamePatterns: ['Dockerfile.*', 'Containerfile.*'],\n    aliases: ['Docker', 'Dockerfile', 'Containerfile'],\n  },\n  fsharp: {\n    id: 'fsharp',\n    extensions: ['.fs', '.fsi', '.fsx', '.fsscript'],\n    aliases: ['F#', 'FSharp', 'fsharp'],\n  },\n  gdscript: {\n    id: 'gdscript',\n    aliases: ['GDScript', 'gdscript'],\n    extensions: ['.gd'],\n  },\n  'git-commit': {\n    id: 'git-commit',\n    aliases: ['Git Commit Message', 'git-commit'],\n    filenames: ['COMMIT_EDITMSG', 'MERGE_MSG'],\n  },\n  'git-rebase': {\n    id: 'git-rebase',\n    aliases: ['Git Rebase Message', 'git-rebase'],\n    filenames: ['git-rebase-todo'],\n  },\n  go: {\n    id: 'go',\n    extensions: ['.go'],\n    aliases: ['Go'],\n  },\n  groovy: {\n    id: 'groovy',\n    aliases: ['Groovy', 'groovy'],\n    extensions: ['.groovy', '.gvy', '.gradle', '.jenkinsfile', '.nf'],\n    filenames: ['Jenkinsfile'],\n    filenamePatterns: ['Jenkinsfile.*'],\n    firstLine: '^#!.*\\\\bgroovy\\\\b',\n  },\n  hack: {\n    id: 'hack',\n    aliases: ['Hack', 'hacklang', 'php'],\n    extensions: ['.php', '.hh', '.hack'],\n    firstLine: '^<\\\\?hh\\\\b.*|#!.*hhvm.*$',\n  },\n  handlebars: {\n    id: 'handlebars',\n    extensions: ['.handlebars', '.hbs', '.hjs'],\n    aliases: ['Handlebars', 'handlebars'],\n    mimetypes: ['text/x-handlebars-template'],\n  },\n  haskell: {\n    id: 'haskell',\n    aliases: ['Haskell', 'haskell'],\n    extensions: ['.hsig', 'hs-boot', '.hs'],\n  },\n  hlsl: {\n    id: 'hlsl',\n    extensions: ['.hlsl', '.hlsli', '.fx', '.fxh', '.vsh', '.psh', '.cginc', '.compute'],\n    aliases: ['HLSL', 'hlsl'],\n  },\n  html: {\n    id: 'html',\n    extensions: [\n      '.html',\n      '.htm',\n      '.shtml',\n      '.xhtml',\n      '.xht',\n      '.mdoc',\n      '.jsp',\n      '.asp',\n      '.aspx',\n      '.jshtm',\n      '.volt',\n      '.ejs',\n      '.rhtml',\n    ],\n    aliases: ['HTML', 'htm', 'html', 'xhtml'],\n    mimetypes: [\n      'text/html',\n      'text/x-jshtm',\n      'text/template',\n      'text/ng-template',\n      'application/xhtml+xml',\n    ],\n  },\n  ignore: {\n    id: 'ignore',\n    aliases: ['Ignore', 'ignore'],\n    extensions: ['.gitignore_global', '.gitignore'],\n  },\n  ini: {\n    id: 'ini',\n    extensions: ['.ini', '.bcfg', '.net'],\n    aliases: ['Ini', 'ini', 'Hack Configuration', 'hack', 'hacklang'],\n    filenames: ['.hhconfig', '.buckconfig', '.flowconfig'],\n  },\n  jade: {\n    id: 'jade',\n    extensions: ['.pug', '.jade'],\n    aliases: ['Pug', 'Jade', 'jade'],\n  },\n  java: {\n    id: 'java',\n    extensions: ['.java', '.jav'],\n    aliases: ['Java', 'java'],\n  },\n  javascript: {\n    id: 'javascript',\n    aliases: ['JavaScript', 'javascript', 'js'],\n    extensions: ['.js', '.es6', '.mjs', '.cjs', '.pac'],\n    filenames: ['jakefile'],\n    firstLine: '^#!.*\\\\bnode',\n    mimetypes: ['text/javascript'],\n  },\n  javascriptreact: {\n    id: 'javascriptreact',\n    aliases: ['JavaScript React', 'jsx'],\n    extensions: ['.jsx'],\n  },\n  jsonc: {\n    id: 'jsonc',\n    filenames: ['tsconfig.json', 'jsconfig.json'],\n    filenamePatterns: ['tsconfig.*.json', 'jsconfig.*.json', 'tsconfig-*.json', 'jsconfig-*.json'],\n  },\n  'jsx-tags': {\n    id: 'jsx-tags',\n    aliases: [],\n  },\n  julia: {\n    id: 'julia',\n    aliases: ['Julia', 'julia'],\n    extensions: ['.jl'],\n    firstLine: '^#!\\\\s*/.*\\\\bjulia[0-9.-]*\\\\b',\n  },\n  juliamarkdown: {\n    id: 'juliamarkdown',\n    aliases: ['Julia Markdown', 'juliamarkdown'],\n    extensions: ['.jmd'],\n  },\n  kotlin: {\n    id: 'kotlin',\n    aliases: ['Kotlin', 'kotlin'],\n    extensions: ['.kt'],\n  },\n  kotlinscript: {\n    id: 'kotlinscript',\n    aliases: ['Kotlinscript', 'kotlinscript'],\n    extensions: ['.kts'],\n  },\n  less: {\n    id: 'less',\n    aliases: ['Less', 'less'],\n    extensions: ['.less'],\n    mimetypes: ['text/x-less', 'text/less'],\n  },\n  'literate haskell': {\n    id: 'literate haskell',\n    aliases: ['Literate Haskell', 'literate Haskell'],\n    extensions: ['.lhs'],\n  },\n  log: {\n    id: 'log',\n    extensions: ['.log', '*.log.?'],\n    aliases: ['Log'],\n  },\n  lua: {\n    id: 'lua',\n    extensions: ['.lua'],\n    aliases: ['Lua', 'lua'],\n  },\n  makefile: {\n    id: 'makefile',\n    aliases: ['Makefile', 'makefile'],\n    extensions: ['.mak', '.mk'],\n    filenames: ['Makefile', 'makefile', 'GNUmakefile', 'OCamlMakefile'],\n    firstLine: '^#!\\\\s*/usr/bin/make',\n  },\n  markdown: {\n    id: 'markdown',\n    aliases: ['Markdown', 'markdown'],\n    extensions: [\n      '.md',\n      '.mkd',\n      '.mdwn',\n      '.mdown',\n      '.markdown',\n      '.markdn',\n      '.mdtxt',\n      '.mdtext',\n      '.workbook',\n    ],\n  },\n  'objective-c': {\n    id: 'objective-c',\n    extensions: ['.m'],\n    aliases: ['Objective-C'],\n  },\n  'objective-cpp': {\n    id: 'objective-cpp',\n    extensions: ['.mm'],\n    aliases: ['Objective-C++'],\n  },\n  perl: {\n    id: 'perl',\n    aliases: ['Perl', 'perl'],\n    extensions: ['.pl', '.pm', '.pod', '.t', '.PL', '.psgi'],\n    firstLine: '^#!.*\\\\bperl\\\\b',\n  },\n  perl6: {\n    id: 'perl6',\n    aliases: ['Perl 6', 'perl6'],\n    extensions: ['.p6', '.pl6', '.pm6', '.nqp'],\n    firstLine: '(^#!.*\\\\bperl6\\\\b)|use\\\\s+v6',\n  },\n  powershell: {\n    id: 'powershell',\n    extensions: ['.ps1', '.psm1', '.psd1', '.pssc', '.psrc'],\n    aliases: ['PowerShell', 'powershell', 'ps', 'ps1'],\n    firstLine: '^#!\\\\s*/.*\\\\bpwsh\\\\b',\n  },\n  properties: {\n    id: 'properties',\n    extensions: [\n      '.properties',\n      '.cfg',\n      '.conf',\n      '.directory',\n      '.gitattributes',\n      '.gitconfig',\n      '.gitmodules',\n      '.editorconfig',\n      'cfg',\n      'tres',\n      'tscn',\n      'godot',\n      'gdns',\n      'gdnlib',\n      'import',\n    ],\n    filenames: ['gitconfig'],\n    filenamePatterns: ['**/.config/git/config', '**/.git/config'],\n    aliases: ['Properties', 'properties'],\n  },\n  python: {\n    id: 'python',\n    extensions: ['.py', '.rpy', '.pyw', '.cpy', '.gyp', '.gypi', '.pyi', '.ipy', '.pyt'],\n    aliases: ['Python', 'py'],\n    filenames: ['Snakefile', 'SConstruct', 'SConscript'],\n    firstLine: '^#!\\\\s*/?.*\\\\bpython[0-9.-]*\\\\b',\n  },\n  r: {\n    id: 'r',\n    extensions: ['.r', '.rhistory', '.rprofile', '.rt'],\n    aliases: ['R', 'r'],\n  },\n  razor: {\n    id: 'razor',\n    extensions: ['.cshtml', '.razor'],\n    aliases: ['Razor', 'razor'],\n    mimetypes: ['text/x-cshtml'],\n  },\n  ruby: {\n    id: 'ruby',\n    extensions: ['.rb', '.rbx', '.rjs', '.gemspec', '.rake', '.ru', '.erb', '.podspec', '.rbi'],\n    filenames: [\n      'rakefile',\n      'gemfile',\n      'guardfile',\n      'podfile',\n      'capfile',\n      'cheffile',\n      'hobofile',\n      'vagrantfile',\n      'appraisals',\n      'rantfile',\n      'berksfile',\n      'berksfile.lock',\n      'thorfile',\n      'puppetfile',\n      'dangerfile',\n      'brewfile',\n      'fastfile',\n      'appfile',\n      'deliverfile',\n      'matchfile',\n      'scanfile',\n      'snapfile',\n      'gymfile',\n    ],\n    aliases: ['Ruby', 'rb'],\n    firstLine: '^#!\\\\s*/.*\\\\bruby\\\\b',\n  },\n  rust: {\n    id: 'rust',\n    extensions: ['.rs'],\n    aliases: ['Rust', 'rust', 'rs'],\n  },\n  scss: {\n    id: 'scss',\n    aliases: ['SCSS', 'scss'],\n    extensions: ['.scss'],\n    mimetypes: ['text/x-scss', 'text/scss'],\n  },\n  shellscript: {\n    id: 'shellscript',\n    aliases: ['Shell Script', 'shellscript', 'bash', 'sh', 'zsh', 'ksh', 'csh'],\n    extensions: [\n      '.sh',\n      '.bash',\n      '.bashrc',\n      '.bash_aliases',\n      '.bash_profile',\n      '.bash_login',\n      '.ebuild',\n      '.profile',\n      '.bash_logout',\n      '.xprofile',\n      '.xsession',\n      '.xsessionrc',\n      '.Xsession',\n      '.zsh',\n      '.zshrc',\n      '.zprofile',\n      '.zlogin',\n      '.zlogout',\n      '.zshenv',\n      '.zsh-theme',\n      '.ksh',\n      '.csh',\n      '.cshrc',\n      '.tcshrc',\n      '.yashrc',\n      '.yash_profile',\n    ],\n    filenames: [\n      'APKBUILD',\n      'PKGBUILD',\n      '.envrc',\n      '.hushlogin',\n      'zshrc',\n      'zshenv',\n      'zlogin',\n      'zprofile',\n      'zlogout',\n      'bashrc_Apple_Terminal',\n      'zshrc_Apple_Terminal',\n    ],\n    firstLine:\n      '^#!.*\\\\b(bash|zsh|sh|ksh|dtksh|pdksh|mksh|ash|dash|yash|sh|csh|jcsh|tcsh|itcsh).*|^#\\\\s*-\\\\*-[^*]*mode:\\\\s*shell-script[^*]*-\\\\*-',\n    mimetypes: ['text/x-shellscript'],\n  },\n  sql: {\n    id: 'sql',\n    extensions: ['.sql', '.dsql'],\n    aliases: ['SQL'],\n  },\n  swift: {\n    id: 'swift',\n    aliases: ['Swift', 'swift'],\n    extensions: ['.swift'],\n  },\n  thrift: {\n    id: 'thrift',\n    extensions: ['.thrift'],\n  },\n  toml: {\n    id: 'toml',\n    aliases: ['TOML', 'toml'],\n    extensions: ['.toml', 'Pipfile'],\n    mimetypes: ['text/x-toml'],\n  },\n  typescript: {\n    id: 'typescript',\n    aliases: ['TypeScript', 'ts', 'typescript'],\n    extensions: ['.ts', '.cts', '.mts'],\n  },\n  typescriptreact: {\n    id: 'typescriptreact',\n    aliases: ['TypeScript React', 'tsx'],\n    extensions: ['.tsx'],\n  },\n  vb: {\n    id: 'vb',\n    extensions: ['.vb', '.brs', '.vbs', '.bas', '.vba'],\n    aliases: ['Visual Basic', 'vb'],\n  },\n  xml: {\n    id: 'xml',\n    extensions: [\n      '.xml',\n      '.xsd',\n      '.ascx',\n      '.atom',\n      '.axml',\n      '.axaml',\n      '.bpmn',\n      '.cpt',\n      '.csl',\n      '.csproj',\n      '.csproj.user',\n      '.dita',\n      '.ditamap',\n      '.dtd',\n      '.ent',\n      '.mod',\n      '.dtml',\n      '.fsproj',\n      '.fxml',\n      '.iml',\n      '.isml',\n      '.jmx',\n      '.launch',\n      '.menu',\n      '.mxml',\n      '.nuspec',\n      '.opml',\n      '.owl',\n      '.proj',\n      '.props',\n      '.pt',\n      '.publishsettings',\n      '.pubxml',\n      '.pubxml.user',\n      '.rbxlx',\n      '.rbxmx',\n      '.rdf',\n      '.rng',\n      '.rss',\n      '.shproj',\n      '.storyboard',\n      '.svg',\n      '.targets',\n      '.tld',\n      '.tmx',\n      '.vbproj',\n      '.vbproj.user',\n      '.vcxproj',\n      '.vcxproj.filters',\n      '.wsdl',\n      '.wxi',\n      '.wxl',\n      '.wxs',\n      '.xaml',\n      '.xbl',\n      '.xib',\n      '.xlf',\n      '.xliff',\n      '.xpdl',\n      '.xul',\n      '.xoml',\n    ],\n    firstLine: '(\\\\<\\\\?xml.*)|(\\\\<svg)|(\\\\<\\\\!doctype\\\\s+svg)',\n    aliases: ['XML', 'xml'],\n  },\n  xsl: {\n    id: 'xsl',\n    extensions: ['.xsl', '.xslt'],\n    aliases: ['XSL', 'xsl'],\n  },\n  yaml: {\n    id: 'yaml',\n    aliases: ['YAML', 'yaml', 'YAML', 'yaml'],\n    extensions: ['.yml', '.eyaml', '.eyml', '.yaml', '.cff'],\n    firstLine: '^#cloud-config',\n    filenames: ['stack.yaml.lock', '.prettierrc'],\n  },\n};\n\nexport {grammars, languages};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nexport const globalCacheStats = {\n  cacheBlobReads: 0,\n  cacheTreeReads: 0,\n  cacheCommitReads: 0,\n\n  duplicateKeyBlob: 0,\n  duplicateKeyTree: 0,\n  duplicateKeyCommit: 0,\n\n  gitHubGetBlob: 0,\n  gitHubGetTree: 0,\n  gitHubGetCommit: 0,\n  gitHubGetCommitComparison: 0,\n  gitHubGetPullRequest: 0,\n  gitHubGetPullRequests: 0,\n};\n\ndeclare global {\n  function getReviewStackCacheStats(): typeof globalCacheStats;\n  function printReviewStackCacheStats(): void;\n}\n\n// Make it so you can run `getReviewStackCacheStats()` in the Console.\nglobalThis.getReviewStackCacheStats = () => globalCacheStats;\n\nglobalThis.printReviewStackCacheStats = () => {\n  /* eslint-disable no-console */\n  console.log('== IndexedDB reads from cache ==');\n  console.log(`blobs: ${globalCacheStats.cacheBlobReads}`);\n  console.log(`trees: ${globalCacheStats.cacheTreeReads}`);\n  console.log(`commits: ${globalCacheStats.cacheCommitReads}`);\n\n  console.log('== IndexedDB duplicate writes ==');\n  console.log(`blobs: ${globalCacheStats.duplicateKeyBlob}`);\n  console.log(`trees: ${globalCacheStats.duplicateKeyTree}`);\n  console.log(`commits: ${globalCacheStats.duplicateKeyCommit}`);\n\n  console.log('== GitHub API calls ==');\n  console.log(`getBlob(): ${globalCacheStats.gitHubGetBlob}`);\n  console.log(`getTree(): ${globalCacheStats.gitHubGetTree}`);\n  console.log(`getCommit(): ${globalCacheStats.gitHubGetCommit}`);\n  console.log(`getCommitComparison(): ${globalCacheStats.gitHubGetCommitComparison}`);\n  console.log(`getPullRequest(): ${globalCacheStats.gitHubGetPullRequest}`);\n  console.log(`getPullRequests(): ${globalCacheStats.gitHubGetPullRequests}`);\n  /* eslint-enable no-console */\n};\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * As of Nov 16, 2022, Firefox does not support indexedDB.databases():\n * https://bugzilla.mozilla.org/show_bug.cgi?id=934640.\n * To support deleting all databases, we have to keep a list of every\n * IndexedDB database that was *ever* created by ReviewStack so that we can\n * be sure to delete all of them during login/logout.\n */\nexport const ALL_DB_NAMES_EVER: ReadonlyArray<string> = ['github-objects-v2'];\n\n/** Update ALL_DB_NAMES_EVER as appropriate, if DB_VERSION changes. */\nexport const DB_VERSION = 2;\n/** Update ALL_DB_NAMES_EVER as appropriate, if DB_NAME changes. */\nexport const DB_NAME = `github-objects-v${DB_VERSION}`;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n * This file contains the logic that coordinates logout activity across multiple\n * instances of ReviewStack opened within the same web browser. It leverages a\n * BroadcastChannel to notify all of the relevant windows and SharedWorkers\n * (e.g., \"browsing contexts\") that the user has opted to logout, which means\n * that:\n *\n * - The context should close any open connection to IndexedDB that it has.\n * - The context should not do any more writes to the IndexedDB (which should\n *   follow from the previous bullet point).\n * - The context in which the user initiated the logout should take\n *   responsibility for calling `clearAllLocalData()` in gitHubCredentials.ts.\n *   In order for the `indexedDB.deleteDatabase()` call to succeed, all of the\n *   other contexts will have had to close their database connections first.\n */\n\nconst LOGOUT_CHANNEL_NAME = 'reviewstack-logout';\nconst INTERNAL_LOGOUT_EVENT_NAME = 'reviewstack-logout-this-window';\n\nconst logoutBroadcastChannel = new BroadcastChannel(LOGOUT_CHANNEL_NAME);\n\ntype LogoutMessage = {\n  logout: true;\n};\n\n/**\n * Used to register listeners via subscribeToLogout() for clients that also\n * want to be notified of logout events from the source window.\n *\n * We use this EventTarget with the INTERNAL_LOGOUT_EVENT_NAME Event that is\n * private to this module.\n */\nconst localSubscribers = new EventTarget();\n\n/**\n * Calls the specified callback when a \"logout\" event is received on the\n * channel. By default, the callback will only be called when the message was\n * fired from another browser tab.\n *\n * Returns a function to remove the subscriptions.\n */\nexport function subscribeToLogout(\n  callback: () => void,\n  includeLogoutEventsFromThisWindow = false,\n): () => void {\n  const unsubscribeCalls: Array<() => void> = [];\n\n  const channelListener = ({data}: MessageEvent) => {\n    if ((data as LogoutMessage).logout === true) {\n      callback();\n    }\n  };\n  logoutBroadcastChannel.addEventListener('message', channelListener);\n  unsubscribeCalls.push(() =>\n    logoutBroadcastChannel.removeEventListener('message', channelListener),\n  );\n\n  if (includeLogoutEventsFromThisWindow) {\n    // Ensure the original callback does not see the Event.\n    const localSubscribersListener = (_event: Event) => {\n      callback();\n    };\n    localSubscribers.addEventListener(INTERNAL_LOGOUT_EVENT_NAME, localSubscribersListener);\n    unsubscribeCalls.push(() =>\n      localSubscribers.removeEventListener(INTERNAL_LOGOUT_EVENT_NAME, localSubscribersListener),\n    );\n  }\n\n  return () => unsubscribeCalls.forEach(callback => callback());\n}\n\nexport function broadcastLogoutMessage() {\n  localSubscribers.dispatchEvent(new Event(INTERNAL_LOGOUT_EVENT_NAME));\n  const message: LogoutMessage = {logout: true};\n  logoutBroadcastChannel.postMessage(message);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AddCommentMutationData,\n  AddLabelsToLabelableInput,\n  AddLabelsToLabelableMutationData,\n  AddPullRequestReviewInput,\n  AddPullRequestReviewMutationData,\n  AddPullRequestReviewCommentInput,\n  AddPullRequestReviewCommentMutationData,\n  LabelFragment,\n  PullRequestReviewDecision,\n  PullRequestState,\n  RemoveLabelsFromLabelableInput,\n  RemoveLabelsFromLabelableMutationData,\n  RequestReviewsInput,\n  RequestReviewsMutationData,\n  StackPullRequestFragment,\n  SubmitPullRequestReviewInput,\n  SubmitPullRequestReviewMutationData,\n  UserFragment,\n} from '../generated/graphql';\nimport type GitHubClient from './GitHubClient';\nimport type {PullRequest} from './pullRequestTimelineTypes';\nimport type {PullsQueryInput, PullsWithPageInfo} from './pullsTypes';\nimport type {CommitComparison} from './restApiTypes';\nimport type {Blob, Commit, GitObject, GitObjectID, ID, Tree} from './types';\n\nimport {globalCacheStats} from './GitHubClientStats';\nimport {DB_VERSION, DB_NAME} from './databaseInfo';\nimport {subscribeToLogout} from './logoutBroadcastChannel';\nimport rejectAfterTimeout from 'shared/rejectAfterTimeout';\n\nconst DB_COMMIT_STORE_NAME = 'commit';\nconst DB_TREE_STORE_NAME = 'tree';\nconst DB_BLOB_STORE_NAME = 'blob';\nconst PR_FRAGMENT_STORE_NAME = 'pr-fragment';\n\ninterface NormalizedCommit extends GitObject {\n  oid: GitObjectID;\n  id: ID;\n  url: string;\n  message: string;\n  messageHeadline: string;\n  messageHeadlineHTML: string;\n  messageBody: string;\n  messageBodyHTML: string;\n  parents: GitObjectID[];\n  tree_oid: GitObjectID;\n  committedDate: string;\n}\n\ntype NormalizedStackPullRequestFragment = {\n  owner: string;\n  name: string;\n  number: number;\n  title: string;\n  updatedAt: string;\n  state: PullRequestState;\n  reviewDecision: PullRequestReviewDecision | null | undefined;\n  headRefOid: GitObjectID;\n  numComments: number;\n};\n\n/** Name of an IDBObjectStore in our IDBDatabase. */\ntype Store =\n  | typeof DB_COMMIT_STORE_NAME\n  | typeof DB_TREE_STORE_NAME\n  | typeof DB_BLOB_STORE_NAME\n  | typeof PR_FRAGMENT_STORE_NAME;\n\ntype StoreTypes = {\n  [DB_COMMIT_STORE_NAME]: NormalizedCommit;\n  [DB_TREE_STORE_NAME]: Tree;\n  [DB_BLOB_STORE_NAME]: Blob;\n  [PR_FRAGMENT_STORE_NAME]: NormalizedStackPullRequestFragment;\n};\n\n/**\n * Represents an open readwrite transaction for the specified store.\n * Callers are expected to invoke add() as many times as necessary\n * (awaiting the result if they want confirmation that the IDBRequest for the\n * corresponding add() call succeeded) and finally invoking commit() when\n * finished.\n */\nclass OpenTransaction<S extends Store, O = StoreTypes[S]> {\n  private tx: IDBTransaction;\n  private store: IDBObjectStore;\n  private txResult: Promise<void>;\n\n  constructor(db: IDBDatabase, private storeName: S) {\n    this.tx = db.transaction(storeName, 'readwrite');\n    this.store = this.tx.objectStore(storeName);\n    this.txResult = new Promise((resolve, reject) => {\n      this.tx.oncomplete = () => resolve();\n      this.tx.onerror = event => {\n        if ((event?.target as IDBRequest).error?.name === 'ConstraintError') {\n          switch (this.storeName) {\n            case DB_BLOB_STORE_NAME: {\n              ++globalCacheStats.duplicateKeyBlob;\n              break;\n            }\n            case DB_TREE_STORE_NAME: {\n              ++globalCacheStats.duplicateKeyTree;\n              break;\n            }\n            case DB_COMMIT_STORE_NAME: {\n              ++globalCacheStats.duplicateKeyCommit;\n              break;\n            }\n          }\n          resolve();\n        } else {\n          reject();\n        }\n      };\n    });\n  }\n\n  add(obj: O): Promise<void> {\n    return new Promise((resolve, reject) => {\n      let request;\n      try {\n        request = this.store.add(obj);\n      } catch (e) {\n        return reject(e);\n      }\n\n      request.onsuccess = _event => resolve();\n      request.onerror = event => {\n        if ((event?.target as IDBRequest).error?.name === 'ConstraintError') {\n          let identifier = 'unknown';\n          if (implementsGitObject(obj)) {\n            identifier = obj.oid;\n          } else {\n            const pr = obj as unknown as NormalizedStackPullRequestFragment;\n            identifier = `${pr.owner}/${pr.name}/${pr.number}`;\n          }\n          // eslint-disable-next-line no-console\n          console.info(`${identifier} already added to store ${this.store.name}`);\n          resolve();\n        } else {\n          reject(event);\n        }\n      };\n    });\n  }\n\n  /**\n   * Returns a Promise that resolves when the underlying IDBTransaction\n   * completes.\n   */\n  commit(): Promise<void> {\n    this.tx.commit();\n    return this.txResult;\n  }\n}\n\nfunction implementsGitObject(obj: unknown): obj is GitObject {\n  return typeof obj === 'object' && obj !== null && 'oid' in obj;\n}\n\n/**\n * Decorates a GitHubClient, but uses IndexedDB as a caching layer.\n */\nexport default class CachingGitHubClient implements GitHubClient {\n  /**\n   * owner and name must be non-null if the getStackPullRequests() will be\n   * used.\n   */\n  constructor(\n    private db: IDBDatabase,\n    private client: GitHubClient,\n    private owner: string | null,\n    private name: string | null,\n  ) {}\n\n  async getCommit(oid: GitObjectID): Promise<Commit | null> {\n    const cachedCommit = await this.getCachedCommit(oid);\n    if (cachedCommit != null) {\n      ++globalCacheStats.cacheCommitReads;\n      return cachedCommit;\n    }\n\n    const commit = await this.client.getCommit(oid);\n    if (commit != null) {\n      // Note that multiple commits may have the same root Tree object (this is\n      // particularly common with stacks created via ghstack), in which case the\n      // underlying IDBTransaction will fail with a ConstraintError if the Tree\n      // already exists in IndexedDB as a result of persisting some other\n      // Commit. (Note that OpenTransaction will swallow this error so the\n      // Promise returned by add() will not reject.)\n      //\n      // There is no great way to avoid this without incurring the cost of an\n      // extra read, which hardly seems worth the cost and is not 100% reliable\n      // because it is subject to TOCTOU races. For the curious,\n      // GitHubClientStats is available to see how often this happens, in\n      // practice.\n      //\n      // Further, we choose not to await the calls to tx.add() (or even invoke\n      // tx.commit()) and return to the caller before the Tree or Commit is\n      // persisted to IndexedDB. This knowingly runs the risk of fetching the\n      // Tree or Commit multiple times.\n      {\n        const tx = new OpenTransaction(this.db, DB_TREE_STORE_NAME);\n        tx.add(commit.tree);\n      }\n      {\n        const tx = new OpenTransaction(this.db, DB_COMMIT_STORE_NAME);\n        const normalizedCommit = normalizeCommit(commit);\n        tx.add(normalizedCommit);\n      }\n    }\n    return commit;\n  }\n\n  getCommitComparison(base: GitObjectID, head: GitObjectID): Promise<CommitComparison | null> {\n    // No caching done for now.\n    return this.client.getCommitComparison(base, head);\n  }\n\n  async getTree(oid: GitObjectID): Promise<Tree | null> {\n    const cachedTree = await this.getCachedTree(oid);\n    if (cachedTree != null) {\n      ++globalCacheStats.cacheTreeReads;\n      return cachedTree;\n    }\n\n    const tree = await this.client.getTree(oid);\n    // Note that if tree is null, it is possible that a Tree with the\n    // GitObjectID comes into existence later, so we should not write a null\n    // entry to IndexedDB.\n    if (tree != null) {\n      // We choose not to await the call to tx.add() (or even invoke\n      // tx.commit()) and return to the caller before the Tree is persisted to\n      // IndexedDB. This knowingly runs the risk of fetching the Tree multiple\n      // times.\n      const tx = new OpenTransaction(this.db, DB_TREE_STORE_NAME);\n      tx.add(tree);\n    }\n    return tree;\n  }\n\n  async getBlob(oid: GitObjectID): Promise<Blob | null> {\n    const cachedBlob = await this.getCachedBlob(oid);\n    if (cachedBlob != null) {\n      ++globalCacheStats.cacheBlobReads;\n      return cachedBlob;\n    }\n\n    const blob = await this.client.getBlob(oid);\n    // Note that if blob is null, it is possible that a Blob with the\n    // GitObjectID comes into existence later, so we should not write a null\n    // entry to IndexedDB.\n    if (blob != null) {\n      // It is imperative that the blob be persisted to IndexedDB before\n      // returning because diffServiceWorker assumes that if it receives a\n      // GitObjectID for a Blob, it will be able to read it from IndexedDB.\n      const tx = new OpenTransaction(this.db, DB_BLOB_STORE_NAME);\n      await tx.add(blob);\n      await tx.commit();\n    }\n    return blob;\n  }\n\n  getPullRequest(pr: number): Promise<PullRequest | null> {\n    // No caching done because the PR could have been updated since the PR data\n    // were requested last.\n    return this.client.getPullRequest(pr);\n  }\n\n  getPullRequests(input: PullsQueryInput): Promise<PullsWithPageInfo | null> {\n    return this.client.getPullRequests(input);\n  }\n\n  getRepoAssignableUsers(query: string | null): Promise<UserFragment[]> {\n    return this.client.getRepoAssignableUsers(query);\n  }\n\n  getRepoLabels(query: string | null): Promise<LabelFragment[]> {\n    return this.client.getRepoLabels(query);\n  }\n\n  // TODO: It should be possible to invalidate these entries because they can\n  // get out of date.\n  async getStackPullRequests(prs: number[]): Promise<StackPullRequestFragment[]> {\n    // First, we try to read as many fragments from the cache as possible.\n    const cachedFragments = await this.getCachedPRFragments(prs);\n\n    // We record each cache miss with the necessary bookkeeping information to\n    // patch up the cachedFragments array.\n    const prsToFetch: number[] = [];\n    const prsToFetchIndex: number[] = [];\n    cachedFragments.forEach((fragment, index) => {\n      if (fragment == null) {\n        prsToFetch.push(prs[index]);\n        prsToFetchIndex.push(index);\n      }\n    });\n\n    // After fetching the cache misses, we write them back into the original\n    // cachedFragments array as well as IndexedDB.\n    const fetchedFragments = await this.client.getStackPullRequests(prsToFetch);\n    const {owner, name} = this.getOwnerAndName();\n\n    const tx = new OpenTransaction(this.db, PR_FRAGMENT_STORE_NAME);\n    await Promise.all(\n      fetchedFragments.map((fragment, index) => {\n        const originalIndex = prsToFetchIndex[index];\n        cachedFragments[originalIndex] = fragment;\n        const normalizedFragment = normalizePullRequestFragment(owner, name, fragment);\n        // Stores a StackPullRequestFragment in IndexedDB, which uses\n        // [owner, name, number] as the key. Of note:\n        // - Unlike blobs and trees where the key is a content hash, the value of a\n        //   StackPullRequestFragment associated with the key can change over time\n        //   because it includes fields like title, updatedAt, etc. It needs to be\n        //   possible to evict/update entries in the table, as appropriate.\n        // - StackPullRequestFragment is defined in StackPullRequestFragment.graphql,\n        //   so if it changes, then this must be updated, as well.\n        return tx.add(normalizedFragment);\n      }),\n    );\n    await tx.commit();\n    return cachedFragments as StackPullRequestFragment[];\n  }\n\n  addComment(id: ID, body: string): Promise<AddCommentMutationData> {\n    return this.client.addComment(id, body);\n  }\n\n  addLabels(input: AddLabelsToLabelableInput): Promise<AddLabelsToLabelableMutationData> {\n    return this.client.addLabels(input);\n  }\n\n  addPullRequestReview(\n    input: AddPullRequestReviewInput,\n  ): Promise<AddPullRequestReviewMutationData> {\n    return this.client.addPullRequestReview(input);\n  }\n\n  addPullRequestReviewComment(\n    input: AddPullRequestReviewCommentInput,\n  ): Promise<AddPullRequestReviewCommentMutationData> {\n    return this.client.addPullRequestReviewComment(input);\n  }\n\n  removeLabels(\n    input: RemoveLabelsFromLabelableInput,\n  ): Promise<RemoveLabelsFromLabelableMutationData> {\n    return this.client.removeLabels(input);\n  }\n\n  requestReviews(input: RequestReviewsInput): Promise<RequestReviewsMutationData> {\n    return this.client.requestReviews(input);\n  }\n\n  submitPullRequestReview(\n    input: SubmitPullRequestReviewInput,\n  ): Promise<SubmitPullRequestReviewMutationData> {\n    return this.client.submitPullRequestReview(input);\n  }\n\n  /**\n   * Attempts to fetch the commit from the local IndexedDB. Returns null if\n   * the commit could not be found in IndexedDB, though it could still exist on\n   * the server.\n   */\n  private getCachedCommit(oid: GitObjectID): Promise<Commit | null> {\n    const tx = this.db.transaction(DB_COMMIT_STORE_NAME, 'readonly');\n    const store = tx.objectStore(DB_COMMIT_STORE_NAME);\n    const request = store.get(oid);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = async _event => {\n        const {result: normalizedCommit} = request;\n        if (normalizedCommit == null) {\n          return resolve(null);\n        }\n\n        const {\n          oid,\n          id,\n          url,\n          message,\n          messageHeadline,\n          messageHeadlineHTML,\n          messageBody,\n          messageBodyHTML,\n          parents,\n          tree_oid,\n          committedDate,\n        } = normalizedCommit;\n        const tree = await this.getTree(tree_oid);\n        if (tree == null) {\n          return reject(`tree ${tree_oid} not found for commit ${oid}`);\n        }\n\n        const commit = {\n          oid: oid as GitObjectID,\n          id: id as ID,\n          url,\n          message: message as string,\n          messageHeadline: messageHeadline as string,\n          messageHeadlineHTML,\n          messageBody,\n          messageBodyHTML,\n          parents: parents as GitObjectID[],\n          tree,\n          committedDate,\n        };\n        resolve(commit);\n      };\n      request.onerror = reject;\n    });\n  }\n\n  /**\n   * Attempts to fetch the tree from the local IndexedDB. Returns null if\n   * the tree could not be found in IndexedDB, though it could still exist on\n   * the server.\n   */\n  private getCachedTree(oid: GitObjectID): Promise<Tree | null> {\n    const tx = this.db.transaction(DB_TREE_STORE_NAME, 'readonly');\n    const store = tx.objectStore(DB_TREE_STORE_NAME);\n    const request = store.get(oid);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = _event => {\n        resolve(request.result ?? null);\n      };\n      request.onerror = reject;\n    });\n  }\n\n  /**\n   * Attempts to fetch the blob from the local IndexedDB. Returns null if\n   * the blob could not be found in IndexedDB, though it could still exist on\n   * the server.\n   */\n  private getCachedBlob(oid: GitObjectID): Promise<Blob | null> {\n    const tx = this.db.transaction(DB_BLOB_STORE_NAME, 'readonly');\n    const store = tx.objectStore(DB_BLOB_STORE_NAME);\n    const request = store.get(oid);\n    return new Promise((resolve, reject) => {\n      request.onsuccess = _event => {\n        resolve(request.result ?? null);\n      };\n      request.onerror = reject;\n    });\n  }\n\n  private getCachedPRFragments(prs: number[]): Promise<Array<StackPullRequestFragment | null>> {\n    const tx = this.db.transaction(PR_FRAGMENT_STORE_NAME, 'readonly');\n    const store = tx.objectStore(PR_FRAGMENT_STORE_NAME);\n    const {owner, name} = this.getOwnerAndName();\n\n    return Promise.all(\n      prs.map(pr => {\n        const key = [owner, name, pr];\n        const request = store.get(key);\n        return new Promise<StackPullRequestFragment | null>((resolve, reject) => {\n          request.onsuccess = _event => {\n            const {result} = request;\n            if (result == null) {\n              resolve(null);\n              return;\n            }\n\n            const {title, updatedAt, state, reviewDecision, headRefOid, numComments} = result;\n            resolve({\n              __typename: 'PullRequest',\n              number: pr,\n              title,\n              updatedAt,\n              state,\n              reviewDecision,\n              headRefOid,\n              comments: {\n                __typename: 'IssueCommentConnection',\n                totalCount: numComments,\n              },\n            });\n          };\n          request.onerror = reject;\n        });\n      }),\n    );\n  }\n\n  private getOwnerAndName(): {owner: string; name: string} {\n    const {owner, name} = this;\n    if (owner == null || name == null) {\n      throw new Error('owner and name must be set in CachingGitHubClient');\n    }\n    return {owner, name};\n  }\n}\n\nconst OPEN_DATABASE_TIMEOUT_MS = 10 * 1000;\n\n/**\n * Returns an open connection to an IDBDatabase that will close if the user\n * logs out (from any window on this origin in the same browser).\n */\nexport function openDatabase(): Promise<IDBDatabase> {\n  return _openDatabase().then(db => {\n    // If we get a \"logout\" event from another window, close the connection in\n    // this window so that the other window can call indexedDB.deleteDatabase()\n    // on all the databases.\n    subscribeToLogout(() => db.close(), /* includeLogoutEventsFromThisWindow */ true);\n    return db;\n  });\n}\n\nasync function _openDatabase(): Promise<IDBDatabase> {\n  const openDatabaseRequest = new Promise((resolve, reject) => {\n    const request = self.indexedDB.open(DB_NAME, DB_VERSION);\n    request.onsuccess = _event => {\n      resolve(request.result);\n    };\n    request.onerror = event => reject(event.target);\n    request.onblocked = event =>\n      // eslint-disable-next-line no-console\n      console.error(\n        `indexedDB blocked while trying to open ${DB_NAME} with version ${DB_VERSION}:`,\n        event,\n      );\n    request.onupgradeneeded = (_event: IDBVersionChangeEvent) => {\n      const {result: db} = request;\n      const commitStore = db.createObjectStore(DB_COMMIT_STORE_NAME, {\n        keyPath: 'oid',\n        autoIncrement: false,\n      });\n      commitStore.createIndex('id', 'id', {unique: false});\n      commitStore.createIndex('url', 'url', {unique: false});\n      commitStore.createIndex('message', 'message', {unique: false});\n      commitStore.createIndex('messageHeadline', 'messageHeadline', {unique: false});\n      commitStore.createIndex('messageHeadlineHTML', 'messageHeadlineHTML', {unique: false});\n      commitStore.createIndex('messageBody', 'messageBody', {unique: false});\n      commitStore.createIndex('messageBodyHTML', 'messageBodyHTML', {unique: false});\n      commitStore.createIndex('parents', 'parents', {unique: false});\n      commitStore.createIndex('tree_oid', 'tree_oid', {unique: false});\n      commitStore.createIndex('committedDate', 'committedDate', {unique: false});\n\n      const treeStore = db.createObjectStore(DB_TREE_STORE_NAME, {\n        keyPath: 'oid',\n        autoIncrement: false,\n      });\n      treeStore.createIndex('id', 'id', {unique: false});\n      treeStore.createIndex('entries', 'entries', {unique: false});\n\n      const blobStore = db.createObjectStore(DB_BLOB_STORE_NAME, {\n        keyPath: 'oid',\n        autoIncrement: false,\n      });\n      blobStore.createIndex('id', 'id', {unique: false});\n      blobStore.createIndex('byteSize', 'byteSize', {unique: false});\n      blobStore.createIndex('isBinary', 'isBinary', {unique: false});\n      blobStore.createIndex('isTruncated', 'isTruncated', {unique: false});\n      blobStore.createIndex('text', 'text', {unique: false});\n\n      const pullRequestFragmentStore = db.createObjectStore(PR_FRAGMENT_STORE_NAME, {\n        keyPath: ['owner', 'name', 'number'],\n        autoIncrement: false,\n      });\n      pullRequestFragmentStore.createIndex('title', 'title', {unique: false});\n      pullRequestFragmentStore.createIndex('updatedAt', 'updatedAt', {unique: false});\n      pullRequestFragmentStore.createIndex('state', 'state', {unique: false});\n      pullRequestFragmentStore.createIndex('headRefOid', 'headRefOid', {unique: false});\n      pullRequestFragmentStore.createIndex('numComments', 'numComments', {unique: false});\n    };\n  });\n\n  // On one occasion, we saw indexedDB.open() fail to fire any of the\n  // expected events (success, error, blocked, upgradeneeded) such that\n  // openDatabaseRequest never settled, causing all queries into\n  // CachingGitHubClient to hang forever. As a safeguard, we leverage\n  // Promise.race() to introduce a timeout so force an explicit failure in this\n  // case.\n  //\n  // Closing all of the Google Chrome browser tabs that were serving content\n  // from the domain and then reopening them appeared to fix the issue.\n  // Presumably there was some sort of active connection that was preventing\n  // open calls from succeeding? Unclear.\n  const database = await rejectAfterTimeout(\n    openDatabaseRequest,\n    OPEN_DATABASE_TIMEOUT_MS,\n    `database failed to open within ${OPEN_DATABASE_TIMEOUT_MS}ms`,\n  );\n  if (database instanceof IDBDatabase) {\n    return database;\n  } else if (database instanceof Error) {\n    throw database;\n  } else {\n    throw Error(`invariant failed, database object was: ${database}`);\n  }\n}\n\nfunction normalizeCommit(commit: Commit): NormalizedCommit {\n  const {\n    oid,\n    id,\n    url,\n    message,\n    messageHeadline,\n    messageHeadlineHTML,\n    messageBody,\n    messageBodyHTML,\n    parents,\n    committedDate,\n  } = commit;\n  return {\n    oid,\n    id,\n    url,\n    message,\n    messageHeadline,\n    messageHeadlineHTML,\n    messageBody,\n    messageBodyHTML,\n    parents,\n    tree_oid: commit.tree.oid,\n    committedDate,\n  };\n}\n\nfunction normalizePullRequestFragment(\n  owner: string,\n  name: string,\n  fragment: StackPullRequestFragment,\n): NormalizedStackPullRequestFragment {\n  const {number, title, updatedAt, state, reviewDecision, headRefOid, comments} = fragment;\n  return {\n    owner,\n    name,\n    number,\n    title,\n    updatedAt,\n    state,\n    reviewDecision,\n    headRefOid,\n    numComments: comments.totalCount,\n  };\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * Takes an existing Promise and wraps it with a new Promise that will either:\n * - be fulfilled with the result from the original promise\n * - be rejected with the provided error message after `timeoutInMillis`\n *   milliseconds.\n *\n * Note that in the case where the returned Promise rejects, there is nothing\n * that stops the execution of the executor function used to create the\n * original Promise.\n */\nexport default function rejectAfterTimeout<T>(\n  promise: Promise<T>,\n  timeoutInMillis: number,\n  message: string,\n): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_resolve, reject) => {\n      setTimeout(() => reject(message), timeoutInMillis);\n    }),\n  ]);\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {\n  AddCommentMutationData,\n  AddLabelsToLabelableInput,\n  AddLabelsToLabelableMutationData,\n  AddPullRequestReviewInput,\n  AddPullRequestReviewMutationData,\n  AddPullRequestReviewCommentInput,\n  AddPullRequestReviewCommentMutationData,\n  LabelFragment,\n  RemoveLabelsFromLabelableInput,\n  RemoveLabelsFromLabelableMutationData,\n  RequestReviewsInput,\n  RequestReviewsMutationData,\n  StackPullRequestFragment,\n  SubmitPullRequestReviewInput,\n  SubmitPullRequestReviewMutationData,\n  UserFragment,\n} from '../generated/graphql';\nimport type GitHubClient from './GitHubClient';\nimport type {PullRequest} from './pullRequestTimelineTypes';\nimport type {PullsQueryInput, PullsWithPageInfo} from './pullsTypes';\nimport type {CommitComparison} from './restApiTypes';\nimport type {Blob, Commit, GitObjectID, ID, Tree} from './types';\n\n/**\n * GitHubClient that fails for all methods. Designed to be used with other\n * implementations of GitHubClient that use the decorator pattern, but never\n * intend to rely on the fallback method.\n */\nexport default class RejectingGitHubClient implements GitHubClient {\n  getCommit(_oid: GitObjectID): Promise<Commit> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getCommitComparison(_base: GitObjectID, _head: GitObjectID): Promise<CommitComparison> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getTree(_oid: GitObjectID): Promise<Tree> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getBlob(oid: GitObjectID): Promise<Blob> {\n    return Promise.reject(`getBlob(${oid}) not implemented`);\n  }\n\n  getPullRequest(_pr: number): Promise<PullRequest | null> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getPullRequests(_input: PullsQueryInput): Promise<PullsWithPageInfo> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getRepoAssignableUsers(_query: string | null): Promise<UserFragment[]> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getRepoLabels(_query: string | null): Promise<LabelFragment[]> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  getStackPullRequests(_prs: number[]): Promise<StackPullRequestFragment[]> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  addComment(_id: ID, _body: string): Promise<AddCommentMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  addLabels(_input: AddLabelsToLabelableInput): Promise<AddLabelsToLabelableMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  addPullRequestReview(\n    _input: AddPullRequestReviewInput,\n  ): Promise<AddPullRequestReviewMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  addPullRequestReviewComment(\n    _input: AddPullRequestReviewCommentInput,\n  ): Promise<AddPullRequestReviewCommentMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  removeLabels(\n    _input: RemoveLabelsFromLabelableInput,\n  ): Promise<RemoveLabelsFromLabelableMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  requestReviews(_input: RequestReviewsInput): Promise<RequestReviewsMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n\n  submitPullRequestReview(\n    _input: SubmitPullRequestReviewInput,\n  ): Promise<SubmitPullRequestReviewMutationData> {\n    return Promise.reject('Method not implemented.');\n  }\n}\n","export type Maybe<T> = T | null;\nexport type InputMaybe<T> = Maybe<T>;\nexport type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };\nexport type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };\nexport type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };\n/** All built-in and custom scalars, mapped to their actual values */\nexport type Scalars = {\n  ID: string;\n  String: string;\n  Boolean: boolean;\n  Int: number;\n  Float: number;\n  /** A (potentially binary) string encoded using base64. */\n  Base64String: string;\n  /**\n   * Represents non-fractional signed whole numeric values. Since the value may\n   * exceed the size of a 32-bit integer, it's encoded as a string.\n   */\n  BigInt: string;\n  /** An ISO-8601 encoded date string. */\n  Date: string;\n  /** An ISO-8601 encoded UTC date string. */\n  DateTime: string;\n  /** A Git object ID. */\n  GitObjectID: string;\n  /** A fully qualified reference name (e.g. `refs/heads/master`). */\n  GitRefname: string;\n  /** Git SSH string */\n  GitSSHRemote: string;\n  /** An ISO-8601 encoded date string. Unlike the DateTime type, GitTimestamp is not converted in UTC. */\n  GitTimestamp: string;\n  /** A string containing HTML code. */\n  HTML: string;\n  /** An ISO-8601 encoded UTC date string with millisecond precision. */\n  PreciseDateTime: string;\n  /** An RFC 3986, RFC 3987, and RFC 6570 (level 4) compliant URI string. */\n  URI: string;\n  /** A valid x509 certificate string */\n  X509Certificate: string;\n};\n\n/** Autogenerated input type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization that is running the migrations. */\n  ownerId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AbortQueuedMigrations */\nexport type AbortQueuedMigrationsPayload = {\n  __typename?: 'AbortQueuedMigrationsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n/** Autogenerated input type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the invitation being accepted */\n  invitationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AcceptEnterpriseAdministratorInvitation */\nexport type AcceptEnterpriseAdministratorInvitationPayload = {\n  __typename?: 'AcceptEnterpriseAdministratorInvitationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The invitation that was accepted. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of accepting an administrator invitation. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AcceptTopicSuggestion */\nexport type AcceptTopicSuggestionPayload = {\n  __typename?: 'AcceptTopicSuggestionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The accepted topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type Actor = {\n  /** A URL pointing to the actor's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** The username of the actor. */\n  login: Scalars['String'];\n  /** The HTTP path for this actor. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this actor. */\n  url: Scalars['URI'];\n};\n\n\n/** Represents an object which can take actions on GitHub. Typically a User or Bot. */\nexport type ActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** Location information for an actor */\nexport type ActorLocation = {\n  __typename?: 'ActorLocation';\n  /** City */\n  city?: Maybe<Scalars['String']>;\n  /** Country name */\n  country?: Maybe<Scalars['String']>;\n  /** Country code */\n  countryCode?: Maybe<Scalars['String']>;\n  /** Region name */\n  region?: Maybe<Scalars['String']>;\n  /** Region or state code */\n  regionCode?: Maybe<Scalars['String']>;\n};\n\n/** The actor's type. */\nexport enum ActorType {\n  /** Indicates a team actor. */\n  Team = 'TEAM',\n  /** Indicates a user actor. */\n  User = 'USER'\n}\n\n/** Autogenerated input type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignableInput = {\n  /** The id of the assignable object to add assignees to. */\n  assignableId: Scalars['ID'];\n  /** The id of users to add as assignees. */\n  assigneeIds: Array<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of AddAssigneesToAssignable */\nexport type AddAssigneesToAssignablePayload = {\n  __typename?: 'AddAssigneesToAssignablePayload';\n  /** The item that was assigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of AddComment */\nexport type AddCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddComment */\nexport type AddCommentPayload = {\n  __typename?: 'AddCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The edge from the subject's comment connection. */\n  commentEdge?: Maybe<IssueCommentEdge>;\n  /** The subject */\n  subject?: Maybe<Node>;\n  /** The edge from the subject's timeline connection. */\n  timelineEdge?: Maybe<IssueTimelineItemEdge>;\n};\n\n/** Autogenerated input type of AddDiscussionComment */\nexport type AddDiscussionCommentInput = {\n  /** The contents of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion to comment on. */\n  discussionId: Scalars['ID'];\n  /** The Node ID of the discussion comment within this discussion to reply to. */\n  replyToId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of AddDiscussionComment */\nexport type AddDiscussionCommentPayload = {\n  __typename?: 'AddDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of AddDiscussionPollVote */\nexport type AddDiscussionPollVoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion poll option to vote for. */\n  pollOptionId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddDiscussionPollVote */\nexport type AddDiscussionPollVotePayload = {\n  __typename?: 'AddDiscussionPollVotePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The poll option that a vote was added to. */\n  pollOption?: Maybe<DiscussionPollOption>;\n};\n\n/** Autogenerated input type of AddEnterpriseOrganizationMember */\nexport type AddEnterpriseOrganizationMemberInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise which owns the organization. */\n  enterpriseId: Scalars['ID'];\n  /** The ID of the organization the users will be added to. */\n  organizationId: Scalars['ID'];\n  /** The role to assign the users in the organization */\n  role?: InputMaybe<OrganizationMemberRole>;\n  /** The IDs of the enterprise members to add. */\n  userIds: Array<Scalars['ID']>;\n};\n\n/** Autogenerated return type of AddEnterpriseOrganizationMember */\nexport type AddEnterpriseOrganizationMemberPayload = {\n  __typename?: 'AddEnterpriseOrganizationMemberPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The users who were added to the organization. */\n  users?: Maybe<Array<User>>;\n};\n\n/** Autogenerated input type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a member who will receive the support entitlement. */\n  login: Scalars['String'];\n};\n\n/** Autogenerated return type of AddEnterpriseSupportEntitlement */\nexport type AddEnterpriseSupportEntitlementPayload = {\n  __typename?: 'AddEnterpriseSupportEntitlementPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of adding the support entitlement. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of AddLabelsToLabelable */\nexport type AddLabelsToLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ids of the labels to add. */\n  labelIds: Array<Scalars['ID']>;\n  /** The id of the labelable object to add labels to. */\n  labelableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddLabelsToLabelable */\nexport type AddLabelsToLabelablePayload = {\n  __typename?: 'AddLabelsToLabelablePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item that was labeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of AddProjectCard */\nexport type AddProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The content of the card. Must be a member of the ProjectCardItem union */\n  contentId?: InputMaybe<Scalars['ID']>;\n  /** The note on the card. */\n  note?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the ProjectColumn. */\n  projectColumnId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddProjectCard */\nexport type AddProjectCardPayload = {\n  __typename?: 'AddProjectCardPayload';\n  /** The edge from the ProjectColumn's card connection. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ProjectColumn */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of AddProjectColumn */\nexport type AddProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the column. */\n  name: Scalars['String'];\n  /** The Node ID of the project. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddProjectColumn */\nexport type AddProjectColumnPayload = {\n  __typename?: 'AddProjectColumnPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The edge from the project's column connection. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n  /** The project */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of AddProjectV2DraftIssue */\nexport type AddProjectV2DraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project to add the draft issue to. */\n  projectId: Scalars['ID'];\n  /**\n   * The title of the draft issue. A project item can also be created by providing\n   * the URL of an Issue or Pull Request if you have access.\n   */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of AddProjectV2DraftIssue */\nexport type AddProjectV2DraftIssuePayload = {\n  __typename?: 'AddProjectV2DraftIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The draft issue added to the project. */\n  projectItem?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of AddProjectV2ItemById */\nexport type AddProjectV2ItemByIdInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the Issue or Pull Request to add. */\n  contentId: Scalars['ID'];\n  /** The ID of the Project to add the item to. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddProjectV2ItemById */\nexport type AddProjectV2ItemByIdPayload = {\n  __typename?: 'AddProjectV2ItemByIdPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item added to the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentInput = {\n  /**\n   * The text of the comment. This field is required\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `body` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * The SHA of the commit to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `commitOID` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  commitOID?: InputMaybe<Scalars['GitObjectID']>;\n  /**\n   * The comment id to reply to.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `inReplyTo` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  inReplyTo?: InputMaybe<Scalars['ID']>;\n  /**\n   * The relative path of the file to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `path` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  path?: InputMaybe<Scalars['String']>;\n  /**\n   * The line index in the diff to comment on.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `position` will be removed. use addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  position?: InputMaybe<Scalars['Int']>;\n  /**\n   * The node ID of the pull request reviewing\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `pullRequestId` will be removed. use\n   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  /**\n   * The Node ID of the review to modify.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `pullRequestReviewId` will be removed. use\n   * addPullRequestReviewThread or addPullRequestReviewThreadReply instead\n   * **Reason:** We are deprecating the addPullRequestReviewComment mutation\n   */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewComment */\nexport type AddPullRequestReviewCommentPayload = {\n  __typename?: 'AddPullRequestReviewCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created comment. */\n  comment?: Maybe<PullRequestReviewComment>;\n  /** The edge from the review's comment connection. */\n  commentEdge?: Maybe<PullRequestReviewCommentEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReview */\nexport type AddPullRequestReviewInput = {\n  /** The contents of the review body comment. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * The review line comments.\n   *\n   * **Upcoming Change on 2023-10-01 UTC**\n   * **Description:** `comments` will be removed. use the `threads` argument instead\n   * **Reason:** We are deprecating comment fields that use diff-relative positioning\n   */\n  comments?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewComment>>>;\n  /** The commit OID the review pertains to. */\n  commitOID?: InputMaybe<Scalars['GitObjectID']>;\n  /** The event to perform on the pull request review. */\n  event?: InputMaybe<PullRequestReviewEvent>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID'];\n  /** The review line comment threads. */\n  threads?: InputMaybe<Array<InputMaybe<DraftPullRequestReviewThread>>>;\n};\n\n/** Autogenerated return type of AddPullRequestReview */\nexport type AddPullRequestReviewPayload = {\n  __typename?: 'AddPullRequestReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** The edge from the pull request's review connection. */\n  reviewEdge?: Maybe<PullRequestReviewEdge>;\n};\n\n/** Autogenerated input type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadInput = {\n  /** Body of the thread's first comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * The line of the blob to which the thread refers, required for line-level\n   * threads. The end of the line range for multi-line comments.\n   */\n  line?: InputMaybe<Scalars['Int']>;\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** The node ID of the pull request reviewing */\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  /** The Node ID of the review to modify. */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']>;\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars['Int']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType?: InputMaybe<PullRequestReviewThreadSubjectType>;\n};\n\n/** Autogenerated return type of AddPullRequestReviewThread */\nexport type AddPullRequestReviewThreadPayload = {\n  __typename?: 'AddPullRequestReviewThreadPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created thread. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Autogenerated input type of AddReaction */\nexport type AddReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the emoji to react with. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddReaction */\nexport type AddReactionPayload = {\n  __typename?: 'AddReactionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reaction groups for the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of AddStar */\nexport type AddStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Starrable ID to star. */\n  starrableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddStar */\nexport type AddStarPayload = {\n  __typename?: 'AddStarPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of AddUpvote */\nexport type AddUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion or comment to upvote. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddUpvote */\nexport type AddUpvotePayload = {\n  __typename?: 'AddUpvotePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Autogenerated input type of AddVerifiableDomain */\nexport type AddVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The URL of the domain */\n  domain: Scalars['URI'];\n  /** The ID of the owner to add the domain to */\n  ownerId: Scalars['ID'];\n};\n\n/** Autogenerated return type of AddVerifiableDomain */\nexport type AddVerifiableDomainPayload = {\n  __typename?: 'AddVerifiableDomainPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The verifiable domain that was added. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Represents an 'added_to_merge_queue' event on a given pull request. */\nexport type AddedToMergeQueueEvent = Node & {\n  __typename?: 'AddedToMergeQueueEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who added this Pull Request to the merge queue */\n  enqueuer?: Maybe<User>;\n  id: Scalars['ID'];\n  /** The merge queue where this pull request was added to. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'added_to_project' event on a given issue or pull request. */\nexport type AddedToProjectEvent = Node & {\n  __typename?: 'AddedToProjectEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String'];\n};\n\n/** Represents an announcement banner. */\nexport type AnnouncementBanner = {\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']>;\n};\n\n/** A GitHub App. */\nexport type App = Node & {\n  __typename?: 'App';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The description of the app. */\n  description?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The IP addresses of the app. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String'];\n  /** A URL pointing to the app's logo. */\n  logoUrl: Scalars['URI'];\n  /** The name of the app. */\n  name: Scalars['String'];\n  /** A slug based on the name of the app for use in URLs. */\n  slug: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The URL to the app's homepage. */\n  url: Scalars['URI'];\n};\n\n\n/** A GitHub App. */\nexport type AppIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/** A GitHub App. */\nexport type AppLogoUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated input type of ApproveDeployments */\nexport type ApproveDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Optional comment for approving deployments */\n  comment?: InputMaybe<Scalars['String']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ApproveDeployments */\nexport type ApproveDeploymentsPayload = {\n  __typename?: 'ApproveDeploymentsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** Autogenerated input type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the verifiable domain to approve. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of ApproveVerifiableDomain */\nexport type ApproveVerifiableDomainPayload = {\n  __typename?: 'ApproveVerifiableDomainPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The verifiable domain that was approved. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** Autogenerated input type of ArchiveProjectV2Item */\nexport type ArchiveProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the ProjectV2Item to archive. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project to archive the item from. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ArchiveProjectV2Item */\nexport type ArchiveProjectV2ItemPayload = {\n  __typename?: 'ArchiveProjectV2ItemPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item archived from the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of ArchiveRepository */\nexport type ArchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the repository to mark as archived. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ArchiveRepository */\nexport type ArchiveRepositoryPayload = {\n  __typename?: 'ArchiveRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository that was marked as archived. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can have users assigned to it. */\nexport type Assignable = {\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n};\n\n\n/** An object that can have users assigned to it. */\nexport type AssignableAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Represents an 'assigned' event on any assignable object. */\nexport type AssignedEvent = Node & {\n  __typename?: 'AssignedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was assigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /**\n   * Identifies the user who was assigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Types that can be assigned to issues. */\nexport type Assignee = Bot | Mannequin | Organization | User;\n\n/** An entry in the audit log. */\nexport type AuditEntry = {\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Types that can initiate an audit log event. */\nexport type AuditEntryActor = Bot | Organization | User;\n\n/** Ordering options for Audit Log connections. */\nexport type AuditLogOrder = {\n  /** The ordering direction. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field to order Audit Logs by. */\n  field?: InputMaybe<AuditLogOrderField>;\n};\n\n/** Properties by which Audit Log connections can be ordered. */\nexport enum AuditLogOrderField {\n  /** Order audit log entries by timestamp */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents a 'auto_merge_disabled' event on a given pull request. */\nexport type AutoMergeDisabledEvent = Node & {\n  __typename?: 'AutoMergeDisabledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who disabled auto-merge for this Pull Request */\n  disabler?: Maybe<User>;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event */\n  pullRequest?: Maybe<PullRequest>;\n  /** The reason auto-merge was disabled */\n  reason?: Maybe<Scalars['String']>;\n  /** The reason_code relating to why auto-merge was disabled */\n  reasonCode?: Maybe<Scalars['String']>;\n};\n\n/** Represents a 'auto_merge_enabled' event on a given pull request. */\nexport type AutoMergeEnabledEvent = Node & {\n  __typename?: 'AutoMergeEnabledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who enabled auto-merge for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents an auto-merge request for a pull request */\nexport type AutoMergeRequest = {\n  __typename?: 'AutoMergeRequest';\n  /** The email address of the author of this auto-merge request. */\n  authorEmail?: Maybe<Scalars['String']>;\n  /**\n   * The commit message of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging.\n   */\n  commitBody?: Maybe<Scalars['String']>;\n  /**\n   * The commit title of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging\n   */\n  commitHeadline?: Maybe<Scalars['String']>;\n  /** When was this auto-merge request was enabled. */\n  enabledAt?: Maybe<Scalars['DateTime']>;\n  /** The actor who created the auto-merge request. */\n  enabledBy?: Maybe<Actor>;\n  /**\n   * The merge method of the auto-merge request. If a merge queue is required by\n   * the base branch, this value will be set by the merge queue when merging.\n   */\n  mergeMethod: PullRequestMergeMethod;\n  /** The pull request that this auto-merge request is set against. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'auto_rebase_enabled' event on a given pull request. */\nexport type AutoRebaseEnabledEvent = Node & {\n  __typename?: 'AutoRebaseEnabledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who enabled auto-merge (rebase) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'auto_squash_enabled' event on a given pull request. */\nexport type AutoSquashEnabledEvent = Node & {\n  __typename?: 'AutoSquashEnabledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who enabled auto-merge (squash) for this Pull Request */\n  enabler?: Maybe<User>;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'automatic_base_change_failed' event on a given pull request. */\nexport type AutomaticBaseChangeFailedEvent = Node & {\n  __typename?: 'AutomaticBaseChangeFailedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The new base for this PR */\n  newBase: Scalars['String'];\n  /** The old base for this PR */\n  oldBase: Scalars['String'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\nexport type AutomaticBaseChangeSucceededEvent = Node & {\n  __typename?: 'AutomaticBaseChangeSucceededEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The new base for this PR */\n  newBase: Scalars['String'];\n  /** The old base for this PR */\n  oldBase: Scalars['String'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_changed' event on a given issue or pull request. */\nexport type BaseRefChangedEvent = Node & {\n  __typename?: 'BaseRefChangedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the name of the base ref for the pull request after it was changed. */\n  currentRefName: Scalars['String'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Identifies the name of the base ref for the pull request before it was changed. */\n  previousRefName: Scalars['String'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'base_ref_deleted' event on a given pull request. */\nexport type BaseRefDeletedEvent = Node & {\n  __typename?: 'BaseRefDeletedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the name of the Ref associated with the `base_ref_deleted` event. */\n  baseRefName?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'base_ref_force_pushed' event on a given pull request. */\nexport type BaseRefForcePushedEvent = Node & {\n  __typename?: 'BaseRefForcePushedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'base_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'base_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'base_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a Git blame. */\nexport type Blame = {\n  __typename?: 'Blame';\n  /** The list of ranges from a Git blame. */\n  ranges: Array<BlameRange>;\n};\n\n/** Represents a range of information from a Git blame. */\nexport type BlameRange = {\n  __typename?: 'BlameRange';\n  /**\n   * Identifies the recency of the change, from 1 (new) to 10 (old). This is\n   * calculated as a 2-quantile and determines the length of distance between the\n   * median age of all the changes in the file and the recency of the current\n   * range's change.\n   */\n  age: Scalars['Int'];\n  /** Identifies the line author */\n  commit: Commit;\n  /** The ending line for the range */\n  endingLine: Scalars['Int'];\n  /** The starting line for the range */\n  startingLine: Scalars['Int'];\n};\n\n/** Represents a Git blob. */\nexport type Blob = GitObject & Node & {\n  __typename?: 'Blob';\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String'];\n  /** Byte size of Blob object */\n  byteSize: Scalars['Int'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding. */\n  isBinary?: Maybe<Scalars['Boolean']>;\n  /** Indicates whether the contents is truncated */\n  isTruncated: Scalars['Boolean'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n  /** UTF8 text data or null if the Blob is binary */\n  text?: Maybe<Scalars['String']>;\n};\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type Bot = Actor & Node & UniformResourceLocatable & {\n  __typename?: 'Bot';\n  /** A URL pointing to the GitHub App's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The username of the actor. */\n  login: Scalars['String'];\n  /** The HTTP path for this bot */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this bot */\n  url: Scalars['URI'];\n};\n\n\n/** A special type of user which takes actions on behalf of GitHub Apps. */\nexport type BotAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** Types which can be actors for `BranchActorAllowance` objects. */\nexport type BranchActorAllowanceActor = App | Team | User;\n\n/** Parameters to be used for the branch_name_pattern rule */\nexport type BranchNamePatternParameters = {\n  __typename?: 'BranchNamePatternParameters';\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean'];\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Parameters to be used for the branch_name_pattern rule */\nexport type BranchNamePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** A branch protection rule. */\nexport type BranchProtectionRule = Node & {\n  __typename?: 'BranchProtectionRule';\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean'];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean'];\n  /** Is branch creation a protected operation. */\n  blocksCreations: Scalars['Boolean'];\n  /** A list of conflicts matching branches protection rule and other branch protection rules */\n  branchProtectionRuleConflicts: BranchProtectionRuleConflictConnection;\n  /** A list of actors able to force push for this branch protection rule. */\n  bypassForcePushAllowances: BypassForcePushAllowanceConnection;\n  /** A list of actors able to bypass PRs for this branch protection rule. */\n  bypassPullRequestAllowances: BypassPullRequestAllowanceConnection;\n  /** The actor who created this branch protection rule. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced: Scalars['Boolean'];\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge: Scalars['Boolean'];\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch: Scalars['Boolean'];\n  /** Repository refs that are protected by this rule */\n  matchingRefs: RefConnection;\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String'];\n  /** A list push allowances for this branch protection rule. */\n  pushAllowances: PushAllowanceConnection;\n  /** The repository associated with this branch protection rule. */\n  repository?: Maybe<Repository>;\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval: Scalars['Boolean'];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;\n  /** List of required deployment environments that must be deployed successfully to update matching branches */\n  requiredDeploymentEnvironments?: Maybe<Array<Maybe<Scalars['String']>>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;\n  /** List of required status checks that must pass for commits to be accepted to matching branches. */\n  requiredStatusChecks?: Maybe<Array<RequiredStatusCheckDescription>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews: Scalars['Boolean'];\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean'];\n  /** Are commits required to be signed. */\n  requiresCommitSignatures: Scalars['Boolean'];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean'];\n  /** Does this branch require deployment to specific environments before merging */\n  requiresDeployments: Scalars['Boolean'];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean'];\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks: Scalars['Boolean'];\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks: Scalars['Boolean'];\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes: Scalars['Boolean'];\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals: Scalars['Boolean'];\n  /** A list review dismissal allowances for this branch protection rule. */\n  reviewDismissalAllowances: ReviewDismissalAllowanceConnection;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBranchProtectionRuleConflictsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassForcePushAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleBypassPullRequestAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleMatchingRefsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRulePushAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A branch protection rule. */\nexport type BranchProtectionRuleReviewDismissalAllowancesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A conflict between two branch protection rules. */\nexport type BranchProtectionRuleConflict = {\n  __typename?: 'BranchProtectionRuleConflict';\n  /** Identifies the branch protection rule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the conflicting branch protection rule. */\n  conflictingBranchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Identifies the branch ref that has conflicting rules */\n  ref?: Maybe<Ref>;\n};\n\n/** The connection type for BranchProtectionRuleConflict. */\nexport type BranchProtectionRuleConflictConnection = {\n  __typename?: 'BranchProtectionRuleConflictConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleConflictEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRuleConflict>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleConflictEdge = {\n  __typename?: 'BranchProtectionRuleConflictEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRuleConflict>;\n};\n\n/** The connection type for BranchProtectionRule. */\nexport type BranchProtectionRuleConnection = {\n  __typename?: 'BranchProtectionRuleConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BranchProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BranchProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type BranchProtectionRuleEdge = {\n  __typename?: 'BranchProtectionRuleEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BranchProtectionRule>;\n};\n\n/**\n * Information about a sponsorship to make for a user or organization with a GitHub\n * Sponsors profile, as part of sponsoring many users or organizations at once.\n */\nexport type BulkSponsorship = {\n  /** The amount to pay to the sponsorable in US dollars. Valid values: 1-12000. */\n  amount: Scalars['Int'];\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n};\n\n/** Types that can represent a repository ruleset bypass actor. */\nexport type BypassActor = App | Team;\n\n/** A user, team, or app who has the ability to bypass a force push requirement on a protected branch. */\nexport type BypassForcePushAllowance = Node & {\n  __typename?: 'BypassForcePushAllowance';\n  /** The actor that can force push. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID'];\n};\n\n/** The connection type for BypassForcePushAllowance. */\nexport type BypassForcePushAllowanceConnection = {\n  __typename?: 'BypassForcePushAllowanceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassForcePushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassForcePushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type BypassForcePushAllowanceEdge = {\n  __typename?: 'BypassForcePushAllowanceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassForcePushAllowance>;\n};\n\n/** A user, team, or app who has the ability to bypass a pull request requirement on a protected branch. */\nexport type BypassPullRequestAllowance = Node & {\n  __typename?: 'BypassPullRequestAllowance';\n  /** The actor that can bypass. */\n  actor?: Maybe<BranchActorAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID'];\n};\n\n/** The connection type for BypassPullRequestAllowance. */\nexport type BypassPullRequestAllowanceConnection = {\n  __typename?: 'BypassPullRequestAllowanceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<BypassPullRequestAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<BypassPullRequestAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type BypassPullRequestAllowanceEdge = {\n  __typename?: 'BypassPullRequestAllowanceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<BypassPullRequestAllowance>;\n};\n\n/** The Common Vulnerability Scoring System */\nexport type Cvss = {\n  __typename?: 'CVSS';\n  /** The CVSS score associated with this advisory */\n  score: Scalars['Float'];\n  /** The CVSS vector string associated with this advisory */\n  vectorString?: Maybe<Scalars['String']>;\n};\n\n/** A common weakness enumeration */\nexport type Cwe = Node & {\n  __typename?: 'CWE';\n  /** The id of the CWE */\n  cweId: Scalars['String'];\n  /** A detailed description of this CWE */\n  description: Scalars['String'];\n  id: Scalars['ID'];\n  /** The name of this CWE */\n  name: Scalars['String'];\n};\n\n/** The connection type for CWE. */\nexport type CweConnection = {\n  __typename?: 'CWEConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CweEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Cwe>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CweEdge = {\n  __typename?: 'CWEEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Cwe>;\n};\n\n/** Autogenerated input type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the pending enterprise administrator invitation. */\n  invitationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CancelEnterpriseAdminInvitation */\nexport type CancelEnterpriseAdminInvitationPayload = {\n  __typename?: 'CancelEnterpriseAdminInvitationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The invitation that was canceled. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** A message confirming the result of canceling an administrator invitation. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of CancelSponsorship */\nexport type CancelSponsorshipInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of CancelSponsorship */\nexport type CancelSponsorshipPayload = {\n  __typename?: 'CancelSponsorshipPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The tier that was being used at the time of cancellation. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of ChangeUserStatus */\nexport type ChangeUserStatusInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The emoji to represent your status. Can either be a native Unicode emoji or an emoji name with colons, e.g., :grinning:. */\n  emoji?: InputMaybe<Scalars['String']>;\n  /** If set, the user status will not be shown after this date. */\n  expiresAt?: InputMaybe<Scalars['DateTime']>;\n  /** Whether this status should indicate you are not fully available on GitHub, e.g., you are away. */\n  limitedAvailability?: InputMaybe<Scalars['Boolean']>;\n  /** A short description of your current status. */\n  message?: InputMaybe<Scalars['String']>;\n  /**\n   * The ID of the organization whose members will be allowed to see the status. If\n   * omitted, the status will be publicly visible.\n   */\n  organizationId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of ChangeUserStatus */\nexport type ChangeUserStatusPayload = {\n  __typename?: 'ChangeUserStatusPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Your updated status. */\n  status?: Maybe<UserStatus>;\n};\n\n/** A single check annotation. */\nexport type CheckAnnotation = {\n  __typename?: 'CheckAnnotation';\n  /** The annotation's severity level. */\n  annotationLevel?: Maybe<CheckAnnotationLevel>;\n  /** The path to the file that this annotation was made on. */\n  blobUrl: Scalars['URI'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The position of this annotation. */\n  location: CheckAnnotationSpan;\n  /** The annotation's message. */\n  message: Scalars['String'];\n  /** The path that this annotation was made on. */\n  path: Scalars['String'];\n  /** Additional information about the annotation. */\n  rawDetails?: Maybe<Scalars['String']>;\n  /** The annotation's title */\n  title?: Maybe<Scalars['String']>;\n};\n\n/** The connection type for CheckAnnotation. */\nexport type CheckAnnotationConnection = {\n  __typename?: 'CheckAnnotationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckAnnotationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckAnnotation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationData = {\n  /** Represents an annotation's information level */\n  annotationLevel: CheckAnnotationLevel;\n  /** The location of the annotation */\n  location: CheckAnnotationRange;\n  /** A short description of the feedback for these lines of code. */\n  message: Scalars['String'];\n  /** The path of the file to add an annotation to. */\n  path: Scalars['String'];\n  /** Details about this annotation. */\n  rawDetails?: InputMaybe<Scalars['String']>;\n  /** The title that represents the annotation. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** An edge in a connection. */\nexport type CheckAnnotationEdge = {\n  __typename?: 'CheckAnnotationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckAnnotation>;\n};\n\n/** Represents an annotation's information level. */\nexport enum CheckAnnotationLevel {\n  /** An annotation indicating an inescapable error. */\n  Failure = 'FAILURE',\n  /** An annotation indicating some information. */\n  Notice = 'NOTICE',\n  /** An annotation indicating an ignorable error. */\n  Warning = 'WARNING'\n}\n\n/** A character position in a check annotation. */\nexport type CheckAnnotationPosition = {\n  __typename?: 'CheckAnnotationPosition';\n  /** Column number (1 indexed). */\n  column?: Maybe<Scalars['Int']>;\n  /** Line number (1 indexed). */\n  line: Scalars['Int'];\n};\n\n/** Information from a check run analysis to specific lines of code. */\nexport type CheckAnnotationRange = {\n  /** The ending column of the range. */\n  endColumn?: InputMaybe<Scalars['Int']>;\n  /** The ending line of the range. */\n  endLine: Scalars['Int'];\n  /** The starting column of the range. */\n  startColumn?: InputMaybe<Scalars['Int']>;\n  /** The starting line of the range. */\n  startLine: Scalars['Int'];\n};\n\n/** An inclusive pair of positions for a check annotation. */\nexport type CheckAnnotationSpan = {\n  __typename?: 'CheckAnnotationSpan';\n  /** End position (inclusive). */\n  end: CheckAnnotationPosition;\n  /** Start position (inclusive). */\n  start: CheckAnnotationPosition;\n};\n\n/** The possible states for a check suite or run conclusion. */\nexport enum CheckConclusionState {\n  /** The check suite or run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check suite or run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check suite or run has failed. */\n  Failure = 'FAILURE',\n  /** The check suite or run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check suite or run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check suite or run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check suite or run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check suite or run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check suite or run has timed out. */\n  TimedOut = 'TIMED_OUT'\n}\n\n/** A check run. */\nexport type CheckRun = Node & RequirableByPullRequest & UniformResourceLocatable & {\n  __typename?: 'CheckRun';\n  /** The check run's annotations */\n  annotations?: Maybe<CheckAnnotationConnection>;\n  /** The check suite that this run is a part of. */\n  checkSuite: CheckSuite;\n  /** Identifies the date and time when the check run was completed. */\n  completedAt?: Maybe<Scalars['DateTime']>;\n  /** The conclusion of the check run. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The corresponding deployment for this job, if any */\n  deployment?: Maybe<Deployment>;\n  /** The URL from which to find full details of the check run on the integrator's site. */\n  detailsUrl?: Maybe<Scalars['URI']>;\n  /** A reference for the check run on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean'];\n  /** The name of the check for this check run. */\n  name: Scalars['String'];\n  /** Information about a pending deployment, if any, in this check run */\n  pendingDeploymentRequest?: Maybe<DeploymentRequest>;\n  /** The permalink to the check run summary. */\n  permalink: Scalars['URI'];\n  /** The repository associated with this check run. */\n  repository: Repository;\n  /** The HTTP path for this check run. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the check run was started. */\n  startedAt?: Maybe<Scalars['DateTime']>;\n  /** The current status of the check run. */\n  status: CheckStatusState;\n  /** The check run's steps */\n  steps?: Maybe<CheckStepConnection>;\n  /** A string representing the check run's summary */\n  summary?: Maybe<Scalars['String']>;\n  /** A string representing the check run's text */\n  text?: Maybe<Scalars['String']>;\n  /** A string representing the check run */\n  title?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this check run. */\n  url: Scalars['URI'];\n};\n\n\n/** A check run. */\nexport type CheckRunAnnotationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A check run. */\nexport type CheckRunIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A check run. */\nexport type CheckRunStepsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  number?: InputMaybe<Scalars['Int']>;\n};\n\n/** Possible further actions the integrator can perform. */\nexport type CheckRunAction = {\n  /** A short explanation of what this action would do. */\n  description: Scalars['String'];\n  /** A reference for the action on the integrator's system. */\n  identifier: Scalars['String'];\n  /** The text to be displayed on a button in the web UI. */\n  label: Scalars['String'];\n};\n\n/** The connection type for CheckRun. */\nexport type CheckRunConnection = {\n  __typename?: 'CheckRunConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckRunEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckRun>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CheckRunEdge = {\n  __typename?: 'CheckRunEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckRun>;\n};\n\n/** The filters that are available when fetching check runs. */\nexport type CheckRunFilter = {\n  /** Filters the check runs created by this application ID. */\n  appId?: InputMaybe<Scalars['Int']>;\n  /** Filters the check runs by this name. */\n  checkName?: InputMaybe<Scalars['String']>;\n  /** Filters the check runs by this type. */\n  checkType?: InputMaybe<CheckRunType>;\n  /** Filters the check runs by these conclusions. */\n  conclusions?: InputMaybe<Array<CheckConclusionState>>;\n  /** Filters the check runs by this status. Superceded by statuses. */\n  status?: InputMaybe<CheckStatusState>;\n  /** Filters the check runs by this status. Overrides status. */\n  statuses?: InputMaybe<Array<CheckStatusState>>;\n};\n\n/** Descriptive details about the check run. */\nexport type CheckRunOutput = {\n  /** The annotations that are made as part of the check run. */\n  annotations?: InputMaybe<Array<CheckAnnotationData>>;\n  /** Images attached to the check run output displayed in the GitHub pull request UI. */\n  images?: InputMaybe<Array<CheckRunOutputImage>>;\n  /** The summary of the check run (supports Commonmark). */\n  summary: Scalars['String'];\n  /** The details of the check run (supports Commonmark). */\n  text?: InputMaybe<Scalars['String']>;\n  /** A title to provide for this check run. */\n  title: Scalars['String'];\n};\n\n/** Images attached to the check run output displayed in the GitHub pull request UI. */\nexport type CheckRunOutputImage = {\n  /** The alternative text for the image. */\n  alt: Scalars['String'];\n  /** A short image description. */\n  caption?: InputMaybe<Scalars['String']>;\n  /** The full URL of the image. */\n  imageUrl: Scalars['URI'];\n};\n\n/** The possible states of a check run in a status rollup. */\nexport enum CheckRunState {\n  /** The check run requires action. */\n  ActionRequired = 'ACTION_REQUIRED',\n  /** The check run has been cancelled. */\n  Cancelled = 'CANCELLED',\n  /** The check run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check run has failed. */\n  Failure = 'FAILURE',\n  /** The check run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check run was neutral. */\n  Neutral = 'NEUTRAL',\n  /** The check run is in pending state. */\n  Pending = 'PENDING',\n  /** The check run has been queued. */\n  Queued = 'QUEUED',\n  /** The check run was skipped. */\n  Skipped = 'SKIPPED',\n  /** The check run was marked stale by GitHub. Only GitHub can use this conclusion. */\n  Stale = 'STALE',\n  /** The check run has failed at startup. */\n  StartupFailure = 'STARTUP_FAILURE',\n  /** The check run has succeeded. */\n  Success = 'SUCCESS',\n  /** The check run has timed out. */\n  TimedOut = 'TIMED_OUT',\n  /** The check run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** Represents a count of the state of a check run. */\nexport type CheckRunStateCount = {\n  __typename?: 'CheckRunStateCount';\n  /** The number of check runs with this state. */\n  count: Scalars['Int'];\n  /** The state of a check run. */\n  state: CheckRunState;\n};\n\n/** The possible types of check runs. */\nexport enum CheckRunType {\n  /** Every check run available. */\n  All = 'ALL',\n  /** The latest check run. */\n  Latest = 'LATEST'\n}\n\n/** The possible states for a check suite or run status. */\nexport enum CheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run has been requested. */\n  Requested = 'REQUESTED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** A single check step. */\nexport type CheckStep = {\n  __typename?: 'CheckStep';\n  /** Identifies the date and time when the check step was completed. */\n  completedAt?: Maybe<Scalars['DateTime']>;\n  /** The conclusion of the check step. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** A reference for the check step on the integrator's system. */\n  externalId?: Maybe<Scalars['String']>;\n  /** The step's name. */\n  name: Scalars['String'];\n  /** The index of the step in the list of steps of the parent check run. */\n  number: Scalars['Int'];\n  /** Number of seconds to completion. */\n  secondsToCompletion?: Maybe<Scalars['Int']>;\n  /** Identifies the date and time when the check step was started. */\n  startedAt?: Maybe<Scalars['DateTime']>;\n  /** The current status of the check step. */\n  status: CheckStatusState;\n};\n\n/** The connection type for CheckStep. */\nexport type CheckStepConnection = {\n  __typename?: 'CheckStepConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckStepEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckStep>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CheckStepEdge = {\n  __typename?: 'CheckStepEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckStep>;\n};\n\n/** A check suite. */\nexport type CheckSuite = Node & {\n  __typename?: 'CheckSuite';\n  /** The GitHub App which created this check suite. */\n  app?: Maybe<App>;\n  /** The name of the branch for this check suite. */\n  branch?: Maybe<Ref>;\n  /** The check runs associated with a check suite. */\n  checkRuns?: Maybe<CheckRunConnection>;\n  /** The commit for this check suite */\n  commit: Commit;\n  /** The conclusion of this check suite. */\n  conclusion?: Maybe<CheckConclusionState>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who triggered the check suite. */\n  creator?: Maybe<User>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** A list of open pull requests matching the check suite. */\n  matchingPullRequests?: Maybe<PullRequestConnection>;\n  /** The push that triggered this check suite. */\n  push?: Maybe<Push>;\n  /** The repository associated with this check suite. */\n  repository: Repository;\n  /** The HTTP path for this check suite */\n  resourcePath: Scalars['URI'];\n  /** The status of this check suite. */\n  status: CheckStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this check suite */\n  url: Scalars['URI'];\n  /** The workflow run associated with this check suite. */\n  workflowRun?: Maybe<WorkflowRun>;\n};\n\n\n/** A check suite. */\nexport type CheckSuiteCheckRunsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<CheckRunFilter>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A check suite. */\nexport type CheckSuiteMatchingPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The auto-trigger preferences that are available for check suites. */\nexport type CheckSuiteAutoTriggerPreference = {\n  /** The node ID of the application that owns the check suite. */\n  appId: Scalars['ID'];\n  /** Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository. */\n  setting: Scalars['Boolean'];\n};\n\n/** The connection type for CheckSuite. */\nexport type CheckSuiteConnection = {\n  __typename?: 'CheckSuiteConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CheckSuiteEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CheckSuite>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CheckSuiteEdge = {\n  __typename?: 'CheckSuiteEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CheckSuite>;\n};\n\n/** The filters that are available when fetching check suites. */\nexport type CheckSuiteFilter = {\n  /** Filters the check suites created by this application ID. */\n  appId?: InputMaybe<Scalars['Int']>;\n  /** Filters the check suites by this name. */\n  checkName?: InputMaybe<Scalars['String']>;\n};\n\n/** An object which can have its data claimed or claim data from another. */\nexport type Claimable = Mannequin | User;\n\n/** Autogenerated input type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the labelable object to clear the labels from. */\n  labelableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ClearLabelsFromLabelable */\nexport type ClearLabelsFromLabelablePayload = {\n  __typename?: 'ClearLabelsFromLabelablePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item that was unlabeled. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of ClearProjectV2ItemFieldValue */\nexport type ClearProjectV2ItemFieldValueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the field to be cleared. */\n  fieldId: Scalars['ID'];\n  /** The ID of the item to be cleared. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ClearProjectV2ItemFieldValue */\nexport type ClearProjectV2ItemFieldValuePayload = {\n  __typename?: 'ClearProjectV2ItemFieldValuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated item. */\n  projectV2Item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of CloneProject */\nexport type CloneProjectInput = {\n  /** The description of the project. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether or not to clone the source project's workflows. */\n  includeWorkflows: Scalars['Boolean'];\n  /** The name of the project. */\n  name: Scalars['String'];\n  /** The visibility of the project, defaults to false (private). */\n  public?: InputMaybe<Scalars['Boolean']>;\n  /** The source project to clone. */\n  sourceId: Scalars['ID'];\n  /** The owner ID to create the project under. */\n  targetOwnerId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CloneProject */\nexport type CloneProjectPayload = {\n  __typename?: 'CloneProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The id of the JobStatus for populating cloned fields. */\n  jobStatusId?: Maybe<Scalars['String']>;\n  /** The new cloned project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars['String']>;\n  /**\n   * Whether to copy all branches from the template to the new repository. Defaults\n   * to copying only the default branch of the template.\n   */\n  includeAllBranches?: InputMaybe<Scalars['Boolean']>;\n  /** The name of the new repository. */\n  name: Scalars['String'];\n  /** The ID of the owner for the new repository. */\n  ownerId: Scalars['ID'];\n  /** The Node ID of the template repository. */\n  repositoryId: Scalars['ID'];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CloneTemplateRepository */\nexport type CloneTemplateRepositoryPayload = {\n  __typename?: 'CloneTemplateRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** An object that can be closed */\nexport type Closable = {\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of CloseDiscussion */\nexport type CloseDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the discussion to be closed. */\n  discussionId: Scalars['ID'];\n  /** The reason why the discussion is being closed. */\n  reason?: InputMaybe<DiscussionCloseReason>;\n};\n\n/** Autogenerated return type of CloseDiscussion */\nexport type CloseDiscussionPayload = {\n  __typename?: 'CloseDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that was closed. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of CloseIssue */\nexport type CloseIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the issue to be closed. */\n  issueId: Scalars['ID'];\n  /** The reason the issue is to be closed. */\n  stateReason?: InputMaybe<IssueClosedStateReason>;\n};\n\n/** Autogenerated return type of CloseIssue */\nexport type CloseIssuePayload = {\n  __typename?: 'CloseIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue that was closed. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ClosePullRequest */\nexport type ClosePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the pull request to be closed. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ClosePullRequest */\nexport type ClosePullRequestPayload = {\n  __typename?: 'ClosePullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that was closed. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'closed' event on any `Closable`. */\nexport type ClosedEvent = Node & UniformResourceLocatable & {\n  __typename?: 'ClosedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Object that was closed. */\n  closable: Closable;\n  /** Object which triggered the creation of this event. */\n  closer?: Maybe<Closer>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The HTTP path for this closed event. */\n  resourcePath: Scalars['URI'];\n  /** The reason the issue state was changed to closed. */\n  stateReason?: Maybe<IssueStateReason>;\n  /** The HTTP URL for this closed event. */\n  url: Scalars['URI'];\n};\n\n/** The object which triggered a `ClosedEvent`. */\nexport type Closer = Commit | PullRequest;\n\n/** The Code of Conduct for a repository */\nexport type CodeOfConduct = Node & {\n  __typename?: 'CodeOfConduct';\n  /** The body of the Code of Conduct */\n  body?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The key for the Code of Conduct */\n  key: Scalars['String'];\n  /** The formal name of the Code of Conduct */\n  name: Scalars['String'];\n  /** The HTTP path for this Code of Conduct */\n  resourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this Code of Conduct */\n  url?: Maybe<Scalars['URI']>;\n};\n\n/** Collaborators affiliation level with a subject. */\nexport enum CollaboratorAffiliation {\n  /** All collaborators the authenticated user can see. */\n  All = 'ALL',\n  /** All collaborators with permissions to an organization-owned subject, regardless of organization membership status. */\n  Direct = 'DIRECT',\n  /** All outside collaborators of an organization-owned subject. */\n  Outside = 'OUTSIDE'\n}\n\n/** Represents a comment. */\nexport type Comment = {\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** Represents a comment. */\nexport type CommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A comment author association with repository. */\nexport enum CommentAuthorAssociation {\n  /** Author has been invited to collaborate on the repository. */\n  Collaborator = 'COLLABORATOR',\n  /** Author has previously committed to the repository. */\n  Contributor = 'CONTRIBUTOR',\n  /** Author has not previously committed to GitHub. */\n  FirstTimer = 'FIRST_TIMER',\n  /** Author has not previously committed to the repository. */\n  FirstTimeContributor = 'FIRST_TIME_CONTRIBUTOR',\n  /** Author is a placeholder for an unclaimed user. */\n  Mannequin = 'MANNEQUIN',\n  /** Author is a member of the organization that owns the repository. */\n  Member = 'MEMBER',\n  /** Author has no association with the repository. */\n  None = 'NONE',\n  /** Author is the owner of the repository. */\n  Owner = 'OWNER'\n}\n\n/** The possible errors that will prevent a user from updating a comment. */\nexport enum CommentCannotUpdateReason {\n  /** Unable to create comment because repository is archived. */\n  Archived = 'ARCHIVED',\n  /** You cannot update this comment */\n  Denied = 'DENIED',\n  /** You must be the author or have write access to this repository to update this comment. */\n  InsufficientAccess = 'INSUFFICIENT_ACCESS',\n  /** Unable to create comment because issue is locked. */\n  Locked = 'LOCKED',\n  /** You must be logged in to update this comment. */\n  LoginRequired = 'LOGIN_REQUIRED',\n  /** Repository is under maintenance. */\n  Maintenance = 'MAINTENANCE',\n  /** At least one email address must be verified to update this comment. */\n  VerifiedEmailRequired = 'VERIFIED_EMAIL_REQUIRED'\n}\n\n/** Represents a 'comment_deleted' event on a given issue or pull request. */\nexport type CommentDeletedEvent = Node & {\n  __typename?: 'CommentDeletedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The user who authored the deleted comment. */\n  deletedCommentAuthor?: Maybe<Actor>;\n  id: Scalars['ID'];\n};\n\n/** Represents a Git commit. */\nexport type Commit = GitObject & Node & Subscribable & UniformResourceLocatable & {\n  __typename?: 'Commit';\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String'];\n  /** The number of additions in this commit. */\n  additions: Scalars['Int'];\n  /**\n   * The merged Pull Request that introduced the commit to the repository. If the\n   * commit is not present in the default branch, additionally returns open Pull\n   * Requests associated with the commit\n   */\n  associatedPullRequests?: Maybe<PullRequestConnection>;\n  /** Authorship details of the commit. */\n  author?: Maybe<GitActor>;\n  /** Check if the committer and the author match. */\n  authoredByCommitter: Scalars['Boolean'];\n  /** The datetime when this commit was authored. */\n  authoredDate: Scalars['DateTime'];\n  /**\n   * The list of authors for this commit based on the git author and the Co-authored-by\n   * message trailer. The git author will always be first.\n   */\n  authors: GitActorConnection;\n  /** Fetches `git blame` information. */\n  blame: Blame;\n  /**\n   * We recommend using the `changedFilesIfAvailable` field instead of\n   * `changedFiles`, as `changedFiles` will cause your request to return an error\n   * if GitHub is unable to calculate the number of changed files.\n   * @deprecated `changedFiles` will be removed. Use `changedFilesIfAvailable` instead. Removal on 2023-01-01 UTC.\n   */\n  changedFiles: Scalars['Int'];\n  /**\n   * The number of changed files in this commit. If GitHub is unable to calculate\n   * the number of changed files (for example due to a timeout), this will return\n   * `null`. We recommend using this field instead of `changedFiles`.\n   */\n  changedFilesIfAvailable?: Maybe<Scalars['Int']>;\n  /** The check suites associated with a commit. */\n  checkSuites?: Maybe<CheckSuiteConnection>;\n  /** Comments made on the commit. */\n  comments: CommitCommentConnection;\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI'];\n  /** The datetime when this commit was committed. */\n  committedDate: Scalars['DateTime'];\n  /** Check if committed via GitHub web UI. */\n  committedViaWeb: Scalars['Boolean'];\n  /** Committer details of the commit. */\n  committer?: Maybe<GitActor>;\n  /** The number of deletions in this commit. */\n  deletions: Scalars['Int'];\n  /** The deployments associated with a commit. */\n  deployments?: Maybe<DeploymentConnection>;\n  /** The tree entry representing the file located at the given path. */\n  file?: Maybe<TreeEntry>;\n  /** The linear commit history starting from (and including) this commit, in the same order as `git log`. */\n  history: CommitHistoryConnection;\n  id: Scalars['ID'];\n  /** The Git commit message */\n  message: Scalars['String'];\n  /** The Git commit message body */\n  messageBody: Scalars['String'];\n  /** The commit message body rendered to HTML. */\n  messageBodyHTML: Scalars['HTML'];\n  /** The Git commit message headline */\n  messageHeadline: Scalars['String'];\n  /** The commit message headline rendered to HTML. */\n  messageHeadlineHTML: Scalars['HTML'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID'];\n  /** The organization this commit was made on behalf of. */\n  onBehalfOf?: Maybe<Organization>;\n  /** The parents of a commit. */\n  parents: CommitConnection;\n  /**\n   * The datetime when this commit was pushed.\n   * @deprecated `pushedDate` is no longer supported. Removal on 2023-07-01 UTC.\n   */\n  pushedDate?: Maybe<Scalars['DateTime']>;\n  /** The Repository this commit belongs to */\n  repository: Repository;\n  /** The HTTP path for this commit */\n  resourcePath: Scalars['URI'];\n  /** Commit signing information, if present. */\n  signature?: Maybe<GitSignature>;\n  /** Status information for this commit */\n  status?: Maybe<Status>;\n  /** Check and Status rollup information for this commit. */\n  statusCheckRollup?: Maybe<StatusCheckRollup>;\n  /** Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file. */\n  submodules: SubmoduleConnection;\n  /**\n   * Returns a URL to download a tarball archive for a repository.\n   * Note: For private repositories, these links are temporary and expire after five minutes.\n   */\n  tarballUrl: Scalars['URI'];\n  /** Commit's root Tree */\n  tree: Tree;\n  /** The HTTP path for the tree of this commit */\n  treeResourcePath: Scalars['URI'];\n  /** The HTTP URL for the tree of this commit */\n  treeUrl: Scalars['URI'];\n  /** The HTTP URL for this commit */\n  url: Scalars['URI'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n  /**\n   * Returns a URL to download a zipball archive for a repository.\n   * Note: For private repositories, these links are temporary and expire after five minutes.\n   */\n  zipballUrl: Scalars['URI'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PullRequestOrder>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitAuthorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitBlameArgs = {\n  path: Scalars['String'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitCheckSuitesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<CheckSuiteFilter>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitDeploymentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  environments?: InputMaybe<Array<Scalars['String']>>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitFileArgs = {\n  path: Scalars['String'];\n};\n\n\n/** Represents a Git commit. */\nexport type CommitHistoryArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  author?: InputMaybe<CommitAuthor>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  path?: InputMaybe<Scalars['String']>;\n  since?: InputMaybe<Scalars['GitTimestamp']>;\n  until?: InputMaybe<Scalars['GitTimestamp']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitParentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents a Git commit. */\nexport type CommitSubmodulesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Specifies an author for filtering Git commits. */\nexport type CommitAuthor = {\n  /** Email addresses to filter by. Commits authored by any of the specified email addresses will be returned. */\n  emails?: InputMaybe<Array<Scalars['String']>>;\n  /**\n   * ID of a User to filter by. If non-null, only commits authored by this user\n   * will be returned. This field takes precedence over emails.\n   */\n  id?: InputMaybe<Scalars['ID']>;\n};\n\n/** Parameters to be used for the commit_author_email_pattern rule */\nexport type CommitAuthorEmailPatternParameters = {\n  __typename?: 'CommitAuthorEmailPatternParameters';\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean'];\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Parameters to be used for the commit_author_email_pattern rule */\nexport type CommitAuthorEmailPatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Represents a comment on a given Commit. */\nexport type CommitComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  __typename?: 'CommitComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the comment body. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the commit associated with the comment, if the commit exists. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Identifies the file path associated with the comment. */\n  path?: Maybe<Scalars['String']>;\n  /** Identifies the line position associated with the comment. */\n  position?: Maybe<Scalars['Int']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this commit comment. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL permalink for this commit comment. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** Represents a comment on a given Commit. */\nexport type CommitCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for CommitComment. */\nexport type CommitCommentConnection = {\n  __typename?: 'CommitCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CommitComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CommitCommentEdge = {\n  __typename?: 'CommitCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CommitComment>;\n};\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThread = Node & RepositoryNode & {\n  __typename?: 'CommitCommentThread';\n  /** The comments that exist in this thread. */\n  comments: CommitCommentConnection;\n  /** The commit the comments were made on. */\n  commit?: Maybe<Commit>;\n  id: Scalars['ID'];\n  /** The file the comments were made on. */\n  path?: Maybe<Scalars['String']>;\n  /** The position in the diff for the commit that the comment was made on. */\n  position?: Maybe<Scalars['Int']>;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n\n/** A thread of comments on a commit. */\nexport type CommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for Commit. */\nexport type CommitConnection = {\n  __typename?: 'CommitConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Ordering options for commit contribution connections. */\nexport type CommitContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field by which to order commit contributions. */\n  field: CommitContributionOrderField;\n};\n\n/** Properties by which commit contribution connections can be ordered. */\nexport enum CommitContributionOrderField {\n  /** Order commit contributions by how many commits they represent. */\n  CommitCount = 'COMMIT_COUNT',\n  /** Order commit contributions by when they were made. */\n  OccurredAt = 'OCCURRED_AT'\n}\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepository = {\n  __typename?: 'CommitContributionsByRepository';\n  /** The commit contributions, each representing a day. */\n  contributions: CreatedCommitContributionConnection;\n  /** The repository in which the commits were made. */\n  repository: Repository;\n  /** The HTTP path for the user's commits to the repository in this time range. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for the user's commits to the repository in this time range. */\n  url: Scalars['URI'];\n};\n\n\n/** This aggregates commits made by a user within one repository. */\nexport type CommitContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<CommitContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type CommitEdge = {\n  __typename?: 'CommitEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Commit>;\n};\n\n/** The connection type for Commit. */\nexport type CommitHistoryConnection = {\n  __typename?: 'CommitHistoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A message to include with a new commit */\nexport type CommitMessage = {\n  /** The body of the message. */\n  body?: InputMaybe<Scalars['String']>;\n  /** The headline of the message. */\n  headline: Scalars['String'];\n};\n\n/** Parameters to be used for the commit_message_pattern rule */\nexport type CommitMessagePatternParameters = {\n  __typename?: 'CommitMessagePatternParameters';\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean'];\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Parameters to be used for the commit_message_pattern rule */\nexport type CommitMessagePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/**\n * A git ref for a commit to be appended to.\n *\n * The ref must be a branch, i.e. its fully qualified name must start\n * with `refs/heads/` (although the input is not required to be fully\n * qualified).\n *\n * The Ref may be specified by its global node ID or by the\n * `repositoryNameWithOwner` and `branchName`.\n *\n * ### Examples\n *\n * Specify a branch using a global node ID:\n *\n *     { \"id\": \"MDM6UmVmMTpyZWZzL2hlYWRzL21haW4=\" }\n *\n * Specify a branch using `repositoryNameWithOwner` and `branchName`:\n *\n *     {\n *       \"repositoryNameWithOwner\": \"github/graphql-client\",\n *       \"branchName\": \"main\"\n *     }\n */\nexport type CommittableBranch = {\n  /** The unqualified name of the branch to append the commit to. */\n  branchName?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the Ref to be updated. */\n  id?: InputMaybe<Scalars['ID']>;\n  /** The nameWithOwner of the repository to commit to. */\n  repositoryNameWithOwner?: InputMaybe<Scalars['String']>;\n};\n\n/** Parameters to be used for the committer_email_pattern rule */\nexport type CommitterEmailPatternParameters = {\n  __typename?: 'CommitterEmailPatternParameters';\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean'];\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Parameters to be used for the committer_email_pattern rule */\nexport type CommitterEmailPatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Represents a comparison between two commit revisions. */\nexport type Comparison = Node & {\n  __typename?: 'Comparison';\n  /** The number of commits ahead of the base branch. */\n  aheadBy: Scalars['Int'];\n  /** The base revision of this comparison. */\n  baseTarget: GitObject;\n  /** The number of commits behind the base branch. */\n  behindBy: Scalars['Int'];\n  /** The commits which compose this comparison. */\n  commits: ComparisonCommitConnection;\n  /** The head revision of this comparison. */\n  headTarget: GitObject;\n  id: Scalars['ID'];\n  /** The status of this comparison. */\n  status: ComparisonStatus;\n};\n\n\n/** Represents a comparison between two commit revisions. */\nexport type ComparisonCommitsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for Commit. */\nexport type ComparisonCommitConnection = {\n  __typename?: 'ComparisonCommitConnection';\n  /** The total count of authors and co-authors across all commits. */\n  authorCount: Scalars['Int'];\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Commit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** The status of a git comparison between two refs. */\nexport enum ComparisonStatus {\n  /** The head ref is ahead of the base ref. */\n  Ahead = 'AHEAD',\n  /** The head ref is behind the base ref. */\n  Behind = 'BEHIND',\n  /** The head ref is both ahead and behind of the base ref, indicating git history has diverged. */\n  Diverged = 'DIVERGED',\n  /** The head ref and base ref are identical. */\n  Identical = 'IDENTICAL'\n}\n\n/** Represents a 'connected' event on a given issue or pull request. */\nexport type ConnectedEvent = Node & {\n  __typename?: 'ConnectedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean'];\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was connected. */\n  subject: ReferencedSubject;\n};\n\n/** Represents a contribution a user made on GitHub, such as opening an issue. */\nexport type Contribution = {\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A calendar of contributions made on GitHub by a user. */\nexport type ContributionCalendar = {\n  __typename?: 'ContributionCalendar';\n  /** A list of hex color codes used in this calendar. The darker the color, the more contributions it represents. */\n  colors: Array<Scalars['String']>;\n  /** Determine if the color set was chosen because it's currently Halloween. */\n  isHalloween: Scalars['Boolean'];\n  /** A list of the months of contributions in this calendar. */\n  months: Array<ContributionCalendarMonth>;\n  /** The count of total contributions in the calendar. */\n  totalContributions: Scalars['Int'];\n  /** A list of the weeks of contributions in this calendar. */\n  weeks: Array<ContributionCalendarWeek>;\n};\n\n/** Represents a single day of contributions on GitHub by a user. */\nexport type ContributionCalendarDay = {\n  __typename?: 'ContributionCalendarDay';\n  /** The hex color code that represents how many contributions were made on this day compared to others in the calendar. */\n  color: Scalars['String'];\n  /** How many contributions were made by the user on this day. */\n  contributionCount: Scalars['Int'];\n  /**\n   * Indication of contributions, relative to other days. Can be used to indicate\n   * which color to represent this day on a calendar.\n   */\n  contributionLevel: ContributionLevel;\n  /** The day this square represents. */\n  date: Scalars['Date'];\n  /** A number representing which day of the week this square represents, e.g., 1 is Monday. */\n  weekday: Scalars['Int'];\n};\n\n/** A month of contributions in a user's contribution graph. */\nexport type ContributionCalendarMonth = {\n  __typename?: 'ContributionCalendarMonth';\n  /** The date of the first day of this month. */\n  firstDay: Scalars['Date'];\n  /** The name of the month. */\n  name: Scalars['String'];\n  /** How many weeks started in this month. */\n  totalWeeks: Scalars['Int'];\n  /** The year the month occurred in. */\n  year: Scalars['Int'];\n};\n\n/** A week of contributions in a user's contribution graph. */\nexport type ContributionCalendarWeek = {\n  __typename?: 'ContributionCalendarWeek';\n  /** The days of contributions in this week. */\n  contributionDays: Array<ContributionCalendarDay>;\n  /** The date of the earliest square in this week. */\n  firstDay: Scalars['Date'];\n};\n\n/** Varying levels of contributions from none to many. */\nexport enum ContributionLevel {\n  /** Lowest 25% of days of contributions. */\n  FirstQuartile = 'FIRST_QUARTILE',\n  /** Highest 25% of days of contributions. More contributions than the third quartile. */\n  FourthQuartile = 'FOURTH_QUARTILE',\n  /** No contributions occurred. */\n  None = 'NONE',\n  /** Second lowest 25% of days of contributions. More contributions than the first quartile. */\n  SecondQuartile = 'SECOND_QUARTILE',\n  /** Second highest 25% of days of contributions. More contributions than second quartile, less than the fourth quartile. */\n  ThirdQuartile = 'THIRD_QUARTILE'\n}\n\n/** Ordering options for contribution connections. */\nexport type ContributionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n};\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollection = {\n  __typename?: 'ContributionsCollection';\n  /** Commit contributions made by the user, grouped by repository. */\n  commitContributionsByRepository: Array<CommitContributionsByRepository>;\n  /** A calendar of this user's contributions on GitHub. */\n  contributionCalendar: ContributionCalendar;\n  /** The years the user has been making contributions with the most recent year first. */\n  contributionYears: Array<Scalars['Int']>;\n  /** Determine if this collection's time span ends in the current month. */\n  doesEndInCurrentMonth: Scalars['Boolean'];\n  /**\n   * The date of the first restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  earliestRestrictedContributionDate?: Maybe<Scalars['Date']>;\n  /** The ending date and time of this collection. */\n  endedAt: Scalars['DateTime'];\n  /**\n   * The first issue the user opened on GitHub. This will be null if that issue was\n   * opened outside the collection's time range and ignoreTimeRange is false. If\n   * the issue is not visible but the user has opted to show private contributions,\n   * a RestrictedContribution will be returned.\n   */\n  firstIssueContribution?: Maybe<CreatedIssueOrRestrictedContribution>;\n  /**\n   * The first pull request the user opened on GitHub. This will be null if that\n   * pull request was opened outside the collection's time range and\n   * ignoreTimeRange is not true. If the pull request is not visible but the user\n   * has opted to show private contributions, a RestrictedContribution will be returned.\n   */\n  firstPullRequestContribution?: Maybe<CreatedPullRequestOrRestrictedContribution>;\n  /**\n   * The first repository the user created on GitHub. This will be null if that\n   * first repository was created outside the collection's time range and\n   * ignoreTimeRange is false. If the repository is not visible, then a\n   * RestrictedContribution is returned.\n   */\n  firstRepositoryContribution?: Maybe<CreatedRepositoryOrRestrictedContribution>;\n  /** Does the user have any more activity in the timeline that occurred prior to the collection's time range? */\n  hasActivityInThePast: Scalars['Boolean'];\n  /** Determine if there are any contributions in this collection. */\n  hasAnyContributions: Scalars['Boolean'];\n  /**\n   * Determine if the user made any contributions in this time frame whose details\n   * are not visible because they were made in a private repository. Can only be\n   * true if the user enabled private contribution counts.\n   */\n  hasAnyRestrictedContributions: Scalars['Boolean'];\n  /** Whether or not the collector's time span is all within the same day. */\n  isSingleDay: Scalars['Boolean'];\n  /** A list of issues the user opened. */\n  issueContributions: CreatedIssueContributionConnection;\n  /** Issue contributions made by the user, grouped by repository. */\n  issueContributionsByRepository: Array<IssueContributionsByRepository>;\n  /**\n   * When the user signed up for GitHub. This will be null if that sign up date\n   * falls outside the collection's time range and ignoreTimeRange is false.\n   */\n  joinedGitHubContribution?: Maybe<JoinedGitHubContribution>;\n  /**\n   * The date of the most recent restricted contribution the user made in this time\n   * period. Can only be non-null when the user has enabled private contribution counts.\n   */\n  latestRestrictedContributionDate?: Maybe<Scalars['Date']>;\n  /**\n   * When this collection's time range does not include any activity from the user, use this\n   * to get a different collection from an earlier time range that does have activity.\n   */\n  mostRecentCollectionWithActivity?: Maybe<ContributionsCollection>;\n  /**\n   * Returns a different contributions collection from an earlier time range than this one\n   * that does not have any contributions.\n   */\n  mostRecentCollectionWithoutActivity?: Maybe<ContributionsCollection>;\n  /**\n   * The issue the user opened on GitHub that received the most comments in the specified\n   * time frame.\n   */\n  popularIssueContribution?: Maybe<CreatedIssueContribution>;\n  /**\n   * The pull request the user opened on GitHub that received the most comments in the\n   * specified time frame.\n   */\n  popularPullRequestContribution?: Maybe<CreatedPullRequestContribution>;\n  /** Pull request contributions made by the user. */\n  pullRequestContributions: CreatedPullRequestContributionConnection;\n  /** Pull request contributions made by the user, grouped by repository. */\n  pullRequestContributionsByRepository: Array<PullRequestContributionsByRepository>;\n  /**\n   * Pull request review contributions made by the user. Returns the most recently\n   * submitted review for each PR reviewed by the user.\n   */\n  pullRequestReviewContributions: CreatedPullRequestReviewContributionConnection;\n  /** Pull request review contributions made by the user, grouped by repository. */\n  pullRequestReviewContributionsByRepository: Array<PullRequestReviewContributionsByRepository>;\n  /** A list of repositories owned by the user that the user created in this time range. */\n  repositoryContributions: CreatedRepositoryContributionConnection;\n  /**\n   * A count of contributions made by the user that the viewer cannot access. Only\n   * non-zero when the user has chosen to share their private contribution counts.\n   */\n  restrictedContributionsCount: Scalars['Int'];\n  /** The beginning date and time of this collection. */\n  startedAt: Scalars['DateTime'];\n  /** How many commits were made by the user in this time span. */\n  totalCommitContributions: Scalars['Int'];\n  /** How many issues the user opened. */\n  totalIssueContributions: Scalars['Int'];\n  /** How many pull requests the user opened. */\n  totalPullRequestContributions: Scalars['Int'];\n  /** How many pull request reviews the user left. */\n  totalPullRequestReviewContributions: Scalars['Int'];\n  /** How many different repositories the user committed to. */\n  totalRepositoriesWithContributedCommits: Scalars['Int'];\n  /** How many different repositories the user opened issues in. */\n  totalRepositoriesWithContributedIssues: Scalars['Int'];\n  /** How many different repositories the user left pull request reviews in. */\n  totalRepositoriesWithContributedPullRequestReviews: Scalars['Int'];\n  /** How many different repositories the user opened pull requests in. */\n  totalRepositoriesWithContributedPullRequests: Scalars['Int'];\n  /** How many repositories the user created. */\n  totalRepositoryContributions: Scalars['Int'];\n  /** The user who made the contributions in this collection. */\n  user: User;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionCommitContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionIssueContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n  maxRepositories?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestContributionsByRepositoryArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n  maxRepositories?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionPullRequestReviewContributionsByRepositoryArgs = {\n  maxRepositories?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalIssueContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalPullRequestContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedIssuesArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoriesWithContributedPullRequestsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n  excludePopular?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A contributions collection aggregates contributions such as opened issues and commits created by a user. */\nexport type ContributionsCollectionTotalRepositoryContributionsArgs = {\n  excludeFirst?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Autogenerated input type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssueInput = {\n  /** The body of the newly created issue. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ProjectCard ID to convert. */\n  projectCardId: Scalars['ID'];\n  /** The ID of the repository to create the issue in. */\n  repositoryId: Scalars['ID'];\n  /** The title of the newly created issue. Defaults to the card's note text. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of ConvertProjectCardNoteToIssue */\nexport type ConvertProjectCardNoteToIssuePayload = {\n  __typename?: 'ConvertProjectCardNoteToIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the pull request to convert to draft */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ConvertPullRequestToDraft */\nexport type ConvertPullRequestToDraftPayload = {\n  __typename?: 'ConvertPullRequestToDraftPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that is now a draft. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'convert_to_draft' event on a given pull request. */\nexport type ConvertToDraftEvent = Node & UniformResourceLocatable & {\n  __typename?: 'ConvertToDraftEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this convert to draft event. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this convert to draft event. */\n  url: Scalars['URI'];\n};\n\n/** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\nexport type ConvertedNoteToIssueEvent = Node & {\n  __typename?: 'ConvertedNoteToIssueEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String'];\n};\n\n/** Represents a 'converted_to_discussion' event on a given issue. */\nexport type ConvertedToDiscussionEvent = Node & {\n  __typename?: 'ConvertedToDiscussionEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The discussion that the issue was converted into. */\n  discussion?: Maybe<Discussion>;\n  id: Scalars['ID'];\n};\n\n/** Autogenerated input type of CopyProjectV2 */\nexport type CopyProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Include draft issues in the new project */\n  includeDraftIssues?: InputMaybe<Scalars['Boolean']>;\n  /** The owner ID of the new project. */\n  ownerId: Scalars['ID'];\n  /** The ID of the source Project to copy. */\n  projectId: Scalars['ID'];\n  /** The title of the project. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CopyProjectV2 */\nexport type CopyProjectV2Payload = {\n  __typename?: 'CopyProjectV2Payload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The copied project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of CreateAttributionInvitation */\nexport type CreateAttributionInvitationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the owner scoping the reattributable data. */\n  ownerId: Scalars['ID'];\n  /** The Node ID of the account owning the data to reattribute. */\n  sourceId: Scalars['ID'];\n  /** The Node ID of the account which may claim the data. */\n  targetId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateAttributionInvitation */\nexport type CreateAttributionInvitationPayload = {\n  __typename?: 'CreateAttributionInvitationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The owner scoping the reattributable data. */\n  owner?: Maybe<Organization>;\n  /** The account owning the data to reattribute. */\n  source?: Maybe<Claimable>;\n  /** The account which may claim the data. */\n  target?: Maybe<Claimable>;\n};\n\n/** Autogenerated input type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars['Boolean']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars['Boolean']>;\n  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']>;\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch?: InputMaybe<Scalars['Boolean']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern: Scalars['String'];\n  /** A list of User, Team, or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The global relay id of the repository in which a new branch protection rule should be created in. */\n  repositoryId: Scalars['ID'];\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval?: InputMaybe<Scalars['Boolean']>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;\n  /** The list of required deployment environments */\n  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;\n  /** Are successful deployments required before merging. */\n  requiresDeployments?: InputMaybe<Scalars['Boolean']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars['Boolean']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;\n  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;\n};\n\n/** Autogenerated return type of CreateBranchProtectionRule */\nexport type CreateBranchProtectionRulePayload = {\n  __typename?: 'CreateBranchProtectionRulePayload';\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of CreateCheckRun */\nexport type CreateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars['DateTime']>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars['URI']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars['String']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID'];\n  /** The name of the check. */\n  name: Scalars['String'];\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars['DateTime']>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of CreateCheckRun */\nexport type CreateCheckRunPayload = {\n  __typename?: 'CreateCheckRunPayload';\n  /** The newly created check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of CreateCheckSuite */\nexport type CreateCheckSuiteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The SHA of the head commit. */\n  headSha: Scalars['GitObjectID'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateCheckSuite */\nexport type CreateCheckSuitePayload = {\n  __typename?: 'CreateCheckSuitePayload';\n  /** The newly created check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchInput = {\n  /** The Ref to be updated.  Must be a branch. */\n  branch: CommittableBranch;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The git commit oid expected at the head of the branch prior to the commit */\n  expectedHeadOid: Scalars['GitObjectID'];\n  /** A description of changes to files in this commit. */\n  fileChanges?: InputMaybe<FileChanges>;\n  /** The commit message the be included with the commit. */\n  message: CommitMessage;\n};\n\n/** Autogenerated return type of CreateCommitOnBranch */\nexport type CreateCommitOnBranchPayload = {\n  __typename?: 'CreateCommitOnBranchPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new commit. */\n  commit?: Maybe<Commit>;\n  /** The ref which has been updated to point to the new commit. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateDeployment */\nexport type CreateDeploymentInput = {\n  /** Attempt to automatically merge the default branch into the requested ref, defaults to true. */\n  autoMerge?: InputMaybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Short description of the deployment. */\n  description?: InputMaybe<Scalars['String']>;\n  /** Name for the target deployment environment. */\n  environment?: InputMaybe<Scalars['String']>;\n  /** JSON payload with extra information about the deployment. */\n  payload?: InputMaybe<Scalars['String']>;\n  /** The node ID of the ref to be deployed. */\n  refId: Scalars['ID'];\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /**\n   * The status contexts to verify against commit status checks. To bypass required\n   * contexts, pass an empty array. Defaults to all unique contexts.\n   */\n  requiredContexts?: InputMaybe<Array<Scalars['String']>>;\n  /** Specifies a task to execute. */\n  task?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of CreateDeployment */\nexport type CreateDeploymentPayload = {\n  __typename?: 'CreateDeploymentPayload';\n  /** True if the default branch has been auto-merged into the deployment ref. */\n  autoMerged?: Maybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new deployment. */\n  deployment?: Maybe<Deployment>;\n};\n\n/** Autogenerated input type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusInput = {\n  /**\n   * Adds a new inactive status to all non-transient, non-production environment\n   * deployments with the same repository and environment name as the created\n   * status's deployment.\n   */\n  autoInactive?: InputMaybe<Scalars['Boolean']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The node ID of the deployment. */\n  deploymentId: Scalars['ID'];\n  /** A short description of the status. Maximum length of 140 characters. */\n  description?: InputMaybe<Scalars['String']>;\n  /** If provided, updates the environment of the deploy. Otherwise, does not modify the environment. */\n  environment?: InputMaybe<Scalars['String']>;\n  /** Sets the URL for accessing your environment. */\n  environmentUrl?: InputMaybe<Scalars['String']>;\n  /**\n   * The log URL to associate with this status.       This URL should contain\n   * output to keep the user updated while the task is running       or serve as\n   * historical information for what happened in the deployment.\n   */\n  logUrl?: InputMaybe<Scalars['String']>;\n  /** The state of the deployment. */\n  state: DeploymentStatusState;\n};\n\n/** Autogenerated return type of CreateDeploymentStatus */\nexport type CreateDeploymentStatusPayload = {\n  __typename?: 'CreateDeploymentStatusPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new deployment status. */\n  deploymentStatus?: Maybe<DeploymentStatus>;\n};\n\n/** Autogenerated input type of CreateDiscussion */\nexport type CreateDiscussionInput = {\n  /** The body of the discussion. */\n  body: Scalars['String'];\n  /** The id of the discussion category to associate with this discussion. */\n  categoryId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the repository on which to create the discussion. */\n  repositoryId: Scalars['ID'];\n  /** The title of the discussion. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CreateDiscussion */\nexport type CreateDiscussionPayload = {\n  __typename?: 'CreateDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that was just created. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationInput = {\n  /** The logins for the administrators of the new organization. */\n  adminLogins: Array<Scalars['String']>;\n  /** The email used for sending billing receipts. */\n  billingEmail: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise owning the new organization. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the new organization. */\n  login: Scalars['String'];\n  /** The profile name of the new organization. */\n  profileName: Scalars['String'];\n};\n\n/** Autogenerated return type of CreateEnterpriseOrganization */\nexport type CreateEnterpriseOrganizationPayload = {\n  __typename?: 'CreateEnterpriseOrganizationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise that owns the created organization. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was created. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of CreateEnvironment */\nexport type CreateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the environment. */\n  name: Scalars['String'];\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateEnvironment */\nexport type CreateEnvironmentPayload = {\n  __typename?: 'CreateEnvironmentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new or existing environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean'];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The ID of the owner for which to create the new IP allow list entry. */\n  ownerId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateIpAllowListEntry */\nexport type CreateIpAllowListEntryPayload = {\n  __typename?: 'CreateIpAllowListEntryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The IP allow list entry that was created. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of CreateIssue */\nexport type CreateIssueInput = {\n  /** The Node ID for the user assignee for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of an issue template in the repository, assigns labels and assignees from the template to the issue */\n  issueTemplate?: InputMaybe<Scalars['String']>;\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The title for the issue. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CreateIssue */\nexport type CreateIssuePayload = {\n  __typename?: 'CreateIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of CreateLabel */\nexport type CreateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A 6 character hex code, without the leading #, identifying the color of the label. */\n  color: Scalars['String'];\n  /** A brief description of the label, such as its purpose. */\n  description?: InputMaybe<Scalars['String']>;\n  /** The name of the label. */\n  name: Scalars['String'];\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateLabel */\nexport type CreateLabelPayload = {\n  __typename?: 'CreateLabelPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new label. */\n  label?: Maybe<Label>;\n};\n\n/** Autogenerated input type of CreateLinkedBranch */\nexport type CreateLinkedBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the issue to link to. */\n  issueId: Scalars['ID'];\n  /** The name of the new branch. Defaults to issue number and title. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The commit SHA to base the new branch on. */\n  oid: Scalars['GitObjectID'];\n  /** ID of the repository to create the branch in. Defaults to the issue repository. */\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of CreateLinkedBranch */\nexport type CreateLinkedBranchPayload = {\n  __typename?: 'CreateLinkedBranchPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new branch issue reference. */\n  linkedBranch?: Maybe<LinkedBranch>;\n};\n\n/** Autogenerated input type of CreateMigrationSource */\nexport type CreateMigrationSourceInput = {\n  /** The migration source access token. */\n  accessToken?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars['String']>;\n  /** The migration source name. */\n  name: Scalars['String'];\n  /** The ID of the organization that will own the migration source. */\n  ownerId: Scalars['ID'];\n  /** The migration source type. */\n  type: MigrationSourceType;\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  url?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of CreateMigrationSource */\nexport type CreateMigrationSourcePayload = {\n  __typename?: 'CreateMigrationSourcePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The created migration source. */\n  migrationSource?: Maybe<MigrationSource>;\n};\n\n/** Autogenerated input type of CreateProject */\nexport type CreateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of project. */\n  name: Scalars['String'];\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID'];\n  /** A list of repository IDs to create as linked repositories for the project */\n  repositoryIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The name of the GitHub-provided template. */\n  template?: InputMaybe<ProjectTemplate>;\n};\n\n/** Autogenerated return type of CreateProject */\nexport type CreateProjectPayload = {\n  __typename?: 'CreateProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of CreateProjectV2Field */\nexport type CreateProjectV2FieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The data type of the field. */\n  dataType: ProjectV2CustomFieldType;\n  /** The name of the field. */\n  name: Scalars['String'];\n  /** The ID of the Project to create the field in. */\n  projectId: Scalars['ID'];\n  /** Options for a single select field. At least one value is required if data_type is SINGLE_SELECT */\n  singleSelectOptions?: InputMaybe<Array<ProjectV2SingleSelectFieldOptionInput>>;\n};\n\n/** Autogenerated return type of CreateProjectV2Field */\nexport type CreateProjectV2FieldPayload = {\n  __typename?: 'CreateProjectV2FieldPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new field. */\n  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** Autogenerated input type of CreateProjectV2 */\nexport type CreateProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The owner ID to create the project under. */\n  ownerId: Scalars['ID'];\n  /** The repository to link the project to. */\n  repositoryId?: InputMaybe<Scalars['ID']>;\n  /** The team to link the project to. The team will be granted read permissions. */\n  teamId?: InputMaybe<Scalars['ID']>;\n  /** The title of the project. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CreateProjectV2 */\nexport type CreateProjectV2Payload = {\n  __typename?: 'CreateProjectV2Payload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of CreatePullRequest */\nexport type CreatePullRequestInput = {\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository. You cannot update the base branch on a pull request to point\n   * to another repository.\n   */\n  baseRefName: Scalars['String'];\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Indicates whether this pull request should be a draft. */\n  draft?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * The name of the branch where your changes are implemented. For cross-repository pull requests\n   * in the same network, namespace `head_ref_name` with a user like this: `username:branch`.\n   */\n  headRefName: Scalars['String'];\n  /** The Node ID of the head repository. */\n  headRepositoryId?: InputMaybe<Scalars['ID']>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The title of the pull request. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CreatePullRequest */\nexport type CreatePullRequestPayload = {\n  __typename?: 'CreatePullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of CreateRef */\nexport type CreateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The fully qualified name of the new Ref (ie: `refs/heads/my_new_branch`). */\n  name: Scalars['String'];\n  /** The GitObjectID that the new Ref shall target. Must point to a commit. */\n  oid: Scalars['GitObjectID'];\n  /** The Node ID of the Repository to create the Ref in. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateRef */\nexport type CreateRefPayload = {\n  __typename?: 'CreateRefPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of CreateRepository */\nexport type CreateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A short description of the new repository. */\n  description?: InputMaybe<Scalars['String']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** The URL for a web page about this repository. */\n  homepageUrl?: InputMaybe<Scalars['URI']>;\n  /** The name of the new repository. */\n  name: Scalars['String'];\n  /** The ID of the owner for the new repository. */\n  ownerId?: InputMaybe<Scalars['ID']>;\n  /**\n   * When an organization is specified as the owner, this ID identifies the team\n   * that should be granted access to the new repository.\n   */\n  teamId?: InputMaybe<Scalars['ID']>;\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars['Boolean']>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n/** Autogenerated return type of CreateRepository */\nexport type CreateRepositoryPayload = {\n  __typename?: 'CreateRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of CreateRepositoryRuleset */\nexport type CreateRepositoryRulesetInput = {\n  /** A list of Team or App IDs allowed to bypass rules in this ruleset. */\n  bypassActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The bypass mode for this ruleset */\n  bypassMode?: InputMaybe<RuleBypassMode>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The set of conditions for this ruleset */\n  conditions: RepositoryRuleConditionsInput;\n  /** The enforcement level for this ruleset */\n  enforcement: RuleEnforcement;\n  /** The name of the ruleset. */\n  name: Scalars['String'];\n  /** The list of rules for this ruleset */\n  rules?: InputMaybe<Array<RepositoryRuleInput>>;\n  /** The global relay id of the source in which a new ruleset should be created in. */\n  sourceId: Scalars['ID'];\n  /** The target of the ruleset. */\n  target?: InputMaybe<RepositoryRulesetTarget>;\n};\n\n/** Autogenerated return type of CreateRepositoryRuleset */\nexport type CreateRepositoryRulesetPayload = {\n  __typename?: 'CreateRepositoryRulesetPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created Ruleset. */\n  ruleset?: Maybe<RepositoryRuleset>;\n};\n\n/** Autogenerated input type of CreateSponsorsListing */\nexport type CreateSponsorsListingInput = {\n  /**\n   * The country or region where the sponsorable's bank account is located.\n   * Required if fiscalHostLogin is not specified, ignored when fiscalHostLogin is specified.\n   */\n  billingCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * The email address we should use to contact you about the GitHub Sponsors\n   * profile being created. This will not be shared publicly. Must be a verified\n   * email address already on your GitHub account. Only relevant when the\n   * sponsorable is yourself. Defaults to your primary email address on file if omitted.\n   */\n  contactEmail?: InputMaybe<Scalars['String']>;\n  /**\n   * The username of the supported fiscal host's GitHub organization, if you want\n   * to receive sponsorship payouts through a fiscal host rather than directly to a\n   * bank account. For example, 'Open-Source-Collective' for Open Source Collective\n   * or 'numfocus' for numFOCUS. Case insensitive. See https://docs.github.com/sponsors/receiving-sponsorships-through-github-sponsors/using-a-fiscal-host-to-receive-github-sponsors-payouts\n   * for more information.\n   */\n  fiscalHostLogin?: InputMaybe<Scalars['String']>;\n  /**\n   * The URL for your profile page on the fiscal host's website, e.g.,\n   * https://opencollective.com/babel or https://numfocus.org/project/bokeh.\n   * Required if fiscalHostLogin is specified.\n   */\n  fiscallyHostedProjectProfileUrl?: InputMaybe<Scalars['String']>;\n  /**\n   * Provide an introduction to serve as the main focus that appears on your GitHub\n   * Sponsors profile. It's a great opportunity to help potential sponsors learn\n   * more about you, your work, and why their sponsorship is important to you.\n   * GitHub-flavored Markdown is supported.\n   */\n  fullDescription?: InputMaybe<Scalars['String']>;\n  /**\n   * The country or region where the sponsorable resides. This is for tax purposes.\n   * Required if the sponsorable is yourself, ignored when sponsorableLogin\n   * specifies an organization.\n   */\n  residenceCountryOrRegionCode?: InputMaybe<SponsorsCountryOrRegionCode>;\n  /**\n   * The username of the organization to create a GitHub Sponsors profile for, if\n   * desired. Defaults to creating a GitHub Sponsors profile for the authenticated\n   * user if omitted.\n   */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of CreateSponsorsListing */\nexport type CreateSponsorsListingPayload = {\n  __typename?: 'CreateSponsorsListingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new GitHub Sponsors profile. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n};\n\n/** Autogenerated input type of CreateSponsorsTier */\nexport type CreateSponsorsTierInput = {\n  /** The value of the new tier in US dollars. Valid values: 1-12000. */\n  amount: Scalars['Int'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A description of what this tier is, what perks sponsors might receive, what a sponsorship at this tier means for you, etc. */\n  description: Scalars['String'];\n  /** Whether sponsorships using this tier should happen monthly/yearly or just once. */\n  isRecurring?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Whether to make the tier available immediately for sponsors to choose.\n   * Defaults to creating a draft tier that will not be publicly visible.\n   */\n  publish?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Optional ID of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization.\n   */\n  repositoryId?: InputMaybe<Scalars['ID']>;\n  /**\n   * Optional name of the private repository that sponsors at this tier should gain\n   * read-only access to. Must be owned by an organization. Necessary if\n   * repositoryOwnerLogin is given. Will be ignored if repositoryId is given.\n   */\n  repositoryName?: InputMaybe<Scalars['String']>;\n  /**\n   * Optional login of the organization owner of the private repository that\n   * sponsors at this tier should gain read-only access to. Necessary if\n   * repositoryName is given. Will be ignored if repositoryId is given.\n   */\n  repositoryOwnerLogin?: InputMaybe<Scalars['String']>;\n  /**\n   * The ID of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableLogin is not given.\n   */\n  sponsorableId?: InputMaybe<Scalars['ID']>;\n  /**\n   * The username of the user or organization who owns the GitHub Sponsors profile.\n   * Defaults to the current user if omitted and sponsorableId is not given.\n   */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n  /** Optional message new sponsors at this tier will receive. */\n  welcomeMessage?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of CreateSponsorsTier */\nexport type CreateSponsorsTierPayload = {\n  __typename?: 'CreateSponsorsTierPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of CreateSponsorship */\nexport type CreateSponsorshipInput = {\n  /** The amount to pay to the sponsorable in US dollars. Required if a tierId is not specified. Valid values: 1-12000. */\n  amount?: InputMaybe<Scalars['Int']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether the sponsorship should happen monthly/yearly or just this one time. Required if a tierId is not specified. */\n  isRecurring?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n  /** The ID of one of sponsorable's existing tiers to sponsor at. Required if amount is not specified. */\n  tierId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of CreateSponsorship */\nexport type CreateSponsorshipPayload = {\n  __typename?: 'CreateSponsorshipPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The sponsorship that was started. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of CreateSponsorships */\nexport type CreateSponsorshipsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorables. Public visibility still does not reveal the dollar value of\n   * the sponsorship.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorables. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']>;\n  /** The username of the user or organization who is acting as the sponsor, paying for the sponsorships. */\n  sponsorLogin: Scalars['String'];\n  /** The list of maintainers to sponsor and for how much apiece. */\n  sponsorships: Array<BulkSponsorship>;\n};\n\n/** Autogenerated return type of CreateSponsorships */\nexport type CreateSponsorshipsPayload = {\n  __typename?: 'CreateSponsorshipsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The users and organizations who received a sponsorship. */\n  sponsorables?: Maybe<Array<Sponsorable>>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentInput = {\n  /** The content of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the discussion to which the comment belongs. */\n  discussionId: Scalars['ID'];\n};\n\n/** Autogenerated return type of CreateTeamDiscussionComment */\nexport type CreateTeamDiscussionCommentPayload = {\n  __typename?: 'CreateTeamDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionInput = {\n  /** The content of the discussion. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * If true, restricts the visibility of this discussion to team members and\n   * organization admins. If false or not specified, allows any organization member\n   * to view this discussion.\n   */\n  private?: InputMaybe<Scalars['Boolean']>;\n  /** The ID of the team to which the discussion belongs. */\n  teamId: Scalars['ID'];\n  /** The title of the discussion. */\n  title: Scalars['String'];\n};\n\n/** Autogenerated return type of CreateTeamDiscussion */\nexport type CreateTeamDiscussionPayload = {\n  __typename?: 'CreateTeamDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Represents the contribution a user made by committing to a repository. */\nexport type CreatedCommitContribution = Contribution & {\n  __typename?: 'CreatedCommitContribution';\n  /** How many commits were made on this day to this repository by the user. */\n  commitCount: Scalars['Int'];\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The repository the user made a commit in. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedCommitContribution. */\nexport type CreatedCommitContributionConnection = {\n  __typename?: 'CreatedCommitContributionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedCommitContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedCommitContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of commits across days and repositories in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CreatedCommitContributionEdge = {\n  __typename?: 'CreatedCommitContributionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedCommitContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by opening an issue. */\nexport type CreatedIssueContribution = Contribution & {\n  __typename?: 'CreatedIssueContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** The issue that was opened. */\n  issue: Issue;\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedIssueContribution. */\nexport type CreatedIssueContributionConnection = {\n  __typename?: 'CreatedIssueContributionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedIssueContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedIssueContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CreatedIssueContributionEdge = {\n  __typename?: 'CreatedIssueContributionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedIssueContribution>;\n};\n\n/** Represents either a issue the viewer can access or a restricted contribution. */\nexport type CreatedIssueOrRestrictedContribution = CreatedIssueContribution | RestrictedContribution;\n\n/** Represents the contribution a user made on GitHub by opening a pull request. */\nexport type CreatedPullRequestContribution = Contribution & {\n  __typename?: 'CreatedPullRequestContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The pull request that was opened. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestContribution. */\nexport type CreatedPullRequestContributionConnection = {\n  __typename?: 'CreatedPullRequestContributionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestContributionEdge = {\n  __typename?: 'CreatedPullRequestContributionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestContribution>;\n};\n\n/** Represents either a pull request the viewer can access or a restricted contribution. */\nexport type CreatedPullRequestOrRestrictedContribution = CreatedPullRequestContribution | RestrictedContribution;\n\n/** Represents the contribution a user made by leaving a review on a pull request. */\nexport type CreatedPullRequestReviewContribution = Contribution & {\n  __typename?: 'CreatedPullRequestReviewContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The pull request the user reviewed. */\n  pullRequest: PullRequest;\n  /** The review the user left on the pull request. */\n  pullRequestReview: PullRequestReview;\n  /** The repository containing the pull request that the user reviewed. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedPullRequestReviewContribution. */\nexport type CreatedPullRequestReviewContributionConnection = {\n  __typename?: 'CreatedPullRequestReviewContributionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedPullRequestReviewContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedPullRequestReviewContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CreatedPullRequestReviewContributionEdge = {\n  __typename?: 'CreatedPullRequestReviewContributionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedPullRequestReviewContribution>;\n};\n\n/** Represents the contribution a user made on GitHub by creating a repository. */\nexport type CreatedRepositoryContribution = Contribution & {\n  __typename?: 'CreatedRepositoryContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The repository that was created. */\n  repository: Repository;\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** The connection type for CreatedRepositoryContribution. */\nexport type CreatedRepositoryContributionConnection = {\n  __typename?: 'CreatedRepositoryContributionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<CreatedRepositoryContributionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<CreatedRepositoryContribution>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type CreatedRepositoryContributionEdge = {\n  __typename?: 'CreatedRepositoryContributionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<CreatedRepositoryContribution>;\n};\n\n/** Represents either a repository the viewer can access or a restricted contribution. */\nexport type CreatedRepositoryOrRestrictedContribution = CreatedRepositoryContribution | RestrictedContribution;\n\n/** Represents a mention made by one issue or pull request to another. */\nexport type CrossReferencedEvent = Node & UniformResourceLocatable & {\n  __typename?: 'CrossReferencedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean'];\n  /** Identifies when the reference was made. */\n  referencedAt: Scalars['DateTime'];\n  /** The HTTP path for this pull request. */\n  resourcePath: Scalars['URI'];\n  /** Issue or pull request that made the reference. */\n  source: ReferencedSubject;\n  /** Issue or pull request to which the reference was made. */\n  target: ReferencedSubject;\n  /** The HTTP URL for this pull request. */\n  url: Scalars['URI'];\n  /** Checks if the target will be closed when the source is merged. */\n  willCloseTarget: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the suggested topic. */\n  name: Scalars['String'];\n  /** The reason why the suggested topic is declined. */\n  reason: TopicSuggestionDeclineReason;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeclineTopicSuggestion */\nexport type DeclineTopicSuggestionPayload = {\n  __typename?: 'DeclineTopicSuggestionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The declined topic. */\n  topic?: Maybe<Topic>;\n};\n\n/** The possible base permissions for repositories. */\nexport enum DefaultRepositoryPermissionField {\n  /** Can read, write, and administrate repos by default */\n  Admin = 'ADMIN',\n  /** No access */\n  None = 'NONE',\n  /** Can read repos by default */\n  Read = 'READ',\n  /** Can read and write repos by default */\n  Write = 'WRITE'\n}\n\n/** Entities that can be deleted. */\nexport type Deletable = {\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRuleInput = {\n  /** The global relay id of the branch protection rule to be deleted. */\n  branchProtectionRuleId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of DeleteBranchProtectionRule */\nexport type DeleteBranchProtectionRulePayload = {\n  __typename?: 'DeleteBranchProtectionRulePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteDeployment */\nexport type DeleteDeploymentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the deployment to be deleted. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteDeployment */\nexport type DeleteDeploymentPayload = {\n  __typename?: 'DeleteDeploymentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node id of the discussion comment to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteDiscussionComment */\nexport type DeleteDiscussionCommentPayload = {\n  __typename?: 'DeleteDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion comment that was just deleted. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of DeleteDiscussion */\nexport type DeleteDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the discussion to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteDiscussion */\nexport type DeleteDiscussionPayload = {\n  __typename?: 'DeleteDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that was just deleted. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of DeleteEnvironment */\nexport type DeleteEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the environment to be deleted. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteEnvironment */\nexport type DeleteEnvironmentPayload = {\n  __typename?: 'DeleteEnvironmentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the IP allow list entry to delete. */\n  ipAllowListEntryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteIpAllowListEntry */\nexport type DeleteIpAllowListEntryPayload = {\n  __typename?: 'DeleteIpAllowListEntryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The IP allow list entry that was deleted. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of DeleteIssueComment */\nexport type DeleteIssueCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteIssueComment */\nexport type DeleteIssueCommentPayload = {\n  __typename?: 'DeleteIssueCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteIssue */\nexport type DeleteIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the issue to delete. */\n  issueId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteIssue */\nexport type DeleteIssuePayload = {\n  __typename?: 'DeleteIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository the issue belonged to */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of DeleteLabel */\nexport type DeleteLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the label to be deleted. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteLabel */\nexport type DeleteLabelPayload = {\n  __typename?: 'DeleteLabelPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteLinkedBranch */\nexport type DeleteLinkedBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the linked branch */\n  linkedBranchId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteLinkedBranch */\nexport type DeleteLinkedBranchPayload = {\n  __typename?: 'DeleteLinkedBranchPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue the linked branch was unlinked from. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of DeletePackageVersion */\nexport type DeletePackageVersionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the package version to be deleted. */\n  packageVersionId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeletePackageVersion */\nexport type DeletePackageVersionPayload = {\n  __typename?: 'DeletePackageVersionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Whether or not the operation succeeded. */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n/** Autogenerated input type of DeleteProjectCard */\nexport type DeleteProjectCardInput = {\n  /** The id of the card to delete. */\n  cardId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of DeleteProjectCard */\nexport type DeleteProjectCardPayload = {\n  __typename?: 'DeleteProjectCardPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The column the deleted card was in. */\n  column?: Maybe<ProjectColumn>;\n  /** The deleted card ID. */\n  deletedCardId?: Maybe<Scalars['ID']>;\n};\n\n/** Autogenerated input type of DeleteProjectColumn */\nexport type DeleteProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the column to delete. */\n  columnId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteProjectColumn */\nexport type DeleteProjectColumnPayload = {\n  __typename?: 'DeleteProjectColumnPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The deleted column ID. */\n  deletedColumnId?: Maybe<Scalars['ID']>;\n  /** The project the deleted column was in. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of DeleteProject */\nexport type DeleteProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteProject */\nexport type DeleteProjectPayload = {\n  __typename?: 'DeleteProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository or organization the project was removed from. */\n  owner?: Maybe<ProjectOwner>;\n};\n\n/** Autogenerated input type of DeleteProjectV2Field */\nexport type DeleteProjectV2FieldInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the field to delete. */\n  fieldId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Field */\nexport type DeleteProjectV2FieldPayload = {\n  __typename?: 'DeleteProjectV2FieldPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The deleted field. */\n  projectV2Field?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** Autogenerated input type of DeleteProjectV2 */\nexport type DeleteProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project to delete. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated input type of DeleteProjectV2Item */\nexport type DeleteProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the item to be removed. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project from which the item should be removed. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Item */\nexport type DeleteProjectV2ItemPayload = {\n  __typename?: 'DeleteProjectV2ItemPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the deleted item. */\n  deletedItemId?: Maybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of DeleteProjectV2 */\nexport type DeleteProjectV2Payload = {\n  __typename?: 'DeleteProjectV2Payload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The deleted Project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of DeleteProjectV2Workflow */\nexport type DeleteProjectV2WorkflowInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the workflow to be removed. */\n  workflowId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteProjectV2Workflow */\nexport type DeleteProjectV2WorkflowPayload = {\n  __typename?: 'DeleteProjectV2WorkflowPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The ID of the deleted workflow. */\n  deletedWorkflowId?: Maybe<Scalars['ID']>;\n  /** The project the deleted workflow was in. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeletePullRequestReviewComment */\nexport type DeletePullRequestReviewCommentPayload = {\n  __typename?: 'DeletePullRequestReviewCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request review the deleted comment belonged to. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** The deleted pull request review comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;\n};\n\n/** Autogenerated input type of DeletePullRequestReview */\nexport type DeletePullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the pull request review to delete. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeletePullRequestReview */\nexport type DeletePullRequestReviewPayload = {\n  __typename?: 'DeletePullRequestReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The deleted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of DeleteRef */\nexport type DeleteRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the Ref to be deleted. */\n  refId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteRef */\nexport type DeleteRefPayload = {\n  __typename?: 'DeleteRefPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteRepositoryRuleset */\nexport type DeleteRepositoryRulesetInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The global relay id of the repository ruleset to be deleted. */\n  repositoryRulesetId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteRepositoryRuleset */\nexport type DeleteRepositoryRulesetPayload = {\n  __typename?: 'DeleteRepositoryRulesetPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the comment to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussionComment */\nexport type DeleteTeamDiscussionCommentPayload = {\n  __typename?: 'DeleteTeamDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The discussion ID to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteTeamDiscussion */\nexport type DeleteTeamDiscussionPayload = {\n  __typename?: 'DeleteTeamDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the verifiable domain to delete. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DeleteVerifiableDomain */\nexport type DeleteVerifiableDomainPayload = {\n  __typename?: 'DeleteVerifiableDomainPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The owning account from which the domain was deleted. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Represents a 'demilestoned' event on a given issue or pull request. */\nexport type DemilestonedEvent = Node & {\n  __typename?: 'DemilestonedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the milestone title associated with the 'demilestoned' event. */\n  milestoneTitle: Scalars['String'];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** A Dependabot Update for a dependency in a repository */\nexport type DependabotUpdate = RepositoryNode & {\n  __typename?: 'DependabotUpdate';\n  /** The error from a dependency update */\n  error?: Maybe<DependabotUpdateError>;\n  /** The associated pull request */\n  pullRequest?: Maybe<PullRequest>;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** An error produced from a Dependabot Update */\nexport type DependabotUpdateError = {\n  __typename?: 'DependabotUpdateError';\n  /** The body of the error */\n  body: Scalars['String'];\n  /** The error code */\n  errorType: Scalars['String'];\n  /** The title of the error */\n  title: Scalars['String'];\n};\n\n/** A dependency manifest entry */\nexport type DependencyGraphDependency = {\n  __typename?: 'DependencyGraphDependency';\n  /** Does the dependency itself have dependencies? */\n  hasDependencies: Scalars['Boolean'];\n  /**\n   * The original name of the package, as it appears in the manifest.\n   * @deprecated `packageLabel` will be removed. Use normalized `packageName` field instead. Removal on 2022-10-01 UTC.\n   */\n  packageLabel: Scalars['String'];\n  /** The dependency package manager */\n  packageManager?: Maybe<Scalars['String']>;\n  /** The name of the package in the canonical form used by the package manager. */\n  packageName: Scalars['String'];\n  /** The repository containing the package */\n  repository?: Maybe<Repository>;\n  /** The dependency version requirements */\n  requirements: Scalars['String'];\n};\n\n/** The connection type for DependencyGraphDependency. */\nexport type DependencyGraphDependencyConnection = {\n  __typename?: 'DependencyGraphDependencyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphDependencyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphDependency>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DependencyGraphDependencyEdge = {\n  __typename?: 'DependencyGraphDependencyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphDependency>;\n};\n\n/** The possible ecosystems of a dependency graph package. */\nexport enum DependencyGraphEcosystem {\n  /** GitHub Actions */\n  Actions = 'ACTIONS',\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Dart packages hosted at pub.dev */\n  Pub = 'PUB',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS',\n  /** Rust crates */\n  Rust = 'RUST'\n}\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifest = Node & {\n  __typename?: 'DependencyGraphManifest';\n  /** Path to view the manifest file blob */\n  blobPath: Scalars['String'];\n  /** A list of manifest dependencies */\n  dependencies?: Maybe<DependencyGraphDependencyConnection>;\n  /** The number of dependencies listed in the manifest */\n  dependenciesCount?: Maybe<Scalars['Int']>;\n  /** Is the manifest too big to parse? */\n  exceedsMaxSize: Scalars['Boolean'];\n  /** Fully qualified manifest filename */\n  filename: Scalars['String'];\n  id: Scalars['ID'];\n  /** Were we able to parse the manifest? */\n  parseable: Scalars['Boolean'];\n  /** The repository containing the manifest */\n  repository: Repository;\n};\n\n\n/** Dependency manifest for a repository */\nexport type DependencyGraphManifestDependenciesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for DependencyGraphManifest. */\nexport type DependencyGraphManifestConnection = {\n  __typename?: 'DependencyGraphManifestConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DependencyGraphManifestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DependencyGraphManifest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DependencyGraphManifestEdge = {\n  __typename?: 'DependencyGraphManifestEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DependencyGraphManifest>;\n};\n\n/** A repository deploy key. */\nexport type DeployKey = Node & {\n  __typename?: 'DeployKey';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The deploy key. */\n  key: Scalars['String'];\n  /** Whether or not the deploy key is read only. */\n  readOnly: Scalars['Boolean'];\n  /** The deploy key title. */\n  title: Scalars['String'];\n  /** Whether or not the deploy key has been verified. */\n  verified: Scalars['Boolean'];\n};\n\n/** The connection type for DeployKey. */\nexport type DeployKeyConnection = {\n  __typename?: 'DeployKeyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeployKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeployKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeployKeyEdge = {\n  __typename?: 'DeployKeyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeployKey>;\n};\n\n/** Represents a 'deployed' event on a given pull request. */\nexport type DeployedEvent = Node & {\n  __typename?: 'DeployedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The deployment associated with the 'deployed' event. */\n  deployment: Deployment;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The ref associated with the 'deployed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents triggered deployment instance. */\nexport type Deployment = Node & {\n  __typename?: 'Deployment';\n  /** Identifies the commit sha of the deployment. */\n  commit?: Maybe<Commit>;\n  /** Identifies the oid of the deployment commit, even if the commit has been deleted. */\n  commitOid: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The deployment description. */\n  description?: Maybe<Scalars['String']>;\n  /** The latest environment to which this deployment was made. */\n  environment?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The latest environment to which this deployment was made. */\n  latestEnvironment?: Maybe<Scalars['String']>;\n  /** The latest status of this deployment. */\n  latestStatus?: Maybe<DeploymentStatus>;\n  /** The original environment to which this deployment was made. */\n  originalEnvironment?: Maybe<Scalars['String']>;\n  /** Extra information that a deployment system might need. */\n  payload?: Maybe<Scalars['String']>;\n  /** Identifies the Ref of the deployment, if the deployment was created by ref. */\n  ref?: Maybe<Ref>;\n  /** Identifies the repository associated with the deployment. */\n  repository: Repository;\n  /** The current state of the deployment. */\n  state?: Maybe<DeploymentState>;\n  /** A list of statuses associated with the deployment. */\n  statuses?: Maybe<DeploymentStatusConnection>;\n  /** The deployment task. */\n  task?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n\n/** Represents triggered deployment instance. */\nexport type DeploymentStatusesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for Deployment. */\nexport type DeploymentConnection = {\n  __typename?: 'DeploymentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Deployment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentEdge = {\n  __typename?: 'DeploymentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Deployment>;\n};\n\n/** Represents a 'deployment_environment_changed' event on a given pull request. */\nexport type DeploymentEnvironmentChangedEvent = Node & {\n  __typename?: 'DeploymentEnvironmentChangedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The deployment status that updated the deployment environment. */\n  deploymentStatus: DeploymentStatus;\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Ordering options for deployment connections */\nexport type DeploymentOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order deployments by. */\n  field: DeploymentOrderField;\n};\n\n/** Properties by which deployment connections can be ordered. */\nexport enum DeploymentOrderField {\n  /** Order collection by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** A protection rule. */\nexport type DeploymentProtectionRule = {\n  __typename?: 'DeploymentProtectionRule';\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The timeout in minutes for this protection rule. */\n  timeout: Scalars['Int'];\n  /** The type of protection rule. */\n  type: DeploymentProtectionRuleType;\n};\n\n\n/** A protection rule. */\nexport type DeploymentProtectionRuleReviewersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for DeploymentProtectionRule. */\nexport type DeploymentProtectionRuleConnection = {\n  __typename?: 'DeploymentProtectionRuleConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentProtectionRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentProtectionRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentProtectionRuleEdge = {\n  __typename?: 'DeploymentProtectionRuleEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentProtectionRule>;\n};\n\n/** The possible protection rule types. */\nexport enum DeploymentProtectionRuleType {\n  /** Required reviewers */\n  RequiredReviewers = 'REQUIRED_REVIEWERS',\n  /** Wait timer */\n  WaitTimer = 'WAIT_TIMER'\n}\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequest = {\n  __typename?: 'DeploymentRequest';\n  /** Whether or not the current user can approve the deployment */\n  currentUserCanApprove: Scalars['Boolean'];\n  /** The target environment of the deployment */\n  environment: Environment;\n  /** The teams or users that can review the deployment */\n  reviewers: DeploymentReviewerConnection;\n  /** The wait timer in minutes configured in the environment */\n  waitTimer: Scalars['Int'];\n  /** The wait timer in minutes configured in the environment */\n  waitTimerStartedAt?: Maybe<Scalars['DateTime']>;\n};\n\n\n/** A request to deploy a workflow run to an environment. */\nexport type DeploymentRequestReviewersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for DeploymentRequest. */\nexport type DeploymentRequestConnection = {\n  __typename?: 'DeploymentRequestConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentRequestEdge = {\n  __typename?: 'DeploymentRequestEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentRequest>;\n};\n\n/** A deployment review. */\nexport type DeploymentReview = Node & {\n  __typename?: 'DeploymentReview';\n  /** The comment the user left. */\n  comment: Scalars['String'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The environments approved or rejected */\n  environments: EnvironmentConnection;\n  id: Scalars['ID'];\n  /** The decision of the user. */\n  state: DeploymentReviewState;\n  /** The user that reviewed the deployment. */\n  user: User;\n};\n\n\n/** A deployment review. */\nexport type DeploymentReviewEnvironmentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for DeploymentReview. */\nexport type DeploymentReviewConnection = {\n  __typename?: 'DeploymentReviewConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewEdge = {\n  __typename?: 'DeploymentReviewEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReview>;\n};\n\n/** The possible states for a deployment review. */\nexport enum DeploymentReviewState {\n  /** The deployment was approved. */\n  Approved = 'APPROVED',\n  /** The deployment was rejected. */\n  Rejected = 'REJECTED'\n}\n\n/** Users and teams. */\nexport type DeploymentReviewer = Team | User;\n\n/** The connection type for DeploymentReviewer. */\nexport type DeploymentReviewerConnection = {\n  __typename?: 'DeploymentReviewerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentReviewerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentReviewer>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentReviewerEdge = {\n  __typename?: 'DeploymentReviewerEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentReviewer>;\n};\n\n/** The possible states in which a deployment can be. */\nexport enum DeploymentState {\n  /** The pending deployment was not updated after 30 minutes. */\n  Abandoned = 'ABANDONED',\n  /** The deployment is currently active. */\n  Active = 'ACTIVE',\n  /** An inactive transient deployment. */\n  Destroyed = 'DESTROYED',\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment has queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n/** Describes the status of a given deployment attempt. */\nexport type DeploymentStatus = Node & {\n  __typename?: 'DeploymentStatus';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the actor who triggered the deployment. */\n  creator: Actor;\n  /** Identifies the deployment associated with status. */\n  deployment: Deployment;\n  /** Identifies the description of the deployment. */\n  description?: Maybe<Scalars['String']>;\n  /** Identifies the environment of the deployment at the time of this deployment status */\n  environment?: Maybe<Scalars['String']>;\n  /** Identifies the environment URL of the deployment. */\n  environmentUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** Identifies the log URL of the deployment. */\n  logUrl?: Maybe<Scalars['URI']>;\n  /** Identifies the current state of the deployment. */\n  state: DeploymentStatusState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for DeploymentStatus. */\nexport type DeploymentStatusConnection = {\n  __typename?: 'DeploymentStatusConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DeploymentStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DeploymentStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DeploymentStatusEdge = {\n  __typename?: 'DeploymentStatusEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DeploymentStatus>;\n};\n\n/** The possible states for a deployment status. */\nexport enum DeploymentStatusState {\n  /** The deployment experienced an error. */\n  Error = 'ERROR',\n  /** The deployment has failed. */\n  Failure = 'FAILURE',\n  /** The deployment is inactive. */\n  Inactive = 'INACTIVE',\n  /** The deployment is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The deployment is pending. */\n  Pending = 'PENDING',\n  /** The deployment is queued */\n  Queued = 'QUEUED',\n  /** The deployment was successful. */\n  Success = 'SUCCESS',\n  /** The deployment is waiting. */\n  Waiting = 'WAITING'\n}\n\n/** Autogenerated input type of DequeuePullRequest */\nexport type DequeuePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the pull request to be dequeued. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of DequeuePullRequest */\nexport type DequeuePullRequestPayload = {\n  __typename?: 'DequeuePullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The merge queue entry of the dequeued pull request. */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n};\n\n/** The possible sides of a diff. */\nexport enum DiffSide {\n  /** The left side of the diff. */\n  Left = 'LEFT',\n  /** The right side of the diff. */\n  Right = 'RIGHT'\n}\n\n/** Autogenerated input type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergeInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the pull request to disable auto merge on. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DisablePullRequestAutoMerge */\nexport type DisablePullRequestAutoMergePayload = {\n  __typename?: 'DisablePullRequestAutoMergePayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request auto merge was disabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'disconnected' event on a given issue or pull request. */\nexport type DisconnectedEvent = Node & {\n  __typename?: 'DisconnectedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean'];\n  /** Issue or pull request from which the issue was disconnected. */\n  source: ReferencedSubject;\n  /** Issue or pull request which was disconnected. */\n  subject: ReferencedSubject;\n};\n\n/** A discussion in a repository. */\nexport type Discussion = Closable & Comment & Deletable & Labelable & Lockable & Node & Reactable & RepositoryNode & Subscribable & Updatable & Votable & {\n  __typename?: 'Discussion';\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** The comment chosen as this discussion's answer, if any. */\n  answer?: Maybe<DiscussionComment>;\n  /** The time when a user chose this discussion's answer, if answered. */\n  answerChosenAt?: Maybe<Scalars['DateTime']>;\n  /** The user who chose this discussion's answer, if answered. */\n  answerChosenBy?: Maybe<Actor>;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The main text of the discussion post. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** The category for this discussion. */\n  category: DiscussionCategory;\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** The replies to the discussion. */\n  comments: DiscussionCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean'];\n  /** The number identifying this discussion within the repository. */\n  number: Scalars['Int'];\n  /** The poll associated with this discussion, if one exists. */\n  poll?: Maybe<DiscussionPoll>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The path for this discussion. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the reason for the discussion's state. */\n  stateReason?: Maybe<DiscussionStateReason>;\n  /** The title of this discussion. */\n  title: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int'];\n  /** The URL for this discussion. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean'];\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A discussion in a repository. */\nexport type DiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A category for discussions in a repository. */\nexport type DiscussionCategory = Node & RepositoryNode & {\n  __typename?: 'DiscussionCategory';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** A description of this category. */\n  description?: Maybe<Scalars['String']>;\n  /** An emoji representing this category. */\n  emoji: Scalars['String'];\n  /** This category's emoji rendered as HTML. */\n  emojiHTML: Scalars['HTML'];\n  id: Scalars['ID'];\n  /** Whether or not discussions in this category support choosing an answer with the markDiscussionCommentAsAnswer mutation. */\n  isAnswerable: Scalars['Boolean'];\n  /** The name of this category. */\n  name: Scalars['String'];\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The slug of this category. */\n  slug: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for DiscussionCategory. */\nexport type DiscussionCategoryConnection = {\n  __typename?: 'DiscussionCategoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCategoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionCategory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCategoryEdge = {\n  __typename?: 'DiscussionCategoryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionCategory>;\n};\n\n/** The possible reasons for closing a discussion. */\nexport enum DiscussionCloseReason {\n  /** The discussion is a duplicate of another */\n  Duplicate = 'DUPLICATE',\n  /** The discussion is no longer relevant */\n  Outdated = 'OUTDATED',\n  /** The discussion has been resolved */\n  Resolved = 'RESOLVED'\n}\n\n/** A comment on a discussion. */\nexport type DiscussionComment = Comment & Deletable & Minimizable & Node & Reactable & Updatable & UpdatableComment & Votable & {\n  __typename?: 'DiscussionComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The time when this replied-to comment was deleted */\n  deletedAt?: Maybe<Scalars['DateTime']>;\n  /** The discussion this comment was created in */\n  discussion?: Maybe<Discussion>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Has this comment been chosen as the answer of its discussion? */\n  isAnswer: Scalars['Boolean'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The threaded replies to this comment. */\n  replies: DiscussionCommentConnection;\n  /** The discussion comment this comment is a reply to */\n  replyTo?: Maybe<DiscussionComment>;\n  /** The path for this discussion comment. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int'];\n  /** The URL for this discussion comment. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Can the current user mark this comment as an answer? */\n  viewerCanMarkAsAnswer: Scalars['Boolean'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Can the current user unmark this comment as an answer? */\n  viewerCanUnmarkAsAnswer: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean'];\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentRepliesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A comment on a discussion. */\nexport type DiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for DiscussionComment. */\nexport type DiscussionCommentConnection = {\n  __typename?: 'DiscussionCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionCommentEdge = {\n  __typename?: 'DiscussionCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionComment>;\n};\n\n/** The connection type for Discussion. */\nexport type DiscussionConnection = {\n  __typename?: 'DiscussionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Discussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionEdge = {\n  __typename?: 'DiscussionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Discussion>;\n};\n\n/** Ways in which lists of discussions can be ordered upon return. */\nexport type DiscussionOrder = {\n  /** The direction in which to order discussions by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order discussions. */\n  field: DiscussionOrderField;\n};\n\n/** Properties by which discussion connections can be ordered. */\nexport enum DiscussionOrderField {\n  /** Order discussions by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order discussions by most recent modification time. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A poll for a discussion. */\nexport type DiscussionPoll = Node & {\n  __typename?: 'DiscussionPoll';\n  /** The discussion that this poll belongs to. */\n  discussion?: Maybe<Discussion>;\n  id: Scalars['ID'];\n  /** The options for this poll. */\n  options?: Maybe<DiscussionPollOptionConnection>;\n  /** The question that is being asked by this poll. */\n  question: Scalars['String'];\n  /** The total number of votes that have been cast for this poll. */\n  totalVoteCount: Scalars['Int'];\n  /** Indicates if the viewer has permission to vote in this poll. */\n  viewerCanVote: Scalars['Boolean'];\n  /** Indicates if the viewer has voted for any option in this poll. */\n  viewerHasVoted: Scalars['Boolean'];\n};\n\n\n/** A poll for a discussion. */\nexport type DiscussionPollOptionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DiscussionPollOptionOrder>;\n};\n\n/** An option for a discussion poll. */\nexport type DiscussionPollOption = Node & {\n  __typename?: 'DiscussionPollOption';\n  id: Scalars['ID'];\n  /** The text for this option. */\n  option: Scalars['String'];\n  /** The discussion poll that this option belongs to. */\n  poll?: Maybe<DiscussionPoll>;\n  /** The total number of votes that have been cast for this option. */\n  totalVoteCount: Scalars['Int'];\n  /** Indicates if the viewer has voted for this option in the poll. */\n  viewerHasVoted: Scalars['Boolean'];\n};\n\n/** The connection type for DiscussionPollOption. */\nexport type DiscussionPollOptionConnection = {\n  __typename?: 'DiscussionPollOptionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<DiscussionPollOptionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<DiscussionPollOption>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type DiscussionPollOptionEdge = {\n  __typename?: 'DiscussionPollOptionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<DiscussionPollOption>;\n};\n\n/** Ordering options for discussion poll option connections. */\nexport type DiscussionPollOptionOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order poll options by. */\n  field: DiscussionPollOptionOrderField;\n};\n\n/** Properties by which discussion poll option connections can be ordered. */\nexport enum DiscussionPollOptionOrderField {\n  /** Order poll options by the order that the poll author specified when creating the poll. */\n  AuthoredOrder = 'AUTHORED_ORDER',\n  /** Order poll options by the number of votes it has. */\n  VoteCount = 'VOTE_COUNT'\n}\n\n/** The possible states of a discussion. */\nexport enum DiscussionState {\n  /** A discussion that has been closed */\n  Closed = 'CLOSED',\n  /** A discussion that is open */\n  Open = 'OPEN'\n}\n\n/** The possible state reasons of a discussion. */\nexport enum DiscussionStateReason {\n  /** The discussion is a duplicate of another */\n  Duplicate = 'DUPLICATE',\n  /** The discussion is no longer relevant */\n  Outdated = 'OUTDATED',\n  /** The discussion was reopened */\n  Reopened = 'REOPENED',\n  /** The discussion has been resolved */\n  Resolved = 'RESOLVED'\n}\n\n/** Autogenerated input type of DismissPullRequestReview */\nexport type DismissPullRequestReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The contents of the pull request review dismissal message. */\n  message: Scalars['String'];\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DismissPullRequestReview */\nexport type DismissPullRequestReviewPayload = {\n  __typename?: 'DismissPullRequestReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The dismissed pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** The possible reasons that a Dependabot alert was dismissed. */\nexport enum DismissReason {\n  /** A fix has already been started */\n  FixStarted = 'FIX_STARTED',\n  /** This alert is inaccurate or incorrect */\n  Inaccurate = 'INACCURATE',\n  /** Vulnerable code is not actually used */\n  NotUsed = 'NOT_USED',\n  /** No bandwidth to fix this */\n  NoBandwidth = 'NO_BANDWIDTH',\n  /** Risk is tolerable to this project */\n  TolerableRisk = 'TOLERABLE_RISK'\n}\n\n/** Autogenerated input type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The reason the Dependabot alert is being dismissed. */\n  dismissReason: DismissReason;\n  /** The Dependabot alert ID to dismiss. */\n  repositoryVulnerabilityAlertId: Scalars['ID'];\n};\n\n/** Autogenerated return type of DismissRepositoryVulnerabilityAlert */\nexport type DismissRepositoryVulnerabilityAlertPayload = {\n  __typename?: 'DismissRepositoryVulnerabilityAlertPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Dependabot alert that was dismissed */\n  repositoryVulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** A draft issue within a project. */\nexport type DraftIssue = Node & {\n  __typename?: 'DraftIssue';\n  /** A list of users to assigned to this draft issue. */\n  assignees: UserConnection;\n  /** The body of the draft issue. */\n  body: Scalars['String'];\n  /** The body of the draft issue rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body of the draft issue rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created this draft issue. */\n  creator?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** List of items linked with the draft issue (currently draft issue can be linked to only one item). */\n  projectV2Items: ProjectV2ItemConnection;\n  /** Projects that link to this draft issue (currently draft issue can be linked to only one project). */\n  projectsV2: ProjectV2Connection;\n  /** The title of the draft issue */\n  title: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueProjectV2ItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A draft issue within a project. */\nexport type DraftIssueProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Specifies a review comment to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewComment = {\n  /** Body of the comment to leave. */\n  body: Scalars['String'];\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** Position in the file to leave a comment on. */\n  position: Scalars['Int'];\n};\n\n/** Specifies a review comment thread to be left with a Pull Request Review. */\nexport type DraftPullRequestReviewThread = {\n  /** Body of the comment to leave. */\n  body: Scalars['String'];\n  /** The line of the blob to which the thread refers. The end of the line range for multi-line comments. */\n  line: Scalars['Int'];\n  /** Path to the file being commented on. */\n  path: Scalars['String'];\n  /** The side of the diff on which the line resides. For multi-line comments, this is the side for the end of the line range. */\n  side?: InputMaybe<DiffSide>;\n  /** The first line of the range to which the comment refers. */\n  startLine?: InputMaybe<Scalars['Int']>;\n  /** The side of the diff on which the start line resides. */\n  startSide?: InputMaybe<DiffSide>;\n};\n\n/** Autogenerated input type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergeInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * Commit body to use for the commit when the PR is mergable; if omitted, a\n   * default message will be used. NOTE: when merging with a merge queue any input\n   * value for commit message is ignored.\n   */\n  commitBody?: InputMaybe<Scalars['String']>;\n  /**\n   * Commit headline to use for the commit when the PR is mergable; if omitted, a\n   * default message will be used. NOTE: when merging with a merge queue any input\n   * value for commit headline is ignored.\n   */\n  commitHeadline?: InputMaybe<Scalars['String']>;\n  /** The expected head OID of the pull request. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']>;\n  /**\n   * The merge method to use. If omitted, defaults to `MERGE`. NOTE: when merging\n   * with a merge queue any input value for merge method is ignored.\n   */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to enable auto-merge on. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of EnablePullRequestAutoMerge */\nexport type EnablePullRequestAutoMergePayload = {\n  __typename?: 'EnablePullRequestAutoMergePayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request auto-merge was enabled on. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of EnqueuePullRequest */\nexport type EnqueuePullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The expected head OID of the pull request. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']>;\n  /** Add the pull request to the front of the queue. */\n  jump?: InputMaybe<Scalars['Boolean']>;\n  /** The ID of the pull request to enqueue. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of EnqueuePullRequest */\nexport type EnqueuePullRequestPayload = {\n  __typename?: 'EnqueuePullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The merge queue entry for the enqueued pull request. */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n};\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type Enterprise = AnnouncementBanner & Node & {\n  __typename?: 'Enterprise';\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']>;\n  /** A URL pointing to the enterprise's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** Enterprise billing informationvisible to enterprise billing managers. */\n  billingInfo?: Maybe<EnterpriseBillingInfo>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The description of the enterprise. */\n  description?: Maybe<Scalars['String']>;\n  /** The description of the enterprise as HTML. */\n  descriptionHTML: Scalars['HTML'];\n  id: Scalars['ID'];\n  /** The location of the enterprise. */\n  location?: Maybe<Scalars['String']>;\n  /** A list of users who are members of this enterprise. */\n  members: EnterpriseMemberConnection;\n  /** The name of the enterprise. */\n  name: Scalars['String'];\n  /** A list of organizations that belong to this enterprise. */\n  organizations: OrganizationConnection;\n  /**\n   * Enterprise information visible to enterprise owners or enterprise owners'\n   * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n   */\n  ownerInfo?: Maybe<EnterpriseOwnerInfo>;\n  /** The HTTP path for this enterprise. */\n  resourcePath: Scalars['URI'];\n  /** The URL-friendly identifier for the enterprise. */\n  slug: Scalars['String'];\n  /** The HTTP URL for this enterprise. */\n  url: Scalars['URI'];\n  /** Is the current viewer an admin of this enterprise? */\n  viewerIsAdmin: Scalars['Boolean'];\n  /** The URL of the enterprise website. */\n  websiteUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseMembersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  deployment?: InputMaybe<EnterpriseUserDeployment>;\n  first?: InputMaybe<Scalars['Int']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']>>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n\n/** An account to manage multiple organizations with consolidated policy and billing. */\nexport type EnterpriseOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  viewerOrganizationRole?: InputMaybe<RoleInOrganization>;\n};\n\n/** The connection type for User. */\nexport type EnterpriseAdministratorConnection = {\n  __typename?: 'EnterpriseAdministratorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A User who is an administrator of an enterprise. */\nexport type EnterpriseAdministratorEdge = {\n  __typename?: 'EnterpriseAdministratorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** An invitation for a user to become an owner or billing manager of an enterprise. */\nexport type EnterpriseAdministratorInvitation = Node & {\n  __typename?: 'EnterpriseAdministratorInvitation';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The email of the person who was invited to the enterprise. */\n  email?: Maybe<Scalars['String']>;\n  /** The enterprise the invitation is for. */\n  enterprise: Enterprise;\n  id: Scalars['ID'];\n  /** The user who was invited to the enterprise. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter?: Maybe<User>;\n  /** The invitee's pending role in the enterprise (owner or billing_manager). */\n  role: EnterpriseAdministratorRole;\n};\n\n/** The connection type for EnterpriseAdministratorInvitation. */\nexport type EnterpriseAdministratorInvitationConnection = {\n  __typename?: 'EnterpriseAdministratorInvitationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseAdministratorInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseAdministratorInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseAdministratorInvitationEdge = {\n  __typename?: 'EnterpriseAdministratorInvitationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** Ordering options for enterprise administrator invitation connections */\nexport type EnterpriseAdministratorInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise administrator invitations by. */\n  field: EnterpriseAdministratorInvitationOrderField;\n};\n\n/** Properties by which enterprise administrator invitation connections can be ordered. */\nexport enum EnterpriseAdministratorInvitationOrderField {\n  /** Order enterprise administrator member invitations by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible administrator roles in an enterprise account. */\nexport enum EnterpriseAdministratorRole {\n  /** Represents a billing manager of the enterprise account. */\n  BillingManager = 'BILLING_MANAGER',\n  /** Represents an owner of the enterprise account. */\n  Owner = 'OWNER'\n}\n\n/** The possible values for the enterprise allow private repository forking policy value. */\nexport enum EnterpriseAllowPrivateRepositoryForkingPolicyValue {\n  /** Members can fork a repository to an organization within this enterprise. */\n  EnterpriseOrganizations = 'ENTERPRISE_ORGANIZATIONS',\n  /** Members can fork a repository to their enterprise-managed user account or an organization inside this enterprise. */\n  EnterpriseOrganizationsUserAccounts = 'ENTERPRISE_ORGANIZATIONS_USER_ACCOUNTS',\n  /** Members can fork a repository to their user account or an organization, either inside or outside of this enterprise. */\n  Everywhere = 'EVERYWHERE',\n  /** Members can fork a repository only within the same organization (intra-org). */\n  SameOrganization = 'SAME_ORGANIZATION',\n  /** Members can fork a repository to their user account or within the same organization. */\n  SameOrganizationUserAccounts = 'SAME_ORGANIZATION_USER_ACCOUNTS',\n  /** Members can fork a repository to their user account. */\n  UserAccounts = 'USER_ACCOUNTS'\n}\n\n/** Metadata for an audit entry containing enterprise account information. */\nexport type EnterpriseAuditEntryData = {\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Enterprise billing information visible to enterprise billing managers and owners. */\nexport type EnterpriseBillingInfo = {\n  __typename?: 'EnterpriseBillingInfo';\n  /** The number of licenseable users/emails across the enterprise. */\n  allLicensableUsersCount: Scalars['Int'];\n  /** The number of data packs used by all organizations owned by the enterprise. */\n  assetPacks: Scalars['Int'];\n  /** The bandwidth quota in GB for all organizations owned by the enterprise. */\n  bandwidthQuota: Scalars['Float'];\n  /** The bandwidth usage in GB for all organizations owned by the enterprise. */\n  bandwidthUsage: Scalars['Float'];\n  /** The bandwidth usage as a percentage of the bandwidth quota. */\n  bandwidthUsagePercentage: Scalars['Int'];\n  /** The storage quota in GB for all organizations owned by the enterprise. */\n  storageQuota: Scalars['Float'];\n  /** The storage usage in GB for all organizations owned by the enterprise. */\n  storageUsage: Scalars['Float'];\n  /** The storage usage as a percentage of the storage quota. */\n  storageUsagePercentage: Scalars['Int'];\n  /** The number of available licenses across all owned organizations based on the unique number of billable users. */\n  totalAvailableLicenses: Scalars['Int'];\n  /** The total number of licenses allocated. */\n  totalLicenses: Scalars['Int'];\n};\n\n/** The possible values for the enterprise base repository permission setting. */\nexport enum EnterpriseDefaultRepositoryPermissionSettingValue {\n  /** Organization members will be able to clone, pull, push, and add new collaborators to all organization repositories. */\n  Admin = 'ADMIN',\n  /** Organization members will only be able to clone and pull public repositories. */\n  None = 'NONE',\n  /** Organizations in the enterprise choose base repository permissions for their members. */\n  NoPolicy = 'NO_POLICY',\n  /** Organization members will be able to clone and pull all organization repositories. */\n  Read = 'READ',\n  /** Organization members will be able to clone, pull, and push all organization repositories. */\n  Write = 'WRITE'\n}\n\n/** The possible values for an enabled/disabled enterprise setting. */\nexport enum EnterpriseEnabledDisabledSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n/** The possible values for an enabled/no policy enterprise setting. */\nexport enum EnterpriseEnabledSettingValue {\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED',\n  /** There is no policy set for organizations in the enterprise. */\n  NoPolicy = 'NO_POLICY'\n}\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterpriseFailedInvitationConnection = {\n  __typename?: 'EnterpriseFailedInvitationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseFailedInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars['Int'];\n};\n\n/** A failed invitation to be a member in an enterprise organization. */\nexport type EnterpriseFailedInvitationEdge = {\n  __typename?: 'EnterpriseFailedInvitationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/**\n * An identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseIdentityProvider = Node & {\n  __typename?: 'EnterpriseIdentityProvider';\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod?: Maybe<SamlDigestAlgorithm>;\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID'];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']>;\n  /** The Issuer Entity ID for the SAML identity provider. */\n  issuer?: Maybe<Scalars['String']>;\n  /** Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable. */\n  recoveryCodes?: Maybe<Array<Scalars['String']>>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod?: Maybe<SamlSignatureAlgorithm>;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/**\n * An identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  login?: InputMaybe<Scalars['String']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']>;\n  userName?: InputMaybe<Scalars['String']>;\n};\n\n/** An object that is a member of an enterprise. */\nexport type EnterpriseMember = EnterpriseUserAccount | User;\n\n/** The connection type for EnterpriseMember. */\nexport type EnterpriseMemberConnection = {\n  __typename?: 'EnterpriseMemberConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseMember>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A User who is a member of an enterprise through one or more organizations. */\nexport type EnterpriseMemberEdge = {\n  __typename?: 'EnterpriseMemberEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseMember>;\n};\n\n/** Ordering options for enterprise member connections. */\nexport type EnterpriseMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise members by. */\n  field: EnterpriseMemberOrderField;\n};\n\n/** Properties by which enterprise member connections can be ordered. */\nexport enum EnterpriseMemberOrderField {\n  /** Order enterprise members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order enterprise members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible values for the enterprise members can create repositories setting. */\nexport enum EnterpriseMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Organization administrators choose whether to allow members to create repositories. */\n  NoPolicy = 'NO_POLICY',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE',\n  /** Members will be able to create only public repositories. */\n  Public = 'PUBLIC'\n}\n\n/** The possible values for the members can make purchases setting. */\nexport enum EnterpriseMembersCanMakePurchasesSettingValue {\n  /** The setting is disabled for organizations in the enterprise. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for organizations in the enterprise. */\n  Enabled = 'ENABLED'\n}\n\n/** The connection type for Organization. */\nexport type EnterpriseOrganizationMembershipConnection = {\n  __typename?: 'EnterpriseOrganizationMembershipConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOrganizationMembershipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An enterprise organization that a user is a member of. */\nexport type EnterpriseOrganizationMembershipEdge = {\n  __typename?: 'EnterpriseOrganizationMembershipEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole;\n};\n\n/** The connection type for User. */\nexport type EnterpriseOutsideCollaboratorConnection = {\n  __typename?: 'EnterpriseOutsideCollaboratorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseOutsideCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdge = {\n  __typename?: 'EnterpriseOutsideCollaboratorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The enterprise organization repositories this user is a member of. */\n  repositories: EnterpriseRepositoryInfoConnection;\n};\n\n\n/** A User who is an outside collaborator of an enterprise through one or more organizations. */\nexport type EnterpriseOutsideCollaboratorEdgeRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n};\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfo = {\n  __typename?: 'EnterpriseOwnerInfo';\n  /** A list of all of the administrators for this enterprise. */\n  admins: EnterpriseAdministratorConnection;\n  /** A list of users in the enterprise who currently have two-factor authentication disabled. */\n  affiliatedUsersWithTwoFactorDisabled: UserConnection;\n  /** Whether or not affiliated users with two-factor authentication disabled exist in the enterprise. */\n  affiliatedUsersWithTwoFactorDisabledExist: Scalars['Boolean'];\n  /** The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise. */\n  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided private repository forking setting value. */\n  allowPrivateRepositoryForkingSettingOrganizations: OrganizationConnection;\n  /** The value for the allow private repository forking policy on the enterprise. */\n  allowPrivateRepositoryForkingSettingPolicyValue?: Maybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;\n  /** The setting value for base repository permissions for organizations in this enterprise. */\n  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;\n  /** A list of enterprise organizations configured with the provided base repository permission. */\n  defaultRepositoryPermissionSettingOrganizations: OrganizationConnection;\n  /**\n   * A list of domains owned by the enterprise. Visible to enterprise owners or\n   * enterprise owners' personal access tokens (classic) with admin:enterprise scope.\n   */\n  domains: VerifiableDomainConnection;\n  /** Enterprise Server installations owned by the enterprise. */\n  enterpriseServerInstallations: EnterpriseServerInstallationConnection;\n  /** A list of failed invitations in the enterprise. */\n  failedInvitations: EnterpriseFailedInvitationConnection;\n  /** The setting value for whether the enterprise has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n  /**\n   * The IP addresses that are allowed to access resources owned by the enterprise.\n   * Visible to enterprise owners or enterprise owners' personal access tokens\n   * (classic) with admin:enterprise scope.\n   */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The setting value for whether the enterprise has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n  /** Whether or not the base repository permission is currently being updated. */\n  isUpdatingDefaultRepositoryPermission: Scalars['Boolean'];\n  /** Whether the two-factor authentication requirement is currently being enforced. */\n  isUpdatingTwoFactorRequirement: Scalars['Boolean'];\n  /**\n   * The setting value for whether organization members with admin permissions on a\n   * repository can change repository visibility.\n   */\n  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided can change repository visibility setting value. */\n  membersCanChangeRepositoryVisibilitySettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can create internal repositories. */\n  membersCanCreateInternalRepositoriesSetting?: Maybe<Scalars['Boolean']>;\n  /** The setting value for whether members of organizations in the enterprise can create private repositories. */\n  membersCanCreatePrivateRepositoriesSetting?: Maybe<Scalars['Boolean']>;\n  /** The setting value for whether members of organizations in the enterprise can create public repositories. */\n  membersCanCreatePublicRepositoriesSetting?: Maybe<Scalars['Boolean']>;\n  /** The setting value for whether members of organizations in the enterprise can create repositories. */\n  membersCanCreateRepositoriesSetting?: Maybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n  /** A list of enterprise organizations configured with the provided repository creation setting value. */\n  membersCanCreateRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete issues. */\n  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete issues setting value. */\n  membersCanDeleteIssuesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members with admin permissions for repositories can delete or transfer repositories. */\n  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can delete repositories setting value. */\n  membersCanDeleteRepositoriesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members of organizations in the enterprise can invite outside collaborators. */\n  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can invite collaborators setting value. */\n  membersCanInviteCollaboratorsSettingOrganizations: OrganizationConnection;\n  /** Indicates whether members of this enterprise's organizations can purchase additional services for those organizations. */\n  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;\n  /** The setting value for whether members with admin permissions for repositories can update protected branches. */\n  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can update protected branches setting value. */\n  membersCanUpdateProtectedBranchesSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether members can view dependency insights. */\n  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided members can view dependency insights setting value. */\n  membersCanViewDependencyInsightsSettingOrganizations: OrganizationConnection;\n  /** Indicates if email notification delivery for this enterprise is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n  /** The OIDC Identity Provider for the enterprise. */\n  oidcProvider?: Maybe<OidcProvider>;\n  /** The setting value for whether organization projects are enabled for organizations in this enterprise. */\n  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided organization projects setting value. */\n  organizationProjectsSettingOrganizations: OrganizationConnection;\n  /** A list of outside collaborators across the repositories in the enterprise. */\n  outsideCollaborators: EnterpriseOutsideCollaboratorConnection;\n  /** A list of pending administrator invitations for the enterprise. */\n  pendingAdminInvitations: EnterpriseAdministratorInvitationConnection;\n  /** A list of pending collaborator invitations across the repositories in the enterprise. */\n  pendingCollaboratorInvitations: RepositoryInvitationConnection;\n  /** A list of pending member invitations for organizations in the enterprise. */\n  pendingMemberInvitations: EnterprisePendingMemberInvitationConnection;\n  /** The setting value for whether repository projects are enabled in this enterprise. */\n  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided repository projects setting value. */\n  repositoryProjectsSettingOrganizations: OrganizationConnection;\n  /** The SAML Identity Provider for the enterprise. */\n  samlIdentityProvider?: Maybe<EnterpriseIdentityProvider>;\n  /** A list of enterprise organizations configured with the SAML single sign-on setting value. */\n  samlIdentityProviderSettingOrganizations: OrganizationConnection;\n  /** A list of members with a support entitlement. */\n  supportEntitlements: EnterpriseMemberConnection;\n  /** The setting value for whether team discussions are enabled for organizations in this enterprise. */\n  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;\n  /** A list of enterprise organizations configured with the provided team discussions setting value. */\n  teamDiscussionsSettingOrganizations: OrganizationConnection;\n  /** The setting value for whether the enterprise requires two-factor authentication for its organizations and users. */\n  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;\n  /** A list of enterprise organizations configured with the two-factor authentication setting value. */\n  twoFactorRequiredSettingOrganizations: OrganizationConnection;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAdminsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']>>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAffiliatedUsersWithTwoFactorDisabledArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoAllowPrivateRepositoryForkingSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoDefaultRepositoryPermissionSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: DefaultRepositoryPermissionField;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoDomainsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isApproved?: InputMaybe<Scalars['Boolean']>;\n  isVerified?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoEnterpriseServerInstallationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  connectedOnly?: InputMaybe<Scalars['Boolean']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoFailedInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanChangeRepositoryVisibilitySettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanCreateRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: OrganizationMembersCanCreateRepositoriesSettingValue;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanDeleteIssuesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanDeleteRepositoriesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanInviteCollaboratorsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanUpdateProtectedBranchesSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoMembersCanViewDependencyInsightsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoOrganizationProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoOutsideCollaboratorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  hasTwoFactorEnabled?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  login?: InputMaybe<Scalars['String']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']>>;\n  query?: InputMaybe<Scalars['String']>;\n  visibility?: InputMaybe<RepositoryVisibility>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingAdminInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseAdministratorInvitationOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingCollaboratorInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryInvitationOrder>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoPendingMemberInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  invitationSource?: InputMaybe<OrganizationInvitationSource>;\n  last?: InputMaybe<Scalars['Int']>;\n  organizationLogins?: InputMaybe<Array<Scalars['String']>>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoRepositoryProjectsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoSamlIdentityProviderSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: IdentityProviderConfigurationState;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoSupportEntitlementsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseMemberOrder>;\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoTeamDiscussionsSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n\n/**\n * Enterprise information visible to enterprise owners or enterprise owners'\n * personal access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type EnterpriseOwnerInfoTwoFactorRequiredSettingOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  value: Scalars['Boolean'];\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type EnterprisePendingMemberInvitationConnection = {\n  __typename?: 'EnterprisePendingMemberInvitationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterprisePendingMemberInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** Identifies the total count of unique users in the connection. */\n  totalUniqueUserCount: Scalars['Int'];\n};\n\n/** An invitation to be a member in an enterprise organization. */\nexport type EnterprisePendingMemberInvitationEdge = {\n  __typename?: 'EnterprisePendingMemberInvitationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** A subset of repository information queryable from an enterprise. */\nexport type EnterpriseRepositoryInfo = Node & {\n  __typename?: 'EnterpriseRepositoryInfo';\n  id: Scalars['ID'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean'];\n  /** The repository's name. */\n  name: Scalars['String'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String'];\n};\n\n/** The connection type for EnterpriseRepositoryInfo. */\nexport type EnterpriseRepositoryInfoConnection = {\n  __typename?: 'EnterpriseRepositoryInfoConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseRepositoryInfoEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseRepositoryInfo>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseRepositoryInfoEdge = {\n  __typename?: 'EnterpriseRepositoryInfoEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseRepositoryInfo>;\n};\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallation = Node & {\n  __typename?: 'EnterpriseServerInstallation';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The customer name to which the Enterprise Server installation belongs. */\n  customerName: Scalars['String'];\n  /** The host name of the Enterprise Server installation. */\n  hostName: Scalars['String'];\n  id: Scalars['ID'];\n  /** Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect. */\n  isConnected: Scalars['Boolean'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** User accounts on this Enterprise Server installation. */\n  userAccounts: EnterpriseServerUserAccountConnection;\n  /** User accounts uploads for the Enterprise Server installation. */\n  userAccountsUploads: EnterpriseServerUserAccountsUploadConnection;\n};\n\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountOrder>;\n};\n\n\n/** An Enterprise Server installation. */\nexport type EnterpriseServerInstallationUserAccountsUploadsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountsUploadOrder>;\n};\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationConnection = {\n  __typename?: 'EnterpriseServerInstallationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerInstallationEdge = {\n  __typename?: 'EnterpriseServerInstallationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>;\n};\n\n/** The connection type for EnterpriseServerInstallation. */\nexport type EnterpriseServerInstallationMembershipConnection = {\n  __typename?: 'EnterpriseServerInstallationMembershipConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerInstallationMembershipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerInstallation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An Enterprise Server installation that a user is a member of. */\nexport type EnterpriseServerInstallationMembershipEdge = {\n  __typename?: 'EnterpriseServerInstallationMembershipEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerInstallation>;\n  /** The role of the user in the enterprise membership. */\n  role: EnterpriseUserAccountMembershipRole;\n};\n\n/** Ordering options for Enterprise Server installation connections. */\nexport type EnterpriseServerInstallationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order Enterprise Server installations by. */\n  field: EnterpriseServerInstallationOrderField;\n};\n\n/** Properties by which Enterprise Server installation connections can be ordered. */\nexport enum EnterpriseServerInstallationOrderField {\n  /** Order Enterprise Server installations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order Enterprise Server installations by customer name */\n  CustomerName = 'CUSTOMER_NAME',\n  /** Order Enterprise Server installations by host name */\n  HostName = 'HOST_NAME'\n}\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccount = Node & {\n  __typename?: 'EnterpriseServerUserAccount';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** User emails belonging to this user account. */\n  emails: EnterpriseServerUserAccountEmailConnection;\n  /** The Enterprise Server installation on which this user account exists. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars['ID'];\n  /** Whether the user account is a site administrator on the Enterprise Server installation. */\n  isSiteAdmin: Scalars['Boolean'];\n  /** The login of the user account on the Enterprise Server installation. */\n  login: Scalars['String'];\n  /** The profile name of the user account on the Enterprise Server installation. */\n  profileName?: Maybe<Scalars['String']>;\n  /** The date and time when the user account was created on the Enterprise Server installation. */\n  remoteCreatedAt: Scalars['DateTime'];\n  /** The ID of the user account on the Enterprise Server installation. */\n  remoteUserId: Scalars['Int'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n\n/** A user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmailsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseServerUserAccountEmailOrder>;\n};\n\n/** The connection type for EnterpriseServerUserAccount. */\nexport type EnterpriseServerUserAccountConnection = {\n  __typename?: 'EnterpriseServerUserAccountConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEdge = {\n  __typename?: 'EnterpriseServerUserAccountEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccount>;\n};\n\n/** An email belonging to a user account on an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountEmail = Node & {\n  __typename?: 'EnterpriseServerUserAccountEmail';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The email address. */\n  email: Scalars['String'];\n  id: Scalars['ID'];\n  /** Indicates whether this is the primary email of the associated user account. */\n  isPrimary: Scalars['Boolean'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The user account to which the email belongs. */\n  userAccount: EnterpriseServerUserAccount;\n};\n\n/** The connection type for EnterpriseServerUserAccountEmail. */\nexport type EnterpriseServerUserAccountEmailConnection = {\n  __typename?: 'EnterpriseServerUserAccountEmailConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmailEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountEmail>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountEmailEdge = {\n  __typename?: 'EnterpriseServerUserAccountEmailEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountEmail>;\n};\n\n/** Ordering options for Enterprise Server user account email connections. */\nexport type EnterpriseServerUserAccountEmailOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order emails by. */\n  field: EnterpriseServerUserAccountEmailOrderField;\n};\n\n/** Properties by which Enterprise Server user account email connections can be ordered. */\nexport enum EnterpriseServerUserAccountEmailOrderField {\n  /** Order emails by email */\n  Email = 'EMAIL'\n}\n\n/** Ordering options for Enterprise Server user account connections. */\nexport type EnterpriseServerUserAccountOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts by. */\n  field: EnterpriseServerUserAccountOrderField;\n};\n\n/** Properties by which Enterprise Server user account connections can be ordered. */\nexport enum EnterpriseServerUserAccountOrderField {\n  /** Order user accounts by login */\n  Login = 'LOGIN',\n  /** Order user accounts by creation time on the Enterprise Server installation */\n  RemoteCreatedAt = 'REMOTE_CREATED_AT'\n}\n\n/** A user accounts upload from an Enterprise Server installation. */\nexport type EnterpriseServerUserAccountsUpload = Node & {\n  __typename?: 'EnterpriseServerUserAccountsUpload';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The enterprise to which this upload belongs. */\n  enterprise: Enterprise;\n  /** The Enterprise Server installation for which this upload was generated. */\n  enterpriseServerInstallation: EnterpriseServerInstallation;\n  id: Scalars['ID'];\n  /** The name of the file uploaded. */\n  name: Scalars['String'];\n  /** The synchronization state of the upload */\n  syncState: EnterpriseServerUserAccountsUploadSyncState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for EnterpriseServerUserAccountsUpload. */\nexport type EnterpriseServerUserAccountsUploadConnection = {\n  __typename?: 'EnterpriseServerUserAccountsUploadConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUploadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<EnterpriseServerUserAccountsUpload>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnterpriseServerUserAccountsUploadEdge = {\n  __typename?: 'EnterpriseServerUserAccountsUploadEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<EnterpriseServerUserAccountsUpload>;\n};\n\n/** Ordering options for Enterprise Server user accounts upload connections. */\nexport type EnterpriseServerUserAccountsUploadOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user accounts uploads by. */\n  field: EnterpriseServerUserAccountsUploadOrderField;\n};\n\n/** Properties by which Enterprise Server user accounts upload connections can be ordered. */\nexport enum EnterpriseServerUserAccountsUploadOrderField {\n  /** Order user accounts uploads by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Synchronization state of the Enterprise Server user accounts upload */\nexport enum EnterpriseServerUserAccountsUploadSyncState {\n  /** The synchronization of the upload failed. */\n  Failure = 'FAILURE',\n  /** The synchronization of the upload is pending. */\n  Pending = 'PENDING',\n  /** The synchronization of the upload succeeded. */\n  Success = 'SUCCESS'\n}\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccount = Actor & Node & {\n  __typename?: 'EnterpriseUserAccount';\n  /** A URL pointing to the enterprise user account's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The enterprise in which this user account exists. */\n  enterprise: Enterprise;\n  /** A list of Enterprise Server installations this user is a member of. */\n  enterpriseInstallations: EnterpriseServerInstallationMembershipConnection;\n  id: Scalars['ID'];\n  /** An identifier for the enterprise user account, a login or email address */\n  login: Scalars['String'];\n  /** The name of the enterprise user account */\n  name?: Maybe<Scalars['String']>;\n  /** A list of enterprise organizations this user is a member of. */\n  organizations: EnterpriseOrganizationMembershipConnection;\n  /** The HTTP path for this user. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this user. */\n  url: Scalars['URI'];\n  /** The user within the enterprise. */\n  user?: Maybe<User>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountEnterpriseInstallationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<EnterpriseServerInstallationOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n\n/** An account for a user who is an admin of an enterprise or a member of an enterprise through one or more organizations. */\nexport type EnterpriseUserAccountOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<EnterpriseUserAccountMembershipRole>;\n};\n\n/** The possible roles for enterprise membership. */\nexport enum EnterpriseUserAccountMembershipRole {\n  /** The user is a member of an organization in the enterprise. */\n  Member = 'MEMBER',\n  /** The user is an owner of an organization in the enterprise. */\n  Owner = 'OWNER',\n  /**\n   * The user is not an owner of the enterprise, and not a member or owner of any\n   * organizations in the enterprise; only for EMU-enabled enterprises.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The possible GitHub Enterprise deployments where this user can exist. */\nexport enum EnterpriseUserDeployment {\n  /** The user is part of a GitHub Enterprise Cloud deployment. */\n  Cloud = 'CLOUD',\n  /** The user is part of a GitHub Enterprise Server deployment. */\n  Server = 'SERVER'\n}\n\n/** An environment. */\nexport type Environment = Node & {\n  __typename?: 'Environment';\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The name of the environment */\n  name: Scalars['String'];\n  /** The protection rules defined for this environment */\n  protectionRules: DeploymentProtectionRuleConnection;\n};\n\n\n/** An environment. */\nexport type EnvironmentProtectionRulesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for Environment. */\nexport type EnvironmentConnection = {\n  __typename?: 'EnvironmentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<EnvironmentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Environment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type EnvironmentEdge = {\n  __typename?: 'EnvironmentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Environment>;\n};\n\n/**\n * An external identity provisioned by SAML SSO or SCIM. If SAML is configured on\n * the organization, the external identity is visible to (1) organization owners,\n * (2) organization owners' personal access tokens (classic) with read:org or\n * admin:org scope, (3) GitHub App with an installation token with read or write\n * access to members. If SAML is configured on the enterprise, the external\n * identity is visible to (1) enterprise owners, (2) enterprise owners' personal\n * access tokens (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type ExternalIdentity = Node & {\n  __typename?: 'ExternalIdentity';\n  /** The GUID for this identity */\n  guid: Scalars['String'];\n  id: Scalars['ID'];\n  /** Organization invitation for this SCIM-provisioned external identity */\n  organizationInvitation?: Maybe<OrganizationInvitation>;\n  /** SAML Identity attributes */\n  samlIdentity?: Maybe<ExternalIdentitySamlAttributes>;\n  /** SCIM Identity attributes */\n  scimIdentity?: Maybe<ExternalIdentityScimAttributes>;\n  /** User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member. */\n  user?: Maybe<User>;\n};\n\n/** An attribute for the External Identity attributes collection */\nexport type ExternalIdentityAttribute = {\n  __typename?: 'ExternalIdentityAttribute';\n  /** The attribute metadata as JSON */\n  metadata?: Maybe<Scalars['String']>;\n  /** The attribute name */\n  name: Scalars['String'];\n  /** The attribute value */\n  value: Scalars['String'];\n};\n\n/** The connection type for ExternalIdentity. */\nexport type ExternalIdentityConnection = {\n  __typename?: 'ExternalIdentityConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ExternalIdentityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ExternalIdentity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ExternalIdentityEdge = {\n  __typename?: 'ExternalIdentityEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ExternalIdentity>;\n};\n\n/** SAML attributes for the External Identity */\nexport type ExternalIdentitySamlAttributes = {\n  __typename?: 'ExternalIdentitySamlAttributes';\n  /** SAML Identity attributes */\n  attributes: Array<ExternalIdentityAttribute>;\n  /** The emails associated with the SAML identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SAML identity */\n  familyName?: Maybe<Scalars['String']>;\n  /** Given name of the SAML identity */\n  givenName?: Maybe<Scalars['String']>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']>>;\n  /** The NameID of the SAML identity */\n  nameId?: Maybe<Scalars['String']>;\n  /** The userName of the SAML identity */\n  username?: Maybe<Scalars['String']>;\n};\n\n/** SCIM attributes for the External Identity */\nexport type ExternalIdentityScimAttributes = {\n  __typename?: 'ExternalIdentityScimAttributes';\n  /** The emails associated with the SCIM identity */\n  emails?: Maybe<Array<UserEmailMetadata>>;\n  /** Family name of the SCIM identity */\n  familyName?: Maybe<Scalars['String']>;\n  /** Given name of the SCIM identity */\n  givenName?: Maybe<Scalars['String']>;\n  /** The groups linked to this identity in IDP */\n  groups?: Maybe<Array<Scalars['String']>>;\n  /** The userName of the SCIM identity */\n  username?: Maybe<Scalars['String']>;\n};\n\n/**\n * A command to add a file at the given path with the given contents as part of a\n * commit.  Any existing file at that that path will be replaced.\n */\nexport type FileAddition = {\n  /** The base64 encoded contents of the file */\n  contents: Scalars['Base64String'];\n  /** The path in the repository where the file will be located */\n  path: Scalars['String'];\n};\n\n/**\n * A description of a set of changes to a file tree to be made as part of\n * a git commit, modeled as zero or more file `additions` and zero or more\n * file `deletions`.\n *\n * Both fields are optional; omitting both will produce a commit with no\n * file changes.\n *\n * `deletions` and `additions` describe changes to files identified\n * by their path in the git tree using unix-style path separators, i.e.\n * `/`.  The root of a git tree is an empty string, so paths are not\n * slash-prefixed.\n *\n * `path` values must be unique across all `additions` and `deletions`\n * provided.  Any duplication will result in a validation error.\n *\n * ### Encoding\n *\n * File contents must be provided in full for each `FileAddition`.\n *\n * The `contents` of a `FileAddition` must be encoded using RFC 4648\n * compliant base64, i.e. correct padding is required and no characters\n * outside the standard alphabet may be used.  Invalid base64\n * encoding will be rejected with a validation error.\n *\n * The encoded contents may be binary.\n *\n * For text files, no assumptions are made about the character encoding of\n * the file contents (after base64 decoding).  No charset transcoding or\n * line-ending normalization will be performed; it is the client's\n * responsibility to manage the character encoding of files they provide.\n * However, for maximum compatibility we recommend using UTF-8 encoding\n * and ensuring that all files in a repository use a consistent\n * line-ending convention (`\\n` or `\\r\\n`), and that all files end\n * with a newline.\n *\n * ### Modeling file changes\n *\n * Each of the the five types of conceptual changes that can be made in a\n * git commit can be described using the `FileChanges` type as follows:\n *\n * 1. New file addition: create file `hello world\\n` at path `docs/README.txt`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n * 2. Existing file modification: change existing `docs/README.txt` to have new\n *    content `new content here\\n`:\n *\n *        {\n *          \"additions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *              \"contents\": base64encode(\"new content here\\n\")\n *            }\n *          ]\n *        }\n *\n * 3. Existing file deletion: remove existing file `docs/README.txt`.\n *    Note that the path is required to exist -- specifying a\n *    path that does not exist on the given branch will abort the\n *    commit and return an error.\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\"\n *            }\n *          ]\n *        }\n *\n *\n * 4. File rename with no changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to the same content at\n *    `newdocs/README.txt`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"hello world\\n\")\n *            }\n *          ]\n *        }\n *\n *\n * 5. File rename with changes: rename `docs/README.txt` with\n *    previous content `hello world\\n` to a file at path\n *    `newdocs/README.txt` with content `new contents\\n`:\n *\n *        {\n *          \"deletions\" [\n *            {\n *              \"path\": \"docs/README.txt\",\n *            }\n *          ],\n *          \"additions\" [\n *            {\n *              \"path\": \"newdocs/README.txt\",\n *              \"contents\": base64encode(\"new contents\\n\")\n *            }\n *          ]\n *        }\n */\nexport type FileChanges = {\n  /** File to add or change. */\n  additions?: InputMaybe<Array<FileAddition>>;\n  /** Files to delete. */\n  deletions?: InputMaybe<Array<FileDeletion>>;\n};\n\n/** A command to delete the file at the given path as part of a commit. */\nexport type FileDeletion = {\n  /** The path to delete */\n  path: Scalars['String'];\n};\n\n/** The possible viewed states of a file . */\nexport enum FileViewedState {\n  /** The file has new changes since last viewed. */\n  Dismissed = 'DISMISSED',\n  /** The file has not been marked as viewed. */\n  Unviewed = 'UNVIEWED',\n  /** The file has been marked as viewed. */\n  Viewed = 'VIEWED'\n}\n\n/** Autogenerated input type of FollowOrganization */\nexport type FollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the organization to follow. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of FollowOrganization */\nexport type FollowOrganizationPayload = {\n  __typename?: 'FollowOrganizationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organization that was followed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of FollowUser */\nexport type FollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the user to follow. */\n  userId: Scalars['ID'];\n};\n\n/** Autogenerated return type of FollowUser */\nexport type FollowUserPayload = {\n  __typename?: 'FollowUserPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The user that was followed. */\n  user?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type FollowerConnection = {\n  __typename?: 'FollowerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** The connection type for User. */\nexport type FollowingConnection = {\n  __typename?: 'FollowingConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A funding platform link for a repository. */\nexport type FundingLink = {\n  __typename?: 'FundingLink';\n  /** The funding platform this link is for. */\n  platform: FundingPlatform;\n  /** The configured URL for this funding link. */\n  url: Scalars['URI'];\n};\n\n/** The possible funding platforms for repository funding links. */\nexport enum FundingPlatform {\n  /** Community Bridge funding platform. */\n  CommunityBridge = 'COMMUNITY_BRIDGE',\n  /** Custom funding platform. */\n  Custom = 'CUSTOM',\n  /** GitHub funding platform. */\n  Github = 'GITHUB',\n  /** IssueHunt funding platform. */\n  Issuehunt = 'ISSUEHUNT',\n  /** Ko-fi funding platform. */\n  KoFi = 'KO_FI',\n  /** LFX Crowdfunding funding platform. */\n  LfxCrowdfunding = 'LFX_CROWDFUNDING',\n  /** Liberapay funding platform. */\n  Liberapay = 'LIBERAPAY',\n  /** Open Collective funding platform. */\n  OpenCollective = 'OPEN_COLLECTIVE',\n  /** Otechie funding platform. */\n  Otechie = 'OTECHIE',\n  /** Patreon funding platform. */\n  Patreon = 'PATREON',\n  /** Tidelift funding platform. */\n  Tidelift = 'TIDELIFT'\n}\n\n/** A generic hovercard context with a message and icon */\nexport type GenericHovercardContext = HovercardContext & {\n  __typename?: 'GenericHovercardContext';\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n};\n\n/** A Gist. */\nexport type Gist = Node & Starrable & UniformResourceLocatable & {\n  __typename?: 'Gist';\n  /** A list of comments associated with the gist */\n  comments: GistCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The gist description. */\n  description?: Maybe<Scalars['String']>;\n  /** The files in this gist. */\n  files?: Maybe<Array<Maybe<GistFile>>>;\n  /** A list of forks associated with the gist */\n  forks: GistConnection;\n  id: Scalars['ID'];\n  /** Identifies if the gist is a fork. */\n  isFork: Scalars['Boolean'];\n  /** Whether the gist is public or not. */\n  isPublic: Scalars['Boolean'];\n  /** The gist name. */\n  name: Scalars['String'];\n  /** The gist owner. */\n  owner?: Maybe<RepositoryOwner>;\n  /** Identifies when the gist was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']>;\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this Gist. */\n  url: Scalars['URI'];\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean'];\n};\n\n\n/** A Gist. */\nexport type GistCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A Gist. */\nexport type GistFilesArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n  oid?: InputMaybe<Scalars['GitObjectID']>;\n};\n\n\n/** A Gist. */\nexport type GistForksArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<GistOrder>;\n};\n\n\n/** A Gist. */\nexport type GistStargazersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Represents a comment on an Gist. */\nexport type GistComment = Comment & Deletable & Minimizable & Node & Updatable & UpdatableComment & {\n  __typename?: 'GistComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the gist. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the comment body. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** The associated gist. */\n  gist: Gist;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** Represents a comment on an Gist. */\nexport type GistCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for GistComment. */\nexport type GistCommentConnection = {\n  __typename?: 'GistCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GistComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type GistCommentEdge = {\n  __typename?: 'GistCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<GistComment>;\n};\n\n/** The connection type for Gist. */\nexport type GistConnection = {\n  __typename?: 'GistConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GistEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Gist>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type GistEdge = {\n  __typename?: 'GistEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Gist>;\n};\n\n/** A file in a gist. */\nexport type GistFile = {\n  __typename?: 'GistFile';\n  /** The file name encoded to remove characters that are invalid in URL paths. */\n  encodedName?: Maybe<Scalars['String']>;\n  /** The gist file encoding. */\n  encoding?: Maybe<Scalars['String']>;\n  /** The file extension from the file name. */\n  extension?: Maybe<Scalars['String']>;\n  /** Indicates if this file is an image. */\n  isImage: Scalars['Boolean'];\n  /** Whether the file's contents were truncated. */\n  isTruncated: Scalars['Boolean'];\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>;\n  /** The gist file name. */\n  name?: Maybe<Scalars['String']>;\n  /** The gist file size in bytes. */\n  size?: Maybe<Scalars['Int']>;\n  /** UTF8 text data or null if the file is binary */\n  text?: Maybe<Scalars['String']>;\n};\n\n\n/** A file in a gist. */\nexport type GistFileTextArgs = {\n  truncate?: InputMaybe<Scalars['Int']>;\n};\n\n/** Ordering options for gist connections */\nexport type GistOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: GistOrderField;\n};\n\n/** Properties by which gist connections can be ordered. */\nexport enum GistOrderField {\n  /** Order gists by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order gists by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order gists by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The privacy of a Gist */\nexport enum GistPrivacy {\n  /** Gists that are public and secret */\n  All = 'ALL',\n  /** Public */\n  Public = 'PUBLIC',\n  /** Secret */\n  Secret = 'SECRET'\n}\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActor = {\n  __typename?: 'GitActor';\n  /** A URL pointing to the author's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** The timestamp of the Git action (authoring or committing). */\n  date?: Maybe<Scalars['GitTimestamp']>;\n  /** The email in the Git commit. */\n  email?: Maybe<Scalars['String']>;\n  /** The name in the Git commit. */\n  name?: Maybe<Scalars['String']>;\n  /** The GitHub user corresponding to the email field. Null if no such user exists. */\n  user?: Maybe<User>;\n};\n\n\n/** Represents an actor in a Git commit (ie. an author or committer). */\nexport type GitActorAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for GitActor. */\nexport type GitActorConnection = {\n  __typename?: 'GitActorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<GitActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<GitActor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type GitActorEdge = {\n  __typename?: 'GitActorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<GitActor>;\n};\n\n/** Represents information about the GitHub instance. */\nexport type GitHubMetadata = {\n  __typename?: 'GitHubMetadata';\n  /** Returns a String that's a SHA of `github-services` */\n  gitHubServicesSha: Scalars['GitObjectID'];\n  /** IP addresses that users connect to for git operations */\n  gitIpAddresses?: Maybe<Array<Scalars['String']>>;\n  /** IP addresses that service hooks are sent from */\n  hookIpAddresses?: Maybe<Array<Scalars['String']>>;\n  /** IP addresses that the importer connects from */\n  importerIpAddresses?: Maybe<Array<Scalars['String']>>;\n  /** Whether or not users are verified */\n  isPasswordAuthenticationVerifiable: Scalars['Boolean'];\n  /** IP addresses for GitHub Pages' A records */\n  pagesIpAddresses?: Maybe<Array<Scalars['String']>>;\n};\n\n/** Represents a Git object. */\nexport type GitObject = {\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n};\n\n/** Information about a signature (GPG or S/MIME) on a Commit or Tag. */\nexport type GitSignature = {\n  /** Email used to sign this object. */\n  email: Scalars['String'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean'];\n};\n\n/** The state of a Git signature. */\nexport enum GitSignatureState {\n  /** The signing certificate or its chain could not be verified */\n  BadCert = 'BAD_CERT',\n  /** Invalid email used for signing */\n  BadEmail = 'BAD_EMAIL',\n  /** Signing key expired */\n  ExpiredKey = 'EXPIRED_KEY',\n  /** Internal error - the GPG verification service misbehaved */\n  GpgverifyError = 'GPGVERIFY_ERROR',\n  /** Internal error - the GPG verification service is unavailable at the moment */\n  GpgverifyUnavailable = 'GPGVERIFY_UNAVAILABLE',\n  /** Invalid signature */\n  Invalid = 'INVALID',\n  /** Malformed signature */\n  MalformedSig = 'MALFORMED_SIG',\n  /** The usage flags for the key that signed this don't allow signing */\n  NotSigningKey = 'NOT_SIGNING_KEY',\n  /** Email used for signing not known to GitHub */\n  NoUser = 'NO_USER',\n  /** Valid signature, though certificate revocation check failed */\n  OcspError = 'OCSP_ERROR',\n  /** Valid signature, pending certificate revocation checking */\n  OcspPending = 'OCSP_PENDING',\n  /** One or more certificates in chain has been revoked */\n  OcspRevoked = 'OCSP_REVOKED',\n  /** Key used for signing not known to GitHub */\n  UnknownKey = 'UNKNOWN_KEY',\n  /** Unknown signature type */\n  UnknownSigType = 'UNKNOWN_SIG_TYPE',\n  /** Unsigned */\n  Unsigned = 'UNSIGNED',\n  /** Email used for signing unverified on GitHub */\n  UnverifiedEmail = 'UNVERIFIED_EMAIL',\n  /** Valid signature and verified by GitHub */\n  Valid = 'VALID'\n}\n\n/** Represents a GPG signature on a Commit or Tag. */\nexport type GpgSignature = GitSignature & {\n  __typename?: 'GpgSignature';\n  /** Email used to sign this object. */\n  email: Scalars['String'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean'];\n  /** Hex-encoded ID of the key that signed this object. */\n  keyId?: Maybe<Scalars['String']>;\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the user to grant the migrator role */\n  login: Scalars['String'];\n};\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayload = {\n  __typename?: 'GrantEnterpriseOrganizationsMigratorRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organizations that had the migrator role applied to for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n\n/** Autogenerated return type of GrantEnterpriseOrganizationsMigratorRole */\nexport type GrantEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated input type of GrantMigratorRole */\nexport type GrantMigratorRoleInput = {\n  /** The user login or Team slug to grant the migrator role. */\n  actor: Scalars['String'];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of GrantMigratorRole */\nexport type GrantMigratorRolePayload = {\n  __typename?: 'GrantMigratorRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n/** Represents a 'head_ref_deleted' event on a given pull request. */\nexport type HeadRefDeletedEvent = Node & {\n  __typename?: 'HeadRefDeletedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the Ref associated with the `head_ref_deleted` event. */\n  headRef?: Maybe<Ref>;\n  /** Identifies the name of the Ref associated with the `head_ref_deleted` event. */\n  headRefName: Scalars['String'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Represents a 'head_ref_force_pushed' event on a given pull request. */\nexport type HeadRefForcePushedEvent = Node & {\n  __typename?: 'HeadRefForcePushedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the after commit SHA for the 'head_ref_force_pushed' event. */\n  afterCommit?: Maybe<Commit>;\n  /** Identifies the before commit SHA for the 'head_ref_force_pushed' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the fully qualified ref name for the 'head_ref_force_pushed' event. */\n  ref?: Maybe<Ref>;\n};\n\n/** Represents a 'head_ref_restored' event on a given pull request. */\nexport type HeadRefRestoredEvent = Node & {\n  __typename?: 'HeadRefRestoredEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n};\n\n/** Detail needed to display a hovercard for a user */\nexport type Hovercard = {\n  __typename?: 'Hovercard';\n  /** Each of the contexts for this hovercard */\n  contexts: Array<HovercardContext>;\n};\n\n/** An individual line of a hovercard */\nexport type HovercardContext = {\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n};\n\n/** The possible states in which authentication can be configured with an identity provider. */\nexport enum IdentityProviderConfigurationState {\n  /** Authentication with an identity provider is configured but not enforced. */\n  Configured = 'CONFIGURED',\n  /** Authentication with an identity provider is configured and enforced. */\n  Enforced = 'ENFORCED',\n  /** Authentication with an identity provider is not configured. */\n  Unconfigured = 'UNCONFIGURED'\n}\n\n/** Autogenerated input type of ImportProject */\nexport type ImportProjectInput = {\n  /** The description of Project. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A list of columns containing issues and pull requests. */\n  columnImports: Array<ProjectColumnImport>;\n  /** The name of Project. */\n  name: Scalars['String'];\n  /** The name of the Organization or User to create the Project under. */\n  ownerName: Scalars['String'];\n  /** Whether the Project is public or not. */\n  public?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Autogenerated return type of ImportProject */\nexport type ImportProjectPayload = {\n  __typename?: 'ImportProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new Project! */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The email of the person to invite as an administrator. */\n  email?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise to which you want to invite an administrator. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a user to invite as an administrator. */\n  invitee?: InputMaybe<Scalars['String']>;\n  /** The role of the administrator. */\n  role?: InputMaybe<EnterpriseAdministratorRole>;\n};\n\n/** Autogenerated return type of InviteEnterpriseAdmin */\nexport type InviteEnterpriseAdminPayload = {\n  __typename?: 'InviteEnterpriseAdminPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The created enterprise administrator invitation. */\n  invitation?: Maybe<EnterpriseAdministratorInvitation>;\n};\n\n/** The possible values for the IP allow list enabled setting. */\nexport enum IpAllowListEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/** An IP address or range of addresses that is allowed to access an owner's resources. */\nexport type IpAllowListEntry = Node & {\n  __typename?: 'IpAllowListEntry';\n  /** A single IP address or range of IP addresses in CIDR notation. */\n  allowListValue: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Whether the entry is currently active. */\n  isActive: Scalars['Boolean'];\n  /** The name of the IP allow list entry. */\n  name?: Maybe<Scalars['String']>;\n  /** The owner of the IP allow list entry. */\n  owner: IpAllowListOwner;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for IpAllowListEntry. */\nexport type IpAllowListEntryConnection = {\n  __typename?: 'IpAllowListEntryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IpAllowListEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IpAllowListEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type IpAllowListEntryEdge = {\n  __typename?: 'IpAllowListEntryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IpAllowListEntry>;\n};\n\n/** Ordering options for IP allow list entry connections. */\nexport type IpAllowListEntryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order IP allow list entries by. */\n  field: IpAllowListEntryOrderField;\n};\n\n/** Properties by which IP allow list entry connections can be ordered. */\nexport enum IpAllowListEntryOrderField {\n  /** Order IP allow list entries by the allow list value. */\n  AllowListValue = 'ALLOW_LIST_VALUE',\n  /** Order IP allow list entries by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible values for the IP allow list configuration for installed GitHub Apps setting. */\nexport enum IpAllowListForInstalledAppsEnabledSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/** Types that can own an IP allow list. */\nexport type IpAllowListOwner = App | Enterprise | Organization;\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type Issue = Assignable & Closable & Comment & Deletable & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  __typename?: 'Issue';\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Identifies the body of the issue. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The http path for this issue body */\n  bodyResourcePath: Scalars['URI'];\n  /** Identifies the body of the issue rendered to text. */\n  bodyText: Scalars['String'];\n  /** The http URL for this issue body */\n  bodyUrl: Scalars['URI'];\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of comments associated with the Issue. */\n  comments: IssueCommentConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']>;\n  /** The hovercard information for this issue */\n  hovercard: Hovercard;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Indicates whether or not this issue is currently pinned to the repository issues list */\n  isPinned?: Maybe<Scalars['Boolean']>;\n  /** Is this issue read by the viewer */\n  isReadByViewer?: Maybe<Scalars['Boolean']>;\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** Branches linked to this issue. */\n  linkedBranches: LinkedBranchConnection;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean'];\n  /** Identifies the milestone associated with the issue. */\n  milestone?: Maybe<Milestone>;\n  /** Identifies the issue number. */\n  number: Scalars['Int'];\n  /** A list of Users that are participating in the Issue conversation. */\n  participants: UserConnection;\n  /** List of project cards associated with this issue. */\n  projectCards: ProjectCardConnection;\n  /** List of project items associated with this issue. */\n  projectItems: ProjectV2ItemConnection;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this issue */\n  resourcePath: Scalars['URI'];\n  /** Identifies the state of the issue. */\n  state: IssueState;\n  /** Identifies the reason for the issue state. */\n  stateReason?: Maybe<IssueStateReason>;\n  /**\n   * A list of events, comments, commits, etc. associated with the issue.\n   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.\n   */\n  timeline: IssueTimelineConnection;\n  /** A list of events, comments, commits, etc. associated with the issue. */\n  timelineItems: IssueTimelineItemsConnection;\n  /** Identifies the issue title. */\n  title: Scalars['String'];\n  /** Identifies the issue title rendered to HTML. */\n  titleHTML: Scalars['String'];\n  /** A list of issues that track this issue */\n  trackedInIssues: IssueConnection;\n  /** A list of issues tracked inside the current issue */\n  trackedIssues: IssueConnection;\n  /** The number of tracked issues for this issue */\n  trackedIssuesCount: Scalars['Int'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this issue */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueLinkedBranchesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueParticipantsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectCardsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeArchived?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  since?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTimelineItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  itemTypes?: InputMaybe<Array<IssueTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars['Int']>;\n  since?: InputMaybe<Scalars['DateTime']>;\n  skip?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedInIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueTrackedIssuesCountArgs = {\n  states?: InputMaybe<Array<InputMaybe<TrackedIssueStates>>>;\n};\n\n\n/** An Issue is a place to discuss ideas, enhancements, tasks, and bugs for a project. */\nexport type IssueUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The possible state reasons of a closed issue. */\nexport enum IssueClosedStateReason {\n  /** An issue that has been closed as completed */\n  Completed = 'COMPLETED',\n  /** An issue that has been closed as not planned */\n  NotPlanned = 'NOT_PLANNED'\n}\n\n/** Represents a comment on an Issue. */\nexport type IssueComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  __typename?: 'IssueComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /** Identifies the issue associated with the comment. */\n  issue: Issue;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Returns the pull request associated with the comment, if this comment was made on a\n   * pull request.\n   */\n  pullRequest?: Maybe<PullRequest>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this issue comment */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this issue comment */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** Represents a comment on an Issue. */\nexport type IssueCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for IssueComment. */\nexport type IssueCommentConnection = {\n  __typename?: 'IssueCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type IssueCommentEdge = {\n  __typename?: 'IssueCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueComment>;\n};\n\n/** Ways in which lists of issue comments can be ordered upon return. */\nexport type IssueCommentOrder = {\n  /** The direction in which to order issue comments by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issue comments by. */\n  field: IssueCommentOrderField;\n};\n\n/** Properties by which issue comment connections can be ordered. */\nexport enum IssueCommentOrderField {\n  /** Order issue comments by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The connection type for Issue. */\nexport type IssueConnection = {\n  __typename?: 'IssueConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Issue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepository = {\n  __typename?: 'IssueContributionsByRepository';\n  /** The issue contributions. */\n  contributions: CreatedIssueContributionConnection;\n  /** The repository in which the issues were opened. */\n  repository: Repository;\n};\n\n\n/** This aggregates issues opened by a user within one repository. */\nexport type IssueContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type IssueEdge = {\n  __typename?: 'IssueEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Issue>;\n};\n\n/** Ways in which to filter lists of issues. */\nexport type IssueFilters = {\n  /**\n   * List issues assigned to given name. Pass in `null` for issues with no assigned\n   * user, and `*` for issues assigned to any user.\n   */\n  assignee?: InputMaybe<Scalars['String']>;\n  /** List issues created by given name. */\n  createdBy?: InputMaybe<Scalars['String']>;\n  /** List issues where the list of label names exist on the issue. */\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  /** List issues where the given name is mentioned in the issue. */\n  mentioned?: InputMaybe<Scalars['String']>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its database ID. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestone?: InputMaybe<Scalars['String']>;\n  /**\n   * List issues by given milestone argument. If an string representation of an\n   * integer is passed, it should refer to a milestone by its number field. Pass in\n   * `null` for issues with no milestone, and `*` for issues that are assigned to any milestone.\n   */\n  milestoneNumber?: InputMaybe<Scalars['String']>;\n  /** List issues that have been updated at or after the given date. */\n  since?: InputMaybe<Scalars['DateTime']>;\n  /** List issues filtered by the list of states given. */\n  states?: InputMaybe<Array<IssueState>>;\n  /** List issues subscribed to by viewer. */\n  viewerSubscribed?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Used for return value of Repository.issueOrPullRequest. */\nexport type IssueOrPullRequest = Issue | PullRequest;\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type IssueOrder = {\n  /** The direction in which to order issues by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order issues by. */\n  field: IssueOrderField;\n};\n\n/** Properties by which issue connections can be ordered. */\nexport enum IssueOrderField {\n  /** Order issues by comment count */\n  Comments = 'COMMENTS',\n  /** Order issues by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order issues by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of an issue. */\nexport enum IssueState {\n  /** An issue that has been closed */\n  Closed = 'CLOSED',\n  /** An issue that is still open */\n  Open = 'OPEN'\n}\n\n/** The possible state reasons of an issue. */\nexport enum IssueStateReason {\n  /** An issue that has been closed as completed */\n  Completed = 'COMPLETED',\n  /** An issue that has been closed as not planned */\n  NotPlanned = 'NOT_PLANNED',\n  /** An issue that has been reopened */\n  Reopened = 'REOPENED'\n}\n\n/** A repository issue template. */\nexport type IssueTemplate = {\n  __typename?: 'IssueTemplate';\n  /** The template purpose. */\n  about?: Maybe<Scalars['String']>;\n  /** The suggested assignees. */\n  assignees: UserConnection;\n  /** The suggested issue body. */\n  body?: Maybe<Scalars['String']>;\n  /** The template filename. */\n  filename: Scalars['String'];\n  /** The suggested issue labels */\n  labels?: Maybe<LabelConnection>;\n  /** The template name. */\n  name: Scalars['String'];\n  /** The suggested issue title. */\n  title?: Maybe<Scalars['String']>;\n};\n\n\n/** A repository issue template. */\nexport type IssueTemplateAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository issue template. */\nexport type IssueTemplateLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** The connection type for IssueTimelineItem. */\nexport type IssueTimelineConnection = {\n  __typename?: 'IssueTimelineConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItem = AssignedEvent | ClosedEvent | Commit | CrossReferencedEvent | DemilestonedEvent | IssueComment | LabeledEvent | LockedEvent | MilestonedEvent | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type IssueTimelineItemEdge = {\n  __typename?: 'IssueTimelineItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItem>;\n};\n\n/** An item in an issue timeline */\nexport type IssueTimelineItems = AddedToProjectEvent | AssignedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DisconnectedEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | ReferencedEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** The connection type for IssueTimelineItems. */\nexport type IssueTimelineItemsConnection = {\n  __typename?: 'IssueTimelineItemsConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<IssueTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<IssueTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int'];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** An edge in a connection. */\nexport type IssueTimelineItemsEdge = {\n  __typename?: 'IssueTimelineItemsEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<IssueTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum IssueTimelineItemsItemType {\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n/** Represents a user signing up for a GitHub account. */\nexport type JoinedGitHubContribution = Contribution & {\n  __typename?: 'JoinedGitHubContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type Label = Node & {\n  __typename?: 'Label';\n  /** Identifies the label color. */\n  color: Scalars['String'];\n  /** Identifies the date and time when the label was created. */\n  createdAt?: Maybe<Scalars['DateTime']>;\n  /** A brief description of this label. */\n  description?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Indicates whether or not this is a default label. */\n  isDefault: Scalars['Boolean'];\n  /** A list of issues associated with this label. */\n  issues: IssueConnection;\n  /** Identifies the label name. */\n  name: Scalars['String'];\n  /** A list of pull requests associated with this label. */\n  pullRequests: PullRequestConnection;\n  /** The repository associated with this label. */\n  repository: Repository;\n  /** The HTTP path for this label. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the label was last updated. */\n  updatedAt?: Maybe<Scalars['DateTime']>;\n  /** The HTTP URL for this label. */\n  url: Scalars['URI'];\n};\n\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A label for categorizing Issues, Pull Requests, Milestones, or Discussions with a given Repository. */\nexport type LabelPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Label. */\nexport type LabelConnection = {\n  __typename?: 'LabelConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LabelEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Label>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type LabelEdge = {\n  __typename?: 'LabelEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Label>;\n};\n\n/** Ways in which lists of labels can be ordered upon return. */\nexport type LabelOrder = {\n  /** The direction in which to order labels by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order labels by. */\n  field: LabelOrderField;\n};\n\n/** Properties by which label connections can be ordered. */\nexport enum LabelOrderField {\n  /** Order labels by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order labels by name */\n  Name = 'NAME'\n}\n\n/** An object that can have labels assigned to it. */\nexport type Labelable = {\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n};\n\n\n/** An object that can have labels assigned to it. */\nexport type LabelableLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n/** Represents a 'labeled' event on a given issue or pull request. */\nexport type LabeledEvent = Node & {\n  __typename?: 'LabeledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the label associated with the 'labeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Represents a given language found in repositories. */\nexport type Language = Node & {\n  __typename?: 'Language';\n  /** The color defined for the current language. */\n  color?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The name of the current language. */\n  name: Scalars['String'];\n};\n\n/** A list of languages associated with the parent. */\nexport type LanguageConnection = {\n  __typename?: 'LanguageConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LanguageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Language>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** The total size in bytes of files written in that language. */\n  totalSize: Scalars['Int'];\n};\n\n/** Represents the language of a repository. */\nexport type LanguageEdge = {\n  __typename?: 'LanguageEdge';\n  cursor: Scalars['String'];\n  node: Language;\n  /** The number of bytes of code written in the language. */\n  size: Scalars['Int'];\n};\n\n/** Ordering options for language connections. */\nexport type LanguageOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order languages by. */\n  field: LanguageOrderField;\n};\n\n/** Properties by which language connections can be ordered. */\nexport enum LanguageOrderField {\n  /** Order languages by the size of all files containing the language */\n  Size = 'SIZE'\n}\n\n/** A repository's open source license */\nexport type License = Node & {\n  __typename?: 'License';\n  /** The full text of the license */\n  body: Scalars['String'];\n  /** The conditions set by the license */\n  conditions: Array<Maybe<LicenseRule>>;\n  /** A human-readable description of the license */\n  description?: Maybe<Scalars['String']>;\n  /** Whether the license should be featured */\n  featured: Scalars['Boolean'];\n  /** Whether the license should be displayed in license pickers */\n  hidden: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** Instructions on how to implement the license */\n  implementation?: Maybe<Scalars['String']>;\n  /** The lowercased SPDX ID of the license */\n  key: Scalars['String'];\n  /** The limitations set by the license */\n  limitations: Array<Maybe<LicenseRule>>;\n  /** The license full name specified by <https://spdx.org/licenses> */\n  name: Scalars['String'];\n  /** Customary short name if applicable (e.g, GPLv3) */\n  nickname?: Maybe<Scalars['String']>;\n  /** The permissions set by the license */\n  permissions: Array<Maybe<LicenseRule>>;\n  /** Whether the license is a pseudo-license placeholder (e.g., other, no-license) */\n  pseudoLicense: Scalars['Boolean'];\n  /** Short identifier specified by <https://spdx.org/licenses> */\n  spdxId?: Maybe<Scalars['String']>;\n  /** URL to the license on <https://choosealicense.com> */\n  url?: Maybe<Scalars['URI']>;\n};\n\n/** Describes a License's conditions, permissions, and limitations */\nexport type LicenseRule = {\n  __typename?: 'LicenseRule';\n  /** A description of the rule */\n  description: Scalars['String'];\n  /** The machine-readable rule key */\n  key: Scalars['String'];\n  /** The human-readable rule label */\n  label: Scalars['String'];\n};\n\n/** Autogenerated input type of LinkProjectV2ToRepository */\nexport type LinkProjectV2ToRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the project to link to the repository. */\n  projectId: Scalars['ID'];\n  /** The ID of the repository to link to the project. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of LinkProjectV2ToRepository */\nexport type LinkProjectV2ToRepositoryPayload = {\n  __typename?: 'LinkProjectV2ToRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository the project is linked to. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of LinkProjectV2ToTeam */\nexport type LinkProjectV2ToTeamInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the project to link to the team. */\n  projectId: Scalars['ID'];\n  /** The ID of the team to link to the project. */\n  teamId: Scalars['ID'];\n};\n\n/** Autogenerated return type of LinkProjectV2ToTeam */\nexport type LinkProjectV2ToTeamPayload = {\n  __typename?: 'LinkProjectV2ToTeamPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The team the project is linked to */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project to link to a Repository */\n  projectId: Scalars['ID'];\n  /** The ID of the Repository to link to a Project. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of LinkRepositoryToProject */\nexport type LinkRepositoryToProjectPayload = {\n  __typename?: 'LinkRepositoryToProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** A branch linked to an issue. */\nexport type LinkedBranch = Node & {\n  __typename?: 'LinkedBranch';\n  id: Scalars['ID'];\n  /** The branch's ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** The connection type for LinkedBranch. */\nexport type LinkedBranchConnection = {\n  __typename?: 'LinkedBranchConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<LinkedBranchEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<LinkedBranch>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type LinkedBranchEdge = {\n  __typename?: 'LinkedBranchEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<LinkedBranch>;\n};\n\n/** Autogenerated input type of LockLockable */\nexport type LockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A reason for why the item will be locked. */\n  lockReason?: InputMaybe<LockReason>;\n  /** ID of the item to be locked. */\n  lockableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of LockLockable */\nexport type LockLockablePayload = {\n  __typename?: 'LockLockablePayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item that was locked. */\n  lockedRecord?: Maybe<Lockable>;\n};\n\n/** The possible reasons that an issue or pull request was locked. */\nexport enum LockReason {\n  /** The issue or pull request was locked because the conversation was off-topic. */\n  OffTopic = 'OFF_TOPIC',\n  /** The issue or pull request was locked because the conversation was resolved. */\n  Resolved = 'RESOLVED',\n  /** The issue or pull request was locked because the conversation was spam. */\n  Spam = 'SPAM',\n  /** The issue or pull request was locked because the conversation was too heated. */\n  TooHeated = 'TOO_HEATED'\n}\n\n/** An object that can be locked. */\nexport type Lockable = {\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** `true` if the object is locked */\n  locked: Scalars['Boolean'];\n};\n\n/** Represents a 'locked' event on a given issue or pull request. */\nexport type LockedEvent = Node & {\n  __typename?: 'LockedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Reason that the conversation was locked (optional). */\n  lockReason?: Maybe<LockReason>;\n  /** Object that was locked. */\n  lockable: Lockable;\n};\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type Mannequin = Actor & Node & UniformResourceLocatable & {\n  __typename?: 'Mannequin';\n  /** A URL pointing to the GitHub App's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** The user that has claimed the data attributed to this mannequin. */\n  claimant?: Maybe<User>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The mannequin's email on the source instance. */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The username of the actor. */\n  login: Scalars['String'];\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The URL to this resource. */\n  url: Scalars['URI'];\n};\n\n\n/** A placeholder user for attribution of imported data on GitHub. */\nexport type MannequinAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for Mannequin. */\nexport type MannequinConnection = {\n  __typename?: 'MannequinConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MannequinEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Mannequin>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a mannequin. */\nexport type MannequinEdge = {\n  __typename?: 'MannequinEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Mannequin>;\n};\n\n/** Ordering options for mannequins. */\nexport type MannequinOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order mannequins by. */\n  field: MannequinOrderField;\n};\n\n/** Properties by which mannequins can be ordered. */\nexport enum MannequinOrderField {\n  /** Order mannequins why when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order mannequins alphabetically by their source login. */\n  Login = 'LOGIN'\n}\n\n/** Autogenerated input type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to mark as an answer. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of MarkDiscussionCommentAsAnswer */\nexport type MarkDiscussionCommentAsAnswerPayload = {\n  __typename?: 'MarkDiscussionCommentAsAnswerPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that includes the chosen comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of MarkFileAsViewed */\nexport type MarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The path of the file to mark as viewed */\n  path: Scalars['String'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MarkFileAsViewed */\nexport type MarkFileAsViewedPayload = {\n  __typename?: 'MarkFileAsViewedPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of MarkProjectV2AsTemplate */\nexport type MarkProjectV2AsTemplateInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project to mark as a template. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MarkProjectV2AsTemplate */\nexport type MarkProjectV2AsTemplatePayload = {\n  __typename?: 'MarkProjectV2AsTemplatePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the pull request to be marked as ready for review. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MarkPullRequestReadyForReview */\nexport type MarkPullRequestReadyForReviewPayload = {\n  __typename?: 'MarkPullRequestReadyForReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that is ready for review. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\nexport type MarkedAsDuplicateEvent = Node & {\n  __typename?: 'MarkedAsDuplicateEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars['ID'];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean'];\n};\n\n/** A public description of a Marketplace category. */\nexport type MarketplaceCategory = Node & {\n  __typename?: 'MarketplaceCategory';\n  /** The category's description. */\n  description?: Maybe<Scalars['String']>;\n  /** The technical description of how apps listed in this category work with GitHub. */\n  howItWorks?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The category's name. */\n  name: Scalars['String'];\n  /** How many Marketplace listings have this as their primary category. */\n  primaryListingCount: Scalars['Int'];\n  /** The HTTP path for this Marketplace category. */\n  resourcePath: Scalars['URI'];\n  /** How many Marketplace listings have this as their secondary category. */\n  secondaryListingCount: Scalars['Int'];\n  /** The short name of the category used in its URL. */\n  slug: Scalars['String'];\n  /** The HTTP URL for this Marketplace category. */\n  url: Scalars['URI'];\n};\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListing = Node & {\n  __typename?: 'MarketplaceListing';\n  /** The GitHub App this listing represents. */\n  app?: Maybe<App>;\n  /** URL to the listing owner's company site. */\n  companyUrl?: Maybe<Scalars['URI']>;\n  /** The HTTP path for configuring access to the listing's integration or OAuth app */\n  configurationResourcePath: Scalars['URI'];\n  /** The HTTP URL for configuring access to the listing's integration or OAuth app */\n  configurationUrl: Scalars['URI'];\n  /** URL to the listing's documentation. */\n  documentationUrl?: Maybe<Scalars['URI']>;\n  /** The listing's detailed description. */\n  extendedDescription?: Maybe<Scalars['String']>;\n  /** The listing's detailed description rendered to HTML. */\n  extendedDescriptionHTML: Scalars['HTML'];\n  /** The listing's introductory description. */\n  fullDescription: Scalars['String'];\n  /** The listing's introductory description rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML'];\n  /** Does this listing have any plans with a free trial? */\n  hasPublishedFreeTrialPlans: Scalars['Boolean'];\n  /** Does this listing have a terms of service link? */\n  hasTermsOfService: Scalars['Boolean'];\n  /** Whether the creator of the app is a verified org */\n  hasVerifiedOwner: Scalars['Boolean'];\n  /** A technical description of how this app works with GitHub. */\n  howItWorks?: Maybe<Scalars['String']>;\n  /** The listing's technical description rendered to HTML. */\n  howItWorksHTML: Scalars['HTML'];\n  id: Scalars['ID'];\n  /** URL to install the product to the viewer's account or organization. */\n  installationUrl?: Maybe<Scalars['URI']>;\n  /** Whether this listing's app has been installed for the current viewer */\n  installedForViewer: Scalars['Boolean'];\n  /** Whether this listing has been removed from the Marketplace. */\n  isArchived: Scalars['Boolean'];\n  /**\n   * Whether this listing is still an editable draft that has not been submitted\n   * for review and is not publicly visible in the Marketplace.\n   */\n  isDraft: Scalars['Boolean'];\n  /** Whether the product this listing represents is available as part of a paid plan. */\n  isPaid: Scalars['Boolean'];\n  /** Whether this listing has been approved for display in the Marketplace. */\n  isPublic: Scalars['Boolean'];\n  /** Whether this listing has been rejected by GitHub for display in the Marketplace. */\n  isRejected: Scalars['Boolean'];\n  /** Whether this listing has been approved for unverified display in the Marketplace. */\n  isUnverified: Scalars['Boolean'];\n  /** Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace. */\n  isUnverifiedPending: Scalars['Boolean'];\n  /** Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromDraft: Scalars['Boolean'];\n  /** Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace. */\n  isVerificationPendingFromUnverified: Scalars['Boolean'];\n  /** Whether this listing has been approved for verified display in the Marketplace. */\n  isVerified: Scalars['Boolean'];\n  /** The hex color code, without the leading '#', for the logo background. */\n  logoBackgroundColor: Scalars['String'];\n  /** URL for the listing's logo image. */\n  logoUrl?: Maybe<Scalars['URI']>;\n  /** The listing's full name. */\n  name: Scalars['String'];\n  /** The listing's very short description without a trailing period or ampersands. */\n  normalizedShortDescription: Scalars['String'];\n  /** URL to the listing's detailed pricing. */\n  pricingUrl?: Maybe<Scalars['URI']>;\n  /** The category that best describes the listing. */\n  primaryCategory: MarketplaceCategory;\n  /** URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL. */\n  privacyPolicyUrl: Scalars['URI'];\n  /** The HTTP path for the Marketplace listing. */\n  resourcePath: Scalars['URI'];\n  /** The URLs for the listing's screenshots. */\n  screenshotUrls: Array<Maybe<Scalars['String']>>;\n  /** An alternate category that describes the listing. */\n  secondaryCategory?: Maybe<MarketplaceCategory>;\n  /** The listing's very short description. */\n  shortDescription: Scalars['String'];\n  /** The short name of the listing used in its URL. */\n  slug: Scalars['String'];\n  /** URL to the listing's status page. */\n  statusUrl?: Maybe<Scalars['URI']>;\n  /** An email address for support for this listing's app. */\n  supportEmail?: Maybe<Scalars['String']>;\n  /**\n   * Either a URL or an email address for support for this listing's app, may\n   * return an empty string for listings that do not require a support URL.\n   */\n  supportUrl: Scalars['URI'];\n  /** URL to the listing's terms of service. */\n  termsOfServiceUrl?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the Marketplace listing. */\n  url: Scalars['URI'];\n  /** Can the current viewer add plans for this Marketplace listing. */\n  viewerCanAddPlans: Scalars['Boolean'];\n  /** Can the current viewer approve this Marketplace listing. */\n  viewerCanApprove: Scalars['Boolean'];\n  /** Can the current viewer delist this Marketplace listing. */\n  viewerCanDelist: Scalars['Boolean'];\n  /** Can the current viewer edit this Marketplace listing. */\n  viewerCanEdit: Scalars['Boolean'];\n  /**\n   * Can the current viewer edit the primary and secondary category of this\n   * Marketplace listing.\n   */\n  viewerCanEditCategories: Scalars['Boolean'];\n  /** Can the current viewer edit the plans for this Marketplace listing. */\n  viewerCanEditPlans: Scalars['Boolean'];\n  /**\n   * Can the current viewer return this Marketplace listing to draft state\n   * so it becomes editable again.\n   */\n  viewerCanRedraft: Scalars['Boolean'];\n  /**\n   * Can the current viewer reject this Marketplace listing by returning it to\n   * an editable draft state or rejecting it entirely.\n   */\n  viewerCanReject: Scalars['Boolean'];\n  /**\n   * Can the current viewer request this listing be reviewed for display in\n   * the Marketplace as verified.\n   */\n  viewerCanRequestApproval: Scalars['Boolean'];\n  /** Indicates whether the current user has an active subscription to this Marketplace listing. */\n  viewerHasPurchased: Scalars['Boolean'];\n  /**\n   * Indicates if the current user has purchased a subscription to this Marketplace listing\n   * for all of the organizations the user owns.\n   */\n  viewerHasPurchasedForAllOrganizations: Scalars['Boolean'];\n  /** Does the current viewer role allow them to administer this Marketplace listing. */\n  viewerIsListingAdmin: Scalars['Boolean'];\n};\n\n\n/** A listing in the GitHub integration marketplace. */\nexport type MarketplaceListingLogoUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n/** Look up Marketplace Listings */\nexport type MarketplaceListingConnection = {\n  __typename?: 'MarketplaceListingConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MarketplaceListingEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MarketplaceListing>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MarketplaceListingEdge = {\n  __typename?: 'MarketplaceListingEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MarketplaceListing>;\n};\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusable = {\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n};\n\n\n/** Entities that have members who can set status messages. */\nexport type MemberStatusableMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n/** Audit log entry for a members_can_delete_repos.clear event. */\nexport type MembersCanDeleteReposClearAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'MembersCanDeleteReposClearAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a members_can_delete_repos.disable event. */\nexport type MembersCanDeleteReposDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'MembersCanDeleteReposDisableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a members_can_delete_repos.enable event. */\nexport type MembersCanDeleteReposEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'MembersCanDeleteReposEnableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Represents a 'mentioned' event on a given issue or pull request. */\nexport type MentionedEvent = Node & {\n  __typename?: 'MentionedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n};\n\n/** Autogenerated input type of MergeBranch */\nexport type MergeBranchInput = {\n  /** The email address to associate with this commit. */\n  authorEmail?: InputMaybe<Scalars['String']>;\n  /** The name of the base branch that the provided head will be merged into. */\n  base: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Message to use for the merge commit. If omitted, a default will be used. */\n  commitMessage?: InputMaybe<Scalars['String']>;\n  /** The head to merge into the base branch. This can be a branch name or a commit GitObjectID. */\n  head: Scalars['String'];\n  /** The Node ID of the Repository containing the base branch that will be modified. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MergeBranch */\nexport type MergeBranchPayload = {\n  __typename?: 'MergeBranchPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The resulting merge Commit. */\n  mergeCommit?: Maybe<Commit>;\n};\n\n/** The possible default commit messages for merges. */\nexport enum MergeCommitMessage {\n  /** Default to a blank commit message. */\n  Blank = 'BLANK',\n  /** Default to the pull request's body. */\n  PrBody = 'PR_BODY',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** The possible default commit titles for merges. */\nexport enum MergeCommitTitle {\n  /** Default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name). */\n  MergeMessage = 'MERGE_MESSAGE',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** Autogenerated input type of MergePullRequest */\nexport type MergePullRequestInput = {\n  /** The email address to associate with this merge. */\n  authorEmail?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Commit body to use for the merge commit; if omitted, a default message will be used */\n  commitBody?: InputMaybe<Scalars['String']>;\n  /** Commit headline to use for the merge commit; if omitted, a default message will be used. */\n  commitHeadline?: InputMaybe<Scalars['String']>;\n  /** OID that the pull request head ref must match to allow merge; if omitted, no check is performed. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']>;\n  /** The merge method to use. If omitted, defaults to 'MERGE' */\n  mergeMethod?: InputMaybe<PullRequestMergeMethod>;\n  /** ID of the pull request to be merged. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MergePullRequest */\nexport type MergePullRequestPayload = {\n  __typename?: 'MergePullRequestPayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that was merged. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** The queue of pull request entries to be merged into a protected branch in a repository. */\nexport type MergeQueue = Node & {\n  __typename?: 'MergeQueue';\n  /** The configuration for this merge queue */\n  configuration?: Maybe<MergeQueueConfiguration>;\n  /** The entries in the queue */\n  entries?: Maybe<MergeQueueEntryConnection>;\n  id: Scalars['ID'];\n  /** The estimated time in seconds until a newly added entry would be merged */\n  nextEntryEstimatedTimeToMerge?: Maybe<Scalars['Int']>;\n  /** The repository this merge queue belongs to */\n  repository?: Maybe<Repository>;\n  /** The HTTP path for this merge queue */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this merge queue */\n  url: Scalars['URI'];\n};\n\n\n/** The queue of pull request entries to be merged into a protected branch in a repository. */\nexport type MergeQueueEntriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Configuration for a MergeQueue */\nexport type MergeQueueConfiguration = {\n  __typename?: 'MergeQueueConfiguration';\n  /** The amount of time in minutes to wait for a check response before considering it a failure. */\n  checkResponseTimeout?: Maybe<Scalars['Int']>;\n  /** The maximum number of entries to build at once. */\n  maximumEntriesToBuild?: Maybe<Scalars['Int']>;\n  /** The maximum number of entries to merge at once. */\n  maximumEntriesToMerge?: Maybe<Scalars['Int']>;\n  /** The merge method to use for this queue. */\n  mergeMethod?: Maybe<PullRequestMergeMethod>;\n  /** The strategy to use when merging entries. */\n  mergingStrategy?: Maybe<MergeQueueMergingStrategy>;\n  /** The minimum number of entries required to merge at once. */\n  minimumEntriesToMerge?: Maybe<Scalars['Int']>;\n  /**\n   * The amount of time in minutes to wait before ignoring the minumum number of\n   * entries in the queue requirement and merging a collection of entries\n   */\n  minimumEntriesToMergeWaitTime?: Maybe<Scalars['Int']>;\n};\n\n/** Entries in a MergeQueue */\nexport type MergeQueueEntry = Node & {\n  __typename?: 'MergeQueueEntry';\n  /** The base commit for this entry */\n  baseCommit?: Maybe<Commit>;\n  /** The date and time this entry was added to the merge queue */\n  enqueuedAt: Scalars['DateTime'];\n  /** The actor that enqueued this entry */\n  enqueuer: Actor;\n  /** The estimated time in seconds until this entry will be merged */\n  estimatedTimeToMerge?: Maybe<Scalars['Int']>;\n  /** The head commit for this entry */\n  headCommit?: Maybe<Commit>;\n  id: Scalars['ID'];\n  /** Whether this pull request should jump the queue */\n  jump: Scalars['Boolean'];\n  /** The merge queue that this entry belongs to */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** The position of this entry in the queue */\n  position: Scalars['Int'];\n  /** The pull request that will be added to a merge group */\n  pullRequest?: Maybe<PullRequest>;\n  /** Does this pull request need to be deployed on its own */\n  solo: Scalars['Boolean'];\n  /** The state of this entry in the queue */\n  state: MergeQueueEntryState;\n};\n\n/** The connection type for MergeQueueEntry. */\nexport type MergeQueueEntryConnection = {\n  __typename?: 'MergeQueueEntryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MergeQueueEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<MergeQueueEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MergeQueueEntryEdge = {\n  __typename?: 'MergeQueueEntryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<MergeQueueEntry>;\n};\n\n/** The possible states for a merge queue entry. */\nexport enum MergeQueueEntryState {\n  /** The entry is currently waiting for checks to pass. */\n  AwaitingChecks = 'AWAITING_CHECKS',\n  /** The entry is currently locked. */\n  Locked = 'LOCKED',\n  /** The entry is currently mergeable. */\n  Mergeable = 'MERGEABLE',\n  /** The entry is currently queued. */\n  Queued = 'QUEUED',\n  /** The entry is currently unmergeable. */\n  Unmergeable = 'UNMERGEABLE'\n}\n\n/** The possible merging strategies for a merge queue. */\nexport enum MergeQueueMergingStrategy {\n  /** Entries only allowed to merge if they are passing. */\n  Allgreen = 'ALLGREEN',\n  /** Failing Entires are allowed to merge if they are with a passing entry. */\n  Headgreen = 'HEADGREEN'\n}\n\n/** Detailed status information about a pull request merge. */\nexport enum MergeStateStatus {\n  /** The head ref is out of date. */\n  Behind = 'BEHIND',\n  /** The merge is blocked. */\n  Blocked = 'BLOCKED',\n  /** Mergeable and passing commit status. */\n  Clean = 'CLEAN',\n  /** The merge commit cannot be cleanly created. */\n  Dirty = 'DIRTY',\n  /**\n   * The merge is blocked due to the pull request being a draft.\n   * @deprecated DRAFT state will be removed from this enum and `isDraft` should be used instead Use PullRequest.isDraft instead. Removal on 2021-01-01 UTC.\n   */\n  Draft = 'DRAFT',\n  /** Mergeable with passing commit status and pre-receive hooks. */\n  HasHooks = 'HAS_HOOKS',\n  /** The state cannot currently be determined. */\n  Unknown = 'UNKNOWN',\n  /** Mergeable with non-passing commit status. */\n  Unstable = 'UNSTABLE'\n}\n\n/** Whether or not a PullRequest can be merged. */\nexport enum MergeableState {\n  /** The pull request cannot be merged due to merge conflicts. */\n  Conflicting = 'CONFLICTING',\n  /** The pull request can be merged. */\n  Mergeable = 'MERGEABLE',\n  /** The mergeability of the pull request is still being calculated. */\n  Unknown = 'UNKNOWN'\n}\n\n/** Represents a 'merged' event on a given pull request. */\nexport type MergedEvent = Node & UniformResourceLocatable & {\n  __typename?: 'MergedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the commit associated with the `merge` event. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the Ref associated with the `merge` event. */\n  mergeRef?: Maybe<Ref>;\n  /** Identifies the name of the Ref associated with the `merge` event. */\n  mergeRefName: Scalars['String'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this merged event. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this merged event. */\n  url: Scalars['URI'];\n};\n\n/** Represents a GitHub Enterprise Importer (GEI) migration. */\nexport type Migration = {\n  /** The migration flag to continue on error. */\n  continueOnError: Scalars['Boolean'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']>;\n  /** The reason the migration failed. */\n  failureReason?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The URL for the migration log (expires 1 day after migration completes). */\n  migrationLogUrl?: Maybe<Scalars['URI']>;\n  /** The migration source. */\n  migrationSource: MigrationSource;\n  /** The target repository name. */\n  repositoryName: Scalars['String'];\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  sourceUrl: Scalars['URI'];\n  /** The migration state. */\n  state: MigrationState;\n  /**\n   * The number of warnings encountered for this migration. To review the warnings,\n   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).\n   */\n  warningsCount: Scalars['Int'];\n};\n\n/** A GitHub Enterprise Importer (GEI) migration source. */\nexport type MigrationSource = Node & {\n  __typename?: 'MigrationSource';\n  id: Scalars['ID'];\n  /** The migration source name. */\n  name: Scalars['String'];\n  /** The migration source type. */\n  type: MigrationSourceType;\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  url: Scalars['URI'];\n};\n\n/** Represents the different GitHub Enterprise Importer (GEI) migration sources. */\nexport enum MigrationSourceType {\n  /** An Azure DevOps migration source. */\n  AzureDevops = 'AZURE_DEVOPS',\n  /** A Bitbucket Server migration source. */\n  BitbucketServer = 'BITBUCKET_SERVER',\n  /** A GitHub Migration API source. */\n  GithubArchive = 'GITHUB_ARCHIVE'\n}\n\n/** The GitHub Enterprise Importer (GEI) migration state. */\nexport enum MigrationState {\n  /** The migration has failed. */\n  Failed = 'FAILED',\n  /** The migration has invalid credentials. */\n  FailedValidation = 'FAILED_VALIDATION',\n  /** The migration is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The migration has not started. */\n  NotStarted = 'NOT_STARTED',\n  /** The migration needs to have its credentials validated. */\n  PendingValidation = 'PENDING_VALIDATION',\n  /** The migration has been queued. */\n  Queued = 'QUEUED',\n  /** The migration has succeeded. */\n  Succeeded = 'SUCCEEDED'\n}\n\n/** Represents a Milestone object on a given repository. */\nexport type Milestone = Closable & Node & UniformResourceLocatable & {\n  __typename?: 'Milestone';\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the actor who created the milestone. */\n  creator?: Maybe<Actor>;\n  /** Identifies the description of the milestone. */\n  description?: Maybe<Scalars['String']>;\n  /** Identifies the due date of the milestone. */\n  dueOn?: Maybe<Scalars['DateTime']>;\n  id: Scalars['ID'];\n  /** A list of issues associated with the milestone. */\n  issues: IssueConnection;\n  /** Identifies the number of the milestone. */\n  number: Scalars['Int'];\n  /** Identifies the percentage complete for the milestone */\n  progressPercentage: Scalars['Float'];\n  /** A list of pull requests associated with the milestone. */\n  pullRequests: PullRequestConnection;\n  /** The repository associated with this milestone. */\n  repository: Repository;\n  /** The HTTP path for this milestone */\n  resourcePath: Scalars['URI'];\n  /** Identifies the state of the milestone. */\n  state: MilestoneState;\n  /** Identifies the title of the milestone. */\n  title: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this milestone */\n  url: Scalars['URI'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n};\n\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestoneIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** Represents a Milestone object on a given repository. */\nexport type MilestonePullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n/** The connection type for Milestone. */\nexport type MilestoneConnection = {\n  __typename?: 'MilestoneConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<MilestoneEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Milestone>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type MilestoneEdge = {\n  __typename?: 'MilestoneEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Milestone>;\n};\n\n/** Types that can be inside a Milestone. */\nexport type MilestoneItem = Issue | PullRequest;\n\n/** Ordering options for milestone connections. */\nexport type MilestoneOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order milestones by. */\n  field: MilestoneOrderField;\n};\n\n/** Properties by which milestone connections can be ordered. */\nexport enum MilestoneOrderField {\n  /** Order milestones by when they were created. */\n  CreatedAt = 'CREATED_AT',\n  /** Order milestones by when they are due. */\n  DueDate = 'DUE_DATE',\n  /** Order milestones by their number. */\n  Number = 'NUMBER',\n  /** Order milestones by when they were last updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible states of a milestone. */\nexport enum MilestoneState {\n  /** A milestone that has been closed. */\n  Closed = 'CLOSED',\n  /** A milestone that is still open. */\n  Open = 'OPEN'\n}\n\n/** Represents a 'milestoned' event on a given issue or pull request. */\nexport type MilestonedEvent = Node & {\n  __typename?: 'MilestonedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the milestone title associated with the 'milestoned' event. */\n  milestoneTitle: Scalars['String'];\n  /** Object referenced by event. */\n  subject: MilestoneItem;\n};\n\n/** Entities that can be minimized. */\nexport type Minimizable = {\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of MinimizeComment */\nexport type MinimizeCommentInput = {\n  /** The classification of comment */\n  classifier: ReportedContentClassifiers;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MinimizeComment */\nexport type MinimizeCommentPayload = {\n  __typename?: 'MinimizeCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The comment that was minimized. */\n  minimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of MoveProjectCard */\nexport type MoveProjectCardInput = {\n  /** Place the new card after the card with this id. Pass null to place it at the top. */\n  afterCardId?: InputMaybe<Scalars['ID']>;\n  /** The id of the card to move. */\n  cardId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the column to move it into. */\n  columnId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MoveProjectCard */\nexport type MoveProjectCardPayload = {\n  __typename?: 'MoveProjectCardPayload';\n  /** The new edge of the moved card. */\n  cardEdge?: Maybe<ProjectCardEdge>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of MoveProjectColumn */\nexport type MoveProjectColumnInput = {\n  /** Place the new column after the column with this id. Pass null to place it at the front. */\n  afterColumnId?: InputMaybe<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The id of the column to move. */\n  columnId: Scalars['ID'];\n};\n\n/** Autogenerated return type of MoveProjectColumn */\nexport type MoveProjectColumnPayload = {\n  __typename?: 'MoveProjectColumnPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new edge of the moved column. */\n  columnEdge?: Maybe<ProjectColumnEdge>;\n};\n\n/** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\nexport type MovedColumnsInProjectEvent = Node & {\n  __typename?: 'MovedColumnsInProjectEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Column name the issue or pull request was moved from. */\n  previousProjectColumnName: Scalars['String'];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Project card referenced by this project event. */\n  projectCard?: Maybe<ProjectCard>;\n  /** Column name the issue or pull request was moved to. */\n  projectColumnName: Scalars['String'];\n};\n\n/** The root query for implementing GraphQL mutations. */\nexport type Mutation = {\n  __typename?: 'Mutation';\n  /** Clear all of a customer's queued migrations */\n  abortQueuedMigrations?: Maybe<AbortQueuedMigrationsPayload>;\n  /** Accepts a pending invitation for a user to become an administrator of an enterprise. */\n  acceptEnterpriseAdministratorInvitation?: Maybe<AcceptEnterpriseAdministratorInvitationPayload>;\n  /** Applies a suggested topic to the repository. */\n  acceptTopicSuggestion?: Maybe<AcceptTopicSuggestionPayload>;\n  /** Adds assignees to an assignable object. */\n  addAssigneesToAssignable?: Maybe<AddAssigneesToAssignablePayload>;\n  /** Adds a comment to an Issue or Pull Request. */\n  addComment?: Maybe<AddCommentPayload>;\n  /** Adds a comment to a Discussion, possibly as a reply to another comment. */\n  addDiscussionComment?: Maybe<AddDiscussionCommentPayload>;\n  /** Vote for an option in a discussion poll. */\n  addDiscussionPollVote?: Maybe<AddDiscussionPollVotePayload>;\n  /** Adds enterprise members to an organization within the enterprise. */\n  addEnterpriseOrganizationMember?: Maybe<AddEnterpriseOrganizationMemberPayload>;\n  /** Adds a support entitlement to an enterprise member. */\n  addEnterpriseSupportEntitlement?: Maybe<AddEnterpriseSupportEntitlementPayload>;\n  /** Adds labels to a labelable object. */\n  addLabelsToLabelable?: Maybe<AddLabelsToLabelablePayload>;\n  /** Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both. */\n  addProjectCard?: Maybe<AddProjectCardPayload>;\n  /** Adds a column to a Project. */\n  addProjectColumn?: Maybe<AddProjectColumnPayload>;\n  /** Creates a new draft issue and add it to a Project. */\n  addProjectV2DraftIssue?: Maybe<AddProjectV2DraftIssuePayload>;\n  /** Links an existing content instance to a Project. */\n  addProjectV2ItemById?: Maybe<AddProjectV2ItemByIdPayload>;\n  /** Adds a review to a Pull Request. */\n  addPullRequestReview?: Maybe<AddPullRequestReviewPayload>;\n  /** Adds a comment to a review. */\n  addPullRequestReviewComment?: Maybe<AddPullRequestReviewCommentPayload>;\n  /** Adds a new thread to a pending Pull Request Review. */\n  addPullRequestReviewThread?: Maybe<AddPullRequestReviewThreadPayload>;\n  /** Adds a reaction to a subject. */\n  addReaction?: Maybe<AddReactionPayload>;\n  /** Adds a star to a Starrable. */\n  addStar?: Maybe<AddStarPayload>;\n  /** Add an upvote to a discussion or discussion comment. */\n  addUpvote?: Maybe<AddUpvotePayload>;\n  /** Adds a verifiable domain to an owning account. */\n  addVerifiableDomain?: Maybe<AddVerifiableDomainPayload>;\n  /** Approve all pending deployments under one or more environments */\n  approveDeployments?: Maybe<ApproveDeploymentsPayload>;\n  /** Approve a verifiable domain for notification delivery. */\n  approveVerifiableDomain?: Maybe<ApproveVerifiableDomainPayload>;\n  /** Archives a ProjectV2Item */\n  archiveProjectV2Item?: Maybe<ArchiveProjectV2ItemPayload>;\n  /** Marks a repository as archived. */\n  archiveRepository?: Maybe<ArchiveRepositoryPayload>;\n  /** Cancels a pending invitation for an administrator to join an enterprise. */\n  cancelEnterpriseAdminInvitation?: Maybe<CancelEnterpriseAdminInvitationPayload>;\n  /** Cancel an active sponsorship. */\n  cancelSponsorship?: Maybe<CancelSponsorshipPayload>;\n  /** Update your status on GitHub. */\n  changeUserStatus?: Maybe<ChangeUserStatusPayload>;\n  /** Clears all labels from a labelable object. */\n  clearLabelsFromLabelable?: Maybe<ClearLabelsFromLabelablePayload>;\n  /**\n   * This mutation clears the value of a field for an item in a Project. Currently\n   * only text, number, date, assignees, labels, single-select, iteration and\n   * milestone fields are supported.\n   */\n  clearProjectV2ItemFieldValue?: Maybe<ClearProjectV2ItemFieldValuePayload>;\n  /** Creates a new project by cloning configuration from an existing project. */\n  cloneProject?: Maybe<CloneProjectPayload>;\n  /** Create a new repository with the same files and directory structure as a template repository. */\n  cloneTemplateRepository?: Maybe<CloneTemplateRepositoryPayload>;\n  /** Close a discussion. */\n  closeDiscussion?: Maybe<CloseDiscussionPayload>;\n  /** Close an issue. */\n  closeIssue?: Maybe<CloseIssuePayload>;\n  /** Close a pull request. */\n  closePullRequest?: Maybe<ClosePullRequestPayload>;\n  /** Convert a project note card to one associated with a newly created issue. */\n  convertProjectCardNoteToIssue?: Maybe<ConvertProjectCardNoteToIssuePayload>;\n  /** Converts a pull request to draft */\n  convertPullRequestToDraft?: Maybe<ConvertPullRequestToDraftPayload>;\n  /** Copy a project. */\n  copyProjectV2?: Maybe<CopyProjectV2Payload>;\n  /** Invites a user to claim reattributable data */\n  createAttributionInvitation?: Maybe<CreateAttributionInvitationPayload>;\n  /** Create a new branch protection rule */\n  createBranchProtectionRule?: Maybe<CreateBranchProtectionRulePayload>;\n  /** Create a check run. */\n  createCheckRun?: Maybe<CreateCheckRunPayload>;\n  /** Create a check suite */\n  createCheckSuite?: Maybe<CreateCheckSuitePayload>;\n  /**\n   * Appends a commit to the given branch as the authenticated user.\n   *\n   * This mutation creates a commit whose parent is the HEAD of the provided\n   * branch and also updates that branch to point to the new commit.\n   * It can be thought of as similar to `git commit`.\n   *\n   * ### Locating a Branch\n   *\n   * Commits are appended to a `branch` of type `Ref`.\n   * This must refer to a git branch (i.e.  the fully qualified path must\n   * begin with `refs/heads/`, although including this prefix is optional.\n   *\n   * Callers may specify the `branch` to commit to either by its global node\n   * ID or by passing both of `repositoryNameWithOwner` and `refName`.  For\n   * more details see the documentation for `CommittableBranch`.\n   *\n   * ### Describing Changes\n   *\n   * `fileChanges` are specified as a `FilesChanges` object describing\n   * `FileAdditions` and `FileDeletions`.\n   *\n   * Please see the documentation for `FileChanges` for more information on\n   * how to use this argument to describe any set of file changes.\n   *\n   * ### Authorship\n   *\n   * Similar to the web commit interface, this mutation does not support\n   * specifying the author or committer of the commit and will not add\n   * support for this in the future.\n   *\n   * A commit created by a successful execution of this mutation will be\n   * authored by the owner of the credential which authenticates the API\n   * request.  The committer will be identical to that of commits authored\n   * using the web interface.\n   *\n   * If you need full control over author and committer information, please\n   * use the Git Database REST API instead.\n   *\n   * ### Commit Signing\n   *\n   * Commits made using this mutation are automatically signed by GitHub if\n   * supported and will be marked as verified in the user interface.\n   */\n  createCommitOnBranch?: Maybe<CreateCommitOnBranchPayload>;\n  /** Creates a new deployment event. */\n  createDeployment?: Maybe<CreateDeploymentPayload>;\n  /** Create a deployment status. */\n  createDeploymentStatus?: Maybe<CreateDeploymentStatusPayload>;\n  /** Create a discussion. */\n  createDiscussion?: Maybe<CreateDiscussionPayload>;\n  /** Creates an organization as part of an enterprise account. */\n  createEnterpriseOrganization?: Maybe<CreateEnterpriseOrganizationPayload>;\n  /** Creates an environment or simply returns it if already exists. */\n  createEnvironment?: Maybe<CreateEnvironmentPayload>;\n  /** Creates a new IP allow list entry. */\n  createIpAllowListEntry?: Maybe<CreateIpAllowListEntryPayload>;\n  /** Creates a new issue. */\n  createIssue?: Maybe<CreateIssuePayload>;\n  /** Creates a new label. */\n  createLabel?: Maybe<CreateLabelPayload>;\n  /** Create a branch linked to an issue. */\n  createLinkedBranch?: Maybe<CreateLinkedBranchPayload>;\n  /** Creates a GitHub Enterprise Importer (GEI) migration source. */\n  createMigrationSource?: Maybe<CreateMigrationSourcePayload>;\n  /** Creates a new project. */\n  createProject?: Maybe<CreateProjectPayload>;\n  /** Creates a new project. */\n  createProjectV2?: Maybe<CreateProjectV2Payload>;\n  /** Create a new project field. */\n  createProjectV2Field?: Maybe<CreateProjectV2FieldPayload>;\n  /** Create a new pull request */\n  createPullRequest?: Maybe<CreatePullRequestPayload>;\n  /** Create a new Git Ref. */\n  createRef?: Maybe<CreateRefPayload>;\n  /** Create a new repository. */\n  createRepository?: Maybe<CreateRepositoryPayload>;\n  /** Create a repository ruleset */\n  createRepositoryRuleset?: Maybe<CreateRepositoryRulesetPayload>;\n  /** Create a GitHub Sponsors profile to allow others to sponsor you or your organization. */\n  createSponsorsListing?: Maybe<CreateSponsorsListingPayload>;\n  /** Create a new payment tier for your GitHub Sponsors profile. */\n  createSponsorsTier?: Maybe<CreateSponsorsTierPayload>;\n  /** Start a new sponsorship of a maintainer in GitHub Sponsors, or reactivate a past sponsorship. */\n  createSponsorship?: Maybe<CreateSponsorshipPayload>;\n  /**\n   * Make many one-time sponsorships for different sponsorable users or\n   * organizations at once. Can only sponsor those who have a public GitHub\n   * Sponsors profile.\n   */\n  createSponsorships?: Maybe<CreateSponsorshipsPayload>;\n  /** Creates a new team discussion. */\n  createTeamDiscussion?: Maybe<CreateTeamDiscussionPayload>;\n  /** Creates a new team discussion comment. */\n  createTeamDiscussionComment?: Maybe<CreateTeamDiscussionCommentPayload>;\n  /** Rejects a suggested topic for the repository. */\n  declineTopicSuggestion?: Maybe<DeclineTopicSuggestionPayload>;\n  /** Delete a branch protection rule */\n  deleteBranchProtectionRule?: Maybe<DeleteBranchProtectionRulePayload>;\n  /** Deletes a deployment. */\n  deleteDeployment?: Maybe<DeleteDeploymentPayload>;\n  /** Delete a discussion and all of its replies. */\n  deleteDiscussion?: Maybe<DeleteDiscussionPayload>;\n  /** Delete a discussion comment. If it has replies, wipe it instead. */\n  deleteDiscussionComment?: Maybe<DeleteDiscussionCommentPayload>;\n  /** Deletes an environment */\n  deleteEnvironment?: Maybe<DeleteEnvironmentPayload>;\n  /** Deletes an IP allow list entry. */\n  deleteIpAllowListEntry?: Maybe<DeleteIpAllowListEntryPayload>;\n  /** Deletes an Issue object. */\n  deleteIssue?: Maybe<DeleteIssuePayload>;\n  /** Deletes an IssueComment object. */\n  deleteIssueComment?: Maybe<DeleteIssueCommentPayload>;\n  /** Deletes a label. */\n  deleteLabel?: Maybe<DeleteLabelPayload>;\n  /** Unlink a branch from an issue. */\n  deleteLinkedBranch?: Maybe<DeleteLinkedBranchPayload>;\n  /** Delete a package version. */\n  deletePackageVersion?: Maybe<DeletePackageVersionPayload>;\n  /** Deletes a project. */\n  deleteProject?: Maybe<DeleteProjectPayload>;\n  /** Deletes a project card. */\n  deleteProjectCard?: Maybe<DeleteProjectCardPayload>;\n  /** Deletes a project column. */\n  deleteProjectColumn?: Maybe<DeleteProjectColumnPayload>;\n  /** Delete a project. */\n  deleteProjectV2?: Maybe<DeleteProjectV2Payload>;\n  /** Delete a project field. */\n  deleteProjectV2Field?: Maybe<DeleteProjectV2FieldPayload>;\n  /** Deletes an item from a Project. */\n  deleteProjectV2Item?: Maybe<DeleteProjectV2ItemPayload>;\n  /** Deletes a project workflow. */\n  deleteProjectV2Workflow?: Maybe<DeleteProjectV2WorkflowPayload>;\n  /** Deletes a pull request review. */\n  deletePullRequestReview?: Maybe<DeletePullRequestReviewPayload>;\n  /** Deletes a pull request review comment. */\n  deletePullRequestReviewComment?: Maybe<DeletePullRequestReviewCommentPayload>;\n  /** Delete a Git Ref. */\n  deleteRef?: Maybe<DeleteRefPayload>;\n  /** Delete a repository ruleset */\n  deleteRepositoryRuleset?: Maybe<DeleteRepositoryRulesetPayload>;\n  /** Deletes a team discussion. */\n  deleteTeamDiscussion?: Maybe<DeleteTeamDiscussionPayload>;\n  /** Deletes a team discussion comment. */\n  deleteTeamDiscussionComment?: Maybe<DeleteTeamDiscussionCommentPayload>;\n  /** Deletes a verifiable domain. */\n  deleteVerifiableDomain?: Maybe<DeleteVerifiableDomainPayload>;\n  /** Remove a pull request from the merge queue. */\n  dequeuePullRequest?: Maybe<DequeuePullRequestPayload>;\n  /** Disable auto merge on the given pull request */\n  disablePullRequestAutoMerge?: Maybe<DisablePullRequestAutoMergePayload>;\n  /** Dismisses an approved or rejected pull request review. */\n  dismissPullRequestReview?: Maybe<DismissPullRequestReviewPayload>;\n  /** Dismisses the Dependabot alert. */\n  dismissRepositoryVulnerabilityAlert?: Maybe<DismissRepositoryVulnerabilityAlertPayload>;\n  /** Enable the default auto-merge on a pull request. */\n  enablePullRequestAutoMerge?: Maybe<EnablePullRequestAutoMergePayload>;\n  /** Add a pull request to the merge queue. */\n  enqueuePullRequest?: Maybe<EnqueuePullRequestPayload>;\n  /** Follow an organization. */\n  followOrganization?: Maybe<FollowOrganizationPayload>;\n  /** Follow a user. */\n  followUser?: Maybe<FollowUserPayload>;\n  /** Grant the migrator role to a user for all organizations under an enterprise account. */\n  grantEnterpriseOrganizationsMigratorRole?: Maybe<GrantEnterpriseOrganizationsMigratorRolePayload>;\n  /** Grant the migrator role to a user or a team. */\n  grantMigratorRole?: Maybe<GrantMigratorRolePayload>;\n  /** Creates a new project by importing columns and a list of issues/PRs. */\n  importProject?: Maybe<ImportProjectPayload>;\n  /** Invite someone to become an administrator of the enterprise. */\n  inviteEnterpriseAdmin?: Maybe<InviteEnterpriseAdminPayload>;\n  /** Links a project to a repository. */\n  linkProjectV2ToRepository?: Maybe<LinkProjectV2ToRepositoryPayload>;\n  /** Links a project to a team. */\n  linkProjectV2ToTeam?: Maybe<LinkProjectV2ToTeamPayload>;\n  /** Creates a repository link for a project. */\n  linkRepositoryToProject?: Maybe<LinkRepositoryToProjectPayload>;\n  /** Lock a lockable object */\n  lockLockable?: Maybe<LockLockablePayload>;\n  /** Mark a discussion comment as the chosen answer for discussions in an answerable category. */\n  markDiscussionCommentAsAnswer?: Maybe<MarkDiscussionCommentAsAnswerPayload>;\n  /** Mark a pull request file as viewed */\n  markFileAsViewed?: Maybe<MarkFileAsViewedPayload>;\n  /** Mark a project as a template. Note that only projects which are owned by an Organization can be marked as a template. */\n  markProjectV2AsTemplate?: Maybe<MarkProjectV2AsTemplatePayload>;\n  /** Marks a pull request ready for review. */\n  markPullRequestReadyForReview?: Maybe<MarkPullRequestReadyForReviewPayload>;\n  /** Merge a head into a branch. */\n  mergeBranch?: Maybe<MergeBranchPayload>;\n  /** Merge a pull request. */\n  mergePullRequest?: Maybe<MergePullRequestPayload>;\n  /** Minimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  minimizeComment?: Maybe<MinimizeCommentPayload>;\n  /** Moves a project card to another place. */\n  moveProjectCard?: Maybe<MoveProjectCardPayload>;\n  /** Moves a project column to another place. */\n  moveProjectColumn?: Maybe<MoveProjectColumnPayload>;\n  /** Pin an issue to a repository */\n  pinIssue?: Maybe<PinIssuePayload>;\n  /** Publish an existing sponsorship tier that is currently still a draft to a GitHub Sponsors profile. */\n  publishSponsorsTier?: Maybe<PublishSponsorsTierPayload>;\n  /** Regenerates the identity provider recovery codes for an enterprise */\n  regenerateEnterpriseIdentityProviderRecoveryCodes?: Maybe<RegenerateEnterpriseIdentityProviderRecoveryCodesPayload>;\n  /** Regenerates a verifiable domain's verification token. */\n  regenerateVerifiableDomainToken?: Maybe<RegenerateVerifiableDomainTokenPayload>;\n  /** Reject all pending deployments under one or more environments */\n  rejectDeployments?: Maybe<RejectDeploymentsPayload>;\n  /** Removes assignees from an assignable object. */\n  removeAssigneesFromAssignable?: Maybe<RemoveAssigneesFromAssignablePayload>;\n  /** Removes an administrator from the enterprise. */\n  removeEnterpriseAdmin?: Maybe<RemoveEnterpriseAdminPayload>;\n  /** Removes the identity provider from an enterprise */\n  removeEnterpriseIdentityProvider?: Maybe<RemoveEnterpriseIdentityProviderPayload>;\n  /** Removes a user from all organizations within the enterprise */\n  removeEnterpriseMember?: Maybe<RemoveEnterpriseMemberPayload>;\n  /** Removes an organization from the enterprise */\n  removeEnterpriseOrganization?: Maybe<RemoveEnterpriseOrganizationPayload>;\n  /** Removes a support entitlement from an enterprise member. */\n  removeEnterpriseSupportEntitlement?: Maybe<RemoveEnterpriseSupportEntitlementPayload>;\n  /** Removes labels from a Labelable object. */\n  removeLabelsFromLabelable?: Maybe<RemoveLabelsFromLabelablePayload>;\n  /** Removes outside collaborator from all repositories in an organization. */\n  removeOutsideCollaborator?: Maybe<RemoveOutsideCollaboratorPayload>;\n  /** Removes a reaction from a subject. */\n  removeReaction?: Maybe<RemoveReactionPayload>;\n  /** Removes a star from a Starrable. */\n  removeStar?: Maybe<RemoveStarPayload>;\n  /** Remove an upvote to a discussion or discussion comment. */\n  removeUpvote?: Maybe<RemoveUpvotePayload>;\n  /** Reopen a discussion. */\n  reopenDiscussion?: Maybe<ReopenDiscussionPayload>;\n  /** Reopen a issue. */\n  reopenIssue?: Maybe<ReopenIssuePayload>;\n  /** Reopen a pull request. */\n  reopenPullRequest?: Maybe<ReopenPullRequestPayload>;\n  /** Set review requests on a pull request. */\n  requestReviews?: Maybe<RequestReviewsPayload>;\n  /** Rerequests an existing check suite. */\n  rerequestCheckSuite?: Maybe<RerequestCheckSuitePayload>;\n  /** Marks a review thread as resolved. */\n  resolveReviewThread?: Maybe<ResolveReviewThreadPayload>;\n  /** Retire a published payment tier from your GitHub Sponsors profile so it cannot be used to start new sponsorships. */\n  retireSponsorsTier?: Maybe<RetireSponsorsTierPayload>;\n  /** Create a pull request that reverts the changes from a merged pull request. */\n  revertPullRequest?: Maybe<RevertPullRequestPayload>;\n  /** Revoke the migrator role to a user for all organizations under an enterprise account. */\n  revokeEnterpriseOrganizationsMigratorRole?: Maybe<RevokeEnterpriseOrganizationsMigratorRolePayload>;\n  /** Revoke the migrator role from a user or a team. */\n  revokeMigratorRole?: Maybe<RevokeMigratorRolePayload>;\n  /** Creates or updates the identity provider for an enterprise. */\n  setEnterpriseIdentityProvider?: Maybe<SetEnterpriseIdentityProviderPayload>;\n  /** Set an organization level interaction limit for an organization's public repositories. */\n  setOrganizationInteractionLimit?: Maybe<SetOrganizationInteractionLimitPayload>;\n  /** Sets an interaction limit setting for a repository. */\n  setRepositoryInteractionLimit?: Maybe<SetRepositoryInteractionLimitPayload>;\n  /** Set a user level interaction limit for an user's public repositories. */\n  setUserInteractionLimit?: Maybe<SetUserInteractionLimitPayload>;\n  /** Starts a GitHub Enterprise Importer organization migration. */\n  startOrganizationMigration?: Maybe<StartOrganizationMigrationPayload>;\n  /** Starts a GitHub Enterprise Importer (GEI) repository migration. */\n  startRepositoryMigration?: Maybe<StartRepositoryMigrationPayload>;\n  /** Submits a pending pull request review. */\n  submitPullRequestReview?: Maybe<SubmitPullRequestReviewPayload>;\n  /** Transfer an organization from one enterprise to another enterprise. */\n  transferEnterpriseOrganization?: Maybe<TransferEnterpriseOrganizationPayload>;\n  /** Transfer an issue to a different repository */\n  transferIssue?: Maybe<TransferIssuePayload>;\n  /** Unarchives a ProjectV2Item */\n  unarchiveProjectV2Item?: Maybe<UnarchiveProjectV2ItemPayload>;\n  /** Unarchives a repository. */\n  unarchiveRepository?: Maybe<UnarchiveRepositoryPayload>;\n  /** Unfollow an organization. */\n  unfollowOrganization?: Maybe<UnfollowOrganizationPayload>;\n  /** Unfollow a user. */\n  unfollowUser?: Maybe<UnfollowUserPayload>;\n  /** Unlinks a project from a repository. */\n  unlinkProjectV2FromRepository?: Maybe<UnlinkProjectV2FromRepositoryPayload>;\n  /** Unlinks a project to a team. */\n  unlinkProjectV2FromTeam?: Maybe<UnlinkProjectV2FromTeamPayload>;\n  /** Deletes a repository link from a project. */\n  unlinkRepositoryFromProject?: Maybe<UnlinkRepositoryFromProjectPayload>;\n  /** Unlock a lockable object */\n  unlockLockable?: Maybe<UnlockLockablePayload>;\n  /** Unmark a discussion comment as the chosen answer for discussions in an answerable category. */\n  unmarkDiscussionCommentAsAnswer?: Maybe<UnmarkDiscussionCommentAsAnswerPayload>;\n  /** Unmark a pull request file as viewed */\n  unmarkFileAsViewed?: Maybe<UnmarkFileAsViewedPayload>;\n  /** Unmark an issue as a duplicate of another issue. */\n  unmarkIssueAsDuplicate?: Maybe<UnmarkIssueAsDuplicatePayload>;\n  /** Unmark a project as a template. */\n  unmarkProjectV2AsTemplate?: Maybe<UnmarkProjectV2AsTemplatePayload>;\n  /** Unminimizes a comment on an Issue, Commit, Pull Request, or Gist */\n  unminimizeComment?: Maybe<UnminimizeCommentPayload>;\n  /** Unpin a pinned issue from a repository */\n  unpinIssue?: Maybe<UnpinIssuePayload>;\n  /** Marks a review thread as unresolved. */\n  unresolveReviewThread?: Maybe<UnresolveReviewThreadPayload>;\n  /** Update a branch protection rule */\n  updateBranchProtectionRule?: Maybe<UpdateBranchProtectionRulePayload>;\n  /** Update a check run */\n  updateCheckRun?: Maybe<UpdateCheckRunPayload>;\n  /** Modifies the settings of an existing check suite */\n  updateCheckSuitePreferences?: Maybe<UpdateCheckSuitePreferencesPayload>;\n  /** Update a discussion */\n  updateDiscussion?: Maybe<UpdateDiscussionPayload>;\n  /** Update the contents of a comment on a Discussion */\n  updateDiscussionComment?: Maybe<UpdateDiscussionCommentPayload>;\n  /** Updates the role of an enterprise administrator. */\n  updateEnterpriseAdministratorRole?: Maybe<UpdateEnterpriseAdministratorRolePayload>;\n  /** Sets whether private repository forks are enabled for an enterprise. */\n  updateEnterpriseAllowPrivateRepositoryForkingSetting?: Maybe<UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload>;\n  /** Sets the base repository permission for organizations in an enterprise. */\n  updateEnterpriseDefaultRepositoryPermissionSetting?: Maybe<UpdateEnterpriseDefaultRepositoryPermissionSettingPayload>;\n  /** Sets whether organization members with admin permissions on a repository can change repository visibility. */\n  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting?: Maybe<UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload>;\n  /** Sets the members can create repositories setting for an enterprise. */\n  updateEnterpriseMembersCanCreateRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload>;\n  /** Sets the members can delete issues setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteIssuesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteIssuesSettingPayload>;\n  /** Sets the members can delete repositories setting for an enterprise. */\n  updateEnterpriseMembersCanDeleteRepositoriesSetting?: Maybe<UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload>;\n  /** Sets whether members can invite collaborators are enabled for an enterprise. */\n  updateEnterpriseMembersCanInviteCollaboratorsSetting?: Maybe<UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload>;\n  /** Sets whether or not an organization admin can make purchases. */\n  updateEnterpriseMembersCanMakePurchasesSetting?: Maybe<UpdateEnterpriseMembersCanMakePurchasesSettingPayload>;\n  /** Sets the members can update protected branches setting for an enterprise. */\n  updateEnterpriseMembersCanUpdateProtectedBranchesSetting?: Maybe<UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload>;\n  /** Sets the members can view dependency insights for an enterprise. */\n  updateEnterpriseMembersCanViewDependencyInsightsSetting?: Maybe<UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload>;\n  /** Sets whether organization projects are enabled for an enterprise. */\n  updateEnterpriseOrganizationProjectsSetting?: Maybe<UpdateEnterpriseOrganizationProjectsSettingPayload>;\n  /** Updates the role of an enterprise owner with an organization. */\n  updateEnterpriseOwnerOrganizationRole?: Maybe<UpdateEnterpriseOwnerOrganizationRolePayload>;\n  /** Updates an enterprise's profile. */\n  updateEnterpriseProfile?: Maybe<UpdateEnterpriseProfilePayload>;\n  /** Sets whether repository projects are enabled for a enterprise. */\n  updateEnterpriseRepositoryProjectsSetting?: Maybe<UpdateEnterpriseRepositoryProjectsSettingPayload>;\n  /** Sets whether team discussions are enabled for an enterprise. */\n  updateEnterpriseTeamDiscussionsSetting?: Maybe<UpdateEnterpriseTeamDiscussionsSettingPayload>;\n  /** Sets whether two factor authentication is required for all users in an enterprise. */\n  updateEnterpriseTwoFactorAuthenticationRequiredSetting?: Maybe<UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload>;\n  /** Updates an environment. */\n  updateEnvironment?: Maybe<UpdateEnvironmentPayload>;\n  /** Sets whether an IP allow list is enabled on an owner. */\n  updateIpAllowListEnabledSetting?: Maybe<UpdateIpAllowListEnabledSettingPayload>;\n  /** Updates an IP allow list entry. */\n  updateIpAllowListEntry?: Maybe<UpdateIpAllowListEntryPayload>;\n  /** Sets whether IP allow list configuration for installed GitHub Apps is enabled on an owner. */\n  updateIpAllowListForInstalledAppsEnabledSetting?: Maybe<UpdateIpAllowListForInstalledAppsEnabledSettingPayload>;\n  /** Updates an Issue. */\n  updateIssue?: Maybe<UpdateIssuePayload>;\n  /** Updates an IssueComment object. */\n  updateIssueComment?: Maybe<UpdateIssueCommentPayload>;\n  /** Updates an existing label. */\n  updateLabel?: Maybe<UpdateLabelPayload>;\n  /** Update the setting to restrict notifications to only verified or approved domains available to an owner. */\n  updateNotificationRestrictionSetting?: Maybe<UpdateNotificationRestrictionSettingPayload>;\n  /** Sets whether private repository forks are enabled for an organization. */\n  updateOrganizationAllowPrivateRepositoryForkingSetting?: Maybe<UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload>;\n  /** Sets whether contributors are required to sign off on web-based commits for repositories in an organization. */\n  updateOrganizationWebCommitSignoffSetting?: Maybe<UpdateOrganizationWebCommitSignoffSettingPayload>;\n  /** Updates an existing project. */\n  updateProject?: Maybe<UpdateProjectPayload>;\n  /** Updates an existing project card. */\n  updateProjectCard?: Maybe<UpdateProjectCardPayload>;\n  /** Updates an existing project column. */\n  updateProjectColumn?: Maybe<UpdateProjectColumnPayload>;\n  /** Updates an existing project (beta). */\n  updateProjectV2?: Maybe<UpdateProjectV2Payload>;\n  /** Update the collaborators on a team or a project */\n  updateProjectV2Collaborators?: Maybe<UpdateProjectV2CollaboratorsPayload>;\n  /** Updates a draft issue within a Project. */\n  updateProjectV2DraftIssue?: Maybe<UpdateProjectV2DraftIssuePayload>;\n  /**\n   * This mutation updates the value of a field for an item in a Project. Currently\n   * only single-select, text, number, date, and iteration fields are supported.\n   */\n  updateProjectV2ItemFieldValue?: Maybe<UpdateProjectV2ItemFieldValuePayload>;\n  /** This mutation updates the position of the item in the project, where the position represents the priority of an item. */\n  updateProjectV2ItemPosition?: Maybe<UpdateProjectV2ItemPositionPayload>;\n  /** Update a pull request */\n  updatePullRequest?: Maybe<UpdatePullRequestPayload>;\n  /** Merge or Rebase HEAD from upstream branch into pull request branch */\n  updatePullRequestBranch?: Maybe<UpdatePullRequestBranchPayload>;\n  /** Updates the body of a pull request review. */\n  updatePullRequestReview?: Maybe<UpdatePullRequestReviewPayload>;\n  /** Updates a pull request review comment. */\n  updatePullRequestReviewComment?: Maybe<UpdatePullRequestReviewCommentPayload>;\n  /** Update a Git Ref. */\n  updateRef?: Maybe<UpdateRefPayload>;\n  /**\n   * Creates, updates and/or deletes multiple refs in a repository.\n   *\n   * This mutation takes a list of `RefUpdate`s and performs these updates\n   * on the repository. All updates are performed atomically, meaning that\n   * if one of them is rejected, no other ref will be modified.\n   *\n   * `RefUpdate.beforeOid` specifies that the given reference needs to point\n   * to the given value before performing any updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to verify that\n   * the references should not exist.\n   *\n   * `RefUpdate.afterOid` specifies the value that the given reference\n   * will point to after performing all updates. A value of\n   * `0000000000000000000000000000000000000000` can be used to delete a\n   * reference.\n   *\n   * If `RefUpdate.force` is set to `true`, a non-fast-forward updates\n   * for the given reference will be allowed.\n   */\n  updateRefs?: Maybe<UpdateRefsPayload>;\n  /** Update information about a repository. */\n  updateRepository?: Maybe<UpdateRepositoryPayload>;\n  /** Update a repository ruleset */\n  updateRepositoryRuleset?: Maybe<UpdateRepositoryRulesetPayload>;\n  /** Sets whether contributors are required to sign off on web-based commits for a repository. */\n  updateRepositoryWebCommitSignoffSetting?: Maybe<UpdateRepositoryWebCommitSignoffSettingPayload>;\n  /** Change visibility of your sponsorship and opt in or out of email updates from the maintainer. */\n  updateSponsorshipPreferences?: Maybe<UpdateSponsorshipPreferencesPayload>;\n  /** Updates the state for subscribable subjects. */\n  updateSubscription?: Maybe<UpdateSubscriptionPayload>;\n  /** Updates a team discussion. */\n  updateTeamDiscussion?: Maybe<UpdateTeamDiscussionPayload>;\n  /** Updates a discussion comment. */\n  updateTeamDiscussionComment?: Maybe<UpdateTeamDiscussionCommentPayload>;\n  /** Updates team review assignment. */\n  updateTeamReviewAssignment?: Maybe<UpdateTeamReviewAssignmentPayload>;\n  /** Update team repository. */\n  updateTeamsRepository?: Maybe<UpdateTeamsRepositoryPayload>;\n  /** Replaces the repository's topics with the given topics. */\n  updateTopics?: Maybe<UpdateTopicsPayload>;\n  /** Verify that a verifiable domain has the expected DNS record. */\n  verifyVerifiableDomain?: Maybe<VerifyVerifiableDomainPayload>;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAbortQueuedMigrationsArgs = {\n  input: AbortQueuedMigrationsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptEnterpriseAdministratorInvitationArgs = {\n  input: AcceptEnterpriseAdministratorInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAcceptTopicSuggestionArgs = {\n  input: AcceptTopicSuggestionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddAssigneesToAssignableArgs = {\n  input: AddAssigneesToAssignableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddCommentArgs = {\n  input: AddCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionCommentArgs = {\n  input: AddDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddDiscussionPollVoteArgs = {\n  input: AddDiscussionPollVoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseOrganizationMemberArgs = {\n  input: AddEnterpriseOrganizationMemberInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddEnterpriseSupportEntitlementArgs = {\n  input: AddEnterpriseSupportEntitlementInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddLabelsToLabelableArgs = {\n  input: AddLabelsToLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectCardArgs = {\n  input: AddProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectColumnArgs = {\n  input: AddProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectV2DraftIssueArgs = {\n  input: AddProjectV2DraftIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddProjectV2ItemByIdArgs = {\n  input: AddProjectV2ItemByIdInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewArgs = {\n  input: AddPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewCommentArgs = {\n  input: AddPullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddPullRequestReviewThreadArgs = {\n  input: AddPullRequestReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddReactionArgs = {\n  input: AddReactionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddStarArgs = {\n  input: AddStarInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddUpvoteArgs = {\n  input: AddUpvoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationAddVerifiableDomainArgs = {\n  input: AddVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveDeploymentsArgs = {\n  input: ApproveDeploymentsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationApproveVerifiableDomainArgs = {\n  input: ApproveVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveProjectV2ItemArgs = {\n  input: ArchiveProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationArchiveRepositoryArgs = {\n  input: ArchiveRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelEnterpriseAdminInvitationArgs = {\n  input: CancelEnterpriseAdminInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCancelSponsorshipArgs = {\n  input: CancelSponsorshipInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationChangeUserStatusArgs = {\n  input: ChangeUserStatusInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearLabelsFromLabelableArgs = {\n  input: ClearLabelsFromLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClearProjectV2ItemFieldValueArgs = {\n  input: ClearProjectV2ItemFieldValueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneProjectArgs = {\n  input: CloneProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloneTemplateRepositoryArgs = {\n  input: CloneTemplateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseDiscussionArgs = {\n  input: CloseDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCloseIssueArgs = {\n  input: CloseIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationClosePullRequestArgs = {\n  input: ClosePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertProjectCardNoteToIssueArgs = {\n  input: ConvertProjectCardNoteToIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationConvertPullRequestToDraftArgs = {\n  input: ConvertPullRequestToDraftInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCopyProjectV2Args = {\n  input: CopyProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateAttributionInvitationArgs = {\n  input: CreateAttributionInvitationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateBranchProtectionRuleArgs = {\n  input: CreateBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckRunArgs = {\n  input: CreateCheckRunInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCheckSuiteArgs = {\n  input: CreateCheckSuiteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateCommitOnBranchArgs = {\n  input: CreateCommitOnBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentArgs = {\n  input: CreateDeploymentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDeploymentStatusArgs = {\n  input: CreateDeploymentStatusInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateDiscussionArgs = {\n  input: CreateDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnterpriseOrganizationArgs = {\n  input: CreateEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateEnvironmentArgs = {\n  input: CreateEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIpAllowListEntryArgs = {\n  input: CreateIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateIssueArgs = {\n  input: CreateIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateLabelArgs = {\n  input: CreateLabelInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateLinkedBranchArgs = {\n  input: CreateLinkedBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateMigrationSourceArgs = {\n  input: CreateMigrationSourceInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectArgs = {\n  input: CreateProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectV2Args = {\n  input: CreateProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateProjectV2FieldArgs = {\n  input: CreateProjectV2FieldInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreatePullRequestArgs = {\n  input: CreatePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRefArgs = {\n  input: CreateRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryArgs = {\n  input: CreateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateRepositoryRulesetArgs = {\n  input: CreateRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorsListingArgs = {\n  input: CreateSponsorsListingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorsTierArgs = {\n  input: CreateSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipArgs = {\n  input: CreateSponsorshipInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateSponsorshipsArgs = {\n  input: CreateSponsorshipsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionArgs = {\n  input: CreateTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationCreateTeamDiscussionCommentArgs = {\n  input: CreateTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeclineTopicSuggestionArgs = {\n  input: DeclineTopicSuggestionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteBranchProtectionRuleArgs = {\n  input: DeleteBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDeploymentArgs = {\n  input: DeleteDeploymentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionArgs = {\n  input: DeleteDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteDiscussionCommentArgs = {\n  input: DeleteDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteEnvironmentArgs = {\n  input: DeleteEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIpAllowListEntryArgs = {\n  input: DeleteIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueArgs = {\n  input: DeleteIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteIssueCommentArgs = {\n  input: DeleteIssueCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteLabelArgs = {\n  input: DeleteLabelInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteLinkedBranchArgs = {\n  input: DeleteLinkedBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePackageVersionArgs = {\n  input: DeletePackageVersionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectArgs = {\n  input: DeleteProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectCardArgs = {\n  input: DeleteProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectColumnArgs = {\n  input: DeleteProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2Args = {\n  input: DeleteProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2FieldArgs = {\n  input: DeleteProjectV2FieldInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2ItemArgs = {\n  input: DeleteProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteProjectV2WorkflowArgs = {\n  input: DeleteProjectV2WorkflowInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewArgs = {\n  input: DeletePullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeletePullRequestReviewCommentArgs = {\n  input: DeletePullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRefArgs = {\n  input: DeleteRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteRepositoryRulesetArgs = {\n  input: DeleteRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionArgs = {\n  input: DeleteTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteTeamDiscussionCommentArgs = {\n  input: DeleteTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDeleteVerifiableDomainArgs = {\n  input: DeleteVerifiableDomainInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDequeuePullRequestArgs = {\n  input: DequeuePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDisablePullRequestAutoMergeArgs = {\n  input: DisablePullRequestAutoMergeInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissPullRequestReviewArgs = {\n  input: DismissPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationDismissRepositoryVulnerabilityAlertArgs = {\n  input: DismissRepositoryVulnerabilityAlertInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnablePullRequestAutoMergeArgs = {\n  input: EnablePullRequestAutoMergeInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationEnqueuePullRequestArgs = {\n  input: EnqueuePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowOrganizationArgs = {\n  input: FollowOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationFollowUserArgs = {\n  input: FollowUserInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantEnterpriseOrganizationsMigratorRoleArgs = {\n  input: GrantEnterpriseOrganizationsMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationGrantMigratorRoleArgs = {\n  input: GrantMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationImportProjectArgs = {\n  input: ImportProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationInviteEnterpriseAdminArgs = {\n  input: InviteEnterpriseAdminInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkProjectV2ToRepositoryArgs = {\n  input: LinkProjectV2ToRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkProjectV2ToTeamArgs = {\n  input: LinkProjectV2ToTeamInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLinkRepositoryToProjectArgs = {\n  input: LinkRepositoryToProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationLockLockableArgs = {\n  input: LockLockableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkDiscussionCommentAsAnswerArgs = {\n  input: MarkDiscussionCommentAsAnswerInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkFileAsViewedArgs = {\n  input: MarkFileAsViewedInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkProjectV2AsTemplateArgs = {\n  input: MarkProjectV2AsTemplateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMarkPullRequestReadyForReviewArgs = {\n  input: MarkPullRequestReadyForReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergeBranchArgs = {\n  input: MergeBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMergePullRequestArgs = {\n  input: MergePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMinimizeCommentArgs = {\n  input: MinimizeCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectCardArgs = {\n  input: MoveProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationMoveProjectColumnArgs = {\n  input: MoveProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPinIssueArgs = {\n  input: PinIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationPublishSponsorsTierArgs = {\n  input: PublishSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateEnterpriseIdentityProviderRecoveryCodesArgs = {\n  input: RegenerateEnterpriseIdentityProviderRecoveryCodesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRegenerateVerifiableDomainTokenArgs = {\n  input: RegenerateVerifiableDomainTokenInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRejectDeploymentsArgs = {\n  input: RejectDeploymentsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveAssigneesFromAssignableArgs = {\n  input: RemoveAssigneesFromAssignableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseAdminArgs = {\n  input: RemoveEnterpriseAdminInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseIdentityProviderArgs = {\n  input: RemoveEnterpriseIdentityProviderInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseMemberArgs = {\n  input: RemoveEnterpriseMemberInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseOrganizationArgs = {\n  input: RemoveEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveEnterpriseSupportEntitlementArgs = {\n  input: RemoveEnterpriseSupportEntitlementInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveLabelsFromLabelableArgs = {\n  input: RemoveLabelsFromLabelableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveOutsideCollaboratorArgs = {\n  input: RemoveOutsideCollaboratorInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveReactionArgs = {\n  input: RemoveReactionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveStarArgs = {\n  input: RemoveStarInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRemoveUpvoteArgs = {\n  input: RemoveUpvoteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenDiscussionArgs = {\n  input: ReopenDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenIssueArgs = {\n  input: ReopenIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationReopenPullRequestArgs = {\n  input: ReopenPullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRequestReviewsArgs = {\n  input: RequestReviewsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRerequestCheckSuiteArgs = {\n  input: RerequestCheckSuiteInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationResolveReviewThreadArgs = {\n  input: ResolveReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRetireSponsorsTierArgs = {\n  input: RetireSponsorsTierInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevertPullRequestArgs = {\n  input: RevertPullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeEnterpriseOrganizationsMigratorRoleArgs = {\n  input: RevokeEnterpriseOrganizationsMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationRevokeMigratorRoleArgs = {\n  input: RevokeMigratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetEnterpriseIdentityProviderArgs = {\n  input: SetEnterpriseIdentityProviderInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetOrganizationInteractionLimitArgs = {\n  input: SetOrganizationInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetRepositoryInteractionLimitArgs = {\n  input: SetRepositoryInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSetUserInteractionLimitArgs = {\n  input: SetUserInteractionLimitInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationStartOrganizationMigrationArgs = {\n  input: StartOrganizationMigrationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationStartRepositoryMigrationArgs = {\n  input: StartRepositoryMigrationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationSubmitPullRequestReviewArgs = {\n  input: SubmitPullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferEnterpriseOrganizationArgs = {\n  input: TransferEnterpriseOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationTransferIssueArgs = {\n  input: TransferIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveProjectV2ItemArgs = {\n  input: UnarchiveProjectV2ItemInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnarchiveRepositoryArgs = {\n  input: UnarchiveRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowOrganizationArgs = {\n  input: UnfollowOrganizationInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnfollowUserArgs = {\n  input: UnfollowUserInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkProjectV2FromRepositoryArgs = {\n  input: UnlinkProjectV2FromRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkProjectV2FromTeamArgs = {\n  input: UnlinkProjectV2FromTeamInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlinkRepositoryFromProjectArgs = {\n  input: UnlinkRepositoryFromProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnlockLockableArgs = {\n  input: UnlockLockableInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkDiscussionCommentAsAnswerArgs = {\n  input: UnmarkDiscussionCommentAsAnswerInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkFileAsViewedArgs = {\n  input: UnmarkFileAsViewedInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkIssueAsDuplicateArgs = {\n  input: UnmarkIssueAsDuplicateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnmarkProjectV2AsTemplateArgs = {\n  input: UnmarkProjectV2AsTemplateInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnminimizeCommentArgs = {\n  input: UnminimizeCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnpinIssueArgs = {\n  input: UnpinIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUnresolveReviewThreadArgs = {\n  input: UnresolveReviewThreadInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateBranchProtectionRuleArgs = {\n  input: UpdateBranchProtectionRuleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckRunArgs = {\n  input: UpdateCheckRunInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateCheckSuitePreferencesArgs = {\n  input: UpdateCheckSuitePreferencesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionArgs = {\n  input: UpdateDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateDiscussionCommentArgs = {\n  input: UpdateDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAdministratorRoleArgs = {\n  input: UpdateEnterpriseAdministratorRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseDefaultRepositoryPermissionSettingArgs = {\n  input: UpdateEnterpriseDefaultRepositoryPermissionSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingArgs = {\n  input: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanCreateRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteIssuesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteIssuesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanDeleteRepositoriesSettingArgs = {\n  input: UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanInviteCollaboratorsSettingArgs = {\n  input: UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanMakePurchasesSettingArgs = {\n  input: UpdateEnterpriseMembersCanMakePurchasesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingArgs = {\n  input: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseMembersCanViewDependencyInsightsSettingArgs = {\n  input: UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOrganizationProjectsSettingArgs = {\n  input: UpdateEnterpriseOrganizationProjectsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseOwnerOrganizationRoleArgs = {\n  input: UpdateEnterpriseOwnerOrganizationRoleInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseProfileArgs = {\n  input: UpdateEnterpriseProfileInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseRepositoryProjectsSettingArgs = {\n  input: UpdateEnterpriseRepositoryProjectsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTeamDiscussionsSettingArgs = {\n  input: UpdateEnterpriseTeamDiscussionsSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnterpriseTwoFactorAuthenticationRequiredSettingArgs = {\n  input: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateEnvironmentArgs = {\n  input: UpdateEnvironmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEnabledSettingArgs = {\n  input: UpdateIpAllowListEnabledSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListEntryArgs = {\n  input: UpdateIpAllowListEntryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIpAllowListForInstalledAppsEnabledSettingArgs = {\n  input: UpdateIpAllowListForInstalledAppsEnabledSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueArgs = {\n  input: UpdateIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateIssueCommentArgs = {\n  input: UpdateIssueCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateLabelArgs = {\n  input: UpdateLabelInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateNotificationRestrictionSettingArgs = {\n  input: UpdateNotificationRestrictionSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateOrganizationAllowPrivateRepositoryForkingSettingArgs = {\n  input: UpdateOrganizationAllowPrivateRepositoryForkingSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateOrganizationWebCommitSignoffSettingArgs = {\n  input: UpdateOrganizationWebCommitSignoffSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectArgs = {\n  input: UpdateProjectInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectCardArgs = {\n  input: UpdateProjectCardInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectColumnArgs = {\n  input: UpdateProjectColumnInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2Args = {\n  input: UpdateProjectV2Input;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2CollaboratorsArgs = {\n  input: UpdateProjectV2CollaboratorsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2DraftIssueArgs = {\n  input: UpdateProjectV2DraftIssueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2ItemFieldValueArgs = {\n  input: UpdateProjectV2ItemFieldValueInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateProjectV2ItemPositionArgs = {\n  input: UpdateProjectV2ItemPositionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestArgs = {\n  input: UpdatePullRequestInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestBranchArgs = {\n  input: UpdatePullRequestBranchInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewArgs = {\n  input: UpdatePullRequestReviewInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdatePullRequestReviewCommentArgs = {\n  input: UpdatePullRequestReviewCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefArgs = {\n  input: UpdateRefInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRefsArgs = {\n  input: UpdateRefsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryArgs = {\n  input: UpdateRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryRulesetArgs = {\n  input: UpdateRepositoryRulesetInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateRepositoryWebCommitSignoffSettingArgs = {\n  input: UpdateRepositoryWebCommitSignoffSettingInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSponsorshipPreferencesArgs = {\n  input: UpdateSponsorshipPreferencesInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateSubscriptionArgs = {\n  input: UpdateSubscriptionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionArgs = {\n  input: UpdateTeamDiscussionInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamDiscussionCommentArgs = {\n  input: UpdateTeamDiscussionCommentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamReviewAssignmentArgs = {\n  input: UpdateTeamReviewAssignmentInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTeamsRepositoryArgs = {\n  input: UpdateTeamsRepositoryInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationUpdateTopicsArgs = {\n  input: UpdateTopicsInput;\n};\n\n\n/** The root query for implementing GraphQL mutations. */\nexport type MutationVerifyVerifiableDomainArgs = {\n  input: VerifyVerifiableDomainInput;\n};\n\n/** An object with an ID. */\nexport type Node = {\n  /** ID of the object. */\n  id: Scalars['ID'];\n};\n\n/** The possible values for the notification restriction setting. */\nexport enum NotificationRestrictionSettingValue {\n  /** The setting is disabled for the owner. */\n  Disabled = 'DISABLED',\n  /** The setting is enabled for the owner. */\n  Enabled = 'ENABLED'\n}\n\n/**\n * An OIDC identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type OidcProvider = Node & {\n  __typename?: 'OIDCProvider';\n  /** The enterprise this identity provider belongs to. */\n  enterprise?: Maybe<Enterprise>;\n  /** ExternalIdentities provisioned by this identity provider. */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID'];\n  /** The OIDC identity provider type */\n  providerType: OidcProviderType;\n  /** The id of the tenant this provider is attached to */\n  tenantId: Scalars['String'];\n};\n\n\n/**\n * An OIDC identity provider configured to provision identities for an enterprise.\n * Visible to enterprise owners or enterprise owners' personal access tokens\n * (classic) with read:enterprise or admin:enterprise scope.\n */\nexport type OidcProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  login?: InputMaybe<Scalars['String']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']>;\n  userName?: InputMaybe<Scalars['String']>;\n};\n\n/** The OIDC identity provider type */\nexport enum OidcProviderType {\n  /** Azure Active Directory */\n  Aad = 'AAD'\n}\n\n/** Metadata for an audit entry with action oauth_application.* */\nexport type OauthApplicationAuditEntryData = {\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a oauth_application.create event. */\nexport type OauthApplicationCreateAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  __typename?: 'OauthApplicationCreateAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The application URL of the OAuth Application. */\n  applicationUrl?: Maybe<Scalars['URI']>;\n  /** The callback URL of the OAuth Application. */\n  callbackUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The rate limit of the OAuth Application. */\n  rateLimit?: Maybe<Scalars['Int']>;\n  /** The state of the OAuth Application. */\n  state?: Maybe<OauthApplicationCreateAuditEntryState>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The state of an OAuth Application when it was created. */\nexport enum OauthApplicationCreateAuditEntryState {\n  /** The OAuth Application was active and allowed to have OAuth Accesses. */\n  Active = 'ACTIVE',\n  /** The OAuth Application was in the process of being deleted. */\n  PendingDeletion = 'PENDING_DELETION',\n  /** The OAuth Application was suspended from generating OAuth Accesses due to abuse or security concerns. */\n  Suspended = 'SUSPENDED'\n}\n\n/** The corresponding operation type for the action */\nexport enum OperationType {\n  /** An existing resource was accessed */\n  Access = 'ACCESS',\n  /** A resource performed an authentication event */\n  Authentication = 'AUTHENTICATION',\n  /** A new resource was created */\n  Create = 'CREATE',\n  /** An existing resource was modified */\n  Modify = 'MODIFY',\n  /** An existing resource was removed */\n  Remove = 'REMOVE',\n  /** An existing resource was restored */\n  Restore = 'RESTORE',\n  /** An existing resource was transferred between multiple resources */\n  Transfer = 'TRANSFER'\n}\n\n/** Possible directions in which to order a list of items when provided an `orderBy` argument. */\nexport enum OrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\n/** Audit log entry for a org.add_billing_manager */\nexport type OrgAddBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgAddBillingManagerAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The email address used to invite a billing manager for the organization. */\n  invitationEmail?: Maybe<Scalars['String']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.add_member */\nexport type OrgAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgAddMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The permission level of the member added to the organization. */\n  permission?: Maybe<OrgAddMemberAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The permissions available to members on an Organization. */\nexport enum OrgAddMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n/** Audit log entry for a org.block_user */\nexport type OrgBlockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgBlockUserAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The blocked user. */\n  blockedUser?: Maybe<User>;\n  /** The username of the blocked user. */\n  blockedUserName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the blocked user. */\n  blockedUserResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the blocked user. */\n  blockedUserUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.config.disable_collaborators_only event. */\nexport type OrgConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgConfigDisableCollaboratorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.config.enable_collaborators_only event. */\nexport type OrgConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgConfigEnableCollaboratorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.create event. */\nexport type OrgCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgCreateAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The billing plan for the Organization. */\n  billingPlan?: Maybe<OrgCreateAuditEntryBillingPlan>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The billing plans available for organizations. */\nexport enum OrgCreateAuditEntryBillingPlan {\n  /** Team Plan */\n  Business = 'BUSINESS',\n  /** Enterprise Cloud Plan */\n  BusinessPlus = 'BUSINESS_PLUS',\n  /** Free Plan */\n  Free = 'FREE',\n  /** Tiered Per Seat Plan */\n  TieredPerSeat = 'TIERED_PER_SEAT',\n  /** Legacy Unlimited Plan */\n  Unlimited = 'UNLIMITED'\n}\n\n/** Audit log entry for a org.disable_oauth_app_restrictions event. */\nexport type OrgDisableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgDisableOauthAppRestrictionsAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.disable_saml event. */\nexport type OrgDisableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgDisableSamlAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The SAML provider's digest algorithm URL. */\n  digestMethodUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The SAML provider's issuer URL. */\n  issuerUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The SAML provider's signature algorithm URL. */\n  signatureMethodUrl?: Maybe<Scalars['URI']>;\n  /** The SAML provider's single sign-on URL. */\n  singleSignOnUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.disable_two_factor_requirement event. */\nexport type OrgDisableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgDisableTwoFactorRequirementAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.enable_oauth_app_restrictions event. */\nexport type OrgEnableOauthAppRestrictionsAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgEnableOauthAppRestrictionsAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.enable_saml event. */\nexport type OrgEnableSamlAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgEnableSamlAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The SAML provider's digest algorithm URL. */\n  digestMethodUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The SAML provider's issuer URL. */\n  issuerUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The SAML provider's signature algorithm URL. */\n  signatureMethodUrl?: Maybe<Scalars['URI']>;\n  /** The SAML provider's single sign-on URL. */\n  singleSignOnUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.enable_two_factor_requirement event. */\nexport type OrgEnableTwoFactorRequirementAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgEnableTwoFactorRequirementAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Ordering options for an organization's enterprise owner connections. */\nexport type OrgEnterpriseOwnerOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order enterprise owners by. */\n  field: OrgEnterpriseOwnerOrderField;\n};\n\n/** Properties by which enterprise owners can be ordered. */\nexport enum OrgEnterpriseOwnerOrderField {\n  /** Order enterprise owners by login. */\n  Login = 'LOGIN'\n}\n\n/** Audit log entry for a org.invite_member event. */\nexport type OrgInviteMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgInviteMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The email address of the organization invitation. */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The organization invitation. */\n  organizationInvitation?: Maybe<OrganizationInvitation>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.invite_to_business event. */\nexport type OrgInviteToBusinessAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgInviteToBusinessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_approved event. */\nexport type OrgOauthAppAccessApprovedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  __typename?: 'OrgOauthAppAccessApprovedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_denied event. */\nexport type OrgOauthAppAccessDeniedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  __typename?: 'OrgOauthAppAccessDeniedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.oauth_app_access_requested event. */\nexport type OrgOauthAppAccessRequestedAuditEntry = AuditEntry & Node & OauthApplicationAuditEntryData & OrganizationAuditEntryData & {\n  __typename?: 'OrgOauthAppAccessRequestedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The name of the OAuth Application. */\n  oauthApplicationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the OAuth Application */\n  oauthApplicationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the OAuth Application */\n  oauthApplicationUrl?: Maybe<Scalars['URI']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.remove_billing_manager event. */\nexport type OrgRemoveBillingManagerAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgRemoveBillingManagerAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The reason for the billing manager being removed. */\n  reason?: Maybe<OrgRemoveBillingManagerAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The reason a billing manager was removed from an Organization. */\nexport enum OrgRemoveBillingManagerAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n/** Audit log entry for a org.remove_member event. */\nexport type OrgRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgRemoveMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The types of membership the member has with the organization. */\n  membershipTypes?: Maybe<Array<OrgRemoveMemberAuditEntryMembershipType>>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The reason for the member being removed. */\n  reason?: Maybe<OrgRemoveMemberAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveMemberAuditEntryMembershipType {\n  /**\n   * Organization administrators have full access and can change several settings,\n   * including the names of repositories that belong to the Organization and Owners\n   * team membership. In addition, organization admins can delete the organization\n   * and all of its repositories.\n   */\n  Admin = 'ADMIN',\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /** A direct member is a user that is a member of the Organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /** A suspended member. */\n  Suspended = 'SUSPENDED',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the Organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason a member was removed from an Organization. */\nexport enum OrgRemoveMemberAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** SAML SSO enforcement requires an external identity */\n  SamlSsoEnforcementRequiresExternalIdentity = 'SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY',\n  /** User was removed from organization during account recovery */\n  TwoFactorAccountRecovery = 'TWO_FACTOR_ACCOUNT_RECOVERY',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE',\n  /** User account has been deleted */\n  UserAccountDeleted = 'USER_ACCOUNT_DELETED'\n}\n\n/** Audit log entry for a org.remove_outside_collaborator event. */\nexport type OrgRemoveOutsideCollaboratorAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgRemoveOutsideCollaboratorAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The types of membership the outside collaborator has with the organization. */\n  membershipTypes?: Maybe<Array<OrgRemoveOutsideCollaboratorAuditEntryMembershipType>>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The reason for the outside collaborator being removed from the Organization. */\n  reason?: Maybe<OrgRemoveOutsideCollaboratorAuditEntryReason>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The type of membership a user has with an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {\n  /** A billing manager is a user who manages the billing settings for the Organization, such as updating payment information. */\n  BillingManager = 'BILLING_MANAGER',\n  /**\n   * An outside collaborator is a person who isn't explicitly a member of the\n   * Organization, but who has Read, Write, or Admin permissions to one or more\n   * repositories in the organization.\n   */\n  OutsideCollaborator = 'OUTSIDE_COLLABORATOR',\n  /**\n   * An unaffiliated collaborator is a person who is not a member of the\n   * Organization and does not have access to any repositories in the organization.\n   */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The reason an outside collaborator was removed from an Organization. */\nexport enum OrgRemoveOutsideCollaboratorAuditEntryReason {\n  /** SAML external identity missing */\n  SamlExternalIdentityMissing = 'SAML_EXTERNAL_IDENTITY_MISSING',\n  /** The organization required 2FA of its billing managers and this user did not have 2FA enabled. */\n  TwoFactorRequirementNonCompliance = 'TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE'\n}\n\n/** Audit log entry for a org.restore_member event. */\nexport type OrgRestoreMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgRestoreMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The number of custom email routings for the restored member. */\n  restoredCustomEmailRoutingsCount?: Maybe<Scalars['Int']>;\n  /** The number of issue assignments for the restored member. */\n  restoredIssueAssignmentsCount?: Maybe<Scalars['Int']>;\n  /** Restored organization membership objects. */\n  restoredMemberships?: Maybe<Array<OrgRestoreMemberAuditEntryMembership>>;\n  /** The number of restored memberships. */\n  restoredMembershipsCount?: Maybe<Scalars['Int']>;\n  /** The number of repositories of the restored member. */\n  restoredRepositoriesCount?: Maybe<Scalars['Int']>;\n  /** The number of starred repositories for the restored member. */\n  restoredRepositoryStarsCount?: Maybe<Scalars['Int']>;\n  /** The number of watched repositories for the restored member. */\n  restoredRepositoryWatchesCount?: Maybe<Scalars['Int']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Types of memberships that can be restored for an Organization member. */\nexport type OrgRestoreMemberAuditEntryMembership = OrgRestoreMemberMembershipOrganizationAuditEntryData | OrgRestoreMemberMembershipRepositoryAuditEntryData | OrgRestoreMemberMembershipTeamAuditEntryData;\n\n/** Metadata for an organization membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipOrganizationAuditEntryData = OrganizationAuditEntryData & {\n  __typename?: 'OrgRestoreMemberMembershipOrganizationAuditEntryData';\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Metadata for a repository membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipRepositoryAuditEntryData = RepositoryAuditEntryData & {\n  __typename?: 'OrgRestoreMemberMembershipRepositoryAuditEntryData';\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Metadata for a team membership for org.restore_member actions */\nexport type OrgRestoreMemberMembershipTeamAuditEntryData = TeamAuditEntryData & {\n  __typename?: 'OrgRestoreMemberMembershipTeamAuditEntryData';\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.unblock_user */\nexport type OrgUnblockUserAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgUnblockUserAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The user being unblocked by the organization. */\n  blockedUser?: Maybe<User>;\n  /** The username of the blocked user. */\n  blockedUserName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the blocked user. */\n  blockedUserResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the blocked user. */\n  blockedUserUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a org.update_default_repository_permission */\nexport type OrgUpdateDefaultRepositoryPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgUpdateDefaultRepositoryPermissionAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The new base repository permission level for the organization. */\n  permission?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n  /** The former base repository permission level for the organization. */\n  permissionWas?: Maybe<OrgUpdateDefaultRepositoryPermissionAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The default permission a repository can have in an Organization. */\nexport enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** No default permission value. */\n  None = 'NONE',\n  /** Can read and clone repositories. */\n  Read = 'READ',\n  /** Can read, clone and push to repositories. */\n  Write = 'WRITE'\n}\n\n/** Audit log entry for a org.update_member event. */\nexport type OrgUpdateMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgUpdateMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The new member permission level for the organization. */\n  permission?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n  /** The former member permission level for the organization. */\n  permissionWas?: Maybe<OrgUpdateMemberAuditEntryPermission>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The permissions available to members on an Organization. */\nexport enum OrgUpdateMemberAuditEntryPermission {\n  /** Can read, clone, push, and add collaborators to repositories. */\n  Admin = 'ADMIN',\n  /** Can read and clone repositories. */\n  Read = 'READ'\n}\n\n/** Audit log entry for a org.update_member_repository_creation_permission event. */\nexport type OrgUpdateMemberRepositoryCreationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** Can members create repositories in the organization. */\n  canCreateRepositories?: Maybe<Scalars['Boolean']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The permission for visibility level of repositories for this organization. */\n  visibility?: Maybe<OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility>;\n};\n\n/** The permissions available for repository creation on an Organization. */\nexport enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {\n  /** All organization members are restricted from creating any repositories. */\n  All = 'ALL',\n  /** All organization members are restricted from creating internal repositories. */\n  Internal = 'INTERNAL',\n  /** All organization members are allowed to create any repositories. */\n  None = 'NONE',\n  /** All organization members are restricted from creating private repositories. */\n  Private = 'PRIVATE',\n  /** All organization members are restricted from creating private or internal repositories. */\n  PrivateInternal = 'PRIVATE_INTERNAL',\n  /** All organization members are restricted from creating public repositories. */\n  Public = 'PUBLIC',\n  /** All organization members are restricted from creating public or internal repositories. */\n  PublicInternal = 'PUBLIC_INTERNAL',\n  /** All organization members are restricted from creating public or private repositories. */\n  PublicPrivate = 'PUBLIC_PRIVATE'\n}\n\n/** Audit log entry for a org.update_member_repository_invitation_permission event. */\nexport type OrgUpdateMemberRepositoryInvitationPermissionAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & {\n  __typename?: 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** Can outside collaborators be invited to repositories in the organization. */\n  canInviteOutsideCollaboratorsToRepositories?: Maybe<Scalars['Boolean']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type Organization = Actor & AnnouncementBanner & MemberStatusable & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {\n  __typename?: 'Organization';\n  /** The text of the announcement */\n  announcement?: Maybe<Scalars['String']>;\n  /** The expiration date of the announcement, if any */\n  announcementExpiresAt?: Maybe<Scalars['DateTime']>;\n  /** Whether the announcement can be dismissed by the user */\n  announcementUserDismissible?: Maybe<Scalars['Boolean']>;\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean'];\n  /** Audit log entries of the organization */\n  auditLog: OrganizationAuditEntryConnection;\n  /** A URL pointing to the organization's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The organization's public profile description. */\n  description?: Maybe<Scalars['String']>;\n  /** The organization's public profile description rendered to HTML. */\n  descriptionHTML?: Maybe<Scalars['String']>;\n  /** A list of domains owned by the organization. */\n  domains?: Maybe<VerifiableDomainConnection>;\n  /** The organization's public email. */\n  email?: Maybe<Scalars['String']>;\n  /** A list of owners of the organization's enterprise account. */\n  enterpriseOwners: OrganizationEnterpriseOwnerConnection;\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int'];\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** The interaction ability settings for this organization. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** The setting value for whether the organization has an IP allow list enabled. */\n  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;\n  /** The IP addresses that are allowed to access resources owned by the organization. */\n  ipAllowListEntries: IpAllowListEntryConnection;\n  /** The setting value for whether the organization has IP allow list configuration for installed GitHub Apps enabled. */\n  ipAllowListForInstalledAppsEnabledSetting: IpAllowListForInstalledAppsEnabledSettingValue;\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean'];\n  /** Whether the organization has verified its profile email and website. */\n  isVerified: Scalars['Boolean'];\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The organization's public profile location. */\n  location?: Maybe<Scalars['String']>;\n  /** The organization's login name. */\n  login: Scalars['String'];\n  /** A list of all mannequins for this organization. */\n  mannequins: MannequinConnection;\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n  /** Members can fork private repositories in this organization */\n  membersCanForkPrivateRepositories: Scalars['Boolean'];\n  /** A list of users who are members of this organization. */\n  membersWithRole: OrganizationMemberConnection;\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];\n  /** The organization's public profile name. */\n  name?: Maybe<Scalars['String']>;\n  /** The HTTP path creating a new team */\n  newTeamResourcePath: Scalars['URI'];\n  /** The HTTP URL creating a new team */\n  newTeamUrl: Scalars['URI'];\n  /** Indicates if email notification delivery for this organization is restricted to verified or approved domains. */\n  notificationDeliveryRestrictionEnabledSetting: NotificationRestrictionSettingValue;\n  /** The billing email for the organization. */\n  organizationBillingEmail?: Maybe<Scalars['String']>;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** A list of users who have been invited to join this organization. */\n  pendingMembers: UserConnection;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing organization's projects */\n  projectsResourcePath: Scalars['URI'];\n  /** The HTTP URL listing organization's projects */\n  projectsUrl: Scalars['URI'];\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n  /** A list of all repository migrations for this organization. */\n  repositoryMigrations: RepositoryMigrationConnection;\n  /**\n   * When true the organization requires all members, billing managers, and outside\n   * collaborators to enable two-factor authentication.\n   */\n  requiresTwoFactorAuthentication?: Maybe<Scalars['Boolean']>;\n  /** The HTTP path for this organization. */\n  resourcePath: Scalars['URI'];\n  /** Returns a single ruleset from the current organization by ID. */\n  ruleset?: Maybe<RepositoryRuleset>;\n  /** A list of rulesets for this organization. */\n  rulesets?: Maybe<RepositoryRulesetConnection>;\n  /**\n   * The Organization's SAML identity provider. Visible to (1) organization owners,\n   * (2) organization owners' personal access tokens (classic) with read:org or\n   * admin:org scope, (3) GitHub App with an installation token with read or write\n   * access to members.\n   */\n  samlIdentityProvider?: Maybe<OrganizationIdentityProvider>;\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /** Find an organization's team by its slug. */\n  team?: Maybe<Team>;\n  /** A list of teams in this organization. */\n  teams: TeamConnection;\n  /** The HTTP path listing organization's teams */\n  teamsResourcePath: Scalars['URI'];\n  /** The HTTP URL listing organization's teams */\n  teamsUrl: Scalars['URI'];\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;\n  /** The organization's Twitter username. */\n  twitterUsername?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this organization. */\n  url: Scalars['URI'];\n  /** Organization is adminable by the viewer. */\n  viewerCanAdminister: Scalars['Boolean'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean'];\n  /** Viewer can create repositories on this organization */\n  viewerCanCreateRepositories: Scalars['Boolean'];\n  /** Viewer can create teams on this organization. */\n  viewerCanCreateTeams: Scalars['Boolean'];\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean'];\n  /** Viewer is an active member of this organization. */\n  viewerIsAMember: Scalars['Boolean'];\n  /** Whether or not this Organization is followed by the viewer. */\n  viewerIsFollowing: Scalars['Boolean'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean'];\n  /** Whether contributors are required to sign off on web-based commits for repositories in this organization. */\n  webCommitSignoffRequired: Scalars['Boolean'];\n  /** The organization's public profile URL. */\n  websiteUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAuditLogArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<AuditLogOrder>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationDomainsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isApproved?: InputMaybe<Scalars['Boolean']>;\n  isVerified?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<VerifiableDomainOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationEnterpriseOwnersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrgEnterpriseOwnerOrder>;\n  organizationRole?: InputMaybe<RoleInOrganization>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIpAllowListEntriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IpAllowListEntryOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationIsSponsoredByArgs = {\n  accountLogin: Scalars['String'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMannequinsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MannequinOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationMembersWithRoleArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPackagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPendingMembersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isFork?: InputMaybe<Scalars['Boolean']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']>;\n  name: Scalars['String'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  answered?: InputMaybe<Scalars['Boolean']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRepositoryMigrationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryMigrationOrder>;\n  repositoryName?: InputMaybe<Scalars['String']>;\n  state?: InputMaybe<MigrationState>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRulesetArgs = {\n  databaseId: Scalars['Int'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationRulesetsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeParents?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamArgs = {\n  slug: Scalars['String'];\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTeamsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  ldapMapped?: InputMaybe<Scalars['Boolean']>;\n  notificationSetting?: InputMaybe<TeamNotificationSetting>;\n  orderBy?: InputMaybe<TeamOrder>;\n  privacy?: InputMaybe<TeamPrivacy>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<TeamRole>;\n  rootTeamsOnly?: InputMaybe<Scalars['Boolean']>;\n  userLogins?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\n/** An account on GitHub, with one or more owners, that has repositories, members and teams. */\nexport type OrganizationTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n/** An audit entry in an organization audit log. */\nexport type OrganizationAuditEntry = MembersCanDeleteReposClearAuditEntry | MembersCanDeleteReposDisableAuditEntry | MembersCanDeleteReposEnableAuditEntry | OauthApplicationCreateAuditEntry | OrgAddBillingManagerAuditEntry | OrgAddMemberAuditEntry | OrgBlockUserAuditEntry | OrgConfigDisableCollaboratorsOnlyAuditEntry | OrgConfigEnableCollaboratorsOnlyAuditEntry | OrgCreateAuditEntry | OrgDisableOauthAppRestrictionsAuditEntry | OrgDisableSamlAuditEntry | OrgDisableTwoFactorRequirementAuditEntry | OrgEnableOauthAppRestrictionsAuditEntry | OrgEnableSamlAuditEntry | OrgEnableTwoFactorRequirementAuditEntry | OrgInviteMemberAuditEntry | OrgInviteToBusinessAuditEntry | OrgOauthAppAccessApprovedAuditEntry | OrgOauthAppAccessDeniedAuditEntry | OrgOauthAppAccessRequestedAuditEntry | OrgRemoveBillingManagerAuditEntry | OrgRemoveMemberAuditEntry | OrgRemoveOutsideCollaboratorAuditEntry | OrgRestoreMemberAuditEntry | OrgUnblockUserAuditEntry | OrgUpdateDefaultRepositoryPermissionAuditEntry | OrgUpdateMemberAuditEntry | OrgUpdateMemberRepositoryCreationPermissionAuditEntry | OrgUpdateMemberRepositoryInvitationPermissionAuditEntry | PrivateRepositoryForkingDisableAuditEntry | PrivateRepositoryForkingEnableAuditEntry | RepoAccessAuditEntry | RepoAddMemberAuditEntry | RepoAddTopicAuditEntry | RepoArchivedAuditEntry | RepoChangeMergeSettingAuditEntry | RepoConfigDisableAnonymousGitAccessAuditEntry | RepoConfigDisableCollaboratorsOnlyAuditEntry | RepoConfigDisableContributorsOnlyAuditEntry | RepoConfigDisableSockpuppetDisallowedAuditEntry | RepoConfigEnableAnonymousGitAccessAuditEntry | RepoConfigEnableCollaboratorsOnlyAuditEntry | RepoConfigEnableContributorsOnlyAuditEntry | RepoConfigEnableSockpuppetDisallowedAuditEntry | RepoConfigLockAnonymousGitAccessAuditEntry | RepoConfigUnlockAnonymousGitAccessAuditEntry | RepoCreateAuditEntry | RepoDestroyAuditEntry | RepoRemoveMemberAuditEntry | RepoRemoveTopicAuditEntry | RepositoryVisibilityChangeDisableAuditEntry | RepositoryVisibilityChangeEnableAuditEntry | TeamAddMemberAuditEntry | TeamAddRepositoryAuditEntry | TeamChangeParentTeamAuditEntry | TeamRemoveMemberAuditEntry | TeamRemoveRepositoryAuditEntry;\n\n/** The connection type for OrganizationAuditEntry. */\nexport type OrganizationAuditEntryConnection = {\n  __typename?: 'OrganizationAuditEntryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationAuditEntryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationAuditEntry>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Metadata for an audit entry with action org.* */\nexport type OrganizationAuditEntryData = {\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n};\n\n/** An edge in a connection. */\nexport type OrganizationAuditEntryEdge = {\n  __typename?: 'OrganizationAuditEntryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationAuditEntry>;\n};\n\n/** A list of organizations managed by an enterprise. */\nexport type OrganizationConnection = {\n  __typename?: 'OrganizationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Organization>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type OrganizationEdge = {\n  __typename?: 'OrganizationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Organization>;\n};\n\n/** The connection type for User. */\nexport type OrganizationEnterpriseOwnerConnection = {\n  __typename?: 'OrganizationEnterpriseOwnerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationEnterpriseOwnerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An enterprise owner in the context of an organization that is part of the enterprise. */\nexport type OrganizationEnterpriseOwnerEdge = {\n  __typename?: 'OrganizationEnterpriseOwnerEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role of the owner with respect to the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/**\n * An Identity Provider configured to provision SAML and SCIM identities for\n * Organizations. Visible to (1) organization owners, (2) organization owners'\n * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub\n * App with an installation token with read or write access to members.\n */\nexport type OrganizationIdentityProvider = Node & {\n  __typename?: 'OrganizationIdentityProvider';\n  /** The digest algorithm used to sign SAML requests for the Identity Provider. */\n  digestMethod?: Maybe<Scalars['URI']>;\n  /** External Identities provisioned by this Identity Provider */\n  externalIdentities: ExternalIdentityConnection;\n  id: Scalars['ID'];\n  /** The x509 certificate used by the Identity Provider to sign assertions and responses. */\n  idpCertificate?: Maybe<Scalars['X509Certificate']>;\n  /** The Issuer Entity ID for the SAML Identity Provider */\n  issuer?: Maybe<Scalars['String']>;\n  /** Organization this Identity Provider belongs to */\n  organization?: Maybe<Organization>;\n  /** The signature algorithm used to sign SAML requests for the Identity Provider. */\n  signatureMethod?: Maybe<Scalars['URI']>;\n  /** The URL endpoint for the Identity Provider's SAML SSO. */\n  ssoUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/**\n * An Identity Provider configured to provision SAML and SCIM identities for\n * Organizations. Visible to (1) organization owners, (2) organization owners'\n * personal access tokens (classic) with read:org or admin:org scope, (3) GitHub\n * App with an installation token with read or write access to members.\n */\nexport type OrganizationIdentityProviderExternalIdentitiesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  login?: InputMaybe<Scalars['String']>;\n  membersOnly?: InputMaybe<Scalars['Boolean']>;\n  userName?: InputMaybe<Scalars['String']>;\n};\n\n/** An Invitation for a user to an organization. */\nexport type OrganizationInvitation = Node & {\n  __typename?: 'OrganizationInvitation';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The email address of the user invited to the organization. */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The source of the invitation. */\n  invitationSource: OrganizationInvitationSource;\n  /** The type of invitation that was sent (e.g. email, user). */\n  invitationType: OrganizationInvitationType;\n  /** The user who was invited to the organization. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The organization the invite is for */\n  organization: Organization;\n  /** The user's pending role in the organization (e.g. member, owner). */\n  role: OrganizationInvitationRole;\n};\n\n/** The connection type for OrganizationInvitation. */\nexport type OrganizationInvitationConnection = {\n  __typename?: 'OrganizationInvitationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type OrganizationInvitationEdge = {\n  __typename?: 'OrganizationInvitationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<OrganizationInvitation>;\n};\n\n/** The possible organization invitation roles. */\nexport enum OrganizationInvitationRole {\n  /** The user is invited to be an admin of the organization. */\n  Admin = 'ADMIN',\n  /** The user is invited to be a billing manager of the organization. */\n  BillingManager = 'BILLING_MANAGER',\n  /** The user is invited to be a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** The user's previous role will be reinstated. */\n  Reinstate = 'REINSTATE'\n}\n\n/** The possible organization invitation sources. */\nexport enum OrganizationInvitationSource {\n  /** The invitation was created from the web interface or from API */\n  Member = 'MEMBER',\n  /** The invitation was created from SCIM */\n  Scim = 'SCIM',\n  /** The invitation was sent before this feature was added */\n  Unknown = 'UNKNOWN'\n}\n\n/** The possible organization invitation types. */\nexport enum OrganizationInvitationType {\n  /** The invitation was to an email address. */\n  Email = 'EMAIL',\n  /** The invitation was to an existing user. */\n  User = 'USER'\n}\n\n/** The connection type for User. */\nexport type OrganizationMemberConnection = {\n  __typename?: 'OrganizationMemberConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<OrganizationMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user within an organization. */\nexport type OrganizationMemberEdge = {\n  __typename?: 'OrganizationMemberEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer. */\n  hasTwoFactorEnabled?: Maybe<Scalars['Boolean']>;\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n  /** The role this user has in the organization. */\n  role?: Maybe<OrganizationMemberRole>;\n};\n\n/** The possible roles within an organization for its members. */\nexport enum OrganizationMemberRole {\n  /** The user is an administrator of the organization. */\n  Admin = 'ADMIN',\n  /** The user is a member of the organization. */\n  Member = 'MEMBER'\n}\n\n/** The possible values for the members can create repositories setting on an organization. */\nexport enum OrganizationMembersCanCreateRepositoriesSettingValue {\n  /** Members will be able to create public and private repositories. */\n  All = 'ALL',\n  /** Members will not be able to create public or private repositories. */\n  Disabled = 'DISABLED',\n  /** Members will be able to create only internal repositories. */\n  Internal = 'INTERNAL',\n  /** Members will be able to create only private repositories. */\n  Private = 'PRIVATE'\n}\n\n/** A GitHub Enterprise Importer (GEI) organization migration. */\nexport type OrganizationMigration = Node & {\n  __typename?: 'OrganizationMigration';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']>;\n  /** The reason the organization migration failed. */\n  failureReason?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The remaining amount of repos to be migrated. */\n  remainingRepositoriesCount?: Maybe<Scalars['Int']>;\n  /** The name of the source organization to be migrated. */\n  sourceOrgName: Scalars['String'];\n  /** The URL of the source organization to migrate. */\n  sourceOrgUrl: Scalars['URI'];\n  /** The migration state. */\n  state: OrganizationMigrationState;\n  /** The name of the target organization. */\n  targetOrgName: Scalars['String'];\n  /** The total amount of repositories to be migrated. */\n  totalRepositoriesCount?: Maybe<Scalars['Int']>;\n};\n\n/** The Octoshift Organization migration state. */\nexport enum OrganizationMigrationState {\n  /** The Octoshift migration has failed. */\n  Failed = 'FAILED',\n  /** The Octoshift migration has invalid credentials. */\n  FailedValidation = 'FAILED_VALIDATION',\n  /** The Octoshift migration is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The Octoshift migration has not started. */\n  NotStarted = 'NOT_STARTED',\n  /** The Octoshift migration needs to have its credentials validated. */\n  PendingValidation = 'PENDING_VALIDATION',\n  /** The Octoshift migration is performing post repository migrations. */\n  PostRepoMigration = 'POST_REPO_MIGRATION',\n  /** The Octoshift migration is performing pre repository migrations. */\n  PreRepoMigration = 'PRE_REPO_MIGRATION',\n  /** The Octoshift migration has been queued. */\n  Queued = 'QUEUED',\n  /** The Octoshift org migration is performing repository migrations. */\n  RepoMigration = 'REPO_MIGRATION',\n  /** The Octoshift migration has succeeded. */\n  Succeeded = 'SUCCEEDED'\n}\n\n/** Used for argument of CreateProjectV2 mutation. */\nexport type OrganizationOrUser = Organization | User;\n\n/** Ordering options for organization connections. */\nexport type OrganizationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order organizations by. */\n  field: OrganizationOrderField;\n};\n\n/** Properties by which organization connections can be ordered. */\nexport enum OrganizationOrderField {\n  /** Order organizations by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order organizations by login */\n  Login = 'LOGIN'\n}\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContext = HovercardContext & {\n  __typename?: 'OrganizationTeamsHovercardContext';\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n  /** Teams in this organization the user is a member of that are relevant */\n  relevantTeams: TeamConnection;\n  /** The path for the full team list for this user */\n  teamsResourcePath: Scalars['URI'];\n  /** The URL for the full team list for this user */\n  teamsUrl: Scalars['URI'];\n  /** The total number of teams the user is on in the organization */\n  totalTeamCount: Scalars['Int'];\n};\n\n\n/** An organization teams hovercard context */\nexport type OrganizationTeamsHovercardContextRelevantTeamsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContext = HovercardContext & {\n  __typename?: 'OrganizationsHovercardContext';\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n  /** Organizations this user is a member of that are relevant */\n  relevantOrganizations: OrganizationConnection;\n  /** The total number of organizations this user is in */\n  totalOrganizationCount: Scalars['Int'];\n};\n\n\n/** An organization list hovercard context */\nexport type OrganizationsHovercardContextRelevantOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n};\n\n/** Information for an uploaded package. */\nexport type Package = Node & {\n  __typename?: 'Package';\n  id: Scalars['ID'];\n  /** Find the latest version for the package. */\n  latestVersion?: Maybe<PackageVersion>;\n  /** Identifies the name of the package. */\n  name: Scalars['String'];\n  /** Identifies the type of the package. */\n  packageType: PackageType;\n  /** The repository this package belongs to. */\n  repository?: Maybe<Repository>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageStatistics>;\n  /** Find package version by version string. */\n  version?: Maybe<PackageVersion>;\n  /** list of versions for this package */\n  versions: PackageVersionConnection;\n};\n\n\n/** Information for an uploaded package. */\nexport type PackageVersionArgs = {\n  version: Scalars['String'];\n};\n\n\n/** Information for an uploaded package. */\nexport type PackageVersionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PackageVersionOrder>;\n};\n\n/** The connection type for Package. */\nexport type PackageConnection = {\n  __typename?: 'PackageConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Package>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PackageEdge = {\n  __typename?: 'PackageEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Package>;\n};\n\n/** A file in a package version. */\nexport type PackageFile = Node & {\n  __typename?: 'PackageFile';\n  id: Scalars['ID'];\n  /** MD5 hash of the file. */\n  md5?: Maybe<Scalars['String']>;\n  /** Name of the file. */\n  name: Scalars['String'];\n  /** The package version this file belongs to. */\n  packageVersion?: Maybe<PackageVersion>;\n  /** SHA1 hash of the file. */\n  sha1?: Maybe<Scalars['String']>;\n  /** SHA256 hash of the file. */\n  sha256?: Maybe<Scalars['String']>;\n  /** Size of the file in bytes. */\n  size?: Maybe<Scalars['Int']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** URL to download the asset. */\n  url?: Maybe<Scalars['URI']>;\n};\n\n/** The connection type for PackageFile. */\nexport type PackageFileConnection = {\n  __typename?: 'PackageFileConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PackageFileEdge = {\n  __typename?: 'PackageFileEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageFile>;\n};\n\n/** Ways in which lists of package files can be ordered upon return. */\nexport type PackageFileOrder = {\n  /** The direction in which to order package files by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package files by. */\n  field?: InputMaybe<PackageFileOrderField>;\n};\n\n/** Properties by which package file connections can be ordered. */\nexport enum PackageFileOrderField {\n  /** Order package files by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ways in which lists of packages can be ordered upon return. */\nexport type PackageOrder = {\n  /** The direction in which to order packages by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order packages by. */\n  field?: InputMaybe<PackageOrderField>;\n};\n\n/** Properties by which package connections can be ordered. */\nexport enum PackageOrderField {\n  /** Order packages by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents an owner of a package. */\nexport type PackageOwner = {\n  id: Scalars['ID'];\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n};\n\n\n/** Represents an owner of a package. */\nexport type PackageOwnerPackagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Represents a object that contains package activity statistics such as downloads. */\nexport type PackageStatistics = {\n  __typename?: 'PackageStatistics';\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int'];\n};\n\n/** A version tag contains the mapping between a tag name and a version. */\nexport type PackageTag = Node & {\n  __typename?: 'PackageTag';\n  id: Scalars['ID'];\n  /** Identifies the tag name of the version. */\n  name: Scalars['String'];\n  /** Version that the tag is associated with. */\n  version?: Maybe<PackageVersion>;\n};\n\n/** The possible types of a package. */\nexport enum PackageType {\n  /** A debian package. */\n  Debian = 'DEBIAN',\n  /**\n   * A docker image.\n   * @deprecated DOCKER will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2021-06-21 UTC.\n   */\n  Docker = 'DOCKER',\n  /**\n   * A maven package.\n   * @deprecated MAVEN will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2023-02-10 UTC.\n   */\n  Maven = 'MAVEN',\n  /**\n   * An npm package.\n   * @deprecated NPM will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.\n   */\n  Npm = 'NPM',\n  /**\n   * A nuget package.\n   * @deprecated NUGET will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-11-21 UTC.\n   */\n  Nuget = 'NUGET',\n  /** A python package. */\n  Pypi = 'PYPI',\n  /**\n   * A rubygems package.\n   * @deprecated RUBYGEMS will be removed from this enum as this type will be migrated to only be used by the Packages REST API. Removal on 2022-12-28 UTC.\n   */\n  Rubygems = 'RUBYGEMS'\n}\n\n/** Information about a specific package version. */\nexport type PackageVersion = Node & {\n  __typename?: 'PackageVersion';\n  /** List of files associated with this package version */\n  files: PackageFileConnection;\n  id: Scalars['ID'];\n  /** The package associated with this version. */\n  package?: Maybe<Package>;\n  /** The platform this version was built for. */\n  platform?: Maybe<Scalars['String']>;\n  /** Whether or not this version is a pre-release. */\n  preRelease: Scalars['Boolean'];\n  /** The README of this package version. */\n  readme?: Maybe<Scalars['String']>;\n  /** The release associated with this package version. */\n  release?: Maybe<Release>;\n  /** Statistics about package activity. */\n  statistics?: Maybe<PackageVersionStatistics>;\n  /** The package version summary. */\n  summary?: Maybe<Scalars['String']>;\n  /** The version string. */\n  version: Scalars['String'];\n};\n\n\n/** Information about a specific package version. */\nexport type PackageVersionFilesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PackageFileOrder>;\n};\n\n/** The connection type for PackageVersion. */\nexport type PackageVersionConnection = {\n  __typename?: 'PackageVersionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PackageVersionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PackageVersion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PackageVersionEdge = {\n  __typename?: 'PackageVersionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PackageVersion>;\n};\n\n/** Ways in which lists of package versions can be ordered upon return. */\nexport type PackageVersionOrder = {\n  /** The direction in which to order package versions by the specified field. */\n  direction?: InputMaybe<OrderDirection>;\n  /** The field in which to order package versions by. */\n  field?: InputMaybe<PackageVersionOrderField>;\n};\n\n/** Properties by which package version connections can be ordered. */\nexport enum PackageVersionOrderField {\n  /** Order package versions by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Represents a object that contains package version activity statistics such as downloads. */\nexport type PackageVersionStatistics = {\n  __typename?: 'PackageVersionStatistics';\n  /** Number of times the package was downloaded since it was created. */\n  downloadsTotalCount: Scalars['Int'];\n};\n\n/** Information about pagination in a connection. */\nexport type PageInfo = {\n  __typename?: 'PageInfo';\n  /** When paginating forwards, the cursor to continue. */\n  endCursor?: Maybe<Scalars['String']>;\n  /** When paginating forwards, are there more items? */\n  hasNextPage: Scalars['Boolean'];\n  /** When paginating backwards, are there more items? */\n  hasPreviousPage: Scalars['Boolean'];\n  /** When paginating backwards, the cursor to continue. */\n  startCursor?: Maybe<Scalars['String']>;\n};\n\n/** The possible types of patch statuses. */\nexport enum PatchStatus {\n  /** The file was added. Git status 'A'. */\n  Added = 'ADDED',\n  /** The file's type was changed. Git status 'T'. */\n  Changed = 'CHANGED',\n  /** The file was copied. Git status 'C'. */\n  Copied = 'COPIED',\n  /** The file was deleted. Git status 'D'. */\n  Deleted = 'DELETED',\n  /** The file's contents were changed. Git status 'M'. */\n  Modified = 'MODIFIED',\n  /** The file was renamed. Git status 'R'. */\n  Renamed = 'RENAMED'\n}\n\n/** Types that can grant permissions on a repository to a user */\nexport type PermissionGranter = Organization | Repository | Team;\n\n/** A level of permission and source for a user's access to a repository. */\nexport type PermissionSource = {\n  __typename?: 'PermissionSource';\n  /** The organization the repository belongs to. */\n  organization: Organization;\n  /** The level of access this source has granted to the user. */\n  permission: DefaultRepositoryPermissionField;\n  /** The source of this permission. */\n  source: PermissionGranter;\n};\n\n/** Autogenerated input type of PinIssue */\nexport type PinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the issue to be pinned */\n  issueId: Scalars['ID'];\n};\n\n/** Autogenerated return type of PinIssue */\nexport type PinIssuePayload = {\n  __typename?: 'PinIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue that was pinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Types that can be pinned to a profile page. */\nexport type PinnableItem = Gist | Repository;\n\n/** The connection type for PinnableItem. */\nexport type PinnableItemConnection = {\n  __typename?: 'PinnableItemConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PinnableItemEdge = {\n  __typename?: 'PinnableItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnableItem>;\n};\n\n/** Represents items that can be pinned to a profile page or dashboard. */\nexport enum PinnableItemType {\n  /** A gist. */\n  Gist = 'GIST',\n  /** An issue. */\n  Issue = 'ISSUE',\n  /** An organization. */\n  Organization = 'ORGANIZATION',\n  /** A project. */\n  Project = 'PROJECT',\n  /** A pull request. */\n  PullRequest = 'PULL_REQUEST',\n  /** A repository. */\n  Repository = 'REPOSITORY',\n  /** A team. */\n  Team = 'TEAM',\n  /** A user. */\n  User = 'USER'\n}\n\n/** A Pinned Discussion is a discussion pinned to a repository's index page. */\nexport type PinnedDiscussion = Node & RepositoryNode & {\n  __typename?: 'PinnedDiscussion';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The discussion that was pinned. */\n  discussion: Discussion;\n  /** Color stops of the chosen gradient */\n  gradientStopColors: Array<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Background texture pattern */\n  pattern: PinnedDiscussionPattern;\n  /** The actor that pinned this discussion. */\n  pinnedBy: Actor;\n  /** Preconfigured background gradient option */\n  preconfiguredGradient?: Maybe<PinnedDiscussionGradient>;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for PinnedDiscussion. */\nexport type PinnedDiscussionConnection = {\n  __typename?: 'PinnedDiscussionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PinnedDiscussionEdge = {\n  __typename?: 'PinnedDiscussionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedDiscussion>;\n};\n\n/** Preconfigured gradients that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionGradient {\n  /** A gradient of blue to mint */\n  BlueMint = 'BLUE_MINT',\n  /** A gradient of blue to purple */\n  BluePurple = 'BLUE_PURPLE',\n  /** A gradient of pink to blue */\n  PinkBlue = 'PINK_BLUE',\n  /** A gradient of purple to coral */\n  PurpleCoral = 'PURPLE_CORAL',\n  /** A gradient of red to orange */\n  RedOrange = 'RED_ORANGE'\n}\n\n/** Preconfigured background patterns that may be used to style discussions pinned within a repository. */\nexport enum PinnedDiscussionPattern {\n  /** An upward-facing chevron pattern */\n  ChevronUp = 'CHEVRON_UP',\n  /** A hollow dot pattern */\n  Dot = 'DOT',\n  /** A solid dot pattern */\n  DotFill = 'DOT_FILL',\n  /** A heart pattern */\n  HeartFill = 'HEART_FILL',\n  /** A plus sign pattern */\n  Plus = 'PLUS',\n  /** A lightning bolt pattern */\n  Zap = 'ZAP'\n}\n\n/** Represents a 'pinned' event on a given issue or pull request. */\nexport type PinnedEvent = Node & {\n  __typename?: 'PinnedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** A Pinned Issue is a issue pinned to a repository's index page. */\nexport type PinnedIssue = Node & {\n  __typename?: 'PinnedIssue';\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** Identifies the primary key from the database as a BigInt. */\n  fullDatabaseId?: Maybe<Scalars['BigInt']>;\n  id: Scalars['ID'];\n  /** The issue that was pinned. */\n  issue: Issue;\n  /** The actor that pinned this issue. */\n  pinnedBy: Actor;\n  /** The repository that this issue was pinned to. */\n  repository: Repository;\n};\n\n/** The connection type for PinnedIssue. */\nexport type PinnedIssueConnection = {\n  __typename?: 'PinnedIssueConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PinnedIssueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PinnedIssue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PinnedIssueEdge = {\n  __typename?: 'PinnedIssueEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PinnedIssue>;\n};\n\n/** Audit log entry for a private_repository_forking.disable event. */\nexport type PrivateRepositoryForkingDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'PrivateRepositoryForkingDisableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a private_repository_forking.enable event. */\nexport type PrivateRepositoryForkingEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'PrivateRepositoryForkingEnableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcase = {\n  __typename?: 'ProfileItemShowcase';\n  /** Whether or not the owner has pinned any repositories or gists. */\n  hasPinnedItems: Scalars['Boolean'];\n  /**\n   * The repositories and gists in the showcase. If the profile owner has any\n   * pinned items, those will be returned. Otherwise, the profile owner's popular\n   * repositories will be returned.\n   */\n  items: PinnableItemConnection;\n};\n\n\n/**\n * A curatable list of repositories relating to a repository owner, which defaults\n * to showing the most popular repositories they own.\n */\nexport type ProfileItemShowcaseItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwner = {\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean'];\n  /** The public profile email. */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The public profile location. */\n  location?: Maybe<Scalars['String']>;\n  /** The username used to login. */\n  login: Scalars['String'];\n  /** The public profile name. */\n  name?: Maybe<Scalars['String']>;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean'];\n  /** The public profile website URL. */\n  websiteUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** Represents any entity on GitHub that has a profile page. */\nexport type ProfileOwnerPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type Project = Closable & Node & Updatable & {\n  __typename?: 'Project';\n  /** The project's description body. */\n  body?: Maybe<Scalars['String']>;\n  /** The projects description body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** Indicates if the object is closed (definition of closed may depend on type) */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** List of columns in the project */\n  columns: ProjectColumnConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who originally created the project. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project's name. */\n  name: Scalars['String'];\n  /** The project's number. */\n  number: Scalars['Int'];\n  /** The project's owner. Currently limited to repositories, organizations, and users. */\n  owner: ProjectOwner;\n  /** List of pending cards in this project */\n  pendingCards: ProjectCardConnection;\n  /** Project progress details. */\n  progress: ProjectProgress;\n  /** The HTTP path for this project */\n  resourcePath: Scalars['URI'];\n  /** Whether the project is open or closed. */\n  state: ProjectState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this project */\n  url: Scalars['URI'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n};\n\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectColumnsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Projects manage issues, pull requests and notes within a project owner. */\nexport type ProjectPendingCardsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A card in a project. */\nexport type ProjectCard = Node & {\n  __typename?: 'ProjectCard';\n  /**\n   * The project column this card is associated under. A card may only belong to one\n   * project column at a time. The column field will be null if the card is created\n   * in a pending state and has yet to be associated with a column. Once cards are\n   * associated with a column, they will not become pending in the future.\n   */\n  column?: Maybe<ProjectColumn>;\n  /** The card content item */\n  content?: Maybe<ProjectCardItem>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created this card */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Whether the card is archived */\n  isArchived: Scalars['Boolean'];\n  /** The card note */\n  note?: Maybe<Scalars['String']>;\n  /** The project that contains this card. */\n  project: Project;\n  /** The HTTP path for this card */\n  resourcePath: Scalars['URI'];\n  /** The state of ProjectCard */\n  state?: Maybe<ProjectCardState>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this card */\n  url: Scalars['URI'];\n};\n\n/** The possible archived states of a project card. */\nexport enum ProjectCardArchivedState {\n  /** A project card that is archived */\n  Archived = 'ARCHIVED',\n  /** A project card that is not archived */\n  NotArchived = 'NOT_ARCHIVED'\n}\n\n/** The connection type for ProjectCard. */\nexport type ProjectCardConnection = {\n  __typename?: 'ProjectCardConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectCardEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectCard>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectCardEdge = {\n  __typename?: 'ProjectCardEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectCard>;\n};\n\n/** An issue or PR and its owning repository to be used in a project card. */\nexport type ProjectCardImport = {\n  /** The issue or pull request number. */\n  number: Scalars['Int'];\n  /** Repository name with owner (owner/repository). */\n  repository: Scalars['String'];\n};\n\n/** Types that can be inside Project Cards. */\nexport type ProjectCardItem = Issue | PullRequest;\n\n/** Various content states of a ProjectCard */\nexport enum ProjectCardState {\n  /** The card has content only. */\n  ContentOnly = 'CONTENT_ONLY',\n  /** The card has a note only. */\n  NoteOnly = 'NOTE_ONLY',\n  /** The card is redacted. */\n  Redacted = 'REDACTED'\n}\n\n/** A column inside a project. */\nexport type ProjectColumn = Node & {\n  __typename?: 'ProjectColumn';\n  /** List of cards in the column */\n  cards: ProjectCardConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project column's name. */\n  name: Scalars['String'];\n  /** The project that contains this column. */\n  project: Project;\n  /** The semantic purpose of the column */\n  purpose?: Maybe<ProjectColumnPurpose>;\n  /** The HTTP path for this project column */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this project column */\n  url: Scalars['URI'];\n};\n\n\n/** A column inside a project. */\nexport type ProjectColumnCardsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for ProjectColumn. */\nexport type ProjectColumnConnection = {\n  __typename?: 'ProjectColumnConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectColumnEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectColumn>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectColumnEdge = {\n  __typename?: 'ProjectColumnEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectColumn>;\n};\n\n/** A project column and a list of its issues and PRs. */\nexport type ProjectColumnImport = {\n  /** The name of the column. */\n  columnName: Scalars['String'];\n  /** A list of issues and pull requests in the column. */\n  issues?: InputMaybe<Array<ProjectCardImport>>;\n  /** The position of the column, starting from 0. */\n  position: Scalars['Int'];\n};\n\n/** The semantic purpose of the column - todo, in progress, or done. */\nexport enum ProjectColumnPurpose {\n  /** The column contains cards which are complete */\n  Done = 'DONE',\n  /** The column contains cards which are currently being worked on */\n  InProgress = 'IN_PROGRESS',\n  /** The column contains cards still to be worked on */\n  Todo = 'TODO'\n}\n\n/** A list of projects associated with the owner. */\nexport type ProjectConnection = {\n  __typename?: 'ProjectConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Project>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectEdge = {\n  __typename?: 'ProjectEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Project>;\n};\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectOrder = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectOrderField;\n};\n\n/** Properties by which project connections can be ordered. */\nexport enum ProjectOrderField {\n  /** Order projects by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order projects by name */\n  Name = 'NAME',\n  /** Order projects by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a Project. */\nexport type ProjectOwner = {\n  id: Scalars['ID'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing owners projects */\n  projectsResourcePath: Scalars['URI'];\n  /** The HTTP URL listing owners projects */\n  projectsUrl: Scalars['URI'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean'];\n};\n\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** Represents an owner of a Project. */\nexport type ProjectOwnerProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n/** Project progress stats. */\nexport type ProjectProgress = {\n  __typename?: 'ProjectProgress';\n  /** The number of done cards. */\n  doneCount: Scalars['Int'];\n  /** The percentage of done cards. */\n  donePercentage: Scalars['Float'];\n  /** Whether progress tracking is enabled and cards with purpose exist for this project */\n  enabled: Scalars['Boolean'];\n  /** The number of in-progress cards. */\n  inProgressCount: Scalars['Int'];\n  /** The percentage of in-progress cards. */\n  inProgressPercentage: Scalars['Float'];\n  /** The number of to do cards. */\n  todoCount: Scalars['Int'];\n  /** The percentage of to do cards. */\n  todoPercentage: Scalars['Float'];\n};\n\n/** State of the project; either 'open' or 'closed' */\nexport enum ProjectState {\n  /** The project is closed. */\n  Closed = 'CLOSED',\n  /** The project is open. */\n  Open = 'OPEN'\n}\n\n/** GitHub-provided templates for Projects */\nexport enum ProjectTemplate {\n  /** Create a board with v2 triggers to automatically move cards across To do, In progress and Done columns. */\n  AutomatedKanbanV2 = 'AUTOMATED_KANBAN_V2',\n  /** Create a board with triggers to automatically move cards across columns with review automation. */\n  AutomatedReviewsKanban = 'AUTOMATED_REVIEWS_KANBAN',\n  /** Create a board with columns for To do, In progress and Done. */\n  BasicKanban = 'BASIC_KANBAN',\n  /** Create a board to triage and prioritize bugs with To do, priority, and Done columns. */\n  BugTriage = 'BUG_TRIAGE'\n}\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2 = Closable & Node & Updatable & {\n  __typename?: 'ProjectV2';\n  /** Returns true if the project is closed. */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who originally created the project. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** A field of the project */\n  field?: Maybe<ProjectV2FieldConfiguration>;\n  /** List of fields and their constraints in the project */\n  fields: ProjectV2FieldConfigurationConnection;\n  id: Scalars['ID'];\n  /** List of items in the project */\n  items: ProjectV2ItemConnection;\n  /** The project's number. */\n  number: Scalars['Int'];\n  /** The project's owner. Currently limited to organizations and users. */\n  owner: ProjectV2Owner;\n  /** Returns true if the project is public. */\n  public: Scalars['Boolean'];\n  /** The project's readme. */\n  readme?: Maybe<Scalars['String']>;\n  /** The repositories the project is linked to. */\n  repositories: RepositoryConnection;\n  /** The HTTP path for this project */\n  resourcePath: Scalars['URI'];\n  /** The project's short description. */\n  shortDescription?: Maybe<Scalars['String']>;\n  /** The teams the project is linked to. */\n  teams: TeamConnection;\n  /** Returns true if this project is a template. */\n  template: Scalars['Boolean'];\n  /** The project's name. */\n  title: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this project */\n  url: Scalars['URI'];\n  /** A view of the project */\n  view?: Maybe<ProjectV2View>;\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** List of views in the project */\n  views: ProjectV2ViewConnection;\n  /** A workflow of the project */\n  workflow?: Maybe<ProjectV2Workflow>;\n  /** List of the workflows in the project */\n  workflows: ProjectV2WorkflowConnection;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2FieldArgs = {\n  name: Scalars['String'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2FieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2ItemOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2RepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2TeamsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TeamOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ViewArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2ViewsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2ViewOrder>;\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2WorkflowArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** New projects that manage issues, pull requests and drafts using tables and boards. */\nexport type ProjectV2WorkflowsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2WorkflowOrder>;\n};\n\n/** Possible collaborators for a project. */\nexport type ProjectV2Actor = Team | User;\n\n/** The connection type for ProjectV2Actor. */\nexport type ProjectV2ActorConnection = {\n  __typename?: 'ProjectV2ActorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Actor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ActorEdge = {\n  __typename?: 'ProjectV2ActorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Actor>;\n};\n\n/** A collaborator to update on a project. Only one of the userId or teamId should be provided. */\nexport type ProjectV2Collaborator = {\n  /** The role to grant the collaborator */\n  role: ProjectV2Roles;\n  /** The ID of the team as a collaborator. */\n  teamId?: InputMaybe<Scalars['ID']>;\n  /** The ID of the user as a collaborator. */\n  userId?: InputMaybe<Scalars['ID']>;\n};\n\n/** The connection type for ProjectV2. */\nexport type ProjectV2Connection = {\n  __typename?: 'ProjectV2Connection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2Edge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** The type of a project field. */\nexport enum ProjectV2CustomFieldType {\n  /** Date */\n  Date = 'DATE',\n  /** Number */\n  Number = 'NUMBER',\n  /** Single Select */\n  SingleSelect = 'SINGLE_SELECT',\n  /** Text */\n  Text = 'TEXT'\n}\n\n/** An edge in a connection. */\nexport type ProjectV2Edge = {\n  __typename?: 'ProjectV2Edge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2>;\n};\n\n/** A field inside a project. */\nexport type ProjectV2Field = Node & ProjectV2FieldCommon & {\n  __typename?: 'ProjectV2Field';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project field's name. */\n  name: Scalars['String'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** Common fields across different project field types */\nexport type ProjectV2FieldCommon = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project field's name. */\n  name: Scalars['String'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** Configurations for project fields. */\nexport type ProjectV2FieldConfiguration = ProjectV2Field | ProjectV2IterationField | ProjectV2SingleSelectField;\n\n/** The connection type for ProjectV2FieldConfiguration. */\nexport type ProjectV2FieldConfigurationConnection = {\n  __typename?: 'ProjectV2FieldConfigurationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2FieldConfigurationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2FieldConfiguration>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2FieldConfigurationEdge = {\n  __typename?: 'ProjectV2FieldConfigurationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2FieldConfiguration>;\n};\n\n/** The connection type for ProjectV2Field. */\nexport type ProjectV2FieldConnection = {\n  __typename?: 'ProjectV2FieldConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2FieldEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Field>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2FieldEdge = {\n  __typename?: 'ProjectV2FieldEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Field>;\n};\n\n/** Ordering options for project v2 field connections */\nexport type ProjectV2FieldOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 fields by. */\n  field: ProjectV2FieldOrderField;\n};\n\n/** Properties by which project v2 field connections can be ordered. */\nexport enum ProjectV2FieldOrderField {\n  /** Order project v2 fields by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order project v2 fields by name */\n  Name = 'NAME',\n  /** Order project v2 fields by position */\n  Position = 'POSITION'\n}\n\n/** The type of a project field. */\nexport enum ProjectV2FieldType {\n  /** Assignees */\n  Assignees = 'ASSIGNEES',\n  /** Date */\n  Date = 'DATE',\n  /** Iteration */\n  Iteration = 'ITERATION',\n  /** Labels */\n  Labels = 'LABELS',\n  /** Linked Pull Requests */\n  LinkedPullRequests = 'LINKED_PULL_REQUESTS',\n  /** Milestone */\n  Milestone = 'MILESTONE',\n  /** Number */\n  Number = 'NUMBER',\n  /** Repository */\n  Repository = 'REPOSITORY',\n  /** Reviewers */\n  Reviewers = 'REVIEWERS',\n  /** Single Select */\n  SingleSelect = 'SINGLE_SELECT',\n  /** Text */\n  Text = 'TEXT',\n  /** Title */\n  Title = 'TITLE',\n  /** Tracked by */\n  TrackedBy = 'TRACKED_BY',\n  /** Tracks */\n  Tracks = 'TRACKS'\n}\n\n/** The values that can be used to update a field of an item inside a Project. Only 1 value can be updated at a time. */\nexport type ProjectV2FieldValue = {\n  /** The ISO 8601 date to set on the field. */\n  date?: InputMaybe<Scalars['Date']>;\n  /** The id of the iteration to set on the field. */\n  iterationId?: InputMaybe<Scalars['String']>;\n  /** The number to set on the field. */\n  number?: InputMaybe<Scalars['Float']>;\n  /** The id of the single select option to set on the field. */\n  singleSelectOptionId?: InputMaybe<Scalars['String']>;\n  /** The text to set on the field. */\n  text?: InputMaybe<Scalars['String']>;\n};\n\n/** Ways in which to filter lists of projects. */\nexport type ProjectV2Filters = {\n  /** List project v2 filtered by the state given. */\n  state?: InputMaybe<ProjectV2State>;\n};\n\n/** An item within a Project. */\nexport type ProjectV2Item = Node & {\n  __typename?: 'ProjectV2Item';\n  /** The content of the referenced draft issue, issue, or pull request */\n  content?: Maybe<ProjectV2ItemContent>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The field value of the first project field which matches the 'name' argument that is set on the item. */\n  fieldValueByName?: Maybe<ProjectV2ItemFieldValue>;\n  /** The field values that are set on the item. */\n  fieldValues: ProjectV2ItemFieldValueConnection;\n  id: Scalars['ID'];\n  /** Whether the item is archived. */\n  isArchived: Scalars['Boolean'];\n  /** The project that contains this item. */\n  project: ProjectV2;\n  /** The type of the item. */\n  type: ProjectV2ItemType;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n\n/** An item within a Project. */\nexport type ProjectV2ItemFieldValueByNameArgs = {\n  name: Scalars['String'];\n};\n\n\n/** An item within a Project. */\nexport type ProjectV2ItemFieldValuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2ItemFieldValueOrder>;\n};\n\n/** The connection type for ProjectV2Item. */\nexport type ProjectV2ItemConnection = {\n  __typename?: 'ProjectV2ItemConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Item>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Types that can be inside Project Items. */\nexport type ProjectV2ItemContent = DraftIssue | Issue | PullRequest;\n\n/** An edge in a connection. */\nexport type ProjectV2ItemEdge = {\n  __typename?: 'ProjectV2ItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Item>;\n};\n\n/** The value of a date field in a Project item. */\nexport type ProjectV2ItemFieldDateValue = Node & ProjectV2ItemFieldValueCommon & {\n  __typename?: 'ProjectV2ItemFieldDateValue';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** Date value for the field */\n  date?: Maybe<Scalars['Date']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The value of an iteration field in a Project item. */\nexport type ProjectV2ItemFieldIterationValue = Node & ProjectV2ItemFieldValueCommon & {\n  __typename?: 'ProjectV2ItemFieldIterationValue';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The duration of the iteration in days. */\n  duration: Scalars['Int'];\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** The ID of the iteration. */\n  iterationId: Scalars['String'];\n  /** The start date of the iteration. */\n  startDate: Scalars['Date'];\n  /** The title of the iteration. */\n  title: Scalars['String'];\n  /** The title of the iteration, with HTML. */\n  titleHTML: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The value of the labels field in a Project item. */\nexport type ProjectV2ItemFieldLabelValue = {\n  __typename?: 'ProjectV2ItemFieldLabelValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** Labels value of a field */\n  labels?: Maybe<LabelConnection>;\n};\n\n\n/** The value of the labels field in a Project item. */\nexport type ProjectV2ItemFieldLabelValueLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The value of a milestone field in a Project item. */\nexport type ProjectV2ItemFieldMilestoneValue = {\n  __typename?: 'ProjectV2ItemFieldMilestoneValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** Milestone value of a field */\n  milestone?: Maybe<Milestone>;\n};\n\n/** The value of a number field in a Project item. */\nexport type ProjectV2ItemFieldNumberValue = Node & ProjectV2ItemFieldValueCommon & {\n  __typename?: 'ProjectV2ItemFieldNumberValue';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Number as a float(8) */\n  number?: Maybe<Scalars['Float']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The value of a pull request field in a Project item. */\nexport type ProjectV2ItemFieldPullRequestValue = {\n  __typename?: 'ProjectV2ItemFieldPullRequestValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The pull requests for this field */\n  pullRequests?: Maybe<PullRequestConnection>;\n};\n\n\n/** The value of a pull request field in a Project item. */\nexport type ProjectV2ItemFieldPullRequestValuePullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<PullRequestOrder>;\n};\n\n/** The value of a repository field in a Project item. */\nexport type ProjectV2ItemFieldRepositoryValue = {\n  __typename?: 'ProjectV2ItemFieldRepositoryValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The repository for this field. */\n  repository?: Maybe<Repository>;\n};\n\n/** The value of a reviewers field in a Project item. */\nexport type ProjectV2ItemFieldReviewerValue = {\n  __typename?: 'ProjectV2ItemFieldReviewerValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The reviewers for this field. */\n  reviewers?: Maybe<RequestedReviewerConnection>;\n};\n\n\n/** The value of a reviewers field in a Project item. */\nexport type ProjectV2ItemFieldReviewerValueReviewersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The value of a single select field in a Project item. */\nexport type ProjectV2ItemFieldSingleSelectValue = Node & ProjectV2ItemFieldValueCommon & {\n  __typename?: 'ProjectV2ItemFieldSingleSelectValue';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** The name of the selected single select option. */\n  name?: Maybe<Scalars['String']>;\n  /** The html name of the selected single select option. */\n  nameHTML?: Maybe<Scalars['String']>;\n  /** The id of the selected single select option. */\n  optionId?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The value of a text field in a Project item. */\nexport type ProjectV2ItemFieldTextValue = Node & ProjectV2ItemFieldValueCommon & {\n  __typename?: 'ProjectV2ItemFieldTextValue';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Text value of a field */\n  text?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The value of a user field in a Project item. */\nexport type ProjectV2ItemFieldUserValue = {\n  __typename?: 'ProjectV2ItemFieldUserValue';\n  /** The field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  /** The users for this field */\n  users?: Maybe<UserConnection>;\n};\n\n\n/** The value of a user field in a Project item. */\nexport type ProjectV2ItemFieldUserValueUsersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Project field values */\nexport type ProjectV2ItemFieldValue = ProjectV2ItemFieldDateValue | ProjectV2ItemFieldIterationValue | ProjectV2ItemFieldLabelValue | ProjectV2ItemFieldMilestoneValue | ProjectV2ItemFieldNumberValue | ProjectV2ItemFieldPullRequestValue | ProjectV2ItemFieldRepositoryValue | ProjectV2ItemFieldReviewerValue | ProjectV2ItemFieldSingleSelectValue | ProjectV2ItemFieldTextValue | ProjectV2ItemFieldUserValue;\n\n/** Common fields across different project field value types */\nexport type ProjectV2ItemFieldValueCommon = {\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created the item. */\n  creator?: Maybe<Actor>;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The project field that contains this value. */\n  field: ProjectV2FieldConfiguration;\n  id: Scalars['ID'];\n  /** The project item that contains this value. */\n  item: ProjectV2Item;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for ProjectV2ItemFieldValue. */\nexport type ProjectV2ItemFieldValueConnection = {\n  __typename?: 'ProjectV2ItemFieldValueConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ItemFieldValueEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2ItemFieldValue>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ItemFieldValueEdge = {\n  __typename?: 'ProjectV2ItemFieldValueEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2ItemFieldValue>;\n};\n\n/** Ordering options for project v2 item field value connections */\nexport type ProjectV2ItemFieldValueOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 item field values by. */\n  field: ProjectV2ItemFieldValueOrderField;\n};\n\n/** Properties by which project v2 item field value connections can be ordered. */\nexport enum ProjectV2ItemFieldValueOrderField {\n  /** Order project v2 item field values by the their position in the project */\n  Position = 'POSITION'\n}\n\n/** Ordering options for project v2 item connections */\nexport type ProjectV2ItemOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 items by. */\n  field: ProjectV2ItemOrderField;\n};\n\n/** Properties by which project v2 item connections can be ordered. */\nexport enum ProjectV2ItemOrderField {\n  /** Order project v2 items by the their position in the project */\n  Position = 'POSITION'\n}\n\n/** The type of a project item. */\nexport enum ProjectV2ItemType {\n  /** Draft Issue */\n  DraftIssue = 'DRAFT_ISSUE',\n  /** Issue */\n  Issue = 'ISSUE',\n  /** Pull Request */\n  PullRequest = 'PULL_REQUEST',\n  /** Redacted Item */\n  Redacted = 'REDACTED'\n}\n\n/** An iteration field inside a project. */\nexport type ProjectV2IterationField = Node & ProjectV2FieldCommon & {\n  __typename?: 'ProjectV2IterationField';\n  /** Iteration configuration settings */\n  configuration: ProjectV2IterationFieldConfiguration;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project field's name. */\n  name: Scalars['String'];\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** Iteration field configuration for a project. */\nexport type ProjectV2IterationFieldConfiguration = {\n  __typename?: 'ProjectV2IterationFieldConfiguration';\n  /** The iteration's completed iterations */\n  completedIterations: Array<ProjectV2IterationFieldIteration>;\n  /** The iteration's duration in days */\n  duration: Scalars['Int'];\n  /** The iteration's iterations */\n  iterations: Array<ProjectV2IterationFieldIteration>;\n  /** The iteration's start day of the week */\n  startDay: Scalars['Int'];\n};\n\n/** Iteration field iteration settings for a project. */\nexport type ProjectV2IterationFieldIteration = {\n  __typename?: 'ProjectV2IterationFieldIteration';\n  /** The iteration's duration in days */\n  duration: Scalars['Int'];\n  /** The iteration's ID. */\n  id: Scalars['String'];\n  /** The iteration's start date */\n  startDate: Scalars['Date'];\n  /** The iteration's title. */\n  title: Scalars['String'];\n  /** The iteration's html title. */\n  titleHTML: Scalars['String'];\n};\n\n/** Ways in which lists of projects can be ordered upon return. */\nexport type ProjectV2Order = {\n  /** The direction in which to order projects by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order projects by. */\n  field: ProjectV2OrderField;\n};\n\n/** Properties by which projects can be ordered. */\nexport enum ProjectV2OrderField {\n  /** The project's date and time of creation */\n  CreatedAt = 'CREATED_AT',\n  /** The project's number */\n  Number = 'NUMBER',\n  /** The project's title */\n  Title = 'TITLE',\n  /** The project's date and time of update */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2Owner = {\n  id: Scalars['ID'];\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n};\n\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2OwnerProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** Represents an owner of a project (beta). */\nexport type ProjectV2OwnerProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n/** Recent projects for the owner. */\nexport type ProjectV2Recent = {\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n};\n\n\n/** Recent projects for the owner. */\nexport type ProjectV2RecentRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The possible roles of a collaborator on a project. */\nexport enum ProjectV2Roles {\n  /** The collaborator can view, edit, and maange the settings of the project */\n  Admin = 'ADMIN',\n  /** The collaborator has no direct access to the project */\n  None = 'NONE',\n  /** The collaborator can view the project */\n  Reader = 'READER',\n  /** The collaborator can view and edit the project */\n  Writer = 'WRITER'\n}\n\n/** A single select field inside a project. */\nexport type ProjectV2SingleSelectField = Node & ProjectV2FieldCommon & {\n  __typename?: 'ProjectV2SingleSelectField';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The field's type. */\n  dataType: ProjectV2FieldType;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The project field's name. */\n  name: Scalars['String'];\n  /** Options for the single select field */\n  options: Array<ProjectV2SingleSelectFieldOption>;\n  /** The project that contains this field. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** Single select field option for a configuration for a project. */\nexport type ProjectV2SingleSelectFieldOption = {\n  __typename?: 'ProjectV2SingleSelectFieldOption';\n  /** The option's ID. */\n  id: Scalars['String'];\n  /** The option's name. */\n  name: Scalars['String'];\n  /** The option's html name. */\n  nameHTML: Scalars['String'];\n};\n\n/** The display color of a single-select field option. */\nexport enum ProjectV2SingleSelectFieldOptionColor {\n  /** BLUE */\n  Blue = 'BLUE',\n  /** GRAY */\n  Gray = 'GRAY',\n  /** GREEN */\n  Green = 'GREEN',\n  /** ORANGE */\n  Orange = 'ORANGE',\n  /** PINK */\n  Pink = 'PINK',\n  /** PURPLE */\n  Purple = 'PURPLE',\n  /** RED */\n  Red = 'RED',\n  /** YELLOW */\n  Yellow = 'YELLOW'\n}\n\n/** Represents a single select field option */\nexport type ProjectV2SingleSelectFieldOptionInput = {\n  /** The display color of the option */\n  color: ProjectV2SingleSelectFieldOptionColor;\n  /** The description text of the option */\n  description: Scalars['String'];\n  /** The name of the option */\n  name: Scalars['String'];\n};\n\n/** Represents a sort by field and direction. */\nexport type ProjectV2SortBy = {\n  __typename?: 'ProjectV2SortBy';\n  /** The direction of the sorting. Possible values are ASC and DESC. */\n  direction: OrderDirection;\n  /** The field by which items are sorted. */\n  field: ProjectV2Field;\n};\n\n/** The connection type for ProjectV2SortBy. */\nexport type ProjectV2SortByConnection = {\n  __typename?: 'ProjectV2SortByConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2SortByEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2SortBy>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2SortByEdge = {\n  __typename?: 'ProjectV2SortByEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2SortBy>;\n};\n\n/** Represents a sort by field and direction. */\nexport type ProjectV2SortByField = {\n  __typename?: 'ProjectV2SortByField';\n  /** The direction of the sorting. Possible values are ASC and DESC. */\n  direction: OrderDirection;\n  /** The field by which items are sorted. */\n  field: ProjectV2FieldConfiguration;\n};\n\n/** The connection type for ProjectV2SortByField. */\nexport type ProjectV2SortByFieldConnection = {\n  __typename?: 'ProjectV2SortByFieldConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2SortByFieldEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2SortByField>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2SortByFieldEdge = {\n  __typename?: 'ProjectV2SortByFieldEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2SortByField>;\n};\n\n/** The possible states of a project v2. */\nexport enum ProjectV2State {\n  /** A project v2 that has been closed */\n  Closed = 'CLOSED',\n  /** A project v2 that is still open */\n  Open = 'OPEN'\n}\n\n/** A view within a ProjectV2. */\nexport type ProjectV2View = Node & {\n  __typename?: 'ProjectV2View';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The view's visible fields. */\n  fields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  /** The project view's filter. */\n  filter?: Maybe<Scalars['String']>;\n  /**\n   * The view's group-by field.\n   * @deprecated The `ProjectV2View#order_by` API is deprecated in favour of the more capable `ProjectV2View#group_by_field` API. Check out the `ProjectV2View#group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  groupBy?: Maybe<ProjectV2FieldConnection>;\n  /** The view's group-by field. */\n  groupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  id: Scalars['ID'];\n  /** The project view's layout. */\n  layout: ProjectV2ViewLayout;\n  /** The project view's name. */\n  name: Scalars['String'];\n  /** The project view's number. */\n  number: Scalars['Int'];\n  /** The project that contains this view. */\n  project: ProjectV2;\n  /**\n   * The view's sort-by config.\n   * @deprecated The `ProjectV2View#sort_by` API is deprecated in favour of the more capable `ProjectV2View#sort_by_fields` API. Check out the `ProjectV2View#sort_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  sortBy?: Maybe<ProjectV2SortByConnection>;\n  /** The view's sort-by config. */\n  sortByFields?: Maybe<ProjectV2SortByFieldConnection>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /**\n   * The view's vertical-group-by field.\n   * @deprecated The `ProjectV2View#vertical_group_by` API is deprecated in favour of the more capable `ProjectV2View#vertical_group_by_fields` API. Check out the `ProjectV2View#vertical_group_by_fields` API as an example for the more capable alternative. Removal on 2023-04-01 UTC.\n   */\n  verticalGroupBy?: Maybe<ProjectV2FieldConnection>;\n  /** The view's vertical-group-by field. */\n  verticalGroupByFields?: Maybe<ProjectV2FieldConfigurationConnection>;\n  /**\n   * The view's visible fields.\n   * @deprecated The `ProjectV2View#visibleFields` API is deprecated in favour of the more capable `ProjectV2View#fields` API. Check out the `ProjectV2View#fields` API as an example for the more capable alternative. Removal on 2023-01-01 UTC.\n   */\n  visibleFields?: Maybe<ProjectV2FieldConnection>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewFieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewGroupByArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewGroupByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewSortByArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewSortByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVerticalGroupByArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVerticalGroupByFieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n\n/** A view within a ProjectV2. */\nexport type ProjectV2ViewVisibleFieldsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2FieldOrder>;\n};\n\n/** The connection type for ProjectV2View. */\nexport type ProjectV2ViewConnection = {\n  __typename?: 'ProjectV2ViewConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2ViewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2View>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2ViewEdge = {\n  __typename?: 'ProjectV2ViewEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2View>;\n};\n\n/** The layout of a project v2 view. */\nexport enum ProjectV2ViewLayout {\n  /** Board layout */\n  BoardLayout = 'BOARD_LAYOUT',\n  /** Roadmap layout */\n  RoadmapLayout = 'ROADMAP_LAYOUT',\n  /** Table layout */\n  TableLayout = 'TABLE_LAYOUT'\n}\n\n/** Ordering options for project v2 view connections */\nexport type ProjectV2ViewOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 views by. */\n  field: ProjectV2ViewOrderField;\n};\n\n/** Properties by which project v2 view connections can be ordered. */\nexport enum ProjectV2ViewOrderField {\n  /** Order project v2 views by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order project v2 views by name */\n  Name = 'NAME',\n  /** Order project v2 views by position */\n  Position = 'POSITION'\n}\n\n/** A workflow inside a project. */\nexport type ProjectV2Workflow = Node & {\n  __typename?: 'ProjectV2Workflow';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The workflows' enabled state. */\n  enabled: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** The workflows' name. */\n  name: Scalars['String'];\n  /** The workflows' number. */\n  number: Scalars['Int'];\n  /** The project that contains this workflow. */\n  project: ProjectV2;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for ProjectV2Workflow. */\nexport type ProjectV2WorkflowConnection = {\n  __typename?: 'ProjectV2WorkflowConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ProjectV2WorkflowEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ProjectV2Workflow>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ProjectV2WorkflowEdge = {\n  __typename?: 'ProjectV2WorkflowEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ProjectV2Workflow>;\n};\n\n/** Ordering options for project v2 workflows connections */\nexport type ProjectV2WorkflowOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order the project v2 workflows by. */\n  field: ProjectV2WorkflowsOrderField;\n};\n\n/** Properties by which project workflows can be ordered. */\nexport enum ProjectV2WorkflowsOrderField {\n  /** The workflows' date and time of creation */\n  CreatedAt = 'CREATED_AT',\n  /** The workflows' name */\n  Name = 'NAME',\n  /** The workflows' number */\n  Number = 'NUMBER',\n  /** The workflows' date and time of update */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A user's public key. */\nexport type PublicKey = Node & {\n  __typename?: 'PublicKey';\n  /** The last time this authorization was used to perform an action. Values will be null for keys not owned by the user. */\n  accessedAt?: Maybe<Scalars['DateTime']>;\n  /**\n   * Identifies the date and time when the key was created. Keys created before\n   * March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.\n   */\n  createdAt?: Maybe<Scalars['DateTime']>;\n  /** The fingerprint for this PublicKey. */\n  fingerprint: Scalars['String'];\n  id: Scalars['ID'];\n  /** Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user. */\n  isReadOnly?: Maybe<Scalars['Boolean']>;\n  /** The public key string. */\n  key: Scalars['String'];\n  /**\n   * Identifies the date and time when the key was updated. Keys created before\n   * March 5th, 2014 may have inaccurate values. Values will be null for keys not\n   * owned by the user.\n   */\n  updatedAt?: Maybe<Scalars['DateTime']>;\n};\n\n/** The connection type for PublicKey. */\nexport type PublicKeyConnection = {\n  __typename?: 'PublicKeyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PublicKeyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PublicKey>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PublicKeyEdge = {\n  __typename?: 'PublicKeyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PublicKey>;\n};\n\n/** Autogenerated input type of PublishSponsorsTier */\nexport type PublishSponsorsTierInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the draft tier to publish. */\n  tierId: Scalars['ID'];\n};\n\n/** Autogenerated return type of PublishSponsorsTier */\nexport type PublishSponsorsTierPayload = {\n  __typename?: 'PublishSponsorsTierPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The tier that was published. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** A repository pull request. */\nexport type PullRequest = Assignable & Closable & Comment & Labelable & Lockable & Node & ProjectV2Owner & Reactable & RepositoryNode & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  __typename?: 'PullRequest';\n  /** Reason that the conversation was locked. */\n  activeLockReason?: Maybe<LockReason>;\n  /** The number of additions in this pull request. */\n  additions: Scalars['Int'];\n  /** A list of Users assigned to this object. */\n  assignees: UserConnection;\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Returns the auto-merge request object if one exists for this pull request. */\n  autoMergeRequest?: Maybe<AutoMergeRequest>;\n  /** Identifies the base Ref associated with the pull request. */\n  baseRef?: Maybe<Ref>;\n  /** Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted. */\n  baseRefName: Scalars['String'];\n  /** Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted. */\n  baseRefOid: Scalars['GitObjectID'];\n  /** The repository associated with this pull request's base Ref. */\n  baseRepository?: Maybe<Repository>;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Whether or not the pull request is rebaseable. */\n  canBeRebased: Scalars['Boolean'];\n  /** The number of changed files in this pull request. */\n  changedFiles: Scalars['Int'];\n  /** The HTTP path for the checks of this pull request. */\n  checksResourcePath: Scalars['URI'];\n  /** The HTTP URL for the checks of this pull request. */\n  checksUrl: Scalars['URI'];\n  /** `true` if the pull request is closed */\n  closed: Scalars['Boolean'];\n  /** Identifies the date and time when the object was closed. */\n  closedAt?: Maybe<Scalars['DateTime']>;\n  /** List of issues that were may be closed by this pull request */\n  closingIssuesReferences?: Maybe<IssueConnection>;\n  /** A list of comments associated with the pull request. */\n  comments: IssueCommentConnection;\n  /** A list of commits present in this pull request's head branch not present in the base branch. */\n  commits: PullRequestCommitConnection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The number of deletions in this pull request. */\n  deletions: Scalars['Int'];\n  /** The actor who edited this pull request's body. */\n  editor?: Maybe<Actor>;\n  /** Lists the files changed within this pull request. */\n  files?: Maybe<PullRequestChangedFileConnection>;\n  /** Identifies the head Ref associated with the pull request. */\n  headRef?: Maybe<Ref>;\n  /** Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted. */\n  headRefName: Scalars['String'];\n  /** Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted. */\n  headRefOid: Scalars['GitObjectID'];\n  /** The repository associated with this pull request's head Ref. */\n  headRepository?: Maybe<Repository>;\n  /** The owner of the repository associated with this pull request's head Ref. */\n  headRepositoryOwner?: Maybe<RepositoryOwner>;\n  /** The hovercard information for this issue */\n  hovercard: Hovercard;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** The head and base repositories are different. */\n  isCrossRepository: Scalars['Boolean'];\n  /** Identifies if the pull request is a draft. */\n  isDraft: Scalars['Boolean'];\n  /** Is this pull request read by the viewer */\n  isReadByViewer?: Maybe<Scalars['Boolean']>;\n  /** A list of labels associated with the object. */\n  labels?: Maybe<LabelConnection>;\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of latest reviews per user associated with the pull request. */\n  latestOpinionatedReviews?: Maybe<PullRequestReviewConnection>;\n  /** A list of latest reviews per user associated with the pull request that are not also pending review. */\n  latestReviews?: Maybe<PullRequestReviewConnection>;\n  /** `true` if the pull request is locked */\n  locked: Scalars['Boolean'];\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify: Scalars['Boolean'];\n  /** The commit that was created when this pull request was merged. */\n  mergeCommit?: Maybe<Commit>;\n  /** The merge queue entry of the pull request in the base branch's merge queue */\n  mergeQueueEntry?: Maybe<MergeQueueEntry>;\n  /** Detailed information about the current pull request merge state status. */\n  mergeStateStatus: MergeStateStatus;\n  /** Whether or not the pull request can be merged based on the existence of merge conflicts. */\n  mergeable: MergeableState;\n  /** Whether or not the pull request was merged. */\n  merged: Scalars['Boolean'];\n  /** The date and time that the pull request was merged. */\n  mergedAt?: Maybe<Scalars['DateTime']>;\n  /** The actor who merged the pull request. */\n  mergedBy?: Maybe<Actor>;\n  /** Identifies the milestone associated with the pull request. */\n  milestone?: Maybe<Milestone>;\n  /** Identifies the pull request number. */\n  number: Scalars['Int'];\n  /** A list of Users that are participating in the Pull Request conversation. */\n  participants: UserConnection;\n  /** The permalink to the pull request. */\n  permalink: Scalars['URI'];\n  /**\n   * The commit that GitHub automatically generated to test if this pull request\n   * could be merged. This field will not return a value if the pull request is\n   * merged, or if the test merge commit is still being generated. See the\n   * `mergeable` field for more details on the mergeability of the pull request.\n   */\n  potentialMergeCommit?: Maybe<Commit>;\n  /** List of project cards associated with this pull request. */\n  projectCards: ProjectCardConnection;\n  /** List of project items associated with this pull request. */\n  projectItems: ProjectV2ItemConnection;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path for this pull request. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP path for reverting this pull request. */\n  revertResourcePath: Scalars['URI'];\n  /** The HTTP URL for reverting this pull request. */\n  revertUrl: Scalars['URI'];\n  /** The current status of this pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>;\n  /** A list of review requests associated with the pull request. */\n  reviewRequests?: Maybe<ReviewRequestConnection>;\n  /** The list of all review threads for this pull request. */\n  reviewThreads: PullRequestReviewThreadConnection;\n  /** A list of reviews associated with the pull request. */\n  reviews?: Maybe<PullRequestReviewConnection>;\n  /** Identifies the state of the pull request. */\n  state: PullRequestState;\n  /** A list of reviewer suggestions based on commit history and past review comments. */\n  suggestedReviewers: Array<Maybe<SuggestedReviewer>>;\n  /**\n   * A list of events, comments, commits, etc. associated with the pull request.\n   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.\n   */\n  timeline: PullRequestTimelineConnection;\n  /** A list of events, comments, commits, etc. associated with the pull request. */\n  timelineItems: PullRequestTimelineItemsConnection;\n  /** Identifies the pull request title. */\n  title: Scalars['String'];\n  /** Identifies the pull request title rendered to HTML. */\n  titleHTML: Scalars['HTML'];\n  /** Returns a count of how many comments this pull request has received. */\n  totalCommentsCount?: Maybe<Scalars['Int']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this pull request. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Whether or not the viewer can apply suggestion. */\n  viewerCanApplySuggestion: Scalars['Boolean'];\n  /** Indicates if the object can be closed by the viewer. */\n  viewerCanClose: Scalars['Boolean'];\n  /** Check if the viewer can restore the deleted head ref. */\n  viewerCanDeleteHeadRef: Scalars['Boolean'];\n  /** Whether or not the viewer can disable auto-merge */\n  viewerCanDisableAutoMerge: Scalars['Boolean'];\n  /** Can the viewer edit files within this pull request. */\n  viewerCanEditFiles: Scalars['Boolean'];\n  /** Whether or not the viewer can enable auto-merge */\n  viewerCanEnableAutoMerge: Scalars['Boolean'];\n  /** Indicates whether the viewer can bypass branch protections and merge the pull request immediately */\n  viewerCanMergeAsAdmin: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Indicates if the object can be reopened by the viewer. */\n  viewerCanReopen: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /**\n   * Whether or not the viewer can update the head ref of this PR, by merging or rebasing the base ref.\n   * If the head ref is up to date or unable to be updated by this user, this will return false.\n   */\n  viewerCanUpdateBranch: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n  /** The latest review given from the viewer. */\n  viewerLatestReview?: Maybe<PullRequestReview>;\n  /** The person who has requested the viewer for review on this pull request. */\n  viewerLatestReviewRequest?: Maybe<ReviewRequest>;\n  /** The merge body text for the viewer and method. */\n  viewerMergeBodyText: Scalars['String'];\n  /** The merge headline text for the viewer and method. */\n  viewerMergeHeadlineText: Scalars['String'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestAssigneesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestClosingIssuesReferencesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  userLinkedOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestCommitsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestFilesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestHovercardArgs = {\n  includeNotificationContexts?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLatestOpinionatedReviewsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  writersOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestLatestReviewsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestParticipantsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectCardsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  archivedStates?: InputMaybe<Array<InputMaybe<ProjectCardArchivedState>>>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeArchived?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository pull request. */\nexport type PullRequestProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewThreadsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestReviewsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  author?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  states?: InputMaybe<Array<PullRequestReviewState>>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestTimelineArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  since?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestTimelineItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  itemTypes?: InputMaybe<Array<PullRequestTimelineItemsItemType>>;\n  last?: InputMaybe<Scalars['Int']>;\n  since?: InputMaybe<Scalars['DateTime']>;\n  skip?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeBodyTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n\n/** A repository pull request. */\nexport type PullRequestViewerMergeHeadlineTextArgs = {\n  mergeType?: InputMaybe<PullRequestMergeMethod>;\n};\n\n/** A file changed in a pull request. */\nexport type PullRequestChangedFile = {\n  __typename?: 'PullRequestChangedFile';\n  /** The number of additions to the file. */\n  additions: Scalars['Int'];\n  /** How the file was changed in this PullRequest */\n  changeType: PatchStatus;\n  /** The number of deletions to the file. */\n  deletions: Scalars['Int'];\n  /** The path of the file. */\n  path: Scalars['String'];\n  /** The state of the file for the viewer. */\n  viewerViewedState: FileViewedState;\n};\n\n/** The connection type for PullRequestChangedFile. */\nexport type PullRequestChangedFileConnection = {\n  __typename?: 'PullRequestChangedFileConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestChangedFileEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestChangedFile>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestChangedFileEdge = {\n  __typename?: 'PullRequestChangedFileEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestChangedFile>;\n};\n\n/** Represents a Git commit part of a pull request. */\nexport type PullRequestCommit = Node & UniformResourceLocatable & {\n  __typename?: 'PullRequestCommit';\n  /** The Git commit object */\n  commit: Commit;\n  id: Scalars['ID'];\n  /** The pull request this commit belongs to */\n  pullRequest: PullRequest;\n  /** The HTTP path for this pull request commit */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this pull request commit */\n  url: Scalars['URI'];\n};\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThread = Node & RepositoryNode & {\n  __typename?: 'PullRequestCommitCommentThread';\n  /** The comments that exist in this thread. */\n  comments: CommitCommentConnection;\n  /** The commit the comments were made on. */\n  commit: Commit;\n  id: Scalars['ID'];\n  /** The file the comments were made on. */\n  path?: Maybe<Scalars['String']>;\n  /** The position in the diff for the commit that the comment was made on. */\n  position?: Maybe<Scalars['Int']>;\n  /** The pull request this commit comment thread belongs to */\n  pullRequest: PullRequest;\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n\n/** Represents a commit comment thread part of a pull request. */\nexport type PullRequestCommitCommentThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for PullRequestCommit. */\nexport type PullRequestCommitConnection = {\n  __typename?: 'PullRequestCommitConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestCommitEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestCommit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestCommitEdge = {\n  __typename?: 'PullRequestCommitEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestCommit>;\n};\n\n/** The connection type for PullRequest. */\nexport type PullRequestConnection = {\n  __typename?: 'PullRequestConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepository = {\n  __typename?: 'PullRequestContributionsByRepository';\n  /** The pull request contributions. */\n  contributions: CreatedPullRequestContributionConnection;\n  /** The repository in which the pull requests were opened. */\n  repository: Repository;\n};\n\n\n/** This aggregates pull requests opened by a user within one repository. */\nexport type PullRequestContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** An edge in a connection. */\nexport type PullRequestEdge = {\n  __typename?: 'PullRequestEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequest>;\n};\n\n/** Represents available types of methods to use when merging a pull request. */\nexport enum PullRequestMergeMethod {\n  /** Add all commits from the head branch to the base branch with a merge commit. */\n  Merge = 'MERGE',\n  /** Add all commits from the head branch onto the base branch individually. */\n  Rebase = 'REBASE',\n  /** Combine all commits from the head branch into a single commit in the base branch. */\n  Squash = 'SQUASH'\n}\n\n/** Ways in which lists of issues can be ordered upon return. */\nexport type PullRequestOrder = {\n  /** The direction in which to order pull requests by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order pull requests by. */\n  field: PullRequestOrderField;\n};\n\n/** Properties by which pull_requests connections can be ordered. */\nexport enum PullRequestOrderField {\n  /** Order pull_requests by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order pull_requests by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\nexport type PullRequestParameters = {\n  __typename?: 'PullRequestParameters';\n  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */\n  dismissStaleReviewsOnPush: Scalars['Boolean'];\n  /** Require an approving review in pull requests that modify files that have a designated code owner. */\n  requireCodeOwnerReview: Scalars['Boolean'];\n  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */\n  requireLastPushApproval: Scalars['Boolean'];\n  /** The number of approving reviews that are required before a pull request can be merged. */\n  requiredApprovingReviewCount: Scalars['Int'];\n  /** All conversations on code must be resolved before a pull request can be merged. */\n  requiredReviewThreadResolution: Scalars['Boolean'];\n};\n\n/** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\nexport type PullRequestParametersInput = {\n  /** New, reviewable commits pushed will dismiss previous pull request review approvals. */\n  dismissStaleReviewsOnPush: Scalars['Boolean'];\n  /** Require an approving review in pull requests that modify files that have a designated code owner. */\n  requireCodeOwnerReview: Scalars['Boolean'];\n  /** Whether the most recent reviewable push must be approved by someone other than the person who pushed it. */\n  requireLastPushApproval: Scalars['Boolean'];\n  /** The number of approving reviews that are required before a pull request can be merged. */\n  requiredApprovingReviewCount: Scalars['Int'];\n  /** All conversations on code must be resolved before a pull request can be merged. */\n  requiredReviewThreadResolution: Scalars['Boolean'];\n};\n\n/** A review object for a given pull request. */\nexport type PullRequestReview = Comment & Deletable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  __typename?: 'PullRequestReview';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** Indicates whether the author of this review has push access to the repository. */\n  authorCanPushToRepository: Scalars['Boolean'];\n  /** Identifies the pull request review body. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body of this review rendered as plain text. */\n  bodyText: Scalars['String'];\n  /** A list of review comments for the current pull request review. */\n  comments: PullRequestReviewCommentConnection;\n  /** Identifies the commit associated with this pull request review. */\n  commit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of teams that this review was made on behalf of. */\n  onBehalfOf: TeamConnection;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the pull request associated with this pull request review. */\n  pullRequest: PullRequest;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this PullRequestReview. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the current state of the pull request review. */\n  state: PullRequestReviewState;\n  /** Identifies when the Pull Request Review was submitted */\n  submittedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL permalink for this PullRequestReview. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewOnBehalfOfArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A review object for a given pull request. */\nexport type PullRequestReviewUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewComment = Comment & Deletable & Minimizable & Node & Reactable & RepositoryNode & Updatable & UpdatableComment & {\n  __typename?: 'PullRequestReviewComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the subject of the comment. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The comment body of this review comment. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The comment body of this review comment rendered as plain text. */\n  bodyText: Scalars['String'];\n  /** Identifies the commit associated with the comment. */\n  commit?: Maybe<Commit>;\n  /** Identifies when the comment was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The diff hunk to which the comment applies. */\n  diffHunk: Scalars['String'];\n  /** Identifies when the comment was created in a draft state. */\n  draftedAt: Scalars['DateTime'];\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Returns whether or not a comment has been minimized. */\n  isMinimized: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** The end line number on the file to which the comment applies */\n  line?: Maybe<Scalars['Int']>;\n  /**\n   * Returns why the comment was minimized. One of `abuse`, `off-topic`,\n   * `outdated`, `resolved`, `duplicate` and `spam`. Note that the case and\n   * formatting of these values differs from the inputs to the `MinimizeComment` mutation.\n   */\n  minimizedReason?: Maybe<Scalars['String']>;\n  /** Identifies the original commit associated with the comment. */\n  originalCommit?: Maybe<Commit>;\n  /** The end line number on the file to which the comment applied when it was first created */\n  originalLine?: Maybe<Scalars['Int']>;\n  /**\n   * The original line index in the diff to which the comment applies.\n   * @deprecated We are phasing out diff-relative positioning for PR comments Removal on 2023-10-01 UTC.\n   */\n  originalPosition: Scalars['Int'];\n  /** The start line number on the file to which the comment applied when it was first created */\n  originalStartLine?: Maybe<Scalars['Int']>;\n  /** Identifies when the comment body is outdated */\n  outdated: Scalars['Boolean'];\n  /** The path to which the comment applies. */\n  path: Scalars['String'];\n  /**\n   * The line index in the diff to which the comment applies.\n   * @deprecated We are phasing out diff-relative positioning for PR comments Use the `line` and `startLine` fields instead, which are file line numbers instead of diff line numbers Removal on 2023-10-01 UTC.\n   */\n  position?: Maybe<Scalars['Int']>;\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** The pull request associated with this review comment. */\n  pullRequest: PullRequest;\n  /** The pull request review associated with this review comment. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The comment this is a reply to. */\n  replyTo?: Maybe<PullRequestReviewComment>;\n  /** The repository associated with this node. */\n  repository: Repository;\n  /** The HTTP path permalink for this review comment. */\n  resourcePath: Scalars['URI'];\n  /** The start line number on the file to which the comment applies */\n  startLine?: Maybe<Scalars['Int']>;\n  /** Identifies the state of the comment. */\n  state: PullRequestReviewCommentState;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType: PullRequestReviewThreadSubjectType;\n  /** Identifies when the comment was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL permalink for this review comment. */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Check if the current viewer can minimize this object. */\n  viewerCanMinimize: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A review comment associated with a given repository pull request. */\nexport type PullRequestReviewCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for PullRequestReviewComment. */\nexport type PullRequestReviewCommentConnection = {\n  __typename?: 'PullRequestReviewCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewCommentEdge = {\n  __typename?: 'PullRequestReviewCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewComment>;\n};\n\n/** The possible states of a pull request review comment. */\nexport enum PullRequestReviewCommentState {\n  /** A comment that is part of a pending review */\n  Pending = 'PENDING',\n  /** A comment that is part of a submitted review */\n  Submitted = 'SUBMITTED'\n}\n\n/** The connection type for PullRequestReview. */\nexport type PullRequestReviewConnection = {\n  __typename?: 'PullRequestReviewConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReview>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepository = {\n  __typename?: 'PullRequestReviewContributionsByRepository';\n  /** The pull request review contributions. */\n  contributions: CreatedPullRequestReviewContributionConnection;\n  /** The repository in which the pull request reviews were made. */\n  repository: Repository;\n};\n\n\n/** This aggregates pull request reviews made by a user within one repository. */\nexport type PullRequestReviewContributionsByRepositoryContributionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ContributionOrder>;\n};\n\n/** The review status of a pull request. */\nexport enum PullRequestReviewDecision {\n  /** The pull request has received an approving review. */\n  Approved = 'APPROVED',\n  /** Changes have been requested on the pull request. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** A review is required before the pull request can be merged. */\n  ReviewRequired = 'REVIEW_REQUIRED'\n}\n\n/** An edge in a connection. */\nexport type PullRequestReviewEdge = {\n  __typename?: 'PullRequestReviewEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReview>;\n};\n\n/** The possible events to perform on a pull request review. */\nexport enum PullRequestReviewEvent {\n  /** Submit feedback and approve merging these changes. */\n  Approve = 'APPROVE',\n  /** Submit general feedback without explicit approval. */\n  Comment = 'COMMENT',\n  /** Dismiss review so it now longer effects merging. */\n  Dismiss = 'DISMISS',\n  /** Submit feedback that must be addressed before merging. */\n  RequestChanges = 'REQUEST_CHANGES'\n}\n\n/** The possible states of a pull request review. */\nexport enum PullRequestReviewState {\n  /** A review allowing the pull request to merge. */\n  Approved = 'APPROVED',\n  /** A review blocking the pull request from merging. */\n  ChangesRequested = 'CHANGES_REQUESTED',\n  /** An informational review. */\n  Commented = 'COMMENTED',\n  /** A review that has been dismissed. */\n  Dismissed = 'DISMISSED',\n  /** A review that has not yet been submitted. */\n  Pending = 'PENDING'\n}\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThread = Node & {\n  __typename?: 'PullRequestReviewThread';\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection;\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide;\n  id: Scalars['ID'];\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars['Boolean'];\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars['Boolean'];\n  /** Whether this thread has been resolved */\n  isResolved: Scalars['Boolean'];\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars['Int']>;\n  /** The original line in the file to which this thread refers. */\n  originalLine?: Maybe<Scalars['Int']>;\n  /** The original start line in the file to which this thread refers (multi-line only). */\n  originalStartLine?: Maybe<Scalars['Int']>;\n  /** Identifies the file path of this thread. */\n  path: Scalars['String'];\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest;\n  /** Identifies the repository associated with this thread. */\n  repository: Repository;\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>;\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>;\n  /** The start line in the file to which this thread refers (multi-line only) */\n  startLine?: Maybe<Scalars['Int']>;\n  /** The level at which the comments in the corresponding thread are targeted, can be a diff line or a file */\n  subjectType: PullRequestReviewThreadSubjectType;\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars['Boolean'];\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars['Boolean'];\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars['Boolean'];\n};\n\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestReviewThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  skip?: InputMaybe<Scalars['Int']>;\n};\n\n/** Review comment threads for a pull request review. */\nexport type PullRequestReviewThreadConnection = {\n  __typename?: 'PullRequestReviewThreadConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestReviewThreadEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestReviewThread>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestReviewThreadEdge = {\n  __typename?: 'PullRequestReviewThreadEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestReviewThread>;\n};\n\n/** The possible subject types of a pull request review comment. */\nexport enum PullRequestReviewThreadSubjectType {\n  /** A comment that has been made against the file of a pull request */\n  File = 'FILE',\n  /** A comment that has been made against the line of a pull request */\n  Line = 'LINE'\n}\n\n/** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\nexport type PullRequestRevisionMarker = {\n  __typename?: 'PullRequestRevisionMarker';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The last commit the viewer has seen. */\n  lastSeenCommit: Commit;\n  /** The pull request to which the marker belongs. */\n  pullRequest: PullRequest;\n};\n\n/** The possible states of a pull request. */\nexport enum PullRequestState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that has been closed by being merged. */\n  Merged = 'MERGED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n/** A repository pull request template. */\nexport type PullRequestTemplate = {\n  __typename?: 'PullRequestTemplate';\n  /** The body of the template */\n  body?: Maybe<Scalars['String']>;\n  /** The filename of the template */\n  filename?: Maybe<Scalars['String']>;\n  /** The repository the template belongs to */\n  repository: Repository;\n};\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestThread = Node & {\n  __typename?: 'PullRequestThread';\n  /** A list of pull request comments associated with the thread. */\n  comments: PullRequestReviewCommentConnection;\n  /** The side of the diff on which this thread was placed. */\n  diffSide: DiffSide;\n  id: Scalars['ID'];\n  /** Whether or not the thread has been collapsed (resolved) */\n  isCollapsed: Scalars['Boolean'];\n  /** Indicates whether this thread was outdated by newer changes. */\n  isOutdated: Scalars['Boolean'];\n  /** Whether this thread has been resolved */\n  isResolved: Scalars['Boolean'];\n  /** The line in the file to which this thread refers */\n  line?: Maybe<Scalars['Int']>;\n  /** Identifies the pull request associated with this thread. */\n  pullRequest: PullRequest;\n  /** Identifies the repository associated with this thread. */\n  repository: Repository;\n  /** The user who resolved this thread */\n  resolvedBy?: Maybe<User>;\n  /** The side of the diff that the first line of the thread starts on (multi-line only) */\n  startDiffSide?: Maybe<DiffSide>;\n  /** The line of the first file diff in the thread. */\n  startLine?: Maybe<Scalars['Int']>;\n  /** Indicates whether the current viewer can reply to this thread. */\n  viewerCanReply: Scalars['Boolean'];\n  /** Whether or not the viewer can resolve this thread */\n  viewerCanResolve: Scalars['Boolean'];\n  /** Whether or not the viewer can unresolve this thread */\n  viewerCanUnresolve: Scalars['Boolean'];\n};\n\n\n/** A threaded list of comments for a given pull request. */\nexport type PullRequestThreadCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  skip?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for PullRequestTimelineItem. */\nexport type PullRequestTimelineConnection = {\n  __typename?: 'PullRequestTimelineConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItem = AssignedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | Commit | CommitCommentThread | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MergedEvent | MilestonedEvent | PullRequestReview | PullRequestReviewComment | PullRequestReviewThread | ReferencedEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemEdge = {\n  __typename?: 'PullRequestTimelineItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItem>;\n};\n\n/** An item in a pull request timeline */\nexport type PullRequestTimelineItems = AddedToMergeQueueEvent | AddedToProjectEvent | AssignedEvent | AutoMergeDisabledEvent | AutoMergeEnabledEvent | AutoRebaseEnabledEvent | AutoSquashEnabledEvent | AutomaticBaseChangeFailedEvent | AutomaticBaseChangeSucceededEvent | BaseRefChangedEvent | BaseRefDeletedEvent | BaseRefForcePushedEvent | ClosedEvent | CommentDeletedEvent | ConnectedEvent | ConvertToDraftEvent | ConvertedNoteToIssueEvent | ConvertedToDiscussionEvent | CrossReferencedEvent | DemilestonedEvent | DeployedEvent | DeploymentEnvironmentChangedEvent | DisconnectedEvent | HeadRefDeletedEvent | HeadRefForcePushedEvent | HeadRefRestoredEvent | IssueComment | LabeledEvent | LockedEvent | MarkedAsDuplicateEvent | MentionedEvent | MergedEvent | MilestonedEvent | MovedColumnsInProjectEvent | PinnedEvent | PullRequestCommit | PullRequestCommitCommentThread | PullRequestReview | PullRequestReviewThread | PullRequestRevisionMarker | ReadyForReviewEvent | ReferencedEvent | RemovedFromMergeQueueEvent | RemovedFromProjectEvent | RenamedTitleEvent | ReopenedEvent | ReviewDismissedEvent | ReviewRequestRemovedEvent | ReviewRequestedEvent | SubscribedEvent | TransferredEvent | UnassignedEvent | UnlabeledEvent | UnlockedEvent | UnmarkedAsDuplicateEvent | UnpinnedEvent | UnsubscribedEvent | UserBlockedEvent;\n\n/** The connection type for PullRequestTimelineItems. */\nexport type PullRequestTimelineItemsConnection = {\n  __typename?: 'PullRequestTimelineItemsConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PullRequestTimelineItemsEdge>>>;\n  /** Identifies the count of items after applying `before` and `after` filters. */\n  filteredCount: Scalars['Int'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PullRequestTimelineItems>>>;\n  /** Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing. */\n  pageCount: Scalars['Int'];\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** Identifies the date and time when the timeline was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** An edge in a connection. */\nexport type PullRequestTimelineItemsEdge = {\n  __typename?: 'PullRequestTimelineItemsEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PullRequestTimelineItems>;\n};\n\n/** The possible item types found in a timeline. */\nexport enum PullRequestTimelineItemsItemType {\n  /** Represents an 'added_to_merge_queue' event on a given pull request. */\n  AddedToMergeQueueEvent = 'ADDED_TO_MERGE_QUEUE_EVENT',\n  /** Represents a 'added_to_project' event on a given issue or pull request. */\n  AddedToProjectEvent = 'ADDED_TO_PROJECT_EVENT',\n  /** Represents an 'assigned' event on any assignable object. */\n  AssignedEvent = 'ASSIGNED_EVENT',\n  /** Represents a 'automatic_base_change_failed' event on a given pull request. */\n  AutomaticBaseChangeFailedEvent = 'AUTOMATIC_BASE_CHANGE_FAILED_EVENT',\n  /** Represents a 'automatic_base_change_succeeded' event on a given pull request. */\n  AutomaticBaseChangeSucceededEvent = 'AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT',\n  /** Represents a 'auto_merge_disabled' event on a given pull request. */\n  AutoMergeDisabledEvent = 'AUTO_MERGE_DISABLED_EVENT',\n  /** Represents a 'auto_merge_enabled' event on a given pull request. */\n  AutoMergeEnabledEvent = 'AUTO_MERGE_ENABLED_EVENT',\n  /** Represents a 'auto_rebase_enabled' event on a given pull request. */\n  AutoRebaseEnabledEvent = 'AUTO_REBASE_ENABLED_EVENT',\n  /** Represents a 'auto_squash_enabled' event on a given pull request. */\n  AutoSquashEnabledEvent = 'AUTO_SQUASH_ENABLED_EVENT',\n  /** Represents a 'base_ref_changed' event on a given issue or pull request. */\n  BaseRefChangedEvent = 'BASE_REF_CHANGED_EVENT',\n  /** Represents a 'base_ref_deleted' event on a given pull request. */\n  BaseRefDeletedEvent = 'BASE_REF_DELETED_EVENT',\n  /** Represents a 'base_ref_force_pushed' event on a given pull request. */\n  BaseRefForcePushedEvent = 'BASE_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'closed' event on any `Closable`. */\n  ClosedEvent = 'CLOSED_EVENT',\n  /** Represents a 'comment_deleted' event on a given issue or pull request. */\n  CommentDeletedEvent = 'COMMENT_DELETED_EVENT',\n  /** Represents a 'connected' event on a given issue or pull request. */\n  ConnectedEvent = 'CONNECTED_EVENT',\n  /** Represents a 'converted_note_to_issue' event on a given issue or pull request. */\n  ConvertedNoteToIssueEvent = 'CONVERTED_NOTE_TO_ISSUE_EVENT',\n  /** Represents a 'converted_to_discussion' event on a given issue. */\n  ConvertedToDiscussionEvent = 'CONVERTED_TO_DISCUSSION_EVENT',\n  /** Represents a 'convert_to_draft' event on a given pull request. */\n  ConvertToDraftEvent = 'CONVERT_TO_DRAFT_EVENT',\n  /** Represents a mention made by one issue or pull request to another. */\n  CrossReferencedEvent = 'CROSS_REFERENCED_EVENT',\n  /** Represents a 'demilestoned' event on a given issue or pull request. */\n  DemilestonedEvent = 'DEMILESTONED_EVENT',\n  /** Represents a 'deployed' event on a given pull request. */\n  DeployedEvent = 'DEPLOYED_EVENT',\n  /** Represents a 'deployment_environment_changed' event on a given pull request. */\n  DeploymentEnvironmentChangedEvent = 'DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT',\n  /** Represents a 'disconnected' event on a given issue or pull request. */\n  DisconnectedEvent = 'DISCONNECTED_EVENT',\n  /** Represents a 'head_ref_deleted' event on a given pull request. */\n  HeadRefDeletedEvent = 'HEAD_REF_DELETED_EVENT',\n  /** Represents a 'head_ref_force_pushed' event on a given pull request. */\n  HeadRefForcePushedEvent = 'HEAD_REF_FORCE_PUSHED_EVENT',\n  /** Represents a 'head_ref_restored' event on a given pull request. */\n  HeadRefRestoredEvent = 'HEAD_REF_RESTORED_EVENT',\n  /** Represents a comment on an Issue. */\n  IssueComment = 'ISSUE_COMMENT',\n  /** Represents a 'labeled' event on a given issue or pull request. */\n  LabeledEvent = 'LABELED_EVENT',\n  /** Represents a 'locked' event on a given issue or pull request. */\n  LockedEvent = 'LOCKED_EVENT',\n  /** Represents a 'marked_as_duplicate' event on a given issue or pull request. */\n  MarkedAsDuplicateEvent = 'MARKED_AS_DUPLICATE_EVENT',\n  /** Represents a 'mentioned' event on a given issue or pull request. */\n  MentionedEvent = 'MENTIONED_EVENT',\n  /** Represents a 'merged' event on a given pull request. */\n  MergedEvent = 'MERGED_EVENT',\n  /** Represents a 'milestoned' event on a given issue or pull request. */\n  MilestonedEvent = 'MILESTONED_EVENT',\n  /** Represents a 'moved_columns_in_project' event on a given issue or pull request. */\n  MovedColumnsInProjectEvent = 'MOVED_COLUMNS_IN_PROJECT_EVENT',\n  /** Represents a 'pinned' event on a given issue or pull request. */\n  PinnedEvent = 'PINNED_EVENT',\n  /** Represents a Git commit part of a pull request. */\n  PullRequestCommit = 'PULL_REQUEST_COMMIT',\n  /** Represents a commit comment thread part of a pull request. */\n  PullRequestCommitCommentThread = 'PULL_REQUEST_COMMIT_COMMENT_THREAD',\n  /** A review object for a given pull request. */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** A threaded list of comments for a given pull request. */\n  PullRequestReviewThread = 'PULL_REQUEST_REVIEW_THREAD',\n  /** Represents the latest point in the pull request timeline for which the viewer has seen the pull request's commits. */\n  PullRequestRevisionMarker = 'PULL_REQUEST_REVISION_MARKER',\n  /** Represents a 'ready_for_review' event on a given pull request. */\n  ReadyForReviewEvent = 'READY_FOR_REVIEW_EVENT',\n  /** Represents a 'referenced' event on a given `ReferencedSubject`. */\n  ReferencedEvent = 'REFERENCED_EVENT',\n  /** Represents a 'removed_from_merge_queue' event on a given pull request. */\n  RemovedFromMergeQueueEvent = 'REMOVED_FROM_MERGE_QUEUE_EVENT',\n  /** Represents a 'removed_from_project' event on a given issue or pull request. */\n  RemovedFromProjectEvent = 'REMOVED_FROM_PROJECT_EVENT',\n  /** Represents a 'renamed' event on a given issue or pull request */\n  RenamedTitleEvent = 'RENAMED_TITLE_EVENT',\n  /** Represents a 'reopened' event on any `Closable`. */\n  ReopenedEvent = 'REOPENED_EVENT',\n  /** Represents a 'review_dismissed' event on a given issue or pull request. */\n  ReviewDismissedEvent = 'REVIEW_DISMISSED_EVENT',\n  /** Represents an 'review_requested' event on a given pull request. */\n  ReviewRequestedEvent = 'REVIEW_REQUESTED_EVENT',\n  /** Represents an 'review_request_removed' event on a given pull request. */\n  ReviewRequestRemovedEvent = 'REVIEW_REQUEST_REMOVED_EVENT',\n  /** Represents a 'subscribed' event on a given `Subscribable`. */\n  SubscribedEvent = 'SUBSCRIBED_EVENT',\n  /** Represents a 'transferred' event on a given issue or pull request. */\n  TransferredEvent = 'TRANSFERRED_EVENT',\n  /** Represents an 'unassigned' event on any assignable object. */\n  UnassignedEvent = 'UNASSIGNED_EVENT',\n  /** Represents an 'unlabeled' event on a given issue or pull request. */\n  UnlabeledEvent = 'UNLABELED_EVENT',\n  /** Represents an 'unlocked' event on a given issue or pull request. */\n  UnlockedEvent = 'UNLOCKED_EVENT',\n  /** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\n  UnmarkedAsDuplicateEvent = 'UNMARKED_AS_DUPLICATE_EVENT',\n  /** Represents an 'unpinned' event on a given issue or pull request. */\n  UnpinnedEvent = 'UNPINNED_EVENT',\n  /** Represents an 'unsubscribed' event on a given `Subscribable`. */\n  UnsubscribedEvent = 'UNSUBSCRIBED_EVENT',\n  /** Represents a 'user_blocked' event on a given user. */\n  UserBlockedEvent = 'USER_BLOCKED_EVENT'\n}\n\n/** The possible target states when updating a pull request. */\nexport enum PullRequestUpdateState {\n  /** A pull request that has been closed without being merged. */\n  Closed = 'CLOSED',\n  /** A pull request that is still open. */\n  Open = 'OPEN'\n}\n\n/** A Git push. */\nexport type Push = Node & {\n  __typename?: 'Push';\n  id: Scalars['ID'];\n  /** The SHA after the push */\n  nextSha?: Maybe<Scalars['GitObjectID']>;\n  /** The permalink for this push. */\n  permalink: Scalars['URI'];\n  /** The SHA before the push */\n  previousSha?: Maybe<Scalars['GitObjectID']>;\n  /** The actor who pushed */\n  pusher: Actor;\n  /** The repository that was pushed to */\n  repository: Repository;\n};\n\n/** A team, user, or app who has the ability to push to a protected branch. */\nexport type PushAllowance = Node & {\n  __typename?: 'PushAllowance';\n  /** The actor that can push. */\n  actor?: Maybe<PushAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID'];\n};\n\n/** Types that can be an actor. */\nexport type PushAllowanceActor = App | Team | User;\n\n/** The connection type for PushAllowance. */\nexport type PushAllowanceConnection = {\n  __typename?: 'PushAllowanceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<PushAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<PushAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type PushAllowanceEdge = {\n  __typename?: 'PushAllowanceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<PushAllowance>;\n};\n\n/** The query root of GitHub's GraphQL interface. */\nexport type Query = {\n  __typename?: 'Query';\n  /** Look up a code of conduct by its key */\n  codeOfConduct?: Maybe<CodeOfConduct>;\n  /** Look up a code of conduct by its key */\n  codesOfConduct?: Maybe<Array<Maybe<CodeOfConduct>>>;\n  /** Look up an enterprise by URL slug. */\n  enterprise?: Maybe<Enterprise>;\n  /** Look up a pending enterprise administrator invitation by invitee, enterprise and role. */\n  enterpriseAdministratorInvitation?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up a pending enterprise administrator invitation by invitation token. */\n  enterpriseAdministratorInvitationByToken?: Maybe<EnterpriseAdministratorInvitation>;\n  /** Look up an open source license by its key */\n  license?: Maybe<License>;\n  /** Return a list of known open source licenses */\n  licenses: Array<Maybe<License>>;\n  /** Get alphabetically sorted list of Marketplace categories */\n  marketplaceCategories: Array<MarketplaceCategory>;\n  /** Look up a Marketplace category by its slug. */\n  marketplaceCategory?: Maybe<MarketplaceCategory>;\n  /** Look up a single Marketplace listing */\n  marketplaceListing?: Maybe<MarketplaceListing>;\n  /** Look up Marketplace listings */\n  marketplaceListings: MarketplaceListingConnection;\n  /** Return information about the GitHub instance */\n  meta: GitHubMetadata;\n  /** Fetches an object given its ID. */\n  node?: Maybe<Node>;\n  /** Lookup nodes by a list of IDs. */\n  nodes: Array<Maybe<Node>>;\n  /** Lookup a organization by login. */\n  organization?: Maybe<Organization>;\n  /** The client's rate limit information. */\n  rateLimit?: Maybe<RateLimit>;\n  /**\n   * Workaround for re-exposing the root query object. (Refer to\n   * https://github.com/facebook/relay/issues/112 for more information.)\n   */\n  relay: Query;\n  /** Lookup a given repository by the owner and repository name. */\n  repository?: Maybe<Repository>;\n  /** Lookup a repository owner (ie. either a User or an Organization) by login. */\n  repositoryOwner?: Maybe<RepositoryOwner>;\n  /** Lookup resource by a URL. */\n  resource?: Maybe<UniformResourceLocatable>;\n  /** Perform a search across resources, returning a maximum of 1,000 results. */\n  search: SearchResultItemConnection;\n  /** GitHub Security Advisories */\n  securityAdvisories: SecurityAdvisoryConnection;\n  /** Fetch a Security Advisory by its GHSA ID */\n  securityAdvisory?: Maybe<SecurityAdvisory>;\n  /** Software Vulnerabilities documented by GitHub Security Advisories */\n  securityVulnerabilities: SecurityVulnerabilityConnection;\n  /** Users and organizations who can be sponsored via GitHub Sponsors. */\n  sponsorables: SponsorableItemConnection;\n  /** Look up a topic by name. */\n  topic?: Maybe<Topic>;\n  /** Lookup a user by login. */\n  user?: Maybe<User>;\n  /** The currently authenticated user. */\n  viewer: User;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryCodeOfConductArgs = {\n  key: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseArgs = {\n  invitationToken?: InputMaybe<Scalars['String']>;\n  slug: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationArgs = {\n  enterpriseSlug: Scalars['String'];\n  role: EnterpriseAdministratorRole;\n  userLogin: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryEnterpriseAdministratorInvitationByTokenArgs = {\n  invitationToken: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryLicenseArgs = {\n  key: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoriesArgs = {\n  excludeEmpty?: InputMaybe<Scalars['Boolean']>;\n  excludeSubcategories?: InputMaybe<Scalars['Boolean']>;\n  includeCategories?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceCategoryArgs = {\n  slug: Scalars['String'];\n  useTopicAliases?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingArgs = {\n  slug: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryMarketplaceListingsArgs = {\n  adminId?: InputMaybe<Scalars['ID']>;\n  after?: InputMaybe<Scalars['String']>;\n  allStates?: InputMaybe<Scalars['Boolean']>;\n  before?: InputMaybe<Scalars['String']>;\n  categorySlug?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  organizationId?: InputMaybe<Scalars['ID']>;\n  primaryCategoryOnly?: InputMaybe<Scalars['Boolean']>;\n  slugs?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n  useTopicAliases?: InputMaybe<Scalars['Boolean']>;\n  viewerCanAdmin?: InputMaybe<Scalars['Boolean']>;\n  withFreeTrialsOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodeArgs = {\n  id: Scalars['ID'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryNodesArgs = {\n  ids: Array<Scalars['ID']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryOrganizationArgs = {\n  login: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRateLimitArgs = {\n  dryRun?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']>;\n  name: Scalars['String'];\n  owner: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryRepositoryOwnerArgs = {\n  login: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryResourceArgs = {\n  url: Scalars['URI'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySearchArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  query: Scalars['String'];\n  type: SearchType;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  first?: InputMaybe<Scalars['Int']>;\n  identifier?: InputMaybe<SecurityAdvisoryIdentifierFilter>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SecurityAdvisoryOrder>;\n  publishedSince?: InputMaybe<Scalars['DateTime']>;\n  updatedSince?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityAdvisoryArgs = {\n  ghsaId: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySecurityVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars['String']>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QuerySponsorablesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  dependencyEcosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  ecosystem?: InputMaybe<DependencyGraphEcosystem>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  onlyDependencies?: InputMaybe<Scalars['Boolean']>;\n  orderBy?: InputMaybe<SponsorableOrder>;\n  orgLoginForDependencies?: InputMaybe<Scalars['String']>;\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryTopicArgs = {\n  name: Scalars['String'];\n};\n\n\n/** The query root of GitHub's GraphQL interface. */\nexport type QueryUserArgs = {\n  login: Scalars['String'];\n};\n\n/** Represents the client's rate limit. */\nexport type RateLimit = {\n  __typename?: 'RateLimit';\n  /** The point cost for the current query counting against the rate limit. */\n  cost: Scalars['Int'];\n  /** The maximum number of points the client is permitted to consume in a 60 minute window. */\n  limit: Scalars['Int'];\n  /** The maximum number of nodes this query may return */\n  nodeCount: Scalars['Int'];\n  /** The number of points remaining in the current rate limit window. */\n  remaining: Scalars['Int'];\n  /** The time at which the current rate limit window resets in UTC epoch seconds. */\n  resetAt: Scalars['DateTime'];\n  /** The number of points used in the current rate limit window. */\n  used: Scalars['Int'];\n};\n\n/** Represents a subject that can be reacted on. */\nexport type Reactable = {\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n};\n\n\n/** Represents a subject that can be reacted on. */\nexport type ReactableReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n/** The connection type for User. */\nexport type ReactingUserConnection = {\n  __typename?: 'ReactingUserConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactingUserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user that's made a reaction. */\nexport type ReactingUserEdge = {\n  __typename?: 'ReactingUserEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  node: User;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime'];\n};\n\n/** An emoji reaction to a particular piece of content. */\nexport type Reaction = Node & {\n  __typename?: 'Reaction';\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The reactable piece of content */\n  reactable: Reactable;\n  /** Identifies the user who created this reaction. */\n  user?: Maybe<User>;\n};\n\n/** A list of reactions that have been left on the subject. */\nexport type ReactionConnection = {\n  __typename?: 'ReactionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reaction>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean'];\n};\n\n/** Emojis that can be attached to Issues, Pull Requests and Comments. */\nexport enum ReactionContent {\n  /** Represents the `:confused:` emoji. */\n  Confused = 'CONFUSED',\n  /** Represents the `:eyes:` emoji. */\n  Eyes = 'EYES',\n  /** Represents the `:heart:` emoji. */\n  Heart = 'HEART',\n  /** Represents the `:hooray:` emoji. */\n  Hooray = 'HOORAY',\n  /** Represents the `:laugh:` emoji. */\n  Laugh = 'LAUGH',\n  /** Represents the `:rocket:` emoji. */\n  Rocket = 'ROCKET',\n  /** Represents the `:-1:` emoji. */\n  ThumbsDown = 'THUMBS_DOWN',\n  /** Represents the `:+1:` emoji. */\n  ThumbsUp = 'THUMBS_UP'\n}\n\n/** An edge in a connection. */\nexport type ReactionEdge = {\n  __typename?: 'ReactionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Reaction>;\n};\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroup = {\n  __typename?: 'ReactionGroup';\n  /** Identifies the emoji reaction. */\n  content: ReactionContent;\n  /** Identifies when the reaction was created. */\n  createdAt?: Maybe<Scalars['DateTime']>;\n  /** Reactors to the reaction subject with the emotion represented by this reaction group. */\n  reactors: ReactorConnection;\n  /** The subject that was reacted to. */\n  subject: Reactable;\n  /**\n   * Users who have reacted to the reaction subject with the emotion represented by this reaction group\n   * @deprecated Reactors can now be mannequins, bots, and organizations. Use the `reactors` field instead. Removal on 2021-10-01 UTC.\n   */\n  users: ReactingUserConnection;\n  /** Whether or not the authenticated user has left a reaction on the subject. */\n  viewerHasReacted: Scalars['Boolean'];\n};\n\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupReactorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A group of emoji reactions to a particular piece of content. */\nexport type ReactionGroupUsersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Ways in which lists of reactions can be ordered upon return. */\nexport type ReactionOrder = {\n  /** The direction in which to order reactions by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order reactions by. */\n  field: ReactionOrderField;\n};\n\n/** A list of fields that reactions can be ordered by. */\nexport enum ReactionOrderField {\n  /** Allows ordering a list of reactions by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Types that can be assigned to reactions. */\nexport type Reactor = Bot | Mannequin | Organization | User;\n\n/** The connection type for Reactor. */\nexport type ReactorConnection = {\n  __typename?: 'ReactorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReactorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Reactor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents an author of a reaction. */\nexport type ReactorEdge = {\n  __typename?: 'ReactorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The author of the reaction. */\n  node: Reactor;\n  /** The moment when the user made the reaction. */\n  reactedAt: Scalars['DateTime'];\n};\n\n/** Represents a 'ready_for_review' event on a given pull request. */\nexport type ReadyForReviewEvent = Node & UniformResourceLocatable & {\n  __typename?: 'ReadyForReviewEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** The HTTP path for this ready for review event. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this ready for review event. */\n  url: Scalars['URI'];\n};\n\n/** Represents a Git reference. */\nexport type Ref = Node & {\n  __typename?: 'Ref';\n  /** A list of pull requests with this ref as the head ref. */\n  associatedPullRequests: PullRequestConnection;\n  /** Branch protection rules for this ref */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** Compares the current ref as a base ref to another head ref, if the comparison can be made. */\n  compare?: Maybe<Comparison>;\n  id: Scalars['ID'];\n  /** The ref name. */\n  name: Scalars['String'];\n  /** The ref's prefix, such as `refs/heads/` or `refs/tags/`. */\n  prefix: Scalars['String'];\n  /** Branch protection rules that are viewable by non-admins */\n  refUpdateRule?: Maybe<RefUpdateRule>;\n  /** The repository the ref belongs to. */\n  repository: Repository;\n  /** The object the ref points to. Returns null when object does not exist. */\n  target?: Maybe<GitObject>;\n};\n\n\n/** Represents a Git reference. */\nexport type RefAssociatedPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** Represents a Git reference. */\nexport type RefCompareArgs = {\n  headRef: Scalars['String'];\n};\n\n/** The connection type for Ref. */\nexport type RefConnection = {\n  __typename?: 'RefConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RefEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Ref>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RefEdge = {\n  __typename?: 'RefEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Ref>;\n};\n\n/** Parameters to be used for the ref_name condition */\nexport type RefNameConditionTarget = {\n  __typename?: 'RefNameConditionTarget';\n  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']>;\n  /**\n   * Array of ref names or patterns to include. One of these patterns must match\n   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the\n   * default branch or `~ALL` to include all branches.\n   */\n  include: Array<Scalars['String']>;\n};\n\n/** Parameters to be used for the ref_name condition */\nexport type RefNameConditionTargetInput = {\n  /** Array of ref names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']>;\n  /**\n   * Array of ref names or patterns to include. One of these patterns must match\n   * for the condition to pass. Also accepts `~DEFAULT_BRANCH` to include the\n   * default branch or `~ALL` to include all branches.\n   */\n  include: Array<Scalars['String']>;\n};\n\n/** Ways in which lists of git refs can be ordered upon return. */\nexport type RefOrder = {\n  /** The direction in which to order refs by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order refs by. */\n  field: RefOrderField;\n};\n\n/** Properties by which ref connections can be ordered. */\nexport enum RefOrderField {\n  /** Order refs by their alphanumeric name */\n  Alphabetical = 'ALPHABETICAL',\n  /** Order refs by underlying commit date if the ref prefix is refs/tags/ */\n  TagCommitDate = 'TAG_COMMIT_DATE'\n}\n\n/** A ref update */\nexport type RefUpdate = {\n  /** The value this ref should be updated to. */\n  afterOid: Scalars['GitObjectID'];\n  /** The value this ref needs to point to before the update. */\n  beforeOid?: InputMaybe<Scalars['GitObjectID']>;\n  /** Force a non fast-forward update. */\n  force?: InputMaybe<Scalars['Boolean']>;\n  /** The fully qualified name of the ref to be update. For example `refs/heads/branch-name` */\n  name: Scalars['GitRefname'];\n};\n\n/** A ref update rules for a viewer. */\nexport type RefUpdateRule = {\n  __typename?: 'RefUpdateRule';\n  /** Can this branch be deleted. */\n  allowsDeletions: Scalars['Boolean'];\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes: Scalars['Boolean'];\n  /** Can matching branches be created. */\n  blocksCreations: Scalars['Boolean'];\n  /** Identifies the protection rule pattern. */\n  pattern: Scalars['String'];\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: Maybe<Scalars['Int']>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: Maybe<Array<Maybe<Scalars['String']>>>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews: Scalars['Boolean'];\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution: Scalars['Boolean'];\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory: Scalars['Boolean'];\n  /** Are commits required to be signed. */\n  requiresSignatures: Scalars['Boolean'];\n  /** Is the viewer allowed to dismiss reviews. */\n  viewerAllowedToDismissReviews: Scalars['Boolean'];\n  /** Can the viewer push to the branch */\n  viewerCanPush: Scalars['Boolean'];\n};\n\n/** Represents a 'referenced' event on a given `ReferencedSubject`. */\nexport type ReferencedEvent = Node & {\n  __typename?: 'ReferencedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the commit associated with the 'referenced' event. */\n  commit?: Maybe<Commit>;\n  /** Identifies the repository associated with the 'referenced' event. */\n  commitRepository: Repository;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Reference originated in a different repository. */\n  isCrossRepository: Scalars['Boolean'];\n  /** Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference. */\n  isDirectReference: Scalars['Boolean'];\n  /** Object referenced by event. */\n  subject: ReferencedSubject;\n};\n\n/** Any referencable object */\nexport type ReferencedSubject = Issue | PullRequest;\n\n/** Autogenerated input type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RegenerateEnterpriseIdentityProviderRecoveryCodes */\nexport type RegenerateEnterpriseIdentityProviderRecoveryCodesPayload = {\n  __typename?: 'RegenerateEnterpriseIdentityProviderRecoveryCodesPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the verifiable domain to regenerate the verification token of. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of RegenerateVerifiableDomainToken */\nexport type RegenerateVerifiableDomainTokenPayload = {\n  __typename?: 'RegenerateVerifiableDomainTokenPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The verification token that was generated. */\n  verificationToken?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of RejectDeployments */\nexport type RejectDeploymentsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Optional comment for rejecting deployments */\n  comment?: InputMaybe<Scalars['String']>;\n  /** The ids of environments to reject deployments */\n  environmentIds: Array<Scalars['ID']>;\n  /** The node ID of the workflow run containing the pending deployments. */\n  workflowRunId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RejectDeployments */\nexport type RejectDeploymentsPayload = {\n  __typename?: 'RejectDeploymentsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The affected deployments. */\n  deployments?: Maybe<Array<Deployment>>;\n};\n\n/** A release contains the content for a release. */\nexport type Release = Node & Reactable & UniformResourceLocatable & {\n  __typename?: 'Release';\n  /** The author of the release */\n  author?: Maybe<User>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The description of the release. */\n  description?: Maybe<Scalars['String']>;\n  /** The description of this release rendered to HTML. */\n  descriptionHTML?: Maybe<Scalars['HTML']>;\n  id: Scalars['ID'];\n  /** Whether or not the release is a draft */\n  isDraft: Scalars['Boolean'];\n  /** Whether or not the release is the latest releast */\n  isLatest: Scalars['Boolean'];\n  /** Whether or not the release is a prerelease */\n  isPrerelease: Scalars['Boolean'];\n  /** A list of users mentioned in the release description */\n  mentions?: Maybe<UserConnection>;\n  /** The title of the release. */\n  name?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the release was created. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** List of releases assets which are dependent on this release. */\n  releaseAssets: ReleaseAssetConnection;\n  /** The repository that the release belongs to. */\n  repository: Repository;\n  /** The HTTP path for this issue */\n  resourcePath: Scalars['URI'];\n  /** A description of the release, rendered to HTML without any links in it. */\n  shortDescriptionHTML?: Maybe<Scalars['HTML']>;\n  /** The Git tag the release points to */\n  tag?: Maybe<Ref>;\n  /** The tag commit for this release. */\n  tagCommit?: Maybe<Commit>;\n  /** The name of the release's Git tag */\n  tagName: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this issue */\n  url: Scalars['URI'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseMentionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseReleaseAssetsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  name?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A release contains the content for a release. */\nexport type ReleaseShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n/** A release asset contains the content for a release asset. */\nexport type ReleaseAsset = Node & {\n  __typename?: 'ReleaseAsset';\n  /** The asset's content-type */\n  contentType: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The number of times this asset was downloaded */\n  downloadCount: Scalars['Int'];\n  /** Identifies the URL where you can download the release asset via the browser. */\n  downloadUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** Identifies the title of the release asset. */\n  name: Scalars['String'];\n  /** Release that the asset is associated with */\n  release?: Maybe<Release>;\n  /** The size (in bytes) of the asset */\n  size: Scalars['Int'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The user that performed the upload */\n  uploadedBy: User;\n  /** Identifies the URL of the release asset. */\n  url: Scalars['URI'];\n};\n\n/** The connection type for ReleaseAsset. */\nexport type ReleaseAssetConnection = {\n  __typename?: 'ReleaseAssetConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseAssetEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReleaseAsset>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ReleaseAssetEdge = {\n  __typename?: 'ReleaseAssetEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReleaseAsset>;\n};\n\n/** The connection type for Release. */\nexport type ReleaseConnection = {\n  __typename?: 'ReleaseConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReleaseEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Release>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ReleaseEdge = {\n  __typename?: 'ReleaseEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Release>;\n};\n\n/** Ways in which lists of releases can be ordered upon return. */\nexport type ReleaseOrder = {\n  /** The direction in which to order releases by the specified field. */\n  direction: OrderDirection;\n  /** The field in which to order releases by. */\n  field: ReleaseOrderField;\n};\n\n/** Properties by which release connections can be ordered. */\nexport enum ReleaseOrderField {\n  /** Order releases by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order releases alphabetically by name */\n  Name = 'NAME'\n}\n\n/** Autogenerated input type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignableInput = {\n  /** The id of the assignable object to remove assignees from. */\n  assignableId: Scalars['ID'];\n  /** The id of users to remove as assignees. */\n  assigneeIds: Array<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of RemoveAssigneesFromAssignable */\nexport type RemoveAssigneesFromAssignablePayload = {\n  __typename?: 'RemoveAssigneesFromAssignablePayload';\n  /** The item that was unassigned. */\n  assignable?: Maybe<Assignable>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Enterprise ID from which to remove the administrator. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the user to remove as an administrator. */\n  login: Scalars['String'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseAdmin */\nexport type RemoveEnterpriseAdminPayload = {\n  __typename?: 'RemoveEnterpriseAdminPayload';\n  /** The user who was removed as an administrator. */\n  admin?: Maybe<User>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of removing an administrator. */\n  message?: Maybe<Scalars['String']>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise from which to remove the identity provider. */\n  enterpriseId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseIdentityProvider */\nexport type RemoveEnterpriseIdentityProviderPayload = {\n  __typename?: 'RemoveEnterpriseIdentityProviderPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The identity provider that was removed from the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseMember */\nexport type RemoveEnterpriseMemberInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise from which the user should be removed. */\n  enterpriseId: Scalars['ID'];\n  /** The ID of the user to remove from the enterprise. */\n  userId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseMember */\nexport type RemoveEnterpriseMemberPayload = {\n  __typename?: 'RemoveEnterpriseMemberPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** The user that was removed from the enterprise. */\n  user?: Maybe<User>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise from which the organization should be removed. */\n  enterpriseId: Scalars['ID'];\n  /** The ID of the organization to remove from the enterprise. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseOrganization */\nexport type RemoveEnterpriseOrganizationPayload = {\n  __typename?: 'RemoveEnterpriseOrganizationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n  /** The organization that was removed from the enterprise. */\n  organization?: Maybe<Organization>;\n  /** The viewer performing the mutation. */\n  viewer?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a member who will lose the support entitlement. */\n  login: Scalars['String'];\n};\n\n/** Autogenerated return type of RemoveEnterpriseSupportEntitlement */\nexport type RemoveEnterpriseSupportEntitlementPayload = {\n  __typename?: 'RemoveEnterpriseSupportEntitlementPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of removing the support entitlement. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ids of labels to remove. */\n  labelIds: Array<Scalars['ID']>;\n  /** The id of the Labelable to remove labels from. */\n  labelableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveLabelsFromLabelable */\nexport type RemoveLabelsFromLabelablePayload = {\n  __typename?: 'RemoveLabelsFromLabelablePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The Labelable the labels were removed from. */\n  labelable?: Maybe<Labelable>;\n};\n\n/** Autogenerated input type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization to remove the outside collaborator from. */\n  organizationId: Scalars['ID'];\n  /** The ID of the outside collaborator to remove. */\n  userId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveOutsideCollaborator */\nexport type RemoveOutsideCollaboratorPayload = {\n  __typename?: 'RemoveOutsideCollaboratorPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The user that was removed as an outside collaborator. */\n  removedUser?: Maybe<User>;\n};\n\n/** Autogenerated input type of RemoveReaction */\nexport type RemoveReactionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of the emoji reaction to remove. */\n  content: ReactionContent;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveReaction */\nexport type RemoveReactionPayload = {\n  __typename?: 'RemoveReactionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The reaction object. */\n  reaction?: Maybe<Reaction>;\n  /** The reaction groups for the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** The reactable subject. */\n  subject?: Maybe<Reactable>;\n};\n\n/** Autogenerated input type of RemoveStar */\nexport type RemoveStarInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Starrable ID to unstar. */\n  starrableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveStar */\nexport type RemoveStarPayload = {\n  __typename?: 'RemoveStarPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The starrable. */\n  starrable?: Maybe<Starrable>;\n};\n\n/** Autogenerated input type of RemoveUpvote */\nexport type RemoveUpvoteInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion or comment to remove upvote. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RemoveUpvote */\nexport type RemoveUpvotePayload = {\n  __typename?: 'RemoveUpvotePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The votable subject. */\n  subject?: Maybe<Votable>;\n};\n\n/** Represents a 'removed_from_merge_queue' event on a given pull request. */\nexport type RemovedFromMergeQueueEvent = Node & {\n  __typename?: 'RemovedFromMergeQueueEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the before commit SHA for the 'removed_from_merge_queue' event. */\n  beforeCommit?: Maybe<Commit>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The user who removed this Pull Request from the merge queue */\n  enqueuer?: Maybe<User>;\n  id: Scalars['ID'];\n  /** The merge queue where this pull request was removed from. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** PullRequest referenced by event. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The reason this pull request was removed from the queue. */\n  reason?: Maybe<Scalars['String']>;\n};\n\n/** Represents a 'removed_from_project' event on a given issue or pull request. */\nexport type RemovedFromProjectEvent = Node & {\n  __typename?: 'RemovedFromProjectEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Project referenced by event. */\n  project?: Maybe<Project>;\n  /** Column name referenced by this project event. */\n  projectColumnName: Scalars['String'];\n};\n\n/** Represents a 'renamed' event on a given issue or pull request */\nexport type RenamedTitleEvent = Node & {\n  __typename?: 'RenamedTitleEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the current title of the issue or pull request. */\n  currentTitle: Scalars['String'];\n  id: Scalars['ID'];\n  /** Identifies the previous title of the issue or pull request. */\n  previousTitle: Scalars['String'];\n  /** Subject that was renamed. */\n  subject: RenamedTitleSubject;\n};\n\n/** An object which has a renamable title */\nexport type RenamedTitleSubject = Issue | PullRequest;\n\n/** Autogenerated input type of ReopenDiscussion */\nexport type ReopenDiscussionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the discussion to be reopened. */\n  discussionId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ReopenDiscussion */\nexport type ReopenDiscussionPayload = {\n  __typename?: 'ReopenDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that was reopened. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of ReopenIssue */\nexport type ReopenIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the issue to be opened. */\n  issueId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ReopenIssue */\nexport type ReopenIssuePayload = {\n  __typename?: 'ReopenIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue that was opened. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of ReopenPullRequest */\nexport type ReopenPullRequestInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the pull request to be reopened. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ReopenPullRequest */\nexport type ReopenPullRequestPayload = {\n  __typename?: 'ReopenPullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that was reopened. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Represents a 'reopened' event on any `Closable`. */\nexport type ReopenedEvent = Node & {\n  __typename?: 'ReopenedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Object that was reopened. */\n  closable: Closable;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The reason the issue state was changed to open. */\n  stateReason?: Maybe<IssueStateReason>;\n};\n\n/** Audit log entry for a repo.access event. */\nexport type RepoAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoAccessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoAccessAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoAccessAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.add_member event. */\nexport type RepoAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoAddMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoAddMemberAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoAddMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.add_topic event. */\nexport type RepoAddTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {\n  __typename?: 'RepoAddTopicAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.archived event. */\nexport type RepoArchivedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoArchivedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoArchivedAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoArchivedAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.change_merge_setting event. */\nexport type RepoChangeMergeSettingAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoChangeMergeSettingAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the change was to enable (true) or disable (false) the merge type */\n  isEnabled?: Maybe<Scalars['Boolean']>;\n  /** The merge method affected by the change */\n  mergeType?: Maybe<RepoChangeMergeSettingAuditEntryMergeType>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The merge options available for pull requests to this repository. */\nexport enum RepoChangeMergeSettingAuditEntryMergeType {\n  /** The pull request is added to the base branch in a merge commit. */\n  Merge = 'MERGE',\n  /** Commits from the pull request are added onto the base branch individually without a merge commit. */\n  Rebase = 'REBASE',\n  /** The pull request's commits are squashed into a single commit before they are merged to the base branch. */\n  Squash = 'SQUASH'\n}\n\n/** Audit log entry for a repo.config.disable_anonymous_git_access event. */\nexport type RepoConfigDisableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigDisableAnonymousGitAccessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.disable_collaborators_only event. */\nexport type RepoConfigDisableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigDisableCollaboratorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.disable_contributors_only event. */\nexport type RepoConfigDisableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigDisableContributorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.disable_sockpuppet_disallowed event. */\nexport type RepoConfigDisableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigDisableSockpuppetDisallowedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.enable_anonymous_git_access event. */\nexport type RepoConfigEnableAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigEnableAnonymousGitAccessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.enable_collaborators_only event. */\nexport type RepoConfigEnableCollaboratorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigEnableCollaboratorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.enable_contributors_only event. */\nexport type RepoConfigEnableContributorsOnlyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigEnableContributorsOnlyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.enable_sockpuppet_disallowed event. */\nexport type RepoConfigEnableSockpuppetDisallowedAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigEnableSockpuppetDisallowedAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.lock_anonymous_git_access event. */\nexport type RepoConfigLockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigLockAnonymousGitAccessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.config.unlock_anonymous_git_access event. */\nexport type RepoConfigUnlockAnonymousGitAccessAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoConfigUnlockAnonymousGitAccessAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repo.create event. */\nexport type RepoCreateAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoCreateAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The name of the parent repository for this forked repository. */\n  forkParentName?: Maybe<Scalars['String']>;\n  /** The name of the root repository for this network. */\n  forkSourceName?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoCreateAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoCreateAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.destroy event. */\nexport type RepoDestroyAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoDestroyAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoDestroyAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoDestroyAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.remove_member event. */\nexport type RepoRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & {\n  __typename?: 'RepoRemoveMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n  /** The visibility of the repository */\n  visibility?: Maybe<RepoRemoveMemberAuditEntryVisibility>;\n};\n\n/** The privacy of a repository */\nexport enum RepoRemoveMemberAuditEntryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repo.remove_topic event. */\nexport type RepoRemoveTopicAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TopicAuditEntryData & {\n  __typename?: 'RepoRemoveTopicAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The reasons a piece of content can be reported or minimized. */\nexport enum ReportedContentClassifiers {\n  /** An abusive or harassing piece of content */\n  Abuse = 'ABUSE',\n  /** A duplicated piece of content */\n  Duplicate = 'DUPLICATE',\n  /** An irrelevant piece of content */\n  OffTopic = 'OFF_TOPIC',\n  /** An outdated piece of content */\n  Outdated = 'OUTDATED',\n  /** The content has been resolved */\n  Resolved = 'RESOLVED',\n  /** A spammy piece of content */\n  Spam = 'SPAM'\n}\n\n/** A repository contains the content for a project. */\nexport type Repository = Node & PackageOwner & ProjectOwner & ProjectV2Recent & RepositoryInfo & Starrable & Subscribable & UniformResourceLocatable & {\n  __typename?: 'Repository';\n  /**\n   * Whether or not a pull request head branch that is behind its base branch can\n   * always be updated even if it is not required to be up to date before merging.\n   */\n  allowUpdateBranch: Scalars['Boolean'];\n  /** Identifies the date and time when the repository was archived. */\n  archivedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of users that can be assigned to issues in this repository. */\n  assignableUsers: UserConnection;\n  /** Whether or not Auto-merge can be enabled on pull requests in this repository. */\n  autoMergeAllowed: Scalars['Boolean'];\n  /** A list of branch protection rules for this repository. */\n  branchProtectionRules: BranchProtectionRuleConnection;\n  /** Returns the code of conduct for this repository */\n  codeOfConduct?: Maybe<CodeOfConduct>;\n  /** Information extracted from the repository's `CODEOWNERS` file. */\n  codeowners?: Maybe<RepositoryCodeowners>;\n  /** A list of collaborators associated with the repository. */\n  collaborators?: Maybe<RepositoryCollaboratorConnection>;\n  /** A list of commit comments associated with the repository. */\n  commitComments: CommitCommentConnection;\n  /** Returns a list of contact links associated to the repository */\n  contactLinks?: Maybe<Array<RepositoryContactLink>>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The Ref associated with the repository's default branch. */\n  defaultBranchRef?: Maybe<Ref>;\n  /** Whether or not branches are automatically deleted when merged in this repository. */\n  deleteBranchOnMerge: Scalars['Boolean'];\n  /** A list of dependency manifests contained in the repository */\n  dependencyGraphManifests?: Maybe<DependencyGraphManifestConnection>;\n  /** A list of deploy keys that are on this repository. */\n  deployKeys: DeployKeyConnection;\n  /** Deployments associated with the repository */\n  deployments: DeploymentConnection;\n  /** The description of the repository. */\n  description?: Maybe<Scalars['String']>;\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars['HTML'];\n  /** Returns a single discussion from the current repository by number. */\n  discussion?: Maybe<Discussion>;\n  /** A list of discussion categories that are available in the repository. */\n  discussionCategories: DiscussionCategoryConnection;\n  /** A discussion category by slug. */\n  discussionCategory?: Maybe<DiscussionCategory>;\n  /** A list of discussions that have been opened in the repository. */\n  discussions: DiscussionConnection;\n  /** The number of kilobytes this repository occupies on disk. */\n  diskUsage?: Maybe<Scalars['Int']>;\n  /** Returns a single active environment from the current repository by name. */\n  environment?: Maybe<Environment>;\n  /** A list of environments that are in this repository. */\n  environments: EnvironmentConnection;\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars['Int'];\n  /** Whether this repository allows forks. */\n  forkingAllowed: Scalars['Boolean'];\n  /** A list of direct forked repositories. */\n  forks: RepositoryConnection;\n  /** The funding links for this repository */\n  fundingLinks: Array<FundingLink>;\n  /** Indicates if the repository has the Discussions feature enabled. */\n  hasDiscussionsEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars['Boolean'];\n  /** Whether vulnerability alerts are enabled for the repository. */\n  hasVulnerabilityAlertsEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars['Boolean'];\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The interaction ability settings for this repository. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars['Boolean'];\n  /** Returns true if blank issue creation is allowed */\n  isBlankIssuesEnabled: Scalars['Boolean'];\n  /** Returns whether or not this repository disabled. */\n  isDisabled: Scalars['Boolean'];\n  /** Returns whether or not this repository is empty. */\n  isEmpty: Scalars['Boolean'];\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars['Boolean'];\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars['Boolean'];\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars['Boolean'];\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars['Boolean'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean'];\n  /** Returns true if this repository has a security policy */\n  isSecurityPolicyEnabled?: Maybe<Scalars['Boolean']>;\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars['Boolean'];\n  /** Is this repository a user configuration repository? */\n  isUserConfigurationRepository: Scalars['Boolean'];\n  /** Returns a single issue from the current repository by number. */\n  issue?: Maybe<Issue>;\n  /** Returns a single issue-like object from the current repository by number. */\n  issueOrPullRequest?: Maybe<IssueOrPullRequest>;\n  /** Returns a list of issue templates associated to the repository */\n  issueTemplates?: Maybe<Array<IssueTemplate>>;\n  /** A list of issues that have been opened in the repository. */\n  issues: IssueConnection;\n  /** Returns a single label by name */\n  label?: Maybe<Label>;\n  /** A list of labels associated with the repository. */\n  labels?: Maybe<LabelConnection>;\n  /** A list containing a breakdown of the language composition of the repository. */\n  languages?: Maybe<LanguageConnection>;\n  /** Get the latest release for the repository if one exists. */\n  latestRelease?: Maybe<Release>;\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>;\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>;\n  /** A list of Users that can be mentioned in the context of the repository. */\n  mentionableUsers: UserConnection;\n  /** Whether or not PRs are merged with a merge commit on this repository. */\n  mergeCommitAllowed: Scalars['Boolean'];\n  /** How the default commit message will be generated when merging a pull request. */\n  mergeCommitMessage: MergeCommitMessage;\n  /** How the default commit title will be generated when merging a pull request. */\n  mergeCommitTitle: MergeCommitTitle;\n  /** The merge queue for a specified branch, otherwise the default branch if not provided. */\n  mergeQueue?: Maybe<MergeQueue>;\n  /** Returns a single milestone from the current repository by number. */\n  milestone?: Maybe<Milestone>;\n  /** A list of milestones associated with the repository. */\n  milestones?: Maybe<MilestoneConnection>;\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars['URI']>;\n  /** The name of the repository. */\n  name: Scalars['String'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String'];\n  /** A Git object in the repository */\n  object?: Maybe<GitObject>;\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars['URI'];\n  /** The User owner of the repository. */\n  owner: RepositoryOwner;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** The repository parent, if this is a fork. */\n  parent?: Maybe<Repository>;\n  /** A list of discussions that have been pinned in this repository. */\n  pinnedDiscussions: PinnedDiscussionConnection;\n  /** A list of pinned issues for this repository. */\n  pinnedIssues?: Maybe<PinnedIssueConnection>;\n  /** The primary language of the repository's code. */\n  primaryLanguage?: Maybe<Language>;\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Finds and returns the Project according to the provided Project number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing the repository's projects */\n  projectsResourcePath: Scalars['URI'];\n  /** The HTTP URL listing the repository's projects */\n  projectsUrl: Scalars['URI'];\n  /** List of projects linked to this repository. */\n  projectsV2: ProjectV2Connection;\n  /** Returns a single pull request from the current repository by number. */\n  pullRequest?: Maybe<PullRequest>;\n  /** Returns a list of pull request templates associated to the repository */\n  pullRequestTemplates?: Maybe<Array<PullRequestTemplate>>;\n  /** A list of pull requests that have been opened in the repository. */\n  pullRequests: PullRequestConnection;\n  /** Identifies the date and time when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']>;\n  /** Whether or not rebase-merging is enabled on this repository. */\n  rebaseMergeAllowed: Scalars['Boolean'];\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** Fetch a given ref from the repository */\n  ref?: Maybe<Ref>;\n  /** Fetch a list of refs from the repository */\n  refs?: Maybe<RefConnection>;\n  /** Lookup a single release given various criteria. */\n  release?: Maybe<Release>;\n  /** List of releases which are dependent on this repository. */\n  releases: ReleaseConnection;\n  /** A list of applied repository-topic associations for this repository. */\n  repositoryTopics: RepositoryTopicConnection;\n  /** The HTTP path for this repository */\n  resourcePath: Scalars['URI'];\n  /** Returns a single ruleset from the current repository by ID. */\n  ruleset?: Maybe<RepositoryRuleset>;\n  /** A list of rulesets for this repository. */\n  rulesets?: Maybe<RepositoryRulesetConnection>;\n  /** The security policy URL. */\n  securityPolicyUrl?: Maybe<Scalars['URI']>;\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars['HTML'];\n  /** Whether or not squash-merging is enabled on this repository. */\n  squashMergeAllowed: Scalars['Boolean'];\n  /** How the default commit message will be generated when squash merging a pull request. */\n  squashMergeCommitMessage: SquashMergeCommitMessage;\n  /** How the default commit title will be generated when squash merging a pull request. */\n  squashMergeCommitTitle: SquashMergeCommitTitle;\n  /**\n   * Whether a squash merge commit can use the pull request title as default.\n   * @deprecated `squashPrTitleUsedAsDefault` will be removed. Use `Repository.squashMergeCommitTitle` instead. Removal on 2023-04-01 UTC.\n   */\n  squashPrTitleUsedAsDefault: Scalars['Boolean'];\n  /** The SSH URL to clone this repository */\n  sshUrl: Scalars['GitSSHRemote'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /**\n   * Returns a list of all submodules in this repository parsed from the\n   * .gitmodules file as of the default branch's HEAD commit.\n   */\n  submodules: SubmoduleConnection;\n  /** Temporary authentication token for cloning this repository. */\n  tempCloneToken?: Maybe<Scalars['String']>;\n  /** The repository from which this repository was generated, if any. */\n  templateRepository?: Maybe<Repository>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this repository */\n  url: Scalars['URI'];\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars['Boolean'];\n  /** Indicates whether the viewer has admin permissions on this repository. */\n  viewerCanAdminister: Scalars['Boolean'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Indicates whether the viewer can update the topics of this repository. */\n  viewerCanUpdateTopics: Scalars['Boolean'];\n  /** The last commit email for the viewer. */\n  viewerDefaultCommitEmail?: Maybe<Scalars['String']>;\n  /** The last used merge method by the viewer or the default for the repository. */\n  viewerDefaultMergeMethod: PullRequestMergeMethod;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean'];\n  /** The users permission level on the repository. Will return null if authenticated as an GitHub App. */\n  viewerPermission?: Maybe<RepositoryPermission>;\n  /** A list of emails this viewer can commit with. */\n  viewerPossibleCommitEmails?: Maybe<Array<Scalars['String']>>;\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n  /** Returns a single vulnerability alert from the current repository by number. */\n  vulnerabilityAlert?: Maybe<RepositoryVulnerabilityAlert>;\n  /** A list of vulnerability alerts that are on this repository. */\n  vulnerabilityAlerts?: Maybe<RepositoryVulnerabilityAlertConnection>;\n  /** A list of users watching the repository. */\n  watchers: UserConnection;\n  /** Whether contributors are required to sign off on web-based commits in this repository. */\n  webCommitSignoffRequired: Scalars['Boolean'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryAssignableUsersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryBranchProtectionRulesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCodeownersArgs = {\n  refName?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCollaboratorsArgs = {\n  affiliation?: InputMaybe<CollaboratorAffiliation>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  login?: InputMaybe<Scalars['String']>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryCommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDependencyGraphManifestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  dependenciesAfter?: InputMaybe<Scalars['String']>;\n  dependenciesFirst?: InputMaybe<Scalars['Int']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  withDependencies?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeployKeysArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDeploymentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  environments?: InputMaybe<Array<Scalars['String']>>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DeploymentOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterByAssignable?: InputMaybe<Scalars['Boolean']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionCategoryArgs = {\n  slug: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  categoryId?: InputMaybe<Scalars['ID']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentArgs = {\n  name: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryEnvironmentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryForksArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssueOrPullRequestArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelArgs = {\n  name: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLabelsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LabelOrder>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryLanguagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<LanguageOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMentionableUsersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMergeQueueArgs = {\n  branch?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestoneArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryMilestonesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<MilestoneOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  states?: InputMaybe<Array<MilestoneState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryObjectArgs = {\n  expression?: InputMaybe<Scalars['String']>;\n  oid?: InputMaybe<Scalars['GitObjectID']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPackagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPinnedIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefArgs = {\n  qualifiedName: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRefsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  direction?: InputMaybe<OrderDirection>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RefOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  refPrefix: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleaseArgs = {\n  tagName: Scalars['String'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryReleasesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReleaseOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRepositoryTopicsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRulesetArgs = {\n  databaseId: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryRulesetsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeParents?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryStargazersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositorySubmodulesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryVulnerabilityAlertsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  dependencyScopes?: InputMaybe<Array<RepositoryVulnerabilityAlertDependencyScope>>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  states?: InputMaybe<Array<RepositoryVulnerabilityAlertState>>;\n};\n\n\n/** A repository contains the content for a project. */\nexport type RepositoryWatchersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The affiliation of a user to a repository */\nexport enum RepositoryAffiliation {\n  /** Repositories that the user has been added to as a collaborator. */\n  Collaborator = 'COLLABORATOR',\n  /**\n   * Repositories that the user has access to through being a member of an\n   * organization. This includes every repository on every team that the user is on.\n   */\n  OrganizationMember = 'ORGANIZATION_MEMBER',\n  /** Repositories that are owned by the authenticated user. */\n  Owner = 'OWNER'\n}\n\n/** Metadata for an audit entry with action repo.* */\nexport type RepositoryAuditEntryData = {\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Information extracted from a repository's `CODEOWNERS` file. */\nexport type RepositoryCodeowners = {\n  __typename?: 'RepositoryCodeowners';\n  /** Any problems that were encountered while parsing the `CODEOWNERS` file. */\n  errors: Array<RepositoryCodeownersError>;\n};\n\n/** An error in a `CODEOWNERS` file. */\nexport type RepositoryCodeownersError = {\n  __typename?: 'RepositoryCodeownersError';\n  /** The column number where the error occurs. */\n  column: Scalars['Int'];\n  /** A short string describing the type of error. */\n  kind: Scalars['String'];\n  /** The line number where the error occurs. */\n  line: Scalars['Int'];\n  /** A complete description of the error, combining information from other fields. */\n  message: Scalars['String'];\n  /** The path to the file when the error occurs. */\n  path: Scalars['String'];\n  /** The content of the line where the error occurs. */\n  source: Scalars['String'];\n  /** A suggestion of how to fix the error. */\n  suggestion?: Maybe<Scalars['String']>;\n};\n\n/** The connection type for User. */\nexport type RepositoryCollaboratorConnection = {\n  __typename?: 'RepositoryCollaboratorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryCollaboratorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user who is a collaborator of a repository. */\nexport type RepositoryCollaboratorEdge = {\n  __typename?: 'RepositoryCollaboratorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  node: User;\n  /** The permission the user has on the repository. */\n  permission: RepositoryPermission;\n  /** A list of sources for the user's access to the repository. */\n  permissionSources?: Maybe<Array<PermissionSource>>;\n};\n\n/** A list of repositories owned by the subject. */\nexport type RepositoryConnection = {\n  __typename?: 'RepositoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /** The total size in kilobytes of all repositories in the connection. */\n  totalDiskUsage: Scalars['Int'];\n};\n\n/** A repository contact link. */\nexport type RepositoryContactLink = {\n  __typename?: 'RepositoryContactLink';\n  /** The contact link purpose. */\n  about: Scalars['String'];\n  /** The contact link name. */\n  name: Scalars['String'];\n  /** The contact link URL. */\n  url: Scalars['URI'];\n};\n\n/** The reason a repository is listed as 'contributed'. */\nexport enum RepositoryContributionType {\n  /** Created a commit */\n  Commit = 'COMMIT',\n  /** Created an issue */\n  Issue = 'ISSUE',\n  /** Created a pull request */\n  PullRequest = 'PULL_REQUEST',\n  /** Reviewed a pull request */\n  PullRequestReview = 'PULL_REQUEST_REVIEW',\n  /** Created the repository */\n  Repository = 'REPOSITORY'\n}\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthor = {\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n};\n\n\n/** Represents an author of discussions in repositories. */\nexport type RepositoryDiscussionAuthorRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  answered?: InputMaybe<Scalars['Boolean']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthor = {\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n};\n\n\n/** Represents an author of discussion comments in repositories. */\nexport type RepositoryDiscussionCommentAuthorRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n/** An edge in a connection. */\nexport type RepositoryEdge = {\n  __typename?: 'RepositoryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Repository>;\n};\n\n/** A subset of repository info. */\nexport type RepositoryInfo = {\n  /** Identifies the date and time when the repository was archived. */\n  archivedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The description of the repository. */\n  description?: Maybe<Scalars['String']>;\n  /** The description of the repository rendered to HTML. */\n  descriptionHTML: Scalars['HTML'];\n  /** Returns how many forks there are of this repository in the whole network. */\n  forkCount: Scalars['Int'];\n  /** Indicates if the repository has the Discussions feature enabled. */\n  hasDiscussionsEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has issues feature enabled. */\n  hasIssuesEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has the Projects feature enabled. */\n  hasProjectsEnabled: Scalars['Boolean'];\n  /** Indicates if the repository has wiki feature enabled. */\n  hasWikiEnabled: Scalars['Boolean'];\n  /** The repository's URL. */\n  homepageUrl?: Maybe<Scalars['URI']>;\n  /** Indicates if the repository is unmaintained. */\n  isArchived: Scalars['Boolean'];\n  /** Identifies if the repository is a fork. */\n  isFork: Scalars['Boolean'];\n  /** Indicates if a repository is either owned by an organization, or is a private fork of an organization repository. */\n  isInOrganization: Scalars['Boolean'];\n  /** Indicates if the repository has been locked or not. */\n  isLocked: Scalars['Boolean'];\n  /** Identifies if the repository is a mirror. */\n  isMirror: Scalars['Boolean'];\n  /** Identifies if the repository is private or internal. */\n  isPrivate: Scalars['Boolean'];\n  /** Identifies if the repository is a template that can be used to generate new repositories. */\n  isTemplate: Scalars['Boolean'];\n  /** The license associated with the repository */\n  licenseInfo?: Maybe<License>;\n  /** The reason the repository has been locked. */\n  lockReason?: Maybe<RepositoryLockReason>;\n  /** The repository's original mirror URL. */\n  mirrorUrl?: Maybe<Scalars['URI']>;\n  /** The name of the repository. */\n  name: Scalars['String'];\n  /** The repository's name with owner. */\n  nameWithOwner: Scalars['String'];\n  /** The image used to represent this repository in Open Graph data. */\n  openGraphImageUrl: Scalars['URI'];\n  /** The User owner of the repository. */\n  owner: RepositoryOwner;\n  /** Identifies the date and time when the repository was last pushed to. */\n  pushedAt?: Maybe<Scalars['DateTime']>;\n  /** The HTTP path for this repository */\n  resourcePath: Scalars['URI'];\n  /** A description of the repository, rendered to HTML without any links in it. */\n  shortDescriptionHTML: Scalars['HTML'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this repository */\n  url: Scalars['URI'];\n  /** Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar. */\n  usesCustomOpenGraphImage: Scalars['Boolean'];\n  /** Indicates the repository's visibility level. */\n  visibility: RepositoryVisibility;\n};\n\n\n/** A subset of repository info. */\nexport type RepositoryInfoShortDescriptionHtmlArgs = {\n  limit?: InputMaybe<Scalars['Int']>;\n};\n\n/** Repository interaction limit that applies to this object. */\nexport type RepositoryInteractionAbility = {\n  __typename?: 'RepositoryInteractionAbility';\n  /** The time the currently active limit expires. */\n  expiresAt?: Maybe<Scalars['DateTime']>;\n  /** The current limit that is enabled on this object. */\n  limit: RepositoryInteractionLimit;\n  /** The origin of the currently active interaction limit. */\n  origin: RepositoryInteractionLimitOrigin;\n};\n\n/** A repository interaction limit. */\nexport enum RepositoryInteractionLimit {\n  /** Users that are not collaborators will not be able to interact with the repository. */\n  CollaboratorsOnly = 'COLLABORATORS_ONLY',\n  /** Users that have not previously committed to a repositorys default branch will be unable to interact with the repository. */\n  ContributorsOnly = 'CONTRIBUTORS_ONLY',\n  /** Users that have recently created their account will be unable to interact with the repository. */\n  ExistingUsers = 'EXISTING_USERS',\n  /** No interaction limits are enabled. */\n  NoLimit = 'NO_LIMIT'\n}\n\n/** The length for a repository interaction limit to be enabled for. */\nexport enum RepositoryInteractionLimitExpiry {\n  /** The interaction limit will expire after 1 day. */\n  OneDay = 'ONE_DAY',\n  /** The interaction limit will expire after 1 month. */\n  OneMonth = 'ONE_MONTH',\n  /** The interaction limit will expire after 1 week. */\n  OneWeek = 'ONE_WEEK',\n  /** The interaction limit will expire after 6 months. */\n  SixMonths = 'SIX_MONTHS',\n  /** The interaction limit will expire after 3 days. */\n  ThreeDays = 'THREE_DAYS'\n}\n\n/** Indicates where an interaction limit is configured. */\nexport enum RepositoryInteractionLimitOrigin {\n  /** A limit that is configured at the organization level. */\n  Organization = 'ORGANIZATION',\n  /** A limit that is configured at the repository level. */\n  Repository = 'REPOSITORY',\n  /** A limit that is configured at the user-wide level. */\n  User = 'USER'\n}\n\n/** An invitation for a user to be added to a repository. */\nexport type RepositoryInvitation = Node & {\n  __typename?: 'RepositoryInvitation';\n  /** The email address that received the invitation. */\n  email?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The user who received the invitation. */\n  invitee?: Maybe<User>;\n  /** The user who created the invitation. */\n  inviter: User;\n  /** The permalink for this repository invitation. */\n  permalink: Scalars['URI'];\n  /** The permission granted on this repository by this invitation. */\n  permission: RepositoryPermission;\n  /** The Repository the user is invited to. */\n  repository?: Maybe<RepositoryInfo>;\n};\n\n/** A list of repository invitations. */\nexport type RepositoryInvitationConnection = {\n  __typename?: 'RepositoryInvitationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryInvitationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryInvitation>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryInvitationEdge = {\n  __typename?: 'RepositoryInvitationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryInvitation>;\n};\n\n/** Ordering options for repository invitation connections. */\nexport type RepositoryInvitationOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repository invitations by. */\n  field: RepositoryInvitationOrderField;\n};\n\n/** Properties by which repository invitation connections can be ordered. */\nexport enum RepositoryInvitationOrderField {\n  /** Order repository invitations by creation time */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible reasons a given repository could be in a locked state. */\nexport enum RepositoryLockReason {\n  /** The repository is locked due to a billing related reason. */\n  Billing = 'BILLING',\n  /** The repository is locked due to a migration. */\n  Migrating = 'MIGRATING',\n  /** The repository is locked due to a move. */\n  Moving = 'MOVING',\n  /** The repository is locked due to a rename. */\n  Rename = 'RENAME',\n  /** The repository is locked due to a trade controls related reason. */\n  TradeRestriction = 'TRADE_RESTRICTION'\n}\n\n/** A GitHub Enterprise Importer (GEI) repository migration. */\nexport type RepositoryMigration = Migration & Node & {\n  __typename?: 'RepositoryMigration';\n  /** The migration flag to continue on error. */\n  continueOnError: Scalars['Boolean'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['String']>;\n  /** The reason the migration failed. */\n  failureReason?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** The URL for the migration log (expires 1 day after migration completes). */\n  migrationLogUrl?: Maybe<Scalars['URI']>;\n  /** The migration source. */\n  migrationSource: MigrationSource;\n  /** The target repository name. */\n  repositoryName: Scalars['String'];\n  /** The migration source URL, for example `https://github.com` or `https://monalisa.ghe.com`. */\n  sourceUrl: Scalars['URI'];\n  /** The migration state. */\n  state: MigrationState;\n  /**\n   * The number of warnings encountered for this migration. To review the warnings,\n   * check the [Migration Log](https://docs.github.com/en/migrations/using-github-enterprise-importer/completing-your-migration-with-github-enterprise-importer/accessing-your-migration-logs-for-github-enterprise-importer).\n   */\n  warningsCount: Scalars['Int'];\n};\n\n/** The connection type for RepositoryMigration. */\nexport type RepositoryMigrationConnection = {\n  __typename?: 'RepositoryMigrationConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryMigrationEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryMigration>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a repository migration. */\nexport type RepositoryMigrationEdge = {\n  __typename?: 'RepositoryMigrationEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryMigration>;\n};\n\n/** Ordering options for repository migrations. */\nexport type RepositoryMigrationOrder = {\n  /** The ordering direction. */\n  direction: RepositoryMigrationOrderDirection;\n  /** The field to order repository migrations by. */\n  field: RepositoryMigrationOrderField;\n};\n\n/** Possible directions in which to order a list of repository migrations when provided an `orderBy` argument. */\nexport enum RepositoryMigrationOrderDirection {\n  /** Specifies an ascending order for a given `orderBy` argument. */\n  Asc = 'ASC',\n  /** Specifies a descending order for a given `orderBy` argument. */\n  Desc = 'DESC'\n}\n\n/** Properties by which repository migrations can be ordered. */\nexport enum RepositoryMigrationOrderField {\n  /** Order mannequins why when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Parameters to be used for the repository_name condition */\nexport type RepositoryNameConditionTarget = {\n  __typename?: 'RepositoryNameConditionTarget';\n  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']>;\n  /**\n   * Array of repository names or patterns to include. One of these patterns must\n   * match for the condition to pass. Also accepts `~ALL` to include all repositories.\n   */\n  include: Array<Scalars['String']>;\n  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */\n  protected: Scalars['Boolean'];\n};\n\n/** Parameters to be used for the repository_name condition */\nexport type RepositoryNameConditionTargetInput = {\n  /** Array of repository names or patterns to exclude. The condition will not pass if any of these patterns match. */\n  exclude: Array<Scalars['String']>;\n  /**\n   * Array of repository names or patterns to include. One of these patterns must\n   * match for the condition to pass. Also accepts `~ALL` to include all repositories.\n   */\n  include: Array<Scalars['String']>;\n  /** Target changes that match these patterns will be prevented except by those with bypass permissions. */\n  protected?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Represents a object that belongs to a repository. */\nexport type RepositoryNode = {\n  /** The repository associated with this node. */\n  repository: Repository;\n};\n\n/** Ordering options for repository connections */\nexport type RepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: RepositoryOrderField;\n};\n\n/** Properties by which repository connections can be ordered. */\nexport enum RepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwner = {\n  /** A URL pointing to the owner's public avatar. */\n  avatarUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** The username used to login. */\n  login: Scalars['String'];\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** The HTTP URL for the owner. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for the owner. */\n  url: Scalars['URI'];\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isFork?: InputMaybe<Scalars['Boolean']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** Represents an owner of a Repository. */\nexport type RepositoryOwnerRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']>;\n  name: Scalars['String'];\n};\n\n/** The access level to a repository */\nexport enum RepositoryPermission {\n  /**\n   * Can read, clone, and push to this repository. Can also manage issues, pull\n   * requests, and repository settings, including adding collaborators\n   */\n  Admin = 'ADMIN',\n  /** Can read, clone, and push to this repository. They can also manage issues, pull requests, and some repository settings */\n  Maintain = 'MAINTAIN',\n  /** Can read and clone this repository. Can also open and comment on issues and pull requests */\n  Read = 'READ',\n  /** Can read and clone this repository. Can also manage issues and pull requests */\n  Triage = 'TRIAGE',\n  /** Can read, clone, and push to this repository. Can also manage issues and pull requests */\n  Write = 'WRITE'\n}\n\n/** The privacy of a repository */\nexport enum RepositoryPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n/** A repository rule. */\nexport type RepositoryRule = Node & {\n  __typename?: 'RepositoryRule';\n  id: Scalars['ID'];\n  /** The parameters for this rule. */\n  parameters?: Maybe<RuleParameters>;\n  /** The type of rule. */\n  type: RepositoryRuleType;\n};\n\n/** Set of conditions that determine if a ruleset will evaluate */\nexport type RepositoryRuleConditions = {\n  __typename?: 'RepositoryRuleConditions';\n  /** Configuration for the ref_name condition */\n  refName?: Maybe<RefNameConditionTarget>;\n  /** Configuration for the repository_name condition */\n  repositoryName?: Maybe<RepositoryNameConditionTarget>;\n};\n\n/** Specifies the conditions required for a ruleset to evaluate */\nexport type RepositoryRuleConditionsInput = {\n  /** Configuration for the ref_name condition */\n  refName?: InputMaybe<RefNameConditionTargetInput>;\n  /** Configuration for the repository_name condition */\n  repositoryName?: InputMaybe<RepositoryNameConditionTargetInput>;\n};\n\n/** The connection type for RepositoryRule. */\nexport type RepositoryRuleConnection = {\n  __typename?: 'RepositoryRuleConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRuleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRuleEdge = {\n  __typename?: 'RepositoryRuleEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRule>;\n};\n\n/** Specifies the attributes for a new or updated rule. */\nexport type RepositoryRuleInput = {\n  /** Optional ID of this rule when updating */\n  id?: InputMaybe<Scalars['ID']>;\n  /** The parameters for the rule. */\n  parameters?: InputMaybe<RuleParametersInput>;\n  /** The type of rule to create. */\n  type: RepositoryRuleType;\n};\n\n/** The rule types supported in rulesets */\nexport enum RepositoryRuleType {\n  /** Branch name pattern */\n  BranchNamePattern = 'BRANCH_NAME_PATTERN',\n  /** Committer email pattern */\n  CommitterEmailPattern = 'COMMITTER_EMAIL_PATTERN',\n  /** Commit author email pattern */\n  CommitAuthorEmailPattern = 'COMMIT_AUTHOR_EMAIL_PATTERN',\n  /** Commit message pattern */\n  CommitMessagePattern = 'COMMIT_MESSAGE_PATTERN',\n  /** Only allow users with bypass permission to create matching refs. */\n  Creation = 'CREATION',\n  /** Only allow users with bypass permissions to delete matching refs. */\n  Deletion = 'DELETION',\n  /** Prevent users with push access from force pushing to branches. */\n  NonFastForward = 'NON_FAST_FORWARD',\n  /** Require all commits be made to a non-target branch and submitted via a pull request before they can be merged. */\n  PullRequest = 'PULL_REQUEST',\n  /**\n   * Choose which environments must be successfully deployed to before branches can\n   * be merged into a branch that matches this rule.\n   */\n  RequiredDeployments = 'REQUIRED_DEPLOYMENTS',\n  /** Prevent merge commits from being pushed to matching branches. */\n  RequiredLinearHistory = 'REQUIRED_LINEAR_HISTORY',\n  /** Commits pushed to matching branches must have verified signatures. */\n  RequiredSignatures = 'REQUIRED_SIGNATURES',\n  /**\n   * Choose which status checks must pass before branches can be merged into a\n   * branch that matches this rule. When enabled, commits must first be pushed to\n   * another branch, then merged or pushed directly to a branch that matches this\n   * rule after status checks have passed.\n   */\n  RequiredStatusChecks = 'REQUIRED_STATUS_CHECKS',\n  /** Tag name pattern */\n  TagNamePattern = 'TAG_NAME_PATTERN',\n  /** Only allow users with bypass permission to update matching refs. */\n  Update = 'UPDATE'\n}\n\n/** A repository ruleset. */\nexport type RepositoryRuleset = Node & {\n  __typename?: 'RepositoryRuleset';\n  /** The actors that can bypass this ruleset */\n  bypassActors?: Maybe<RepositoryRulesetBypassActorConnection>;\n  /** The bypass mode of this ruleset */\n  bypassMode: RuleBypassMode;\n  /** The set of conditions that must evaluate to true for this ruleset to apply */\n  conditions: RepositoryRuleConditions;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The enforcement level of this ruleset */\n  enforcement: RuleEnforcement;\n  id: Scalars['ID'];\n  /** Name of the ruleset. */\n  name: Scalars['String'];\n  /** List of rules. */\n  rules?: Maybe<RepositoryRuleConnection>;\n  /** Source of ruleset. */\n  source: RuleSource;\n  /** Target of the ruleset. */\n  target?: Maybe<RepositoryRulesetTarget>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n\n/** A repository ruleset. */\nexport type RepositoryRulesetBypassActorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A repository ruleset. */\nexport type RepositoryRulesetRulesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  type?: InputMaybe<RepositoryRuleType>;\n};\n\n/** A team or app that has the ability to bypass a rules defined on a ruleset */\nexport type RepositoryRulesetBypassActor = Node & {\n  __typename?: 'RepositoryRulesetBypassActor';\n  /** The actor that can bypass rules. */\n  actor?: Maybe<BypassActor>;\n  id: Scalars['ID'];\n  /** Identifies the ruleset associated with the allowed actor */\n  repositoryRuleset?: Maybe<RepositoryRuleset>;\n};\n\n/** The connection type for RepositoryRulesetBypassActor. */\nexport type RepositoryRulesetBypassActorConnection = {\n  __typename?: 'RepositoryRulesetBypassActorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRulesetBypassActorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRulesetBypassActor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRulesetBypassActorEdge = {\n  __typename?: 'RepositoryRulesetBypassActorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRulesetBypassActor>;\n};\n\n/** The connection type for RepositoryRuleset. */\nexport type RepositoryRulesetConnection = {\n  __typename?: 'RepositoryRulesetConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryRulesetEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryRuleset>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryRulesetEdge = {\n  __typename?: 'RepositoryRulesetEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryRuleset>;\n};\n\n/** The targets supported for rulesets */\nexport enum RepositoryRulesetTarget {\n  /** Branch */\n  Branch = 'BRANCH',\n  /** Tag */\n  Tag = 'TAG'\n}\n\n/** A repository-topic connects a repository to a topic. */\nexport type RepositoryTopic = Node & UniformResourceLocatable & {\n  __typename?: 'RepositoryTopic';\n  id: Scalars['ID'];\n  /** The HTTP path for this repository-topic. */\n  resourcePath: Scalars['URI'];\n  /** The topic. */\n  topic: Topic;\n  /** The HTTP URL for this repository-topic. */\n  url: Scalars['URI'];\n};\n\n/** The connection type for RepositoryTopic. */\nexport type RepositoryTopicConnection = {\n  __typename?: 'RepositoryTopicConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryTopicEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryTopic>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RepositoryTopicEdge = {\n  __typename?: 'RepositoryTopicEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryTopic>;\n};\n\n/** The repository's visibility level. */\nexport enum RepositoryVisibility {\n  /** The repository is visible only to users in the same business. */\n  Internal = 'INTERNAL',\n  /** The repository is visible only to those with explicit access. */\n  Private = 'PRIVATE',\n  /** The repository is visible to everyone. */\n  Public = 'PUBLIC'\n}\n\n/** Audit log entry for a repository_visibility_change.disable event. */\nexport type RepositoryVisibilityChangeDisableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'RepositoryVisibilityChangeDisableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a repository_visibility_change.enable event. */\nexport type RepositoryVisibilityChangeEnableAuditEntry = AuditEntry & EnterpriseAuditEntryData & Node & OrganizationAuditEntryData & {\n  __typename?: 'RepositoryVisibilityChangeEnableAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  /** The HTTP path for this enterprise. */\n  enterpriseResourcePath?: Maybe<Scalars['URI']>;\n  /** The slug of the enterprise. */\n  enterpriseSlug?: Maybe<Scalars['String']>;\n  /** The HTTP URL for this enterprise. */\n  enterpriseUrl?: Maybe<Scalars['URI']>;\n  id: Scalars['ID'];\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** A Dependabot alert for a repository with a dependency affected by a security vulnerability. */\nexport type RepositoryVulnerabilityAlert = Node & RepositoryNode & {\n  __typename?: 'RepositoryVulnerabilityAlert';\n  /** When was the alert auto-dismissed? */\n  autoDismissedAt?: Maybe<Scalars['DateTime']>;\n  /** When was the alert created? */\n  createdAt: Scalars['DateTime'];\n  /** The associated Dependabot update */\n  dependabotUpdate?: Maybe<DependabotUpdate>;\n  /** The scope of an alert's dependency */\n  dependencyScope?: Maybe<RepositoryVulnerabilityAlertDependencyScope>;\n  /** Comment explaining the reason the alert was dismissed */\n  dismissComment?: Maybe<Scalars['String']>;\n  /** The reason the alert was dismissed */\n  dismissReason?: Maybe<Scalars['String']>;\n  /** When was the alert dismissed? */\n  dismissedAt?: Maybe<Scalars['DateTime']>;\n  /** The user who dismissed the alert */\n  dismisser?: Maybe<User>;\n  /** When was the alert fixed? */\n  fixedAt?: Maybe<Scalars['DateTime']>;\n  id: Scalars['ID'];\n  /** Identifies the alert number. */\n  number: Scalars['Int'];\n  /** The associated repository */\n  repository: Repository;\n  /** The associated security advisory */\n  securityAdvisory?: Maybe<SecurityAdvisory>;\n  /** The associated security vulnerability */\n  securityVulnerability?: Maybe<SecurityVulnerability>;\n  /** Identifies the state of the alert. */\n  state: RepositoryVulnerabilityAlertState;\n  /** The vulnerable manifest filename */\n  vulnerableManifestFilename: Scalars['String'];\n  /** The vulnerable manifest path */\n  vulnerableManifestPath: Scalars['String'];\n  /** The vulnerable requirements */\n  vulnerableRequirements?: Maybe<Scalars['String']>;\n};\n\n/** The connection type for RepositoryVulnerabilityAlert. */\nexport type RepositoryVulnerabilityAlertConnection = {\n  __typename?: 'RepositoryVulnerabilityAlertConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RepositoryVulnerabilityAlertEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RepositoryVulnerabilityAlert>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** The possible scopes of an alert's dependency. */\nexport enum RepositoryVulnerabilityAlertDependencyScope {\n  /** A dependency that is only used in development */\n  Development = 'DEVELOPMENT',\n  /** A dependency that is leveraged during application runtime */\n  Runtime = 'RUNTIME'\n}\n\n/** An edge in a connection. */\nexport type RepositoryVulnerabilityAlertEdge = {\n  __typename?: 'RepositoryVulnerabilityAlertEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RepositoryVulnerabilityAlert>;\n};\n\n/** The possible states of an alert */\nexport enum RepositoryVulnerabilityAlertState {\n  /** An alert that has been automatically closed by Dependabot. */\n  AutoDismissed = 'AUTO_DISMISSED',\n  /** An alert that has been manually closed by a user. */\n  Dismissed = 'DISMISSED',\n  /** An alert that has been resolved by a code change. */\n  Fixed = 'FIXED',\n  /** An alert that is still open. */\n  Open = 'OPEN'\n}\n\n/** Autogenerated input type of RequestReviews */\nexport type RequestReviewsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the pull request to modify. */\n  pullRequestId: Scalars['ID'];\n  /** The Node IDs of the team to request. */\n  teamIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** Add users to the set rather than replace. */\n  union?: InputMaybe<Scalars['Boolean']>;\n  /** The Node IDs of the user to request. */\n  userIds?: InputMaybe<Array<Scalars['ID']>>;\n};\n\n/** Autogenerated return type of RequestReviews */\nexport type RequestReviewsPayload = {\n  __typename?: 'RequestReviewsPayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that is getting requests. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The edge from the pull request to the requested reviewers. */\n  requestedReviewersEdge?: Maybe<UserEdge>;\n};\n\n/** The possible states that can be requested when creating a check run. */\nexport enum RequestableCheckStatusState {\n  /** The check suite or run has been completed. */\n  Completed = 'COMPLETED',\n  /** The check suite or run is in progress. */\n  InProgress = 'IN_PROGRESS',\n  /** The check suite or run is in pending state. */\n  Pending = 'PENDING',\n  /** The check suite or run has been queued. */\n  Queued = 'QUEUED',\n  /** The check suite or run is in waiting state. */\n  Waiting = 'WAITING'\n}\n\n/** Types that can be requested reviewers. */\nexport type RequestedReviewer = Mannequin | Team | User;\n\n/** The connection type for RequestedReviewer. */\nexport type RequestedReviewerConnection = {\n  __typename?: 'RequestedReviewerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<RequestedReviewerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<RequestedReviewer>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type RequestedReviewerEdge = {\n  __typename?: 'RequestedReviewerEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<RequestedReviewer>;\n};\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequest = {\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean'];\n};\n\n\n/** Represents a type that can be required by a pull request for merging. */\nexport type RequirableByPullRequestIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']>;\n};\n\n/**\n * Choose which environments must be successfully deployed to before branches can\n * be merged into a branch that matches this rule.\n */\nexport type RequiredDeploymentsParameters = {\n  __typename?: 'RequiredDeploymentsParameters';\n  /** The environments that must be successfully deployed to before branches can be merged. */\n  requiredDeploymentEnvironments: Array<Scalars['String']>;\n};\n\n/**\n * Choose which environments must be successfully deployed to before branches can\n * be merged into a branch that matches this rule.\n */\nexport type RequiredDeploymentsParametersInput = {\n  /** The environments that must be successfully deployed to before branches can be merged. */\n  requiredDeploymentEnvironments: Array<Scalars['String']>;\n};\n\n/** Represents a required status check for a protected branch, but not any specific run of that check. */\nexport type RequiredStatusCheckDescription = {\n  __typename?: 'RequiredStatusCheckDescription';\n  /** The App that must provide this status in order for it to be accepted. */\n  app?: Maybe<App>;\n  /** The name of this status. */\n  context: Scalars['String'];\n};\n\n/** Specifies the attributes for a new or updated required status check. */\nexport type RequiredStatusCheckInput = {\n  /**\n   * The ID of the App that must set the status in order for it to be accepted.\n   * Omit this value to use whichever app has recently been setting this status, or\n   * use \"any\" to allow any app to set the status.\n   */\n  appId?: InputMaybe<Scalars['ID']>;\n  /** Status check context that must pass for commits to be accepted to the matching branch. */\n  context: Scalars['String'];\n};\n\n/**\n * Choose which status checks must pass before branches can be merged into a branch\n * that matches this rule. When enabled, commits must first be pushed to another\n * branch, then merged or pushed directly to a branch that matches this rule after\n * status checks have passed.\n */\nexport type RequiredStatusChecksParameters = {\n  __typename?: 'RequiredStatusChecksParameters';\n  /** Status checks that are required. */\n  requiredStatusChecks: Array<StatusCheckConfiguration>;\n  /**\n   * Whether pull requests targeting a matching branch must be tested with the\n   * latest code. This setting will not take effect unless at least one status\n   * check is enabled.\n   */\n  strictRequiredStatusChecksPolicy: Scalars['Boolean'];\n};\n\n/**\n * Choose which status checks must pass before branches can be merged into a branch\n * that matches this rule. When enabled, commits must first be pushed to another\n * branch, then merged or pushed directly to a branch that matches this rule after\n * status checks have passed.\n */\nexport type RequiredStatusChecksParametersInput = {\n  /** Status checks that are required. */\n  requiredStatusChecks: Array<StatusCheckConfigurationInput>;\n  /**\n   * Whether pull requests targeting a matching branch must be tested with the\n   * latest code. This setting will not take effect unless at least one status\n   * check is enabled.\n   */\n  strictRequiredStatusChecksPolicy: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of RerequestCheckSuite */\nexport type RerequestCheckSuiteInput = {\n  /** The Node ID of the check suite. */\n  checkSuiteId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RerequestCheckSuite */\nexport type RerequestCheckSuitePayload = {\n  __typename?: 'RerequestCheckSuitePayload';\n  /** The requested check suite. */\n  checkSuite?: Maybe<CheckSuite>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of ResolveReviewThread */\nexport type ResolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the thread to resolve */\n  threadId: Scalars['ID'];\n};\n\n/** Autogenerated return type of ResolveReviewThread */\nexport type ResolveReviewThreadPayload = {\n  __typename?: 'ResolveReviewThreadPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents a private contribution a user made on GitHub. */\nexport type RestrictedContribution = Contribution & {\n  __typename?: 'RestrictedContribution';\n  /**\n   * Whether this contribution is associated with a record you do not have access to. For\n   * example, your own 'first issue' contribution may have been made on a repository you can no\n   * longer access.\n   */\n  isRestricted: Scalars['Boolean'];\n  /** When this contribution was made. */\n  occurredAt: Scalars['DateTime'];\n  /** The HTTP path for this contribution. */\n  resourcePath: Scalars['URI'];\n  /** The HTTP URL for this contribution. */\n  url: Scalars['URI'];\n  /** The user who made this contribution. */\n  user: User;\n};\n\n/** Autogenerated input type of RetireSponsorsTier */\nexport type RetireSponsorsTierInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the published tier to retire. */\n  tierId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RetireSponsorsTier */\nexport type RetireSponsorsTierPayload = {\n  __typename?: 'RetireSponsorsTierPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The tier that was retired. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n};\n\n/** Autogenerated input type of RevertPullRequest */\nexport type RevertPullRequestInput = {\n  /** The description of the revert pull request. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Indicates whether the revert pull request should be a draft. */\n  draft?: InputMaybe<Scalars['Boolean']>;\n  /** The ID of the pull request to revert. */\n  pullRequestId: Scalars['ID'];\n  /** The title of the revert pull request. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of RevertPullRequest */\nexport type RevertPullRequestPayload = {\n  __typename?: 'RevertPullRequestPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The pull request that was reverted. */\n  pullRequest?: Maybe<PullRequest>;\n  /** The new pull request that reverts the input pull request. */\n  revertPullRequest?: Maybe<PullRequest>;\n};\n\n/** A user, team, or app who has the ability to dismiss a review on a protected branch. */\nexport type ReviewDismissalAllowance = Node & {\n  __typename?: 'ReviewDismissalAllowance';\n  /** The actor that can dismiss. */\n  actor?: Maybe<ReviewDismissalAllowanceActor>;\n  /** Identifies the branch protection rule associated with the allowed user, team, or app. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  id: Scalars['ID'];\n};\n\n/** Types that can be an actor. */\nexport type ReviewDismissalAllowanceActor = App | Team | User;\n\n/** The connection type for ReviewDismissalAllowance. */\nexport type ReviewDismissalAllowanceConnection = {\n  __typename?: 'ReviewDismissalAllowanceConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewDismissalAllowanceEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewDismissalAllowance>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ReviewDismissalAllowanceEdge = {\n  __typename?: 'ReviewDismissalAllowanceEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewDismissalAllowance>;\n};\n\n/** Represents a 'review_dismissed' event on a given issue or pull request. */\nexport type ReviewDismissedEvent = Node & UniformResourceLocatable & {\n  __typename?: 'ReviewDismissedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** Identifies the optional message associated with the 'review_dismissed' event. */\n  dismissalMessage?: Maybe<Scalars['String']>;\n  /** Identifies the optional message associated with the event, rendered to HTML. */\n  dismissalMessageHTML?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Identifies the previous state of the review with the 'review_dismissed' event. */\n  previousReviewState: PullRequestReviewState;\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the commit which caused the review to become stale. */\n  pullRequestCommit?: Maybe<PullRequestCommit>;\n  /** The HTTP path for this review dismissed event. */\n  resourcePath: Scalars['URI'];\n  /** Identifies the review associated with the 'review_dismissed' event. */\n  review?: Maybe<PullRequestReview>;\n  /** The HTTP URL for this review dismissed event. */\n  url: Scalars['URI'];\n};\n\n/** A request for a user to review a pull request. */\nexport type ReviewRequest = Node & {\n  __typename?: 'ReviewRequest';\n  /** Whether this request was created for a code owner */\n  asCodeOwner: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** Identifies the pull request associated with this review request. */\n  pullRequest: PullRequest;\n  /** The reviewer that is requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** The connection type for ReviewRequest. */\nexport type ReviewRequestConnection = {\n  __typename?: 'ReviewRequestConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<ReviewRequestEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<ReviewRequest>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type ReviewRequestEdge = {\n  __typename?: 'ReviewRequestEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<ReviewRequest>;\n};\n\n/** Represents an 'review_request_removed' event on a given pull request. */\nexport type ReviewRequestRemovedEvent = Node & {\n  __typename?: 'ReviewRequestRemovedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review request was removed. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/** Represents an 'review_requested' event on a given pull request. */\nexport type ReviewRequestedEvent = Node & {\n  __typename?: 'ReviewRequestedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** PullRequest referenced by event. */\n  pullRequest: PullRequest;\n  /** Identifies the reviewer whose review was requested. */\n  requestedReviewer?: Maybe<RequestedReviewer>;\n};\n\n/**\n * A hovercard context with a message describing the current code review state of the pull\n * request.\n */\nexport type ReviewStatusHovercardContext = HovercardContext & {\n  __typename?: 'ReviewStatusHovercardContext';\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n  /** The current status of the pull request with respect to code review. */\n  reviewDecision?: Maybe<PullRequestReviewDecision>;\n};\n\n/** Autogenerated input type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise to which all organizations managed by it will be granted the migrator role. */\n  enterpriseId: Scalars['ID'];\n  /** The login of the user to revoke the migrator role */\n  login: Scalars['String'];\n};\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayload = {\n  __typename?: 'RevokeEnterpriseOrganizationsMigratorRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organizations that had the migrator role revoked for the given user. */\n  organizations?: Maybe<OrganizationConnection>;\n};\n\n\n/** Autogenerated return type of RevokeEnterpriseOrganizationsMigratorRole */\nexport type RevokeEnterpriseOrganizationsMigratorRolePayloadOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated input type of RevokeMigratorRole */\nexport type RevokeMigratorRoleInput = {\n  /** The user login or Team slug to revoke the migrator role from. */\n  actor: Scalars['String'];\n  /** Specifies the type of the actor, can be either USER or TEAM. */\n  actorType: ActorType;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization that the user/team belongs to. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of RevokeMigratorRole */\nexport type RevokeMigratorRolePayload = {\n  __typename?: 'RevokeMigratorRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Did the operation succeed? */\n  success?: Maybe<Scalars['Boolean']>;\n};\n\n/** Possible roles a user may have in relation to an organization. */\nexport enum RoleInOrganization {\n  /** A user who is a direct member of the organization. */\n  DirectMember = 'DIRECT_MEMBER',\n  /** A user with full administrative access to the organization. */\n  Owner = 'OWNER',\n  /** A user who is unaffiliated with the organization. */\n  Unaffiliated = 'UNAFFILIATED'\n}\n\n/** The bypass mode for a rule or ruleset. */\nexport enum RuleBypassMode {\n  /** Bypassing is disabled */\n  None = 'NONE',\n  /** Those with bypass permission at the organization level can bypass */\n  Organization = 'ORGANIZATION',\n  /** Those with bypass permission at the organization level can always bypass */\n  OrganizationAlways = 'ORGANIZATION_ALWAYS',\n  /** Bypassing is disabled */\n  OrganizationNone = 'ORGANIZATION_NONE',\n  /** Those with bypass permission at the organization level can bypass for pull requests only */\n  OrganizationPrsOnly = 'ORGANIZATION_PRS_ONLY',\n  /** Those with bypass permission at the repository level can bypass */\n  Repository = 'REPOSITORY'\n}\n\n/** The level of enforcement for a rule or ruleset. */\nexport enum RuleEnforcement {\n  /** Rules will be enforced */\n  Active = 'ACTIVE',\n  /** Do not evaluate or enforce rules */\n  Disabled = 'DISABLED',\n  /**\n   * Allow admins to test rules before enforcing them. Admins can view insights on\n   * the Rule Insights page (`evaluate` is only available with GitHub Enterprise).\n   */\n  Evaluate = 'EVALUATE'\n}\n\n/** Types which can be parameters for `RepositoryRule` objects. */\nexport type RuleParameters = BranchNamePatternParameters | CommitAuthorEmailPatternParameters | CommitMessagePatternParameters | CommitterEmailPatternParameters | PullRequestParameters | RequiredDeploymentsParameters | RequiredStatusChecksParameters | TagNamePatternParameters | UpdateParameters;\n\n/** Specifies the parameters for a `RepositoryRule` object. Only one of the fields should be specified. */\nexport type RuleParametersInput = {\n  /** Parameters used for the `branch_name_pattern` rule type */\n  branchNamePattern?: InputMaybe<BranchNamePatternParametersInput>;\n  /** Parameters used for the `commit_author_email_pattern` rule type */\n  commitAuthorEmailPattern?: InputMaybe<CommitAuthorEmailPatternParametersInput>;\n  /** Parameters used for the `commit_message_pattern` rule type */\n  commitMessagePattern?: InputMaybe<CommitMessagePatternParametersInput>;\n  /** Parameters used for the `committer_email_pattern` rule type */\n  committerEmailPattern?: InputMaybe<CommitterEmailPatternParametersInput>;\n  /** Parameters used for the `pull_request` rule type */\n  pullRequest?: InputMaybe<PullRequestParametersInput>;\n  /** Parameters used for the `required_deployments` rule type */\n  requiredDeployments?: InputMaybe<RequiredDeploymentsParametersInput>;\n  /** Parameters used for the `required_status_checks` rule type */\n  requiredStatusChecks?: InputMaybe<RequiredStatusChecksParametersInput>;\n  /** Parameters used for the `tag_name_pattern` rule type */\n  tagNamePattern?: InputMaybe<TagNamePatternParametersInput>;\n  /** Parameters used for the `update` rule type */\n  update?: InputMaybe<UpdateParametersInput>;\n};\n\n/** Types which can have `RepositoryRule` objects. */\nexport type RuleSource = Organization | Repository;\n\n/** The possible digest algorithms used to sign SAML requests for an identity provider. */\nexport enum SamlDigestAlgorithm {\n  /** SHA1 */\n  Sha1 = 'SHA1',\n  /** SHA256 */\n  Sha256 = 'SHA256',\n  /** SHA384 */\n  Sha384 = 'SHA384',\n  /** SHA512 */\n  Sha512 = 'SHA512'\n}\n\n/** The possible signature algorithms used to sign SAML requests for a Identity Provider. */\nexport enum SamlSignatureAlgorithm {\n  /** RSA-SHA1 */\n  RsaSha1 = 'RSA_SHA1',\n  /** RSA-SHA256 */\n  RsaSha256 = 'RSA_SHA256',\n  /** RSA-SHA384 */\n  RsaSha384 = 'RSA_SHA384',\n  /** RSA-SHA512 */\n  RsaSha512 = 'RSA_SHA512'\n}\n\n/** A Saved Reply is text a user can use to reply quickly. */\nexport type SavedReply = Node & {\n  __typename?: 'SavedReply';\n  /** The body of the saved reply. */\n  body: Scalars['String'];\n  /** The saved reply body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The title of the saved reply. */\n  title: Scalars['String'];\n  /** The user that saved this reply. */\n  user?: Maybe<Actor>;\n};\n\n/** The connection type for SavedReply. */\nexport type SavedReplyConnection = {\n  __typename?: 'SavedReplyConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SavedReplyEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SavedReply>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SavedReplyEdge = {\n  __typename?: 'SavedReplyEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SavedReply>;\n};\n\n/** Ordering options for saved reply connections. */\nexport type SavedReplyOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order saved replies by. */\n  field: SavedReplyOrderField;\n};\n\n/** Properties by which saved reply connections can be ordered. */\nexport enum SavedReplyOrderField {\n  /** Order saved reply by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The results of a search. */\nexport type SearchResultItem = App | Discussion | Issue | MarketplaceListing | Organization | PullRequest | Repository | User;\n\n/**\n * A list of results that matched against a search query. Regardless of the number\n * of matches, a maximum of 1,000 results will be available across all types,\n * potentially split across many pages.\n */\nexport type SearchResultItemConnection = {\n  __typename?: 'SearchResultItemConnection';\n  /**\n   * The total number of pieces of code that matched the search query. Regardless\n   * of the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  codeCount: Scalars['Int'];\n  /**\n   * The total number of discussions that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  discussionCount: Scalars['Int'];\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SearchResultItemEdge>>>;\n  /**\n   * The total number of issues that matched the search query. Regardless of the\n   * total number of matches, a maximum of 1,000 results will be available across all types.\n   */\n  issueCount: Scalars['Int'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SearchResultItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /**\n   * The total number of repositories that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  repositoryCount: Scalars['Int'];\n  /**\n   * The total number of users that matched the search query. Regardless of the\n   * total number of matches, a maximum of 1,000 results will be available across all types.\n   */\n  userCount: Scalars['Int'];\n  /**\n   * The total number of wiki pages that matched the search query. Regardless of\n   * the total number of matches, a maximum of 1,000 results will be available\n   * across all types.\n   */\n  wikiCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SearchResultItemEdge = {\n  __typename?: 'SearchResultItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SearchResultItem>;\n  /** Text matches on the result found. */\n  textMatches?: Maybe<Array<Maybe<TextMatch>>>;\n};\n\n/** Represents the individual results of a search. */\nexport enum SearchType {\n  /** Returns matching discussions in repositories. */\n  Discussion = 'DISCUSSION',\n  /** Returns results matching issues in repositories. */\n  Issue = 'ISSUE',\n  /** Returns results matching repositories. */\n  Repository = 'REPOSITORY',\n  /** Returns results matching users and organizations on GitHub. */\n  User = 'USER'\n}\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisory = Node & {\n  __typename?: 'SecurityAdvisory';\n  /** The classification of the advisory */\n  classification: SecurityAdvisoryClassification;\n  /** The CVSS associated with this advisory */\n  cvss: Cvss;\n  /** CWEs associated with this Advisory */\n  cwes: CweConnection;\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** This is a long plaintext description of the advisory */\n  description: Scalars['String'];\n  /** The GitHub Security Advisory ID */\n  ghsaId: Scalars['String'];\n  id: Scalars['ID'];\n  /** A list of identifiers for this advisory */\n  identifiers: Array<SecurityAdvisoryIdentifier>;\n  /** The permalink for the advisory's dependabot alerts page */\n  notificationsPermalink?: Maybe<Scalars['URI']>;\n  /** The organization that originated the advisory */\n  origin: Scalars['String'];\n  /** The permalink for the advisory */\n  permalink?: Maybe<Scalars['URI']>;\n  /** When the advisory was published */\n  publishedAt: Scalars['DateTime'];\n  /** A list of references for this advisory */\n  references: Array<SecurityAdvisoryReference>;\n  /** The severity of the advisory */\n  severity: SecurityAdvisorySeverity;\n  /** A short plaintext summary of the advisory */\n  summary: Scalars['String'];\n  /** When the advisory was last updated */\n  updatedAt: Scalars['DateTime'];\n  /** Vulnerabilities associated with this Advisory */\n  vulnerabilities: SecurityVulnerabilityConnection;\n  /** When the advisory was withdrawn, if it has been withdrawn */\n  withdrawnAt?: Maybe<Scalars['DateTime']>;\n};\n\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryCwesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A GitHub Security Advisory */\nexport type SecurityAdvisoryVulnerabilitiesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  classifications?: InputMaybe<Array<SecurityAdvisoryClassification>>;\n  ecosystem?: InputMaybe<SecurityAdvisoryEcosystem>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SecurityVulnerabilityOrder>;\n  package?: InputMaybe<Scalars['String']>;\n  severities?: InputMaybe<Array<SecurityAdvisorySeverity>>;\n};\n\n/** Classification of the advisory. */\nexport enum SecurityAdvisoryClassification {\n  /** Classification of general advisories. */\n  General = 'GENERAL',\n  /** Classification of malware advisories. */\n  Malware = 'MALWARE'\n}\n\n/** The connection type for SecurityAdvisory. */\nexport type SecurityAdvisoryConnection = {\n  __typename?: 'SecurityAdvisoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityAdvisoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityAdvisory>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** The possible ecosystems of a security vulnerability's package. */\nexport enum SecurityAdvisoryEcosystem {\n  /** GitHub Actions */\n  Actions = 'ACTIONS',\n  /** PHP packages hosted at packagist.org */\n  Composer = 'COMPOSER',\n  /** Erlang/Elixir packages hosted at hex.pm */\n  Erlang = 'ERLANG',\n  /** Go modules */\n  Go = 'GO',\n  /** Java artifacts hosted at the Maven central repository */\n  Maven = 'MAVEN',\n  /** JavaScript packages hosted at npmjs.com */\n  Npm = 'NPM',\n  /** .NET packages hosted at the NuGet Gallery */\n  Nuget = 'NUGET',\n  /** Python packages hosted at PyPI.org */\n  Pip = 'PIP',\n  /** Dart packages hosted at pub.dev */\n  Pub = 'PUB',\n  /** Ruby gems hosted at RubyGems.org */\n  Rubygems = 'RUBYGEMS',\n  /** Rust crates */\n  Rust = 'RUST'\n}\n\n/** An edge in a connection. */\nexport type SecurityAdvisoryEdge = {\n  __typename?: 'SecurityAdvisoryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityAdvisory>;\n};\n\n/** A GitHub Security Advisory Identifier */\nexport type SecurityAdvisoryIdentifier = {\n  __typename?: 'SecurityAdvisoryIdentifier';\n  /** The identifier type, e.g. GHSA, CVE */\n  type: Scalars['String'];\n  /** The identifier */\n  value: Scalars['String'];\n};\n\n/** An advisory identifier to filter results on. */\nexport type SecurityAdvisoryIdentifierFilter = {\n  /** The identifier type. */\n  type: SecurityAdvisoryIdentifierType;\n  /** The identifier string. Supports exact or partial matching. */\n  value: Scalars['String'];\n};\n\n/** Identifier formats available for advisories. */\nexport enum SecurityAdvisoryIdentifierType {\n  /** Common Vulnerabilities and Exposures Identifier. */\n  Cve = 'CVE',\n  /** GitHub Security Advisory ID. */\n  Ghsa = 'GHSA'\n}\n\n/** Ordering options for security advisory connections */\nexport type SecurityAdvisoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security advisories by. */\n  field: SecurityAdvisoryOrderField;\n};\n\n/** Properties by which security advisory connections can be ordered. */\nexport enum SecurityAdvisoryOrderField {\n  /** Order advisories by publication time */\n  PublishedAt = 'PUBLISHED_AT',\n  /** Order advisories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** An individual package */\nexport type SecurityAdvisoryPackage = {\n  __typename?: 'SecurityAdvisoryPackage';\n  /** The ecosystem the package belongs to, e.g. RUBYGEMS, NPM */\n  ecosystem: SecurityAdvisoryEcosystem;\n  /** The package name */\n  name: Scalars['String'];\n};\n\n/** An individual package version */\nexport type SecurityAdvisoryPackageVersion = {\n  __typename?: 'SecurityAdvisoryPackageVersion';\n  /** The package name or version */\n  identifier: Scalars['String'];\n};\n\n/** A GitHub Security Advisory Reference */\nexport type SecurityAdvisoryReference = {\n  __typename?: 'SecurityAdvisoryReference';\n  /** A publicly accessible reference */\n  url: Scalars['URI'];\n};\n\n/** Severity of the vulnerability. */\nexport enum SecurityAdvisorySeverity {\n  /** Critical. */\n  Critical = 'CRITICAL',\n  /** High. */\n  High = 'HIGH',\n  /** Low. */\n  Low = 'LOW',\n  /** Moderate. */\n  Moderate = 'MODERATE'\n}\n\n/** An individual vulnerability within an Advisory */\nexport type SecurityVulnerability = {\n  __typename?: 'SecurityVulnerability';\n  /** The Advisory associated with this Vulnerability */\n  advisory: SecurityAdvisory;\n  /** The first version containing a fix for the vulnerability */\n  firstPatchedVersion?: Maybe<SecurityAdvisoryPackageVersion>;\n  /** A description of the vulnerable package */\n  package: SecurityAdvisoryPackage;\n  /** The severity of the vulnerability within this package */\n  severity: SecurityAdvisorySeverity;\n  /** When the vulnerability was last updated */\n  updatedAt: Scalars['DateTime'];\n  /**\n   * A string that describes the vulnerable package versions.\n   * This string follows a basic syntax with a few forms.\n   * + `= 0.2.0` denotes a single vulnerable version.\n   * + `<= 1.0.8` denotes a version range up to and including the specified version\n   * + `< 0.1.11` denotes a version range up to, but excluding, the specified version\n   * + `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.\n   * + `>= 0.0.1` denotes a version range with a known minimum, but no known maximum\n   */\n  vulnerableVersionRange: Scalars['String'];\n};\n\n/** The connection type for SecurityVulnerability. */\nexport type SecurityVulnerabilityConnection = {\n  __typename?: 'SecurityVulnerabilityConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SecurityVulnerabilityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SecurityVulnerability>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SecurityVulnerabilityEdge = {\n  __typename?: 'SecurityVulnerabilityEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SecurityVulnerability>;\n};\n\n/** Ordering options for security vulnerability connections */\nexport type SecurityVulnerabilityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order security vulnerabilities by. */\n  field: SecurityVulnerabilityOrderField;\n};\n\n/** Properties by which security vulnerability connections can be ordered. */\nexport enum SecurityVulnerabilityOrderField {\n  /** Order vulnerability by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** Autogenerated input type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The digest algorithm used to sign SAML requests for the identity provider. */\n  digestMethod: SamlDigestAlgorithm;\n  /** The ID of the enterprise on which to set an identity provider. */\n  enterpriseId: Scalars['ID'];\n  /** The x509 certificate used by the identity provider to sign assertions and responses. */\n  idpCertificate: Scalars['String'];\n  /** The Issuer Entity ID for the SAML identity provider */\n  issuer?: InputMaybe<Scalars['String']>;\n  /** The signature algorithm used to sign SAML requests for the identity provider. */\n  signatureMethod: SamlSignatureAlgorithm;\n  /** The URL endpoint for the identity provider's SAML SSO. */\n  ssoUrl: Scalars['URI'];\n};\n\n/** Autogenerated return type of SetEnterpriseIdentityProvider */\nexport type SetEnterpriseIdentityProviderPayload = {\n  __typename?: 'SetEnterpriseIdentityProviderPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The identity provider for the enterprise. */\n  identityProvider?: Maybe<EnterpriseIdentityProvider>;\n};\n\n/** Autogenerated input type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the organization to set a limit for. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of SetOrganizationInteractionLimit */\nexport type SetOrganizationInteractionLimitPayload = {\n  __typename?: 'SetOrganizationInteractionLimitPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organization that the interaction limit was set for. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the repository to set a limit for. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of SetRepositoryInteractionLimit */\nexport type SetRepositoryInteractionLimitPayload = {\n  __typename?: 'SetRepositoryInteractionLimitPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository that the interaction limit was set for. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** When this limit should expire. */\n  expiry?: InputMaybe<RepositoryInteractionLimitExpiry>;\n  /** The limit to set. */\n  limit: RepositoryInteractionLimit;\n  /** The ID of the user to set a limit for. */\n  userId: Scalars['ID'];\n};\n\n/** Autogenerated return type of SetUserInteractionLimit */\nexport type SetUserInteractionLimitPayload = {\n  __typename?: 'SetUserInteractionLimitPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The user that the interaction limit was set for. */\n  user?: Maybe<User>;\n};\n\n/** Represents an S/MIME signature on a Commit or Tag. */\nexport type SmimeSignature = GitSignature & {\n  __typename?: 'SmimeSignature';\n  /** Email used to sign this object. */\n  email: Scalars['String'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean'];\n};\n\n/** Social media profile associated with a user. */\nexport type SocialAccount = {\n  __typename?: 'SocialAccount';\n  /** Name of the social media account as it appears on the profile. */\n  displayName: Scalars['String'];\n  /** Software or company that hosts the social media account. */\n  provider: SocialAccountProvider;\n  /** URL of the social media account. */\n  url: Scalars['URI'];\n};\n\n/** The connection type for SocialAccount. */\nexport type SocialAccountConnection = {\n  __typename?: 'SocialAccountConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SocialAccountEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SocialAccount>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SocialAccountEdge = {\n  __typename?: 'SocialAccountEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SocialAccount>;\n};\n\n/** Software or company that hosts social media accounts. */\nexport enum SocialAccountProvider {\n  /** Social media and networking website. */\n  Facebook = 'FACEBOOK',\n  /** Catch-all for social media providers that do not yet have specific handling. */\n  Generic = 'GENERIC',\n  /** Fork of Mastodon with a greater focus on local posting. */\n  Hometown = 'HOMETOWN',\n  /** Social media website with a focus on photo and video sharing. */\n  Instagram = 'INSTAGRAM',\n  /** Professional networking website. */\n  Linkedin = 'LINKEDIN',\n  /** Open-source federated microblogging service. */\n  Mastodon = 'MASTODON',\n  /** Social news aggregation and discussion website. */\n  Reddit = 'REDDIT',\n  /** Live-streaming service. */\n  Twitch = 'TWITCH',\n  /** Microblogging website. */\n  Twitter = 'TWITTER',\n  /** Online video platform. */\n  Youtube = 'YOUTUBE'\n}\n\n/** Entities that can sponsor others via GitHub Sponsors */\nexport type Sponsor = Organization | User;\n\n/** The connection type for Sponsor. */\nexport type SponsorConnection = {\n  __typename?: 'SponsorConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsor>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user or organization who is sponsoring someone in GitHub Sponsors. */\nexport type SponsorEdge = {\n  __typename?: 'SponsorEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsor>;\n};\n\n/** Ordering options for connections to get sponsor entities for GitHub Sponsors. */\nexport type SponsorOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsor entities by. */\n  field: SponsorOrderField;\n};\n\n/** Properties by which sponsor connections can be ordered. */\nexport enum SponsorOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN',\n  /** Order sponsors by their relevance to the viewer. */\n  Relevance = 'RELEVANCE'\n}\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type Sponsorable = {\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int'];\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean'];\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean'];\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean'];\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableIsSponsoredByArgs = {\n  accountLogin: Scalars['String'];\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** Entities that can sponsor or be sponsored through GitHub Sponsors. */\nexport type SponsorableTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n/** Entities that can be sponsored via GitHub Sponsors */\nexport type SponsorableItem = Organization | User;\n\n/** The connection type for SponsorableItem. */\nexport type SponsorableItemConnection = {\n  __typename?: 'SponsorableItemConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorableItemEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorableItem>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SponsorableItemEdge = {\n  __typename?: 'SponsorableItemEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorableItem>;\n};\n\n/** Ordering options for connections to get sponsorable entities for GitHub Sponsors. */\nexport type SponsorableOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorable entities by. */\n  field: SponsorableOrderField;\n};\n\n/** Properties by which sponsorable connections can be ordered. */\nexport enum SponsorableOrderField {\n  /** Order sponsorable entities by login (username). */\n  Login = 'LOGIN'\n}\n\n/** An event related to sponsorship activity. */\nexport type SponsorsActivity = Node & {\n  __typename?: 'SponsorsActivity';\n  /** What action this activity indicates took place. */\n  action: SponsorsActivityAction;\n  id: Scalars['ID'];\n  /** The tier that the sponsorship used to use, for tier change events. */\n  previousSponsorsTier?: Maybe<SponsorsTier>;\n  /** The user or organization who triggered this activity and was/is sponsoring the sponsorable. */\n  sponsor?: Maybe<Sponsor>;\n  /** The user or organization that is being sponsored, the maintainer. */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier. */\n  sponsorsTier?: Maybe<SponsorsTier>;\n  /** The timestamp of this event. */\n  timestamp?: Maybe<Scalars['DateTime']>;\n  /** Was this sponsorship made alongside other sponsorships at the same time from the same sponsor? */\n  viaBulkSponsorship: Scalars['Boolean'];\n};\n\n/** The possible actions that GitHub Sponsors activities can represent. */\nexport enum SponsorsActivityAction {\n  /** The activity was cancelling a sponsorship. */\n  CancelledSponsorship = 'CANCELLED_SPONSORSHIP',\n  /** The activity was starting a sponsorship. */\n  NewSponsorship = 'NEW_SPONSORSHIP',\n  /** The activity was scheduling a downgrade or cancellation. */\n  PendingChange = 'PENDING_CHANGE',\n  /** The activity was funds being refunded to the sponsor or GitHub. */\n  Refund = 'REFUND',\n  /** The activity was disabling matching for a previously matched sponsorship. */\n  SponsorMatchDisabled = 'SPONSOR_MATCH_DISABLED',\n  /** The activity was changing the sponsorship tier, either directly by the sponsor or by a scheduled/pending change. */\n  TierChange = 'TIER_CHANGE'\n}\n\n/** The connection type for SponsorsActivity. */\nexport type SponsorsActivityConnection = {\n  __typename?: 'SponsorsActivityConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsActivityEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsActivity>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SponsorsActivityEdge = {\n  __typename?: 'SponsorsActivityEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsActivity>;\n};\n\n/** Ordering options for GitHub Sponsors activity connections. */\nexport type SponsorsActivityOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order activity by. */\n  field: SponsorsActivityOrderField;\n};\n\n/** Properties by which GitHub Sponsors activity connections can be ordered. */\nexport enum SponsorsActivityOrderField {\n  /** Order activities by when they happened. */\n  Timestamp = 'TIMESTAMP'\n}\n\n/** The possible time periods for which Sponsors activities can be requested. */\nexport enum SponsorsActivityPeriod {\n  /** Don't restrict the activity to any date range, include all activity. */\n  All = 'ALL',\n  /** The previous calendar day. */\n  Day = 'DAY',\n  /** The previous thirty days. */\n  Month = 'MONTH',\n  /** The previous seven days. */\n  Week = 'WEEK'\n}\n\n/** Represents countries or regions for billing and residence for a GitHub Sponsors profile. */\nexport enum SponsorsCountryOrRegionCode {\n  /** Andorra */\n  Ad = 'AD',\n  /** United Arab Emirates */\n  Ae = 'AE',\n  /** Afghanistan */\n  Af = 'AF',\n  /** Antigua and Barbuda */\n  Ag = 'AG',\n  /** Anguilla */\n  Ai = 'AI',\n  /** Albania */\n  Al = 'AL',\n  /** Armenia */\n  Am = 'AM',\n  /** Angola */\n  Ao = 'AO',\n  /** Antarctica */\n  Aq = 'AQ',\n  /** Argentina */\n  Ar = 'AR',\n  /** American Samoa */\n  As = 'AS',\n  /** Austria */\n  At = 'AT',\n  /** Australia */\n  Au = 'AU',\n  /** Aruba */\n  Aw = 'AW',\n  /** land */\n  Ax = 'AX',\n  /** Azerbaijan */\n  Az = 'AZ',\n  /** Bosnia and Herzegovina */\n  Ba = 'BA',\n  /** Barbados */\n  Bb = 'BB',\n  /** Bangladesh */\n  Bd = 'BD',\n  /** Belgium */\n  Be = 'BE',\n  /** Burkina Faso */\n  Bf = 'BF',\n  /** Bulgaria */\n  Bg = 'BG',\n  /** Bahrain */\n  Bh = 'BH',\n  /** Burundi */\n  Bi = 'BI',\n  /** Benin */\n  Bj = 'BJ',\n  /** Saint Barthlemy */\n  Bl = 'BL',\n  /** Bermuda */\n  Bm = 'BM',\n  /** Brunei Darussalam */\n  Bn = 'BN',\n  /** Bolivia */\n  Bo = 'BO',\n  /** Bonaire, Sint Eustatius and Saba */\n  Bq = 'BQ',\n  /** Brazil */\n  Br = 'BR',\n  /** Bahamas */\n  Bs = 'BS',\n  /** Bhutan */\n  Bt = 'BT',\n  /** Bouvet Island */\n  Bv = 'BV',\n  /** Botswana */\n  Bw = 'BW',\n  /** Belarus */\n  By = 'BY',\n  /** Belize */\n  Bz = 'BZ',\n  /** Canada */\n  Ca = 'CA',\n  /** Cocos (Keeling) Islands */\n  Cc = 'CC',\n  /** Congo (Kinshasa) */\n  Cd = 'CD',\n  /** Central African Republic */\n  Cf = 'CF',\n  /** Congo (Brazzaville) */\n  Cg = 'CG',\n  /** Switzerland */\n  Ch = 'CH',\n  /** Cte d'Ivoire */\n  Ci = 'CI',\n  /** Cook Islands */\n  Ck = 'CK',\n  /** Chile */\n  Cl = 'CL',\n  /** Cameroon */\n  Cm = 'CM',\n  /** China */\n  Cn = 'CN',\n  /** Colombia */\n  Co = 'CO',\n  /** Costa Rica */\n  Cr = 'CR',\n  /** Cape Verde */\n  Cv = 'CV',\n  /** Curaao */\n  Cw = 'CW',\n  /** Christmas Island */\n  Cx = 'CX',\n  /** Cyprus */\n  Cy = 'CY',\n  /** Czech Republic */\n  Cz = 'CZ',\n  /** Germany */\n  De = 'DE',\n  /** Djibouti */\n  Dj = 'DJ',\n  /** Denmark */\n  Dk = 'DK',\n  /** Dominica */\n  Dm = 'DM',\n  /** Dominican Republic */\n  Do = 'DO',\n  /** Algeria */\n  Dz = 'DZ',\n  /** Ecuador */\n  Ec = 'EC',\n  /** Estonia */\n  Ee = 'EE',\n  /** Egypt */\n  Eg = 'EG',\n  /** Western Sahara */\n  Eh = 'EH',\n  /** Eritrea */\n  Er = 'ER',\n  /** Spain */\n  Es = 'ES',\n  /** Ethiopia */\n  Et = 'ET',\n  /** Finland */\n  Fi = 'FI',\n  /** Fiji */\n  Fj = 'FJ',\n  /** Falkland Islands */\n  Fk = 'FK',\n  /** Micronesia */\n  Fm = 'FM',\n  /** Faroe Islands */\n  Fo = 'FO',\n  /** France */\n  Fr = 'FR',\n  /** Gabon */\n  Ga = 'GA',\n  /** United Kingdom */\n  Gb = 'GB',\n  /** Grenada */\n  Gd = 'GD',\n  /** Georgia */\n  Ge = 'GE',\n  /** French Guiana */\n  Gf = 'GF',\n  /** Guernsey */\n  Gg = 'GG',\n  /** Ghana */\n  Gh = 'GH',\n  /** Gibraltar */\n  Gi = 'GI',\n  /** Greenland */\n  Gl = 'GL',\n  /** Gambia */\n  Gm = 'GM',\n  /** Guinea */\n  Gn = 'GN',\n  /** Guadeloupe */\n  Gp = 'GP',\n  /** Equatorial Guinea */\n  Gq = 'GQ',\n  /** Greece */\n  Gr = 'GR',\n  /** South Georgia and South Sandwich Islands */\n  Gs = 'GS',\n  /** Guatemala */\n  Gt = 'GT',\n  /** Guam */\n  Gu = 'GU',\n  /** Guinea-Bissau */\n  Gw = 'GW',\n  /** Guyana */\n  Gy = 'GY',\n  /** Hong Kong */\n  Hk = 'HK',\n  /** Heard and McDonald Islands */\n  Hm = 'HM',\n  /** Honduras */\n  Hn = 'HN',\n  /** Croatia */\n  Hr = 'HR',\n  /** Haiti */\n  Ht = 'HT',\n  /** Hungary */\n  Hu = 'HU',\n  /** Indonesia */\n  Id = 'ID',\n  /** Ireland */\n  Ie = 'IE',\n  /** Israel */\n  Il = 'IL',\n  /** Isle of Man */\n  Im = 'IM',\n  /** India */\n  In = 'IN',\n  /** British Indian Ocean Territory */\n  Io = 'IO',\n  /** Iraq */\n  Iq = 'IQ',\n  /** Iran */\n  Ir = 'IR',\n  /** Iceland */\n  Is = 'IS',\n  /** Italy */\n  It = 'IT',\n  /** Jersey */\n  Je = 'JE',\n  /** Jamaica */\n  Jm = 'JM',\n  /** Jordan */\n  Jo = 'JO',\n  /** Japan */\n  Jp = 'JP',\n  /** Kenya */\n  Ke = 'KE',\n  /** Kyrgyzstan */\n  Kg = 'KG',\n  /** Cambodia */\n  Kh = 'KH',\n  /** Kiribati */\n  Ki = 'KI',\n  /** Comoros */\n  Km = 'KM',\n  /** Saint Kitts and Nevis */\n  Kn = 'KN',\n  /** Korea, South */\n  Kr = 'KR',\n  /** Kuwait */\n  Kw = 'KW',\n  /** Cayman Islands */\n  Ky = 'KY',\n  /** Kazakhstan */\n  Kz = 'KZ',\n  /** Laos */\n  La = 'LA',\n  /** Lebanon */\n  Lb = 'LB',\n  /** Saint Lucia */\n  Lc = 'LC',\n  /** Liechtenstein */\n  Li = 'LI',\n  /** Sri Lanka */\n  Lk = 'LK',\n  /** Liberia */\n  Lr = 'LR',\n  /** Lesotho */\n  Ls = 'LS',\n  /** Lithuania */\n  Lt = 'LT',\n  /** Luxembourg */\n  Lu = 'LU',\n  /** Latvia */\n  Lv = 'LV',\n  /** Libya */\n  Ly = 'LY',\n  /** Morocco */\n  Ma = 'MA',\n  /** Monaco */\n  Mc = 'MC',\n  /** Moldova */\n  Md = 'MD',\n  /** Montenegro */\n  Me = 'ME',\n  /** Saint Martin (French part) */\n  Mf = 'MF',\n  /** Madagascar */\n  Mg = 'MG',\n  /** Marshall Islands */\n  Mh = 'MH',\n  /** Macedonia */\n  Mk = 'MK',\n  /** Mali */\n  Ml = 'ML',\n  /** Myanmar */\n  Mm = 'MM',\n  /** Mongolia */\n  Mn = 'MN',\n  /** Macau */\n  Mo = 'MO',\n  /** Northern Mariana Islands */\n  Mp = 'MP',\n  /** Martinique */\n  Mq = 'MQ',\n  /** Mauritania */\n  Mr = 'MR',\n  /** Montserrat */\n  Ms = 'MS',\n  /** Malta */\n  Mt = 'MT',\n  /** Mauritius */\n  Mu = 'MU',\n  /** Maldives */\n  Mv = 'MV',\n  /** Malawi */\n  Mw = 'MW',\n  /** Mexico */\n  Mx = 'MX',\n  /** Malaysia */\n  My = 'MY',\n  /** Mozambique */\n  Mz = 'MZ',\n  /** Namibia */\n  Na = 'NA',\n  /** New Caledonia */\n  Nc = 'NC',\n  /** Niger */\n  Ne = 'NE',\n  /** Norfolk Island */\n  Nf = 'NF',\n  /** Nigeria */\n  Ng = 'NG',\n  /** Nicaragua */\n  Ni = 'NI',\n  /** Netherlands */\n  Nl = 'NL',\n  /** Norway */\n  No = 'NO',\n  /** Nepal */\n  Np = 'NP',\n  /** Nauru */\n  Nr = 'NR',\n  /** Niue */\n  Nu = 'NU',\n  /** New Zealand */\n  Nz = 'NZ',\n  /** Oman */\n  Om = 'OM',\n  /** Panama */\n  Pa = 'PA',\n  /** Peru */\n  Pe = 'PE',\n  /** French Polynesia */\n  Pf = 'PF',\n  /** Papua New Guinea */\n  Pg = 'PG',\n  /** Philippines */\n  Ph = 'PH',\n  /** Pakistan */\n  Pk = 'PK',\n  /** Poland */\n  Pl = 'PL',\n  /** Saint Pierre and Miquelon */\n  Pm = 'PM',\n  /** Pitcairn */\n  Pn = 'PN',\n  /** Puerto Rico */\n  Pr = 'PR',\n  /** Palestine */\n  Ps = 'PS',\n  /** Portugal */\n  Pt = 'PT',\n  /** Palau */\n  Pw = 'PW',\n  /** Paraguay */\n  Py = 'PY',\n  /** Qatar */\n  Qa = 'QA',\n  /** Reunion */\n  Re = 'RE',\n  /** Romania */\n  Ro = 'RO',\n  /** Serbia */\n  Rs = 'RS',\n  /** Russian Federation */\n  Ru = 'RU',\n  /** Rwanda */\n  Rw = 'RW',\n  /** Saudi Arabia */\n  Sa = 'SA',\n  /** Solomon Islands */\n  Sb = 'SB',\n  /** Seychelles */\n  Sc = 'SC',\n  /** Sudan */\n  Sd = 'SD',\n  /** Sweden */\n  Se = 'SE',\n  /** Singapore */\n  Sg = 'SG',\n  /** Saint Helena */\n  Sh = 'SH',\n  /** Slovenia */\n  Si = 'SI',\n  /** Svalbard and Jan Mayen Islands */\n  Sj = 'SJ',\n  /** Slovakia */\n  Sk = 'SK',\n  /** Sierra Leone */\n  Sl = 'SL',\n  /** San Marino */\n  Sm = 'SM',\n  /** Senegal */\n  Sn = 'SN',\n  /** Somalia */\n  So = 'SO',\n  /** Suriname */\n  Sr = 'SR',\n  /** South Sudan */\n  Ss = 'SS',\n  /** Sao Tome and Principe */\n  St = 'ST',\n  /** El Salvador */\n  Sv = 'SV',\n  /** Sint Maarten (Dutch part) */\n  Sx = 'SX',\n  /** Swaziland */\n  Sz = 'SZ',\n  /** Turks and Caicos Islands */\n  Tc = 'TC',\n  /** Chad */\n  Td = 'TD',\n  /** French Southern Lands */\n  Tf = 'TF',\n  /** Togo */\n  Tg = 'TG',\n  /** Thailand */\n  Th = 'TH',\n  /** Tajikistan */\n  Tj = 'TJ',\n  /** Tokelau */\n  Tk = 'TK',\n  /** Timor-Leste */\n  Tl = 'TL',\n  /** Turkmenistan */\n  Tm = 'TM',\n  /** Tunisia */\n  Tn = 'TN',\n  /** Tonga */\n  To = 'TO',\n  /** Turkey */\n  Tr = 'TR',\n  /** Trinidad and Tobago */\n  Tt = 'TT',\n  /** Tuvalu */\n  Tv = 'TV',\n  /** Taiwan */\n  Tw = 'TW',\n  /** Tanzania */\n  Tz = 'TZ',\n  /** Ukraine */\n  Ua = 'UA',\n  /** Uganda */\n  Ug = 'UG',\n  /** United States Minor Outlying Islands */\n  Um = 'UM',\n  /** United States of America */\n  Us = 'US',\n  /** Uruguay */\n  Uy = 'UY',\n  /** Uzbekistan */\n  Uz = 'UZ',\n  /** Vatican City */\n  Va = 'VA',\n  /** Saint Vincent and the Grenadines */\n  Vc = 'VC',\n  /** Venezuela */\n  Ve = 'VE',\n  /** Virgin Islands, British */\n  Vg = 'VG',\n  /** Virgin Islands, U.S. */\n  Vi = 'VI',\n  /** Vietnam */\n  Vn = 'VN',\n  /** Vanuatu */\n  Vu = 'VU',\n  /** Wallis and Futuna Islands */\n  Wf = 'WF',\n  /** Samoa */\n  Ws = 'WS',\n  /** Yemen */\n  Ye = 'YE',\n  /** Mayotte */\n  Yt = 'YT',\n  /** South Africa */\n  Za = 'ZA',\n  /** Zambia */\n  Zm = 'ZM',\n  /** Zimbabwe */\n  Zw = 'ZW'\n}\n\n/** A goal associated with a GitHub Sponsors listing, representing a target the sponsored maintainer would like to attain. */\nexport type SponsorsGoal = {\n  __typename?: 'SponsorsGoal';\n  /** A description of the goal from the maintainer. */\n  description?: Maybe<Scalars['String']>;\n  /** What the objective of this goal is. */\n  kind: SponsorsGoalKind;\n  /** The percentage representing how complete this goal is, between 0-100. */\n  percentComplete: Scalars['Int'];\n  /**\n   * What the goal amount is. Represents an amount in USD for monthly sponsorship\n   * amount goals. Represents a count of unique sponsors for total sponsors count goals.\n   */\n  targetValue: Scalars['Int'];\n  /** A brief summary of the kind and target value of this goal. */\n  title: Scalars['String'];\n};\n\n/** The different kinds of goals a GitHub Sponsors member can have. */\nexport enum SponsorsGoalKind {\n  /** The goal is about getting a certain amount in USD from sponsorships each month. */\n  MonthlySponsorshipAmount = 'MONTHLY_SPONSORSHIP_AMOUNT',\n  /** The goal is about reaching a certain number of sponsors. */\n  TotalSponsorsCount = 'TOTAL_SPONSORS_COUNT'\n}\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListing = Node & {\n  __typename?: 'SponsorsListing';\n  /** The current goal the maintainer is trying to reach with GitHub Sponsors, if any. */\n  activeGoal?: Maybe<SponsorsGoal>;\n  /**\n   * The Stripe Connect account currently in use for payouts for this Sponsors\n   * listing, if any. Will only return a value when queried by the maintainer\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  activeStripeConnectAccount?: Maybe<StripeConnectAccount>;\n  /**\n   * The name of the country or region with the maintainer's bank account or fiscal\n   * host. Will only return a value when queried by the maintainer themselves, or\n   * by an admin of the sponsorable organization.\n   */\n  billingCountryOrRegion?: Maybe<Scalars['String']>;\n  /**\n   * The email address used by GitHub to contact the sponsorable about their GitHub\n   * Sponsors profile. Will only return a value when queried by the maintainer\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  contactEmailAddress?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The HTTP path for the Sponsors dashboard for this Sponsors listing. */\n  dashboardResourcePath: Scalars['URI'];\n  /** The HTTP URL for the Sponsors dashboard for this Sponsors listing. */\n  dashboardUrl: Scalars['URI'];\n  /** The records featured on the GitHub Sponsors profile. */\n  featuredItems: Array<SponsorsListingFeaturedItem>;\n  /**\n   * The fiscal host used for payments, if any. Will only return a value when\n   * queried by the maintainer themselves, or by an admin of the sponsorable organization.\n   */\n  fiscalHost?: Maybe<Organization>;\n  /** The full description of the listing. */\n  fullDescription: Scalars['String'];\n  /** The full description of the listing rendered to HTML. */\n  fullDescriptionHTML: Scalars['HTML'];\n  id: Scalars['ID'];\n  /** Whether this listing is publicly visible. */\n  isPublic: Scalars['Boolean'];\n  /** The listing's full name. */\n  name: Scalars['String'];\n  /** A future date on which this listing is eligible to receive a payout. */\n  nextPayoutDate?: Maybe<Scalars['Date']>;\n  /**\n   * The name of the country or region where the maintainer resides. Will only\n   * return a value when queried by the maintainer themselves, or by an admin of\n   * the sponsorable organization.\n   */\n  residenceCountryOrRegion?: Maybe<Scalars['String']>;\n  /** The HTTP path for this Sponsors listing. */\n  resourcePath: Scalars['URI'];\n  /** The short description of the listing. */\n  shortDescription: Scalars['String'];\n  /** The short name of the listing. */\n  slug: Scalars['String'];\n  /** The entity this listing represents who can be sponsored on GitHub Sponsors. */\n  sponsorable: Sponsorable;\n  /** The tiers for this GitHub Sponsors profile. */\n  tiers?: Maybe<SponsorsTierConnection>;\n  /** The HTTP URL for this Sponsors listing. */\n  url: Scalars['URI'];\n};\n\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingFeaturedItemsArgs = {\n  featureableTypes?: InputMaybe<Array<SponsorsListingFeaturedItemFeatureableType>>;\n};\n\n\n/** A GitHub Sponsors listing. */\nexport type SponsorsListingTiersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeUnpublished?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorsTierOrder>;\n};\n\n/** A record that can be featured on a GitHub Sponsors profile. */\nexport type SponsorsListingFeatureableItem = Repository | User;\n\n/** A record that is promoted on a GitHub Sponsors profile. */\nexport type SponsorsListingFeaturedItem = Node & {\n  __typename?: 'SponsorsListingFeaturedItem';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /**\n   * Will either be a description from the sponsorable maintainer about why they\n   * featured this item, or the item's description itself, such as a user's bio\n   * from their GitHub profile page.\n   */\n  description?: Maybe<Scalars['String']>;\n  /** The record that is featured on the GitHub Sponsors profile. */\n  featureable: SponsorsListingFeatureableItem;\n  id: Scalars['ID'];\n  /**\n   * The position of this featured item on the GitHub Sponsors profile with a lower\n   * position indicating higher precedence. Starts at 1.\n   */\n  position: Scalars['Int'];\n  /** The GitHub Sponsors profile that features this record. */\n  sponsorsListing: SponsorsListing;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The different kinds of records that can be featured on a GitHub Sponsors profile page. */\nexport enum SponsorsListingFeaturedItemFeatureableType {\n  /** A repository owned by the user or organization with the GitHub Sponsors profile. */\n  Repository = 'REPOSITORY',\n  /** A user who belongs to the organization with the GitHub Sponsors profile. */\n  User = 'USER'\n}\n\n/** A GitHub Sponsors tier associated with a GitHub Sponsors listing. */\nexport type SponsorsTier = Node & {\n  __typename?: 'SponsorsTier';\n  /** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\n  adminInfo?: Maybe<SponsorsTierAdminInfo>;\n  /**\n   * Get a different tier for this tier's maintainer that is at the same frequency\n   * as this tier but with an equal or lesser cost. Returns the published tier with\n   * the monthly price closest to this tier's without going over.\n   */\n  closestLesserValueTier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The description of the tier. */\n  description: Scalars['String'];\n  /** The tier description rendered to HTML */\n  descriptionHTML: Scalars['HTML'];\n  id: Scalars['ID'];\n  /**\n   * Whether this tier was chosen at checkout time by the sponsor rather than\n   * defined ahead of time by the maintainer who manages the Sponsors listing.\n   */\n  isCustomAmount: Scalars['Boolean'];\n  /** Whether this tier is only for use with one-time sponsorships. */\n  isOneTime: Scalars['Boolean'];\n  /** How much this tier costs per month in cents. */\n  monthlyPriceInCents: Scalars['Int'];\n  /** How much this tier costs per month in USD. */\n  monthlyPriceInDollars: Scalars['Int'];\n  /** The name of the tier. */\n  name: Scalars['String'];\n  /** The sponsors listing that this tier belongs to. */\n  sponsorsListing: SponsorsListing;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfo = {\n  __typename?: 'SponsorsTierAdminInfo';\n  /**\n   * Indicates whether this tier is still a work in progress by the sponsorable and\n   * not yet published to the associated GitHub Sponsors profile. Draft tiers\n   * cannot be used for new sponsorships and will not be in use on existing\n   * sponsorships. Draft tiers cannot be seen by anyone but the admins of the\n   * GitHub Sponsors profile.\n   */\n  isDraft: Scalars['Boolean'];\n  /**\n   * Indicates whether this tier is published to the associated GitHub Sponsors\n   * profile. Published tiers are visible to anyone who can see the GitHub Sponsors\n   * profile, and are available for use in sponsorships if the GitHub Sponsors\n   * profile is publicly visible.\n   */\n  isPublished: Scalars['Boolean'];\n  /**\n   * Indicates whether this tier has been retired from the associated GitHub\n   * Sponsors profile. Retired tiers are no longer shown on the GitHub Sponsors\n   * profile and cannot be chosen for new sponsorships. Existing sponsorships may\n   * still use retired tiers if the sponsor selected the tier before it was retired.\n   */\n  isRetired: Scalars['Boolean'];\n  /** The sponsorships using this tier. */\n  sponsorships: SponsorshipConnection;\n};\n\n\n/** SponsorsTier information only visible to users that can administer the associated Sponsors listing. */\nexport type SponsorsTierAdminInfoSponsorshipsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n/** The connection type for SponsorsTier. */\nexport type SponsorsTierConnection = {\n  __typename?: 'SponsorsTierConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorsTierEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorsTier>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SponsorsTierEdge = {\n  __typename?: 'SponsorsTierEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorsTier>;\n};\n\n/** Ordering options for Sponsors tiers connections. */\nexport type SponsorsTierOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order tiers by. */\n  field: SponsorsTierOrderField;\n};\n\n/** Properties by which Sponsors tiers connections can be ordered. */\nexport enum SponsorsTierOrderField {\n  /** Order tiers by creation time. */\n  CreatedAt = 'CREATED_AT',\n  /** Order tiers by their monthly price in cents */\n  MonthlyPriceInCents = 'MONTHLY_PRICE_IN_CENTS'\n}\n\n/** A sponsorship relationship between a sponsor and a maintainer */\nexport type Sponsorship = Node & {\n  __typename?: 'Sponsorship';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /**\n   * Whether the sponsorship is active. False implies the sponsor is a past sponsor\n   * of the maintainer, while true implies they are a current sponsor.\n   */\n  isActive: Scalars['Boolean'];\n  /** Whether this sponsorship represents a one-time payment versus a recurring sponsorship. */\n  isOneTimePayment: Scalars['Boolean'];\n  /**\n   * Whether the sponsor has chosen to receive sponsorship update emails sent from\n   * the sponsorable. Only returns a non-null value when the viewer has permission to know this.\n   */\n  isSponsorOptedIntoEmail?: Maybe<Scalars['Boolean']>;\n  /**\n   * The entity that is being sponsored\n   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.\n   */\n  maintainer: User;\n  /** The privacy level for this sponsorship. */\n  privacyLevel: SponsorshipPrivacy;\n  /**\n   * The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.\n   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.\n   */\n  sponsor?: Maybe<User>;\n  /** The user or organization that is sponsoring, if you have permission to view them. */\n  sponsorEntity?: Maybe<Sponsor>;\n  /** The entity that is being sponsored */\n  sponsorable: Sponsorable;\n  /** The associated sponsorship tier */\n  tier?: Maybe<SponsorsTier>;\n  /** Identifies the date and time when the current tier was chosen for this sponsorship. */\n  tierSelectedAt?: Maybe<Scalars['DateTime']>;\n};\n\n/** The connection type for Sponsorship. */\nexport type SponsorshipConnection = {\n  __typename?: 'SponsorshipConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Sponsorship>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n  /**\n   * The total amount in cents of all recurring sponsorships in the connection\n   * whose amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInCents: Scalars['Int'];\n  /**\n   * The total amount in USD of all recurring sponsorships in the connection whose\n   * amount you can view. Does not include one-time sponsorships.\n   */\n  totalRecurringMonthlyPriceInDollars: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipEdge = {\n  __typename?: 'SponsorshipEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Sponsorship>;\n};\n\n/** An update sent to sponsors of a user or organization on GitHub Sponsors. */\nexport type SponsorshipNewsletter = Node & {\n  __typename?: 'SponsorshipNewsletter';\n  /** The author of the newsletter. */\n  author?: Maybe<User>;\n  /** The contents of the newsletter, the message the sponsorable wanted to give. */\n  body: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Indicates if the newsletter has been made available to sponsors. */\n  isPublished: Scalars['Boolean'];\n  /** The user or organization this newsletter is from. */\n  sponsorable: Sponsorable;\n  /** The subject of the newsletter, what it's about. */\n  subject: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** The connection type for SponsorshipNewsletter. */\nexport type SponsorshipNewsletterConnection = {\n  __typename?: 'SponsorshipNewsletterConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SponsorshipNewsletterEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<SponsorshipNewsletter>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SponsorshipNewsletterEdge = {\n  __typename?: 'SponsorshipNewsletterEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<SponsorshipNewsletter>;\n};\n\n/** Ordering options for sponsorship newsletter connections. */\nexport type SponsorshipNewsletterOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship newsletters by. */\n  field: SponsorshipNewsletterOrderField;\n};\n\n/** Properties by which sponsorship update connections can be ordered. */\nexport enum SponsorshipNewsletterOrderField {\n  /** Order sponsorship newsletters by when they were created. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** Ordering options for sponsorship connections. */\nexport type SponsorshipOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order sponsorship by. */\n  field: SponsorshipOrderField;\n};\n\n/** Properties by which sponsorship connections can be ordered. */\nexport enum SponsorshipOrderField {\n  /** Order sponsorship by creation time. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The privacy of a sponsorship */\nexport enum SponsorshipPrivacy {\n  /** Private */\n  Private = 'PRIVATE',\n  /** Public */\n  Public = 'PUBLIC'\n}\n\n/** The possible default commit messages for squash merges. */\nexport enum SquashMergeCommitMessage {\n  /** Default to a blank commit message. */\n  Blank = 'BLANK',\n  /** Default to the branch's commit messages. */\n  CommitMessages = 'COMMIT_MESSAGES',\n  /** Default to the pull request's body. */\n  PrBody = 'PR_BODY'\n}\n\n/** The possible default commit titles for squash merges. */\nexport enum SquashMergeCommitTitle {\n  /** Default to the commit's title (if only one commit) or the pull request's title (when more than one commit). */\n  CommitOrPrTitle = 'COMMIT_OR_PR_TITLE',\n  /** Default to the pull request's title. */\n  PrTitle = 'PR_TITLE'\n}\n\n/** Represents an SSH signature on a Commit or Tag. */\nexport type SshSignature = GitSignature & {\n  __typename?: 'SshSignature';\n  /** Email used to sign this object. */\n  email: Scalars['String'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean'];\n  /** Hex-encoded fingerprint of the key that signed this object. */\n  keyFingerprint?: Maybe<Scalars['String']>;\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean'];\n};\n\n/** Ways in which star connections can be ordered. */\nexport type StarOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: StarOrderField;\n};\n\n/** Properties by which star connections can be ordered. */\nexport enum StarOrderField {\n  /** Allows ordering a list of stars by when they were created. */\n  StarredAt = 'STARRED_AT'\n}\n\n/** The connection type for User. */\nexport type StargazerConnection = {\n  __typename?: 'StargazerConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StargazerEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user that's starred a repository. */\nexport type StargazerEdge = {\n  __typename?: 'StargazerEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  node: User;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime'];\n};\n\n/** Things that can be starred. */\nexport type Starrable = {\n  id: Scalars['ID'];\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean'];\n};\n\n\n/** Things that can be starred. */\nexport type StarrableStargazersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** The connection type for Repository. */\nexport type StarredRepositoryConnection = {\n  __typename?: 'StarredRepositoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StarredRepositoryEdge>>>;\n  /** Is the list of stars for this user truncated? This is true for users that have many stars. */\n  isOverLimit: Scalars['Boolean'];\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a starred repository. */\nexport type StarredRepositoryEdge = {\n  __typename?: 'StarredRepositoryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  node: Repository;\n  /** Identifies when the item was starred. */\n  starredAt: Scalars['DateTime'];\n};\n\n/** Autogenerated input type of StartOrganizationMigration */\nexport type StartOrganizationMigrationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The migration source access token. */\n  sourceAccessToken: Scalars['String'];\n  /** The URL of the organization to migrate. */\n  sourceOrgUrl: Scalars['URI'];\n  /** The ID of the enterprise the target organization belongs to. */\n  targetEnterpriseId: Scalars['ID'];\n  /** The name of the target organization. */\n  targetOrgName: Scalars['String'];\n};\n\n/** Autogenerated return type of StartOrganizationMigration */\nexport type StartOrganizationMigrationPayload = {\n  __typename?: 'StartOrganizationMigrationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new organization migration. */\n  orgMigration?: Maybe<OrganizationMigration>;\n};\n\n/** Autogenerated input type of StartRepositoryMigration */\nexport type StartRepositoryMigrationInput = {\n  /** The migration source access token. */\n  accessToken?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether to continue the migration on error. Defaults to `false`. */\n  continueOnError?: InputMaybe<Scalars['Boolean']>;\n  /** The signed URL to access the user-uploaded git archive. */\n  gitArchiveUrl?: InputMaybe<Scalars['String']>;\n  /** The GitHub personal access token of the user importing to the target repository. */\n  githubPat?: InputMaybe<Scalars['String']>;\n  /** Whether to lock the source repository. */\n  lockSource?: InputMaybe<Scalars['Boolean']>;\n  /** The signed URL to access the user-uploaded metadata archive. */\n  metadataArchiveUrl?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization that will own the imported repository. */\n  ownerId: Scalars['ID'];\n  /** The name of the imported repository. */\n  repositoryName: Scalars['String'];\n  /** Whether to skip migrating releases for the repository. */\n  skipReleases?: InputMaybe<Scalars['Boolean']>;\n  /** The ID of the migration source. */\n  sourceId: Scalars['ID'];\n  /** The URL of the source repository. */\n  sourceRepositoryUrl?: InputMaybe<Scalars['URI']>;\n  /** The visibility of the imported repository. */\n  targetRepoVisibility?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of StartRepositoryMigration */\nexport type StartRepositoryMigrationPayload = {\n  __typename?: 'StartRepositoryMigrationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The new repository migration. */\n  repositoryMigration?: Maybe<RepositoryMigration>;\n};\n\n/** Represents a commit status. */\nexport type Status = Node & {\n  __typename?: 'Status';\n  /** A list of status contexts and check runs for this commit. */\n  combinedContexts: StatusCheckRollupContextConnection;\n  /** The commit this status is attached to. */\n  commit?: Maybe<Commit>;\n  /** Looks up an individual status context by context name. */\n  context?: Maybe<StatusContext>;\n  /** The individual status contexts for this commit. */\n  contexts: Array<StatusContext>;\n  id: Scalars['ID'];\n  /** The combined commit status. */\n  state: StatusState;\n};\n\n\n/** Represents a commit status. */\nexport type StatusCombinedContextsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents a commit status. */\nexport type StatusContextArgs = {\n  name: Scalars['String'];\n};\n\n/** Required status check */\nexport type StatusCheckConfiguration = {\n  __typename?: 'StatusCheckConfiguration';\n  /** The status check context name that must be present on the commit. */\n  context: Scalars['String'];\n  /** The optional integration ID that this status check must originate from. */\n  integrationId?: Maybe<Scalars['Int']>;\n};\n\n/** Required status check */\nexport type StatusCheckConfigurationInput = {\n  /** The status check context name that must be present on the commit. */\n  context: Scalars['String'];\n  /** The optional integration ID that this status check must originate from. */\n  integrationId?: InputMaybe<Scalars['Int']>;\n};\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollup = Node & {\n  __typename?: 'StatusCheckRollup';\n  /** The commit the status and check runs are attached to. */\n  commit?: Maybe<Commit>;\n  /** A list of status contexts and check runs for this commit. */\n  contexts: StatusCheckRollupContextConnection;\n  id: Scalars['ID'];\n  /** The combined status for the commit. */\n  state: StatusState;\n};\n\n\n/** Represents the rollup for both the check runs and status for a commit. */\nexport type StatusCheckRollupContextsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Types that can be inside a StatusCheckRollup context. */\nexport type StatusCheckRollupContext = CheckRun | StatusContext;\n\n/** The connection type for StatusCheckRollupContext. */\nexport type StatusCheckRollupContextConnection = {\n  __typename?: 'StatusCheckRollupContextConnection';\n  /** The number of check runs in this rollup. */\n  checkRunCount: Scalars['Int'];\n  /** Counts of check runs by state. */\n  checkRunCountsByState?: Maybe<Array<CheckRunStateCount>>;\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<StatusCheckRollupContextEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<StatusCheckRollupContext>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** The number of status contexts in this rollup. */\n  statusContextCount: Scalars['Int'];\n  /** Counts of status contexts by state. */\n  statusContextCountsByState?: Maybe<Array<StatusContextStateCount>>;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type StatusCheckRollupContextEdge = {\n  __typename?: 'StatusCheckRollupContextEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<StatusCheckRollupContext>;\n};\n\n/** Represents an individual commit status context */\nexport type StatusContext = Node & RequirableByPullRequest & {\n  __typename?: 'StatusContext';\n  /** The avatar of the OAuth application or the user that created the status */\n  avatarUrl?: Maybe<Scalars['URI']>;\n  /** This commit this status context is attached to. */\n  commit?: Maybe<Commit>;\n  /** The name of this status context. */\n  context: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The actor who created this status context. */\n  creator?: Maybe<Actor>;\n  /** The description for this status context. */\n  description?: Maybe<Scalars['String']>;\n  id: Scalars['ID'];\n  /** Whether this is required to pass before merging for a specific pull request. */\n  isRequired: Scalars['Boolean'];\n  /** The state of this status context. */\n  state: StatusState;\n  /** The URL for this status context. */\n  targetUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/** Represents an individual commit status context */\nexport type StatusContextAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** Represents an individual commit status context */\nexport type StatusContextIsRequiredArgs = {\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  pullRequestNumber?: InputMaybe<Scalars['Int']>;\n};\n\n/** Represents a count of the state of a status context. */\nexport type StatusContextStateCount = {\n  __typename?: 'StatusContextStateCount';\n  /** The number of statuses with this state. */\n  count: Scalars['Int'];\n  /** The state of a status context. */\n  state: StatusState;\n};\n\n/** The possible commit status states. */\nexport enum StatusState {\n  /** Status is errored. */\n  Error = 'ERROR',\n  /** Status is expected. */\n  Expected = 'EXPECTED',\n  /** Status is failing. */\n  Failure = 'FAILURE',\n  /** Status is pending. */\n  Pending = 'PENDING',\n  /** Status is successful. */\n  Success = 'SUCCESS'\n}\n\n/** A Stripe Connect account for receiving sponsorship funds from GitHub Sponsors. */\nexport type StripeConnectAccount = {\n  __typename?: 'StripeConnectAccount';\n  /** The account number used to identify this Stripe Connect account. */\n  accountId: Scalars['String'];\n  /**\n   * The name of the country or region of an external account, such as a bank\n   * account, tied to the Stripe Connect account. Will only return a value when\n   * queried by the maintainer of the associated GitHub Sponsors profile\n   * themselves, or by an admin of the sponsorable organization.\n   */\n  billingCountryOrRegion?: Maybe<Scalars['String']>;\n  /**\n   * The name of the country or region of the Stripe Connect account. Will only\n   * return a value when queried by the maintainer of the associated GitHub\n   * Sponsors profile themselves, or by an admin of the sponsorable organization.\n   */\n  countryOrRegion?: Maybe<Scalars['String']>;\n  /** Whether this Stripe Connect account is currently in use for the associated GitHub Sponsors profile. */\n  isActive: Scalars['Boolean'];\n  /** The GitHub Sponsors profile associated with this Stripe Connect account. */\n  sponsorsListing: SponsorsListing;\n  /** The URL to access this Stripe Connect account on Stripe's website. */\n  stripeDashboardUrl: Scalars['URI'];\n};\n\n/** Autogenerated input type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewInput = {\n  /** The text field to set on the Pull Request Review. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The event to send to the Pull Request Review. */\n  event: PullRequestReviewEvent;\n  /** The Pull Request ID to submit any pending reviews. */\n  pullRequestId?: InputMaybe<Scalars['ID']>;\n  /** The Pull Request Review ID to submit. */\n  pullRequestReviewId?: InputMaybe<Scalars['ID']>;\n};\n\n/** Autogenerated return type of SubmitPullRequestReview */\nexport type SubmitPullRequestReviewPayload = {\n  __typename?: 'SubmitPullRequestReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The submitted pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** A pointer to a repository at a specific revision embedded inside another repository. */\nexport type Submodule = {\n  __typename?: 'Submodule';\n  /** The branch of the upstream submodule for tracking updates */\n  branch?: Maybe<Scalars['String']>;\n  /** The git URL of the submodule repository */\n  gitUrl: Scalars['URI'];\n  /** The name of the submodule in .gitmodules */\n  name: Scalars['String'];\n  /** The name of the submodule in .gitmodules (Base64-encoded) */\n  nameRaw: Scalars['Base64String'];\n  /** The path in the superproject that this submodule is located in */\n  path: Scalars['String'];\n  /** The path in the superproject that this submodule is located in (Base64-encoded) */\n  pathRaw: Scalars['Base64String'];\n  /** The commit revision of the subproject repository being tracked by the submodule */\n  subprojectCommitOid?: Maybe<Scalars['GitObjectID']>;\n};\n\n/** The connection type for Submodule. */\nexport type SubmoduleConnection = {\n  __typename?: 'SubmoduleConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<SubmoduleEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Submodule>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type SubmoduleEdge = {\n  __typename?: 'SubmoduleEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Submodule>;\n};\n\n/** Entities that can be subscribed to for web and email notifications. */\nexport type Subscribable = {\n  id: Scalars['ID'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n/** Represents a 'subscribed' event on a given `Subscribable`. */\nexport type SubscribedEvent = Node & {\n  __typename?: 'SubscribedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** The possible states of a subscription. */\nexport enum SubscriptionState {\n  /** The User is never notified. */\n  Ignored = 'IGNORED',\n  /** The User is notified of all conversations. */\n  Subscribed = 'SUBSCRIBED',\n  /** The User is only notified when participating or @mentioned. */\n  Unsubscribed = 'UNSUBSCRIBED'\n}\n\n/** A suggestion to review a pull request based on a user's commit history and review comments. */\nexport type SuggestedReviewer = {\n  __typename?: 'SuggestedReviewer';\n  /** Is this suggestion based on past commits? */\n  isAuthor: Scalars['Boolean'];\n  /** Is this suggestion based on past review comments? */\n  isCommenter: Scalars['Boolean'];\n  /** Identifies the user suggested to review the pull request. */\n  reviewer: User;\n};\n\n/** Represents a Git tag. */\nexport type Tag = GitObject & Node & {\n  __typename?: 'Tag';\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** The Git tag message. */\n  message?: Maybe<Scalars['String']>;\n  /** The Git tag name. */\n  name: Scalars['String'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n  /** Details about the tag author. */\n  tagger?: Maybe<GitActor>;\n  /** The Git object the tag points to. */\n  target: GitObject;\n};\n\n/** Parameters to be used for the tag_name_pattern rule */\nexport type TagNamePatternParameters = {\n  __typename?: 'TagNamePatternParameters';\n  /** How this rule will appear to users. */\n  name?: Maybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate: Scalars['Boolean'];\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** Parameters to be used for the tag_name_pattern rule */\nexport type TagNamePatternParametersInput = {\n  /** How this rule will appear to users. */\n  name?: InputMaybe<Scalars['String']>;\n  /** If true, the rule will fail if the pattern matches. */\n  negate?: InputMaybe<Scalars['Boolean']>;\n  /** The operator to use for matching. */\n  operator: Scalars['String'];\n  /** The pattern to match with. */\n  pattern: Scalars['String'];\n};\n\n/** A team of users in an organization. */\nexport type Team = MemberStatusable & Node & Subscribable & {\n  __typename?: 'Team';\n  /** A list of teams that are ancestors of this team. */\n  ancestors: TeamConnection;\n  /** A URL pointing to the team's avatar. */\n  avatarUrl?: Maybe<Scalars['URI']>;\n  /** List of child teams belonging to this team */\n  childTeams: TeamConnection;\n  /** The slug corresponding to the organization and team. */\n  combinedSlug: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The description of the team. */\n  description?: Maybe<Scalars['String']>;\n  /** Find a team discussion by its number. */\n  discussion?: Maybe<TeamDiscussion>;\n  /** A list of team discussions. */\n  discussions: TeamDiscussionConnection;\n  /** The HTTP path for team discussions */\n  discussionsResourcePath: Scalars['URI'];\n  /** The HTTP URL for team discussions */\n  discussionsUrl: Scalars['URI'];\n  /** The HTTP path for editing this team */\n  editTeamResourcePath: Scalars['URI'];\n  /** The HTTP URL for editing this team */\n  editTeamUrl: Scalars['URI'];\n  id: Scalars['ID'];\n  /** A list of pending invitations for users to this team */\n  invitations?: Maybe<OrganizationInvitationConnection>;\n  /** Get the status messages members of this entity have set that are either public or visible only to the organization. */\n  memberStatuses: UserStatusConnection;\n  /** A list of users who are members of this team. */\n  members: TeamMemberConnection;\n  /** The HTTP path for the team' members */\n  membersResourcePath: Scalars['URI'];\n  /** The HTTP URL for the team' members */\n  membersUrl: Scalars['URI'];\n  /** The name of the team. */\n  name: Scalars['String'];\n  /** The HTTP path creating a new team */\n  newTeamResourcePath: Scalars['URI'];\n  /** The HTTP URL creating a new team */\n  newTeamUrl: Scalars['URI'];\n  /** The notification setting that the team has set. */\n  notificationSetting: TeamNotificationSetting;\n  /** The organization that owns this team. */\n  organization: Organization;\n  /** The parent team of the team. */\n  parentTeam?: Maybe<Team>;\n  /** The level of privacy the team has. */\n  privacy: TeamPrivacy;\n  /** Finds and returns the project according to the provided project number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** List of projects this team has collaborator access to. */\n  projectsV2: ProjectV2Connection;\n  /** A list of repositories this team has access to. */\n  repositories: TeamRepositoryConnection;\n  /** The HTTP path for this team's repositories */\n  repositoriesResourcePath: Scalars['URI'];\n  /** The HTTP URL for this team's repositories */\n  repositoriesUrl: Scalars['URI'];\n  /** The HTTP path for this team */\n  resourcePath: Scalars['URI'];\n  /** What algorithm is used for review assignment for this team */\n  reviewRequestDelegationAlgorithm?: Maybe<TeamReviewAssignmentAlgorithm>;\n  /** True if review assignment is enabled for this team */\n  reviewRequestDelegationEnabled: Scalars['Boolean'];\n  /** How many team members are required for review assignment for this team */\n  reviewRequestDelegationMemberCount?: Maybe<Scalars['Int']>;\n  /** When assigning team members via delegation, whether the entire team should be notified as well. */\n  reviewRequestDelegationNotifyTeam: Scalars['Boolean'];\n  /** The slug corresponding to the team. */\n  slug: Scalars['String'];\n  /** The HTTP path for this team's teams */\n  teamsResourcePath: Scalars['URI'];\n  /** The HTTP URL for this team's teams */\n  teamsUrl: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this team */\n  url: Scalars['URI'];\n  /** Team is adminable by the viewer. */\n  viewerCanAdminister: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamAncestorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamChildTeamsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  immediateOnly?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TeamOrder>;\n  userLogins?: InputMaybe<Array<Scalars['String']>>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamDiscussionArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A team of users in an organization. */\nexport type TeamDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isPinned?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TeamDiscussionOrder>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamInvitationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamMemberStatusesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<UserStatusOrder>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamMembersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  membership?: InputMaybe<TeamMembershipType>;\n  orderBy?: InputMaybe<TeamMemberOrder>;\n  query?: InputMaybe<Scalars['String']>;\n  role?: InputMaybe<TeamMemberRole>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** A team of users in an organization. */\nexport type TeamProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<ProjectV2Filters>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A team of users in an organization. */\nexport type TeamRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TeamRepositoryOrder>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n/** Audit log entry for a team.add_member event. */\nexport type TeamAddMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  __typename?: 'TeamAddMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a team.add_repository event. */\nexport type TeamAddRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {\n  __typename?: 'TeamAddRepositoryAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Metadata for an audit entry with action team.* */\nexport type TeamAuditEntryData = {\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a team.change_parent_team event. */\nexport type TeamChangeParentTeamAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  __typename?: 'TeamChangeParentTeamAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The new parent team. */\n  parentTeam?: Maybe<Team>;\n  /** The name of the new parent team */\n  parentTeamName?: Maybe<Scalars['String']>;\n  /** The name of the former parent team */\n  parentTeamNameWas?: Maybe<Scalars['String']>;\n  /** The HTTP path for the parent team */\n  parentTeamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the parent team */\n  parentTeamUrl?: Maybe<Scalars['URI']>;\n  /** The former parent team. */\n  parentTeamWas?: Maybe<Team>;\n  /** The HTTP path for the previous parent team */\n  parentTeamWasResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the previous parent team */\n  parentTeamWasUrl?: Maybe<Scalars['URI']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The connection type for Team. */\nexport type TeamConnection = {\n  __typename?: 'TeamConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Team>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** A team discussion. */\nexport type TeamDiscussion = Comment & Deletable & Node & Reactable & Subscribable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  __typename?: 'TeamDiscussion';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the discussion's team. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** Identifies the discussion body hash. */\n  bodyVersion: Scalars['String'];\n  /** A list of comments on this discussion. */\n  comments: TeamDiscussionCommentConnection;\n  /** The HTTP path for discussion comments */\n  commentsResourcePath: Scalars['URI'];\n  /** The HTTP URL for discussion comments */\n  commentsUrl: Scalars['URI'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** Whether or not the discussion is pinned. */\n  isPinned: Scalars['Boolean'];\n  /** Whether or not the discussion is only visible to team members and org admins. */\n  isPrivate: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the discussion within its team. */\n  number: Scalars['Int'];\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The HTTP path for this discussion */\n  resourcePath: Scalars['URI'];\n  /** The team that defines the context of this discussion. */\n  team: Team;\n  /** The title of the discussion */\n  title: Scalars['String'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this discussion */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Whether or not the current viewer can pin this discussion. */\n  viewerCanPin: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the viewer is able to change their subscription status for the repository. */\n  viewerCanSubscribe: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n  /** Identifies if the viewer is watching, not watching, or ignoring the subscribable entity. */\n  viewerSubscription?: Maybe<SubscriptionState>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  fromComment?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<TeamDiscussionCommentOrder>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A team discussion. */\nexport type TeamDiscussionUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionComment = Comment & Deletable & Node & Reactable & UniformResourceLocatable & Updatable & UpdatableComment & {\n  __typename?: 'TeamDiscussionComment';\n  /** The actor who authored the comment. */\n  author?: Maybe<Actor>;\n  /** Author's association with the comment's team. */\n  authorAssociation: CommentAuthorAssociation;\n  /** The body as Markdown. */\n  body: Scalars['String'];\n  /** The body rendered to HTML. */\n  bodyHTML: Scalars['HTML'];\n  /** The body rendered to text. */\n  bodyText: Scalars['String'];\n  /** The current version of the body content. */\n  bodyVersion: Scalars['String'];\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Check if this comment was created via an email reply. */\n  createdViaEmail: Scalars['Boolean'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The discussion this comment is about. */\n  discussion: TeamDiscussion;\n  /** The actor who edited the comment. */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Check if this comment was edited and includes an edit with the creation data */\n  includesCreatedEdit: Scalars['Boolean'];\n  /** The moment the editor made the last edit */\n  lastEditedAt?: Maybe<Scalars['DateTime']>;\n  /** Identifies the comment number. */\n  number: Scalars['Int'];\n  /** Identifies when the comment was published at. */\n  publishedAt?: Maybe<Scalars['DateTime']>;\n  /** A list of reactions grouped by content left on the subject. */\n  reactionGroups?: Maybe<Array<ReactionGroup>>;\n  /** A list of Reactions left on the Issue. */\n  reactions: ReactionConnection;\n  /** The HTTP path for this comment */\n  resourcePath: Scalars['URI'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this comment */\n  url: Scalars['URI'];\n  /** A list of edits to this content. */\n  userContentEdits?: Maybe<UserContentEditConnection>;\n  /** Check if the current viewer can delete this object. */\n  viewerCanDelete: Scalars['Boolean'];\n  /** Can user react to this subject */\n  viewerCanReact: Scalars['Boolean'];\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n  /** Did the viewer author this comment. */\n  viewerDidAuthor: Scalars['Boolean'];\n};\n\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentReactionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  content?: InputMaybe<ReactionContent>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ReactionOrder>;\n};\n\n\n/** A comment on a team discussion. */\nexport type TeamDiscussionCommentUserContentEditsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for TeamDiscussionComment. */\nexport type TeamDiscussionCommentConnection = {\n  __typename?: 'TeamDiscussionCommentConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionCommentEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussionComment>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionCommentEdge = {\n  __typename?: 'TeamDiscussionCommentEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussionComment>;\n};\n\n/** Ways in which team discussion comment connections can be ordered. */\nexport type TeamDiscussionCommentOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionCommentOrderField;\n};\n\n/** Properties by which team discussion comment connections can be ordered. */\nexport enum TeamDiscussionCommentOrderField {\n  /** Allows sequential ordering of team discussion comments (which is equivalent to chronological ordering). */\n  Number = 'NUMBER'\n}\n\n/** The connection type for TeamDiscussion. */\nexport type TeamDiscussionConnection = {\n  __typename?: 'TeamDiscussionConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamDiscussionEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<TeamDiscussion>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type TeamDiscussionEdge = {\n  __typename?: 'TeamDiscussionEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<TeamDiscussion>;\n};\n\n/** Ways in which team discussion connections can be ordered. */\nexport type TeamDiscussionOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field by which to order nodes. */\n  field: TeamDiscussionOrderField;\n};\n\n/** Properties by which team discussion connections can be ordered. */\nexport enum TeamDiscussionOrderField {\n  /** Allows chronological ordering of team discussions. */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** An edge in a connection. */\nexport type TeamEdge = {\n  __typename?: 'TeamEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<Team>;\n};\n\n/** The connection type for User. */\nexport type TeamMemberConnection = {\n  __typename?: 'TeamMemberConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamMemberEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a user who is a member of a team. */\nexport type TeamMemberEdge = {\n  __typename?: 'TeamMemberEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The HTTP path to the organization's member access page. */\n  memberAccessResourcePath: Scalars['URI'];\n  /** The HTTP URL to the organization's member access page. */\n  memberAccessUrl: Scalars['URI'];\n  node: User;\n  /** The role the member has on the team. */\n  role: TeamMemberRole;\n};\n\n/** Ordering options for team member connections */\nexport type TeamMemberOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order team members by. */\n  field: TeamMemberOrderField;\n};\n\n/** Properties by which team member connections can be ordered. */\nexport enum TeamMemberOrderField {\n  /** Order team members by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order team members by login */\n  Login = 'LOGIN'\n}\n\n/** The possible team member roles; either 'maintainer' or 'member'. */\nexport enum TeamMemberRole {\n  /** A team maintainer has permission to add and remove team members. */\n  Maintainer = 'MAINTAINER',\n  /** A team member has no administrative permissions on the team. */\n  Member = 'MEMBER'\n}\n\n/** Defines which types of team members are included in the returned list. Can be one of IMMEDIATE, CHILD_TEAM or ALL. */\nexport enum TeamMembershipType {\n  /** Includes immediate and child team members for the team. */\n  All = 'ALL',\n  /** Includes only child team members for the team. */\n  ChildTeam = 'CHILD_TEAM',\n  /** Includes only immediate members of the team. */\n  Immediate = 'IMMEDIATE'\n}\n\n/** The possible team notification values. */\nexport enum TeamNotificationSetting {\n  /** No one will receive notifications. */\n  NotificationsDisabled = 'NOTIFICATIONS_DISABLED',\n  /** Everyone will receive notifications when the team is @mentioned. */\n  NotificationsEnabled = 'NOTIFICATIONS_ENABLED'\n}\n\n/** Ways in which team connections can be ordered. */\nexport type TeamOrder = {\n  /** The direction in which to order nodes. */\n  direction: OrderDirection;\n  /** The field in which to order nodes by. */\n  field: TeamOrderField;\n};\n\n/** Properties by which team connections can be ordered. */\nexport enum TeamOrderField {\n  /** Allows ordering a list of teams by name. */\n  Name = 'NAME'\n}\n\n/** The possible team privacy values. */\nexport enum TeamPrivacy {\n  /** A secret team can only be seen by its members. */\n  Secret = 'SECRET',\n  /** A visible team can be seen and @mentioned by every member of the organization. */\n  Visible = 'VISIBLE'\n}\n\n/** Audit log entry for a team.remove_member event. */\nexport type TeamRemoveMemberAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & TeamAuditEntryData & {\n  __typename?: 'TeamRemoveMemberAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** Audit log entry for a team.remove_repository event. */\nexport type TeamRemoveRepositoryAuditEntry = AuditEntry & Node & OrganizationAuditEntryData & RepositoryAuditEntryData & TeamAuditEntryData & {\n  __typename?: 'TeamRemoveRepositoryAuditEntry';\n  /** The action name */\n  action: Scalars['String'];\n  /** The user who initiated the action */\n  actor?: Maybe<AuditEntryActor>;\n  /** The IP address of the actor */\n  actorIp?: Maybe<Scalars['String']>;\n  /** A readable representation of the actor's location */\n  actorLocation?: Maybe<ActorLocation>;\n  /** The username of the user who initiated the action */\n  actorLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the actor. */\n  actorResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the actor. */\n  actorUrl?: Maybe<Scalars['URI']>;\n  /** The time the action was initiated */\n  createdAt: Scalars['PreciseDateTime'];\n  id: Scalars['ID'];\n  /** Whether the team was mapped to an LDAP Group. */\n  isLdapMapped?: Maybe<Scalars['Boolean']>;\n  /** The corresponding operation type for the action */\n  operationType?: Maybe<OperationType>;\n  /** The Organization associated with the Audit Entry. */\n  organization?: Maybe<Organization>;\n  /** The name of the Organization. */\n  organizationName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the organization */\n  organizationResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the organization */\n  organizationUrl?: Maybe<Scalars['URI']>;\n  /** The repository associated with the action */\n  repository?: Maybe<Repository>;\n  /** The name of the repository */\n  repositoryName?: Maybe<Scalars['String']>;\n  /** The HTTP path for the repository */\n  repositoryResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the repository */\n  repositoryUrl?: Maybe<Scalars['URI']>;\n  /** The team associated with the action */\n  team?: Maybe<Team>;\n  /** The name of the team */\n  teamName?: Maybe<Scalars['String']>;\n  /** The HTTP path for this team */\n  teamResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for this team */\n  teamUrl?: Maybe<Scalars['URI']>;\n  /** The user affected by the action */\n  user?: Maybe<User>;\n  /** For actions involving two users, the actor is the initiator and the user is the affected user. */\n  userLogin?: Maybe<Scalars['String']>;\n  /** The HTTP path for the user. */\n  userResourcePath?: Maybe<Scalars['URI']>;\n  /** The HTTP URL for the user. */\n  userUrl?: Maybe<Scalars['URI']>;\n};\n\n/** The connection type for Repository. */\nexport type TeamRepositoryConnection = {\n  __typename?: 'TeamRepositoryConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<TeamRepositoryEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<Repository>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** Represents a team repository. */\nexport type TeamRepositoryEdge = {\n  __typename?: 'TeamRepositoryEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  node: Repository;\n  /** The permission level the team has on the repository */\n  permission: RepositoryPermission;\n};\n\n/** Ordering options for team repository connections */\nexport type TeamRepositoryOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order repositories by. */\n  field: TeamRepositoryOrderField;\n};\n\n/** Properties by which team repository connections can be ordered. */\nexport enum TeamRepositoryOrderField {\n  /** Order repositories by creation time */\n  CreatedAt = 'CREATED_AT',\n  /** Order repositories by name */\n  Name = 'NAME',\n  /** Order repositories by permission */\n  Permission = 'PERMISSION',\n  /** Order repositories by push time */\n  PushedAt = 'PUSHED_AT',\n  /** Order repositories by number of stargazers */\n  Stargazers = 'STARGAZERS',\n  /** Order repositories by update time */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** The possible team review assignment algorithms */\nexport enum TeamReviewAssignmentAlgorithm {\n  /** Balance review load across the entire team */\n  LoadBalance = 'LOAD_BALANCE',\n  /** Alternate reviews between each team member */\n  RoundRobin = 'ROUND_ROBIN'\n}\n\n/** The role of a user on a team. */\nexport enum TeamRole {\n  /** User has admin rights on the team. */\n  Admin = 'ADMIN',\n  /** User is a member of the team. */\n  Member = 'MEMBER'\n}\n\n/** A text match within a search result. */\nexport type TextMatch = {\n  __typename?: 'TextMatch';\n  /** The specific text fragment within the property matched on. */\n  fragment: Scalars['String'];\n  /** Highlights within the matched fragment. */\n  highlights: Array<TextMatchHighlight>;\n  /** The property matched on. */\n  property: Scalars['String'];\n};\n\n/** Represents a single highlight in a search result match. */\nexport type TextMatchHighlight = {\n  __typename?: 'TextMatchHighlight';\n  /** The indice in the fragment where the matched text begins. */\n  beginIndice: Scalars['Int'];\n  /** The indice in the fragment where the matched text ends. */\n  endIndice: Scalars['Int'];\n  /** The text matched. */\n  text: Scalars['String'];\n};\n\n/** A topic aggregates entities that are related to a subject. */\nexport type Topic = Node & Starrable & {\n  __typename?: 'Topic';\n  id: Scalars['ID'];\n  /** The topic's name. */\n  name: Scalars['String'];\n  /**\n   * A list of related topics, including aliases of this topic, sorted with the most relevant\n   * first. Returns up to 10 Topics.\n   */\n  relatedTopics: Array<Topic>;\n  /** A list of repositories. */\n  repositories: RepositoryConnection;\n  /** Returns a count of how many stargazers there are on this object */\n  stargazerCount: Scalars['Int'];\n  /** A list of users who have starred this starrable. */\n  stargazers: StargazerConnection;\n  /** Returns a boolean indicating whether the viewing user has starred this starrable. */\n  viewerHasStarred: Scalars['Boolean'];\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRelatedTopicsArgs = {\n  first?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n  sponsorableOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A topic aggregates entities that are related to a subject. */\nexport type TopicStargazersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarOrder>;\n};\n\n/** Metadata for an audit entry with a topic. */\nexport type TopicAuditEntryData = {\n  /** The name of the topic added to the repository */\n  topic?: Maybe<Topic>;\n  /** The name of the topic added to the repository */\n  topicName?: Maybe<Scalars['String']>;\n};\n\n/** Reason that the suggested topic is declined. */\nexport enum TopicSuggestionDeclineReason {\n  /** The suggested topic is not relevant to the repository. */\n  NotRelevant = 'NOT_RELEVANT',\n  /** The viewer does not like the suggested topic. */\n  PersonalPreference = 'PERSONAL_PREFERENCE',\n  /** The suggested topic is too general for the repository. */\n  TooGeneral = 'TOO_GENERAL',\n  /** The suggested topic is too specific for the repository (e.g. #ruby-on-rails-version-4-2-1). */\n  TooSpecific = 'TOO_SPECIFIC'\n}\n\n/** The possible states of a tracked issue. */\nexport enum TrackedIssueStates {\n  /** The tracked issue is closed */\n  Closed = 'CLOSED',\n  /** The tracked issue is open */\n  Open = 'OPEN'\n}\n\n/** Autogenerated input type of TransferEnterpriseOrganization */\nexport type TransferEnterpriseOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise where the organization should be transferred. */\n  destinationEnterpriseId: Scalars['ID'];\n  /** The ID of the organization to transfer. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of TransferEnterpriseOrganization */\nexport type TransferEnterpriseOrganizationPayload = {\n  __typename?: 'TransferEnterpriseOrganizationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organization for which a transfer was initiated. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of TransferIssue */\nexport type TransferIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether to create labels if they don't exist in the target repository (matched by name) */\n  createLabelsIfMissing?: InputMaybe<Scalars['Boolean']>;\n  /** The Node ID of the issue to be transferred */\n  issueId: Scalars['ID'];\n  /** The Node ID of the repository the issue should be transferred to */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of TransferIssue */\nexport type TransferIssuePayload = {\n  __typename?: 'TransferIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue that was transferred */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents a 'transferred' event on a given issue or pull request. */\nexport type TransferredEvent = Node & {\n  __typename?: 'TransferredEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The repository this came from */\n  fromRepository?: Maybe<Repository>;\n  id: Scalars['ID'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Represents a Git tree. */\nexport type Tree = GitObject & Node & {\n  __typename?: 'Tree';\n  /** An abbreviated version of the Git object ID */\n  abbreviatedOid: Scalars['String'];\n  /** The HTTP path for this Git object */\n  commitResourcePath: Scalars['URI'];\n  /** The HTTP URL for this Git object */\n  commitUrl: Scalars['URI'];\n  /** A list of tree entries. */\n  entries?: Maybe<Array<TreeEntry>>;\n  id: Scalars['ID'];\n  /** The Git object ID */\n  oid: Scalars['GitObjectID'];\n  /** The Repository the Git object belongs to */\n  repository: Repository;\n};\n\n/** Represents a Git tree entry. */\nexport type TreeEntry = {\n  __typename?: 'TreeEntry';\n  /** The extension of the file */\n  extension?: Maybe<Scalars['String']>;\n  /** Whether or not this tree entry is generated */\n  isGenerated: Scalars['Boolean'];\n  /** The programming language this file is written in. */\n  language?: Maybe<Language>;\n  /** Number of lines in the file. */\n  lineCount?: Maybe<Scalars['Int']>;\n  /** Entry file mode. */\n  mode: Scalars['Int'];\n  /** Entry file name. */\n  name: Scalars['String'];\n  /** Entry file name. (Base64-encoded) */\n  nameRaw: Scalars['Base64String'];\n  /** Entry file object. */\n  object?: Maybe<GitObject>;\n  /** Entry file Git object ID. */\n  oid: Scalars['GitObjectID'];\n  /** The full path of the file. */\n  path?: Maybe<Scalars['String']>;\n  /** The full path of the file. (Base64-encoded) */\n  pathRaw?: Maybe<Scalars['Base64String']>;\n  /** The Repository the tree entry belongs to */\n  repository: Repository;\n  /** Entry byte size */\n  size: Scalars['Int'];\n  /** If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule */\n  submodule?: Maybe<Submodule>;\n  /** Entry file type. */\n  type: Scalars['String'];\n};\n\n/** Autogenerated input type of UnarchiveProjectV2Item */\nexport type UnarchiveProjectV2ItemInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the ProjectV2Item to unarchive. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project to archive the item from. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnarchiveProjectV2Item */\nexport type UnarchiveProjectV2ItemPayload = {\n  __typename?: 'UnarchiveProjectV2ItemPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item unarchived from the project. */\n  item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of UnarchiveRepository */\nexport type UnarchiveRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the repository to unarchive. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnarchiveRepository */\nexport type UnarchiveRepositoryPayload = {\n  __typename?: 'UnarchiveRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository that was unarchived. */\n  repository?: Maybe<Repository>;\n};\n\n/** Represents an 'unassigned' event on any assignable object. */\nexport type UnassignedEvent = Node & {\n  __typename?: 'UnassignedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the assignable associated with the event. */\n  assignable: Assignable;\n  /** Identifies the user or mannequin that was unassigned. */\n  assignee?: Maybe<Assignee>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /**\n   * Identifies the subject (user) who was unassigned.\n   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.\n   */\n  user?: Maybe<User>;\n};\n\n/** Autogenerated input type of UnfollowOrganization */\nexport type UnfollowOrganizationInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the organization to unfollow. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnfollowOrganization */\nexport type UnfollowOrganizationPayload = {\n  __typename?: 'UnfollowOrganizationPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The organization that was unfollowed. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UnfollowUser */\nexport type UnfollowUserInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the user to unfollow. */\n  userId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnfollowUser */\nexport type UnfollowUserPayload = {\n  __typename?: 'UnfollowUserPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The user that was unfollowed. */\n  user?: Maybe<User>;\n};\n\n/** Represents a type that can be retrieved by a URL. */\nexport type UniformResourceLocatable = {\n  /** The HTML path to this resource. */\n  resourcePath: Scalars['URI'];\n  /** The URL to this resource. */\n  url: Scalars['URI'];\n};\n\n/** Represents an unknown signature on a Commit or Tag. */\nexport type UnknownSignature = GitSignature & {\n  __typename?: 'UnknownSignature';\n  /** Email used to sign this object. */\n  email: Scalars['String'];\n  /** True if the signature is valid and verified by GitHub. */\n  isValid: Scalars['Boolean'];\n  /** Payload for GPG signing object. Raw ODB object without the signature header. */\n  payload: Scalars['String'];\n  /** ASCII-armored signature header from object. */\n  signature: Scalars['String'];\n  /** GitHub user corresponding to the email signing this commit. */\n  signer?: Maybe<User>;\n  /**\n   * The state of this signature. `VALID` if signature is valid and verified by\n   * GitHub, otherwise represents reason why signature is considered invalid.\n   */\n  state: GitSignatureState;\n  /** True if the signature was made with GitHub's signing key. */\n  wasSignedByGitHub: Scalars['Boolean'];\n};\n\n/** Represents an 'unlabeled' event on a given issue or pull request. */\nexport type UnlabeledEvent = Node & {\n  __typename?: 'UnlabeledEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the label associated with the 'unlabeled' event. */\n  label: Label;\n  /** Identifies the `Labelable` associated with the event. */\n  labelable: Labelable;\n};\n\n/** Autogenerated input type of UnlinkProjectV2FromRepository */\nexport type UnlinkProjectV2FromRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the project to unlink from the repository. */\n  projectId: Scalars['ID'];\n  /** The ID of the repository to unlink from the project. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnlinkProjectV2FromRepository */\nexport type UnlinkProjectV2FromRepositoryPayload = {\n  __typename?: 'UnlinkProjectV2FromRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository the project is no longer linked to. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UnlinkProjectV2FromTeam */\nexport type UnlinkProjectV2FromTeamInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the project to unlink from the team. */\n  projectId: Scalars['ID'];\n  /** The ID of the team to unlink from the project. */\n  teamId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnlinkProjectV2FromTeam */\nexport type UnlinkProjectV2FromTeamPayload = {\n  __typename?: 'UnlinkProjectV2FromTeamPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The team the project is unlinked from */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project linked to the Repository. */\n  projectId: Scalars['ID'];\n  /** The ID of the Repository linked to the Project. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnlinkRepositoryFromProject */\nexport type UnlinkRepositoryFromProjectPayload = {\n  __typename?: 'UnlinkRepositoryFromProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The linked Project. */\n  project?: Maybe<Project>;\n  /** The linked Repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UnlockLockable */\nexport type UnlockLockableInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the item to be unlocked. */\n  lockableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnlockLockable */\nexport type UnlockLockablePayload = {\n  __typename?: 'UnlockLockablePayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The item that was unlocked. */\n  unlockedRecord?: Maybe<Lockable>;\n};\n\n/** Represents an 'unlocked' event on a given issue or pull request. */\nexport type UnlockedEvent = Node & {\n  __typename?: 'UnlockedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Object that was unlocked. */\n  lockable: Lockable;\n};\n\n/** Autogenerated input type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to unmark as an answer. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnmarkDiscussionCommentAsAnswer */\nexport type UnmarkDiscussionCommentAsAnswerPayload = {\n  __typename?: 'UnmarkDiscussionCommentAsAnswerPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The discussion that includes the comment. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The path of the file to mark as unviewed */\n  path: Scalars['String'];\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnmarkFileAsViewed */\nexport type UnmarkFileAsViewedPayload = {\n  __typename?: 'UnmarkFileAsViewedPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicateInput = {\n  /** ID of the issue or pull request currently considered canonical/authoritative/original. */\n  canonicalId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** ID of the issue or pull request currently marked as a duplicate. */\n  duplicateId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnmarkIssueAsDuplicate */\nexport type UnmarkIssueAsDuplicatePayload = {\n  __typename?: 'UnmarkIssueAsDuplicatePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue or pull request that was marked as a duplicate. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n};\n\n/** Autogenerated input type of UnmarkProjectV2AsTemplate */\nexport type UnmarkProjectV2AsTemplateInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Project to unmark as a template. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnmarkProjectV2AsTemplate */\nexport type UnmarkProjectV2AsTemplatePayload = {\n  __typename?: 'UnmarkProjectV2AsTemplatePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Represents an 'unmarked_as_duplicate' event on a given issue or pull request. */\nexport type UnmarkedAsDuplicateEvent = Node & {\n  __typename?: 'UnmarkedAsDuplicateEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** The authoritative issue or pull request which has been duplicated by another. */\n  canonical?: Maybe<IssueOrPullRequest>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** The issue or pull request which has been marked as a duplicate of another. */\n  duplicate?: Maybe<IssueOrPullRequest>;\n  id: Scalars['ID'];\n  /** Canonical and duplicate belong to different repositories. */\n  isCrossRepository: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of UnminimizeComment */\nexport type UnminimizeCommentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the subject to modify. */\n  subjectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnminimizeComment */\nexport type UnminimizeCommentPayload = {\n  __typename?: 'UnminimizeCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The comment that was unminimized. */\n  unminimizedComment?: Maybe<Minimizable>;\n};\n\n/** Autogenerated input type of UnpinIssue */\nexport type UnpinIssueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the issue to be unpinned */\n  issueId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnpinIssue */\nexport type UnpinIssuePayload = {\n  __typename?: 'UnpinIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue that was unpinned */\n  issue?: Maybe<Issue>;\n};\n\n/** Represents an 'unpinned' event on a given issue or pull request. */\nexport type UnpinnedEvent = Node & {\n  __typename?: 'UnpinnedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Identifies the issue associated with the event. */\n  issue: Issue;\n};\n\n/** Autogenerated input type of UnresolveReviewThread */\nexport type UnresolveReviewThreadInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the thread to unresolve */\n  threadId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UnresolveReviewThread */\nexport type UnresolveReviewThreadPayload = {\n  __typename?: 'UnresolveReviewThreadPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The thread to resolve. */\n  thread?: Maybe<PullRequestReviewThread>;\n};\n\n/** Represents an 'unsubscribed' event on a given `Subscribable`. */\nexport type UnsubscribedEvent = Node & {\n  __typename?: 'UnsubscribedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** Object referenced by event. */\n  subscribable: Subscribable;\n};\n\n/** Entities that can be updated. */\nexport type Updatable = {\n  /** Check if the current viewer can update this object. */\n  viewerCanUpdate: Scalars['Boolean'];\n};\n\n/** Comments that can be updated. */\nexport type UpdatableComment = {\n  /** Reasons why the current viewer can not update this comment. */\n  viewerCannotUpdateReasons: Array<CommentCannotUpdateReason>;\n};\n\n/** Autogenerated input type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRuleInput = {\n  /** Can this branch be deleted. */\n  allowsDeletions?: InputMaybe<Scalars['Boolean']>;\n  /** Are force pushes allowed on this branch. */\n  allowsForcePushes?: InputMaybe<Scalars['Boolean']>;\n  /** Is branch creation a protected operation. */\n  blocksCreations?: InputMaybe<Scalars['Boolean']>;\n  /** The global relay id of the branch protection rule to be updated. */\n  branchProtectionRuleId: Scalars['ID'];\n  /** A list of User, Team, or App IDs allowed to bypass force push targeting matching branches. */\n  bypassForcePushActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** A list of User, Team, or App IDs allowed to bypass pull requests targeting matching branches. */\n  bypassPullRequestActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Will new commits pushed to matching branches dismiss pull request review approvals. */\n  dismissesStaleReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Can admins overwrite branch protection. */\n  isAdminEnforced?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Whether users can pull changes from upstream when the branch is locked. Set to\n   * `true` to allow fork syncing. Set to `false` to prevent fork syncing.\n   */\n  lockAllowsFetchAndMerge?: InputMaybe<Scalars['Boolean']>;\n  /** Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. */\n  lockBranch?: InputMaybe<Scalars['Boolean']>;\n  /** The glob-like pattern used to determine matching branches. */\n  pattern?: InputMaybe<Scalars['String']>;\n  /** A list of User, Team, or App IDs allowed to push to matching branches. */\n  pushActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** Whether the most recent push must be approved by someone other than the person who pushed it */\n  requireLastPushApproval?: InputMaybe<Scalars['Boolean']>;\n  /** Number of approving reviews required to update matching branches. */\n  requiredApprovingReviewCount?: InputMaybe<Scalars['Int']>;\n  /** The list of required deployment environments */\n  requiredDeploymentEnvironments?: InputMaybe<Array<Scalars['String']>>;\n  /** List of required status check contexts that must pass for commits to be accepted to matching branches. */\n  requiredStatusCheckContexts?: InputMaybe<Array<Scalars['String']>>;\n  /** The list of required status checks */\n  requiredStatusChecks?: InputMaybe<Array<RequiredStatusCheckInput>>;\n  /** Are approving reviews required to update matching branches. */\n  requiresApprovingReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Are reviews from code owners required to update matching branches. */\n  requiresCodeOwnerReviews?: InputMaybe<Scalars['Boolean']>;\n  /** Are commits required to be signed. */\n  requiresCommitSignatures?: InputMaybe<Scalars['Boolean']>;\n  /** Are conversations required to be resolved before merging. */\n  requiresConversationResolution?: InputMaybe<Scalars['Boolean']>;\n  /** Are successful deployments required before merging. */\n  requiresDeployments?: InputMaybe<Scalars['Boolean']>;\n  /** Are merge commits prohibited from being pushed to this branch. */\n  requiresLinearHistory?: InputMaybe<Scalars['Boolean']>;\n  /** Are status checks required to update matching branches. */\n  requiresStatusChecks?: InputMaybe<Scalars['Boolean']>;\n  /** Are branches required to be up to date before merging. */\n  requiresStrictStatusChecks?: InputMaybe<Scalars['Boolean']>;\n  /** Is pushing to matching branches restricted. */\n  restrictsPushes?: InputMaybe<Scalars['Boolean']>;\n  /** Is dismissal of pull request reviews restricted. */\n  restrictsReviewDismissals?: InputMaybe<Scalars['Boolean']>;\n  /** A list of User, Team, or App IDs allowed to dismiss reviews on pull requests targeting matching branches. */\n  reviewDismissalActorIds?: InputMaybe<Array<Scalars['ID']>>;\n};\n\n/** Autogenerated return type of UpdateBranchProtectionRule */\nexport type UpdateBranchProtectionRulePayload = {\n  __typename?: 'UpdateBranchProtectionRulePayload';\n  /** The newly created BranchProtectionRule. */\n  branchProtectionRule?: Maybe<BranchProtectionRule>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateCheckRun */\nexport type UpdateCheckRunInput = {\n  /** Possible further actions the integrator can perform, which a user may trigger. */\n  actions?: InputMaybe<Array<CheckRunAction>>;\n  /** The node of the check. */\n  checkRunId: Scalars['ID'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The time that the check run finished. */\n  completedAt?: InputMaybe<Scalars['DateTime']>;\n  /** The final conclusion of the check. */\n  conclusion?: InputMaybe<CheckConclusionState>;\n  /** The URL of the integrator's site that has the full details of the check. */\n  detailsUrl?: InputMaybe<Scalars['URI']>;\n  /** A reference for the run on the integrator's system. */\n  externalId?: InputMaybe<Scalars['String']>;\n  /** The name of the check. */\n  name?: InputMaybe<Scalars['String']>;\n  /** Descriptive details about the run. */\n  output?: InputMaybe<CheckRunOutput>;\n  /** The node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** The time that the check run began. */\n  startedAt?: InputMaybe<Scalars['DateTime']>;\n  /** The current status. */\n  status?: InputMaybe<RequestableCheckStatusState>;\n};\n\n/** Autogenerated return type of UpdateCheckRun */\nexport type UpdateCheckRunPayload = {\n  __typename?: 'UpdateCheckRunPayload';\n  /** The updated check run. */\n  checkRun?: Maybe<CheckRun>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesInput = {\n  /** The check suite preferences to modify. */\n  autoTriggerPreferences: Array<CheckSuiteAutoTriggerPreference>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateCheckSuitePreferences */\nexport type UpdateCheckSuitePreferencesPayload = {\n  __typename?: 'UpdateCheckSuitePreferencesPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentInput = {\n  /** The new contents of the comment body. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion comment to update. */\n  commentId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateDiscussionComment */\nexport type UpdateDiscussionCommentPayload = {\n  __typename?: 'UpdateDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The modified discussion comment. */\n  comment?: Maybe<DiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateDiscussion */\nexport type UpdateDiscussionInput = {\n  /** The new contents of the discussion body. */\n  body?: InputMaybe<Scalars['String']>;\n  /** The Node ID of a discussion category within the same repository to change this discussion to. */\n  categoryId?: InputMaybe<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion to update. */\n  discussionId: Scalars['ID'];\n  /** The new discussion title. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateDiscussion */\nexport type UpdateDiscussionPayload = {\n  __typename?: 'UpdateDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The modified discussion. */\n  discussion?: Maybe<Discussion>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Enterprise which the admin belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The login of a administrator whose role is being changed. */\n  login: Scalars['String'];\n  /** The new role for the Enterprise administrator. */\n  role: EnterpriseAdministratorRole;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAdministratorRole */\nexport type UpdateEnterpriseAdministratorRolePayload = {\n  __typename?: 'UpdateEnterpriseAdministratorRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of changing the administrator's role. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the allow private repository forking setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the allow private repository forking policy on the enterprise. */\n  policyValue?: InputMaybe<EnterpriseAllowPrivateRepositoryForkingPolicyValue>;\n  /** The value for the allow private repository forking setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseAllowPrivateRepositoryForkingSetting */\nexport type UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload = {\n  __typename?: 'UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated allow private repository forking setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the base repository permission setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the base repository permission setting on the enterprise. */\n  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseDefaultRepositoryPermissionSetting */\nexport type UpdateEnterpriseDefaultRepositoryPermissionSettingPayload = {\n  __typename?: 'UpdateEnterpriseDefaultRepositoryPermissionSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated base repository permission setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the base repository permission setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can change repository visibility setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can change repository visibility setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanChangeRepositoryVisibilitySetting */\nexport type UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can change repository visibility setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can change repository visibility setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can create repositories setting. */\n  enterpriseId: Scalars['ID'];\n  /** Allow members to create internal repositories. Defaults to current value. */\n  membersCanCreateInternalRepositories?: InputMaybe<Scalars['Boolean']>;\n  /** Allow members to create private repositories. Defaults to current value. */\n  membersCanCreatePrivateRepositories?: InputMaybe<Scalars['Boolean']>;\n  /** Allow members to create public repositories. Defaults to current value. */\n  membersCanCreatePublicRepositories?: InputMaybe<Scalars['Boolean']>;\n  /** When false, allow member organizations to set their own repository creation member privileges. */\n  membersCanCreateRepositoriesPolicyEnabled?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * Value for the members can create repositories setting on the enterprise. This\n   * or the granular public/private/internal allowed fields (but not both) must be provided.\n   */\n  settingValue?: InputMaybe<EnterpriseMembersCanCreateRepositoriesSettingValue>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanCreateRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can create repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can create repositories setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can delete issues setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can delete issues setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteIssuesSetting */\nexport type UpdateEnterpriseMembersCanDeleteIssuesSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanDeleteIssuesSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can delete issues setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete issues setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can delete repositories setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can delete repositories setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanDeleteRepositoriesSetting */\nexport type UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can delete repositories setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can delete repositories setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can invite collaborators setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can invite collaborators setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanInviteCollaboratorsSetting */\nexport type UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can invite collaborators setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can invite collaborators setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can make purchases setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can make purchases setting on the enterprise. */\n  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanMakePurchasesSetting */\nexport type UpdateEnterpriseMembersCanMakePurchasesSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanMakePurchasesSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can make purchases setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can make purchases setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can update protected branches setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can update protected branches setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanUpdateProtectedBranchesSetting */\nexport type UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can update protected branches setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can update protected branches setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the members can view dependency insights setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the members can view dependency insights setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseMembersCanViewDependencyInsightsSetting */\nexport type UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload = {\n  __typename?: 'UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated members can view dependency insights setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the members can view dependency insights setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the organization projects setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the organization projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOrganizationProjectsSetting */\nexport type UpdateEnterpriseOrganizationProjectsSettingPayload = {\n  __typename?: 'UpdateEnterpriseOrganizationProjectsSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated organization projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the organization projects setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRoleInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Enterprise which the owner belongs to. */\n  enterpriseId: Scalars['ID'];\n  /** The ID of the organization for membership change. */\n  organizationId: Scalars['ID'];\n  /** The role to assume in the organization. */\n  organizationRole: RoleInOrganization;\n};\n\n/** Autogenerated return type of UpdateEnterpriseOwnerOrganizationRole */\nexport type UpdateEnterpriseOwnerOrganizationRolePayload = {\n  __typename?: 'UpdateEnterpriseOwnerOrganizationRolePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of changing the owner's organization role. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfileInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The description of the enterprise. */\n  description?: InputMaybe<Scalars['String']>;\n  /** The Enterprise ID to update. */\n  enterpriseId: Scalars['ID'];\n  /** The location of the enterprise. */\n  location?: InputMaybe<Scalars['String']>;\n  /** The name of the enterprise. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The URL of the enterprise's website. */\n  websiteUrl?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateEnterpriseProfile */\nexport type UpdateEnterpriseProfilePayload = {\n  __typename?: 'UpdateEnterpriseProfilePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated enterprise. */\n  enterprise?: Maybe<Enterprise>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the repository projects setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the repository projects setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseRepositoryProjectsSetting */\nexport type UpdateEnterpriseRepositoryProjectsSettingPayload = {\n  __typename?: 'UpdateEnterpriseRepositoryProjectsSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated repository projects setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the repository projects setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the team discussions setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the team discussions setting on the enterprise. */\n  settingValue: EnterpriseEnabledDisabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTeamDiscussionsSetting */\nexport type UpdateEnterpriseTeamDiscussionsSettingPayload = {\n  __typename?: 'UpdateEnterpriseTeamDiscussionsSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated team discussions setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the team discussions setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the enterprise on which to set the two factor authentication required setting. */\n  enterpriseId: Scalars['ID'];\n  /** The value for the two factor authentication required setting on the enterprise. */\n  settingValue: EnterpriseEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateEnterpriseTwoFactorAuthenticationRequiredSetting */\nexport type UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload = {\n  __typename?: 'UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The enterprise with the updated two factor authentication required setting. */\n  enterprise?: Maybe<Enterprise>;\n  /** A message confirming the result of updating the two factor authentication required setting. */\n  message?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateEnvironment */\nexport type UpdateEnvironmentInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The node ID of the environment. */\n  environmentId: Scalars['ID'];\n  /** The ids of users or teams that can approve deployments to this environment */\n  reviewers?: InputMaybe<Array<Scalars['ID']>>;\n  /** The wait timer in minutes. */\n  waitTimer?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated return type of UpdateEnvironment */\nexport type UpdateEnvironmentPayload = {\n  __typename?: 'UpdateEnvironmentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated environment. */\n  environment?: Maybe<Environment>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the owner on which to set the IP allow list enabled setting. */\n  ownerId: Scalars['ID'];\n  /** The value for the IP allow list enabled setting. */\n  settingValue: IpAllowListEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEnabledSetting */\nexport type UpdateIpAllowListEnabledSettingPayload = {\n  __typename?: 'UpdateIpAllowListEnabledSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryInput = {\n  /** An IP address or range of addresses in CIDR notation. */\n  allowListValue: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the IP allow list entry to update. */\n  ipAllowListEntryId: Scalars['ID'];\n  /** Whether the IP allow list entry is active when an IP allow list is enabled. */\n  isActive: Scalars['Boolean'];\n  /** An optional name for the IP allow list entry. */\n  name?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateIpAllowListEntry */\nexport type UpdateIpAllowListEntryPayload = {\n  __typename?: 'UpdateIpAllowListEntryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The IP allow list entry that was updated. */\n  ipAllowListEntry?: Maybe<IpAllowListEntry>;\n};\n\n/** Autogenerated input type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the owner. */\n  ownerId: Scalars['ID'];\n  /** The value for the IP allow list configuration for installed GitHub Apps setting. */\n  settingValue: IpAllowListForInstalledAppsEnabledSettingValue;\n};\n\n/** Autogenerated return type of UpdateIpAllowListForInstalledAppsEnabledSetting */\nexport type UpdateIpAllowListForInstalledAppsEnabledSettingPayload = {\n  __typename?: 'UpdateIpAllowListForInstalledAppsEnabledSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The IP allow list owner on which the setting was updated. */\n  owner?: Maybe<IpAllowListOwner>;\n};\n\n/** Autogenerated input type of UpdateIssueComment */\nexport type UpdateIssueCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the IssueComment to modify. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateIssueComment */\nexport type UpdateIssueCommentPayload = {\n  __typename?: 'UpdateIssueCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated comment. */\n  issueComment?: Maybe<IssueComment>;\n};\n\n/** Autogenerated input type of UpdateIssue */\nexport type UpdateIssueInput = {\n  /** An array of Node IDs of users for this issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The body for the issue description. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the Issue to modify. */\n  id: Scalars['ID'];\n  /** An array of Node IDs of labels for this issue. */\n  labelIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The Node ID of the milestone for this issue. */\n  milestoneId?: InputMaybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this issue. */\n  projectIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The desired issue state. */\n  state?: InputMaybe<IssueState>;\n  /** The title for the issue. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateIssue */\nexport type UpdateIssuePayload = {\n  __typename?: 'UpdateIssuePayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The issue. */\n  issue?: Maybe<Issue>;\n};\n\n/** Autogenerated input type of UpdateLabel */\nexport type UpdateLabelInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A 6 character hex code, without the leading #, identifying the updated color of the label. */\n  color?: InputMaybe<Scalars['String']>;\n  /** A brief description of the label, such as its purpose. */\n  description?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the label to be updated. */\n  id: Scalars['ID'];\n  /** The updated name of the label. */\n  name?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateLabel */\nexport type UpdateLabelPayload = {\n  __typename?: 'UpdateLabelPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated label. */\n  label?: Maybe<Label>;\n};\n\n/** Autogenerated input type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the owner on which to set the restrict notifications setting. */\n  ownerId: Scalars['ID'];\n  /** The value for the restrict notifications setting. */\n  settingValue: NotificationRestrictionSettingValue;\n};\n\n/** Autogenerated return type of UpdateNotificationRestrictionSetting */\nexport type UpdateNotificationRestrictionSettingPayload = {\n  __typename?: 'UpdateNotificationRestrictionSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The owner on which the setting was updated. */\n  owner?: Maybe<VerifiableDomainOwner>;\n};\n\n/** Autogenerated input type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Enable forking of private repositories in the organization? */\n  forkingEnabled: Scalars['Boolean'];\n  /** The ID of the organization on which to set the allow private repository forking setting. */\n  organizationId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateOrganizationAllowPrivateRepositoryForkingSetting */\nexport type UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload = {\n  __typename?: 'UpdateOrganizationAllowPrivateRepositoryForkingSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of updating the allow private repository forking setting. */\n  message?: Maybe<Scalars['String']>;\n  /** The organization with the updated allow private repository forking setting. */\n  organization?: Maybe<Organization>;\n};\n\n/** Autogenerated input type of UpdateOrganizationWebCommitSignoffSetting */\nexport type UpdateOrganizationWebCommitSignoffSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the organization on which to set the web commit signoff setting. */\n  organizationId: Scalars['ID'];\n  /** Enable signoff on web-based commits for repositories in the organization? */\n  webCommitSignoffRequired: Scalars['Boolean'];\n};\n\n/** Autogenerated return type of UpdateOrganizationWebCommitSignoffSetting */\nexport type UpdateOrganizationWebCommitSignoffSettingPayload = {\n  __typename?: 'UpdateOrganizationWebCommitSignoffSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of updating the web commit signoff setting. */\n  message?: Maybe<Scalars['String']>;\n  /** The organization with the updated web commit signoff setting. */\n  organization?: Maybe<Organization>;\n};\n\n/** Only allow users with bypass permission to update matching refs. */\nexport type UpdateParameters = {\n  __typename?: 'UpdateParameters';\n  /** Branch can pull changes from its upstream repository */\n  updateAllowsFetchAndMerge: Scalars['Boolean'];\n};\n\n/** Only allow users with bypass permission to update matching refs. */\nexport type UpdateParametersInput = {\n  /** Branch can pull changes from its upstream repository */\n  updateAllowsFetchAndMerge: Scalars['Boolean'];\n};\n\n/** Autogenerated input type of UpdateProjectCard */\nexport type UpdateProjectCardInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Whether or not the ProjectCard should be archived */\n  isArchived?: InputMaybe<Scalars['Boolean']>;\n  /** The note of ProjectCard. */\n  note?: InputMaybe<Scalars['String']>;\n  /** The ProjectCard ID to update. */\n  projectCardId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateProjectCard */\nexport type UpdateProjectCardPayload = {\n  __typename?: 'UpdateProjectCardPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated ProjectCard. */\n  projectCard?: Maybe<ProjectCard>;\n};\n\n/** Autogenerated input type of UpdateProjectColumn */\nexport type UpdateProjectColumnInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of project column. */\n  name: Scalars['String'];\n  /** The ProjectColumn ID to update. */\n  projectColumnId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateProjectColumn */\nexport type UpdateProjectColumnPayload = {\n  __typename?: 'UpdateProjectColumnPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated project column. */\n  projectColumn?: Maybe<ProjectColumn>;\n};\n\n/** Autogenerated input type of UpdateProject */\nexport type UpdateProjectInput = {\n  /** The description of project. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The name of project. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The Project ID to update. */\n  projectId: Scalars['ID'];\n  /** Whether the project is public or not. */\n  public?: InputMaybe<Scalars['Boolean']>;\n  /** Whether the project is open or closed. */\n  state?: InputMaybe<ProjectState>;\n};\n\n/** Autogenerated return type of UpdateProject */\nexport type UpdateProjectPayload = {\n  __typename?: 'UpdateProjectPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated project. */\n  project?: Maybe<Project>;\n};\n\n/** Autogenerated input type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The collaborators to update. */\n  collaborators: Array<ProjectV2Collaborator>;\n  /** The ID of the project to update the collaborators for. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsPayload = {\n  __typename?: 'UpdateProjectV2CollaboratorsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The collaborators granted a role */\n  collaborators?: Maybe<ProjectV2ActorConnection>;\n};\n\n\n/** Autogenerated return type of UpdateProjectV2Collaborators */\nexport type UpdateProjectV2CollaboratorsPayloadCollaboratorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated input type of UpdateProjectV2DraftIssue */\nexport type UpdateProjectV2DraftIssueInput = {\n  /** The IDs of the assignees of the draft issue. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The body of the draft issue. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the draft issue to update. */\n  draftIssueId: Scalars['ID'];\n  /** The title of the draft issue. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateProjectV2DraftIssue */\nexport type UpdateProjectV2DraftIssuePayload = {\n  __typename?: 'UpdateProjectV2DraftIssuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The draft issue updated in the project. */\n  draftIssue?: Maybe<DraftIssue>;\n};\n\n/** Autogenerated input type of UpdateProjectV2 */\nexport type UpdateProjectV2Input = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Set the project to closed or open. */\n  closed?: InputMaybe<Scalars['Boolean']>;\n  /** The ID of the Project to update. */\n  projectId: Scalars['ID'];\n  /** Set the project to public or private. */\n  public?: InputMaybe<Scalars['Boolean']>;\n  /** Set the readme description of the project. */\n  readme?: InputMaybe<Scalars['String']>;\n  /** Set the short description of the project. */\n  shortDescription?: InputMaybe<Scalars['String']>;\n  /** Set the title of the project. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateProjectV2ItemFieldValue */\nexport type UpdateProjectV2ItemFieldValueInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the field to be updated. */\n  fieldId: Scalars['ID'];\n  /** The ID of the item to be updated. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID'];\n  /** The value which will be set on the field. */\n  value: ProjectV2FieldValue;\n};\n\n/** Autogenerated return type of UpdateProjectV2ItemFieldValue */\nexport type UpdateProjectV2ItemFieldValuePayload = {\n  __typename?: 'UpdateProjectV2ItemFieldValuePayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated item. */\n  projectV2Item?: Maybe<ProjectV2Item>;\n};\n\n/** Autogenerated input type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionInput = {\n  /** The ID of the item to position this item after. If omitted or set to null the item will be moved to top. */\n  afterId?: InputMaybe<Scalars['ID']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the item to be moved. */\n  itemId: Scalars['ID'];\n  /** The ID of the Project. */\n  projectId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionPayload = {\n  __typename?: 'UpdateProjectV2ItemPositionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The items in the new order */\n  items?: Maybe<ProjectV2ItemConnection>;\n};\n\n\n/** Autogenerated return type of UpdateProjectV2ItemPosition */\nexport type UpdateProjectV2ItemPositionPayloadItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated return type of UpdateProjectV2 */\nexport type UpdateProjectV2Payload = {\n  __typename?: 'UpdateProjectV2Payload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated Project. */\n  projectV2?: Maybe<ProjectV2>;\n};\n\n/** Autogenerated input type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The head ref oid for the upstream branch. */\n  expectedHeadOid?: InputMaybe<Scalars['GitObjectID']>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdatePullRequestBranch */\nexport type UpdatePullRequestBranchPayload = {\n  __typename?: 'UpdatePullRequestBranchPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequest */\nexport type UpdatePullRequestInput = {\n  /** An array of Node IDs of users for this pull request. */\n  assigneeIds?: InputMaybe<Array<Scalars['ID']>>;\n  /**\n   * The name of the branch you want your changes pulled into. This should be an existing branch\n   * on the current repository.\n   */\n  baseRefName?: InputMaybe<Scalars['String']>;\n  /** The contents of the pull request. */\n  body?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** An array of Node IDs of labels for this pull request. */\n  labelIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** Indicates whether maintainers can modify the pull request. */\n  maintainerCanModify?: InputMaybe<Scalars['Boolean']>;\n  /** The Node ID of the milestone for this pull request. */\n  milestoneId?: InputMaybe<Scalars['ID']>;\n  /** An array of Node IDs for projects associated with this pull request. */\n  projectIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The Node ID of the pull request. */\n  pullRequestId: Scalars['ID'];\n  /** The target state of the pull request. */\n  state?: InputMaybe<PullRequestUpdateState>;\n  /** The title of the pull request. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdatePullRequest */\nexport type UpdatePullRequestPayload = {\n  __typename?: 'UpdatePullRequestPayload';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated pull request. */\n  pullRequest?: Maybe<PullRequest>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentInput = {\n  /** The text of the comment. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the comment to modify. */\n  pullRequestReviewCommentId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdatePullRequestReviewComment */\nexport type UpdatePullRequestReviewCommentPayload = {\n  __typename?: 'UpdatePullRequestReviewCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated comment. */\n  pullRequestReviewComment?: Maybe<PullRequestReviewComment>;\n};\n\n/** Autogenerated input type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewInput = {\n  /** The contents of the pull request review body. */\n  body: Scalars['String'];\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the pull request review to modify. */\n  pullRequestReviewId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdatePullRequestReview */\nexport type UpdatePullRequestReviewPayload = {\n  __typename?: 'UpdatePullRequestReviewPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated pull request review. */\n  pullRequestReview?: Maybe<PullRequestReview>;\n};\n\n/** Autogenerated input type of UpdateRef */\nexport type UpdateRefInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Permit updates of branch Refs that are not fast-forwards? */\n  force?: InputMaybe<Scalars['Boolean']>;\n  /** The GitObjectID that the Ref shall be updated to target. */\n  oid: Scalars['GitObjectID'];\n  /** The Node ID of the Ref to be updated. */\n  refId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateRef */\nexport type UpdateRefPayload = {\n  __typename?: 'UpdateRefPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated Ref. */\n  ref?: Maybe<Ref>;\n};\n\n/** Autogenerated input type of UpdateRefs */\nexport type UpdateRefsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A list of ref updates. */\n  refUpdates: Array<RefUpdate>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateRefs */\nexport type UpdateRefsPayload = {\n  __typename?: 'UpdateRefsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n};\n\n/** Autogenerated input type of UpdateRepository */\nexport type UpdateRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** A new description for the repository. Pass an empty string to erase the existing description. */\n  description?: InputMaybe<Scalars['String']>;\n  /** Indicates if the repository should have the discussions feature enabled. */\n  hasDiscussionsEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the issues feature enabled. */\n  hasIssuesEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the project boards feature enabled. */\n  hasProjectsEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** Indicates if the repository should have the wiki feature enabled. */\n  hasWikiEnabled?: InputMaybe<Scalars['Boolean']>;\n  /** The URL for a web page about this repository. Pass an empty string to erase the existing URL. */\n  homepageUrl?: InputMaybe<Scalars['URI']>;\n  /** The new name of the repository. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID'];\n  /**\n   * Whether this repository should be marked as a template such that anyone who\n   * can access it can create new repositories with the same files and directory structure.\n   */\n  template?: InputMaybe<Scalars['Boolean']>;\n};\n\n/** Autogenerated return type of UpdateRepository */\nexport type UpdateRepositoryPayload = {\n  __typename?: 'UpdateRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateRepositoryRuleset */\nexport type UpdateRepositoryRulesetInput = {\n  /** A list of Team or App IDs allowed to bypass rules in this ruleset. */\n  bypassActorIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The bypass mode for this ruleset */\n  bypassMode?: InputMaybe<RuleBypassMode>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The list of conditions for this ruleset */\n  conditions?: InputMaybe<RepositoryRuleConditionsInput>;\n  /** The enforcement level for this ruleset */\n  enforcement?: InputMaybe<RuleEnforcement>;\n  /** The name of the ruleset. */\n  name?: InputMaybe<Scalars['String']>;\n  /** The global relay id of the repository ruleset to be updated. */\n  repositoryRulesetId: Scalars['ID'];\n  /** The list of rules for this ruleset */\n  rules?: InputMaybe<Array<RepositoryRuleInput>>;\n  /** The target of the ruleset. */\n  target?: InputMaybe<RepositoryRulesetTarget>;\n};\n\n/** Autogenerated return type of UpdateRepositoryRuleset */\nexport type UpdateRepositoryRulesetPayload = {\n  __typename?: 'UpdateRepositoryRulesetPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The newly created Ruleset. */\n  ruleset?: Maybe<RepositoryRuleset>;\n};\n\n/** Autogenerated input type of UpdateRepositoryWebCommitSignoffSetting */\nexport type UpdateRepositoryWebCommitSignoffSettingInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the repository to update. */\n  repositoryId: Scalars['ID'];\n  /** Indicates if the repository should require signoff on web-based commits. */\n  webCommitSignoffRequired: Scalars['Boolean'];\n};\n\n/** Autogenerated return type of UpdateRepositoryWebCommitSignoffSetting */\nexport type UpdateRepositoryWebCommitSignoffSettingPayload = {\n  __typename?: 'UpdateRepositoryWebCommitSignoffSettingPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** A message confirming the result of updating the web commit signoff setting. */\n  message?: Maybe<Scalars['String']>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** Autogenerated input type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /**\n   * Specify whether others should be able to see that the sponsor is sponsoring\n   * the sponsorable. Public visibility still does not reveal which tier is used.\n   */\n  privacyLevel?: InputMaybe<SponsorshipPrivacy>;\n  /** Whether the sponsor should receive email updates from the sponsorable. */\n  receiveEmails?: InputMaybe<Scalars['Boolean']>;\n  /**\n   * The ID of the user or organization who is acting as the sponsor, paying for\n   * the sponsorship. Required if sponsorLogin is not given.\n   */\n  sponsorId?: InputMaybe<Scalars['ID']>;\n  /**\n   * The username of the user or organization who is acting as the sponsor, paying\n   * for the sponsorship. Required if sponsorId is not given.\n   */\n  sponsorLogin?: InputMaybe<Scalars['String']>;\n  /** The ID of the user or organization who is receiving the sponsorship. Required if sponsorableLogin is not given. */\n  sponsorableId?: InputMaybe<Scalars['ID']>;\n  /** The username of the user or organization who is receiving the sponsorship. Required if sponsorableId is not given. */\n  sponsorableLogin?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateSponsorshipPreferences */\nexport type UpdateSponsorshipPreferencesPayload = {\n  __typename?: 'UpdateSponsorshipPreferencesPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The sponsorship that was updated. */\n  sponsorship?: Maybe<Sponsorship>;\n};\n\n/** Autogenerated input type of UpdateSubscription */\nexport type UpdateSubscriptionInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The new state of the subscription. */\n  state: SubscriptionState;\n  /** The Node ID of the subscribable object to modify. */\n  subscribableId: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateSubscription */\nexport type UpdateSubscriptionPayload = {\n  __typename?: 'UpdateSubscriptionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The input subscribable entity. */\n  subscribable?: Maybe<Subscribable>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentInput = {\n  /** The updated text of the comment. */\n  body: Scalars['String'];\n  /** The current version of the body content. */\n  bodyVersion?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the comment to modify. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of UpdateTeamDiscussionComment */\nexport type UpdateTeamDiscussionCommentPayload = {\n  __typename?: 'UpdateTeamDiscussionCommentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated comment. */\n  teamDiscussionComment?: Maybe<TeamDiscussionComment>;\n};\n\n/** Autogenerated input type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionInput = {\n  /** The updated text of the discussion. */\n  body?: InputMaybe<Scalars['String']>;\n  /**\n   * The current version of the body content. If provided, this update operation\n   * will be rejected if the given version does not match the latest version on the server.\n   */\n  bodyVersion?: InputMaybe<Scalars['String']>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the discussion to modify. */\n  id: Scalars['ID'];\n  /** If provided, sets the pinned state of the updated discussion. */\n  pinned?: InputMaybe<Scalars['Boolean']>;\n  /** The updated title of the discussion. */\n  title?: InputMaybe<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateTeamDiscussion */\nexport type UpdateTeamDiscussionPayload = {\n  __typename?: 'UpdateTeamDiscussionPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The updated discussion. */\n  teamDiscussion?: Maybe<TeamDiscussion>;\n};\n\n/** Autogenerated input type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentInput = {\n  /** The algorithm to use for review assignment */\n  algorithm?: InputMaybe<TeamReviewAssignmentAlgorithm>;\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Turn on or off review assignment */\n  enabled: Scalars['Boolean'];\n  /** An array of team member IDs to exclude */\n  excludedTeamMemberIds?: InputMaybe<Array<Scalars['ID']>>;\n  /** The Node ID of the team to update review assignments of */\n  id: Scalars['ID'];\n  /** Notify the entire team of the PR if it is delegated */\n  notifyTeam?: InputMaybe<Scalars['Boolean']>;\n  /** The number of team members to assign */\n  teamMemberCount?: InputMaybe<Scalars['Int']>;\n};\n\n/** Autogenerated return type of UpdateTeamReviewAssignment */\nexport type UpdateTeamReviewAssignmentPayload = {\n  __typename?: 'UpdateTeamReviewAssignmentPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The team that was modified */\n  team?: Maybe<Team>;\n};\n\n/** Autogenerated input type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** Permission that should be granted to the teams. */\n  permission: RepositoryPermission;\n  /** Repository ID being granted access to. */\n  repositoryId: Scalars['ID'];\n  /** A list of teams being granted access. Limit: 10 */\n  teamIds: Array<Scalars['ID']>;\n};\n\n/** Autogenerated return type of UpdateTeamsRepository */\nexport type UpdateTeamsRepositoryPayload = {\n  __typename?: 'UpdateTeamsRepositoryPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The repository that was updated. */\n  repository?: Maybe<Repository>;\n  /** The teams granted permission on the repository. */\n  teams?: Maybe<Array<Team>>;\n};\n\n/** Autogenerated input type of UpdateTopics */\nexport type UpdateTopicsInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The Node ID of the repository. */\n  repositoryId: Scalars['ID'];\n  /** An array of topic names. */\n  topicNames: Array<Scalars['String']>;\n};\n\n/** Autogenerated return type of UpdateTopics */\nexport type UpdateTopicsPayload = {\n  __typename?: 'UpdateTopicsPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** Names of the provided topics that are not valid. */\n  invalidTopicNames?: Maybe<Array<Scalars['String']>>;\n  /** The updated repository. */\n  repository?: Maybe<Repository>;\n};\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type User = Actor & Node & PackageOwner & ProfileOwner & ProjectOwner & ProjectV2Owner & ProjectV2Recent & RepositoryDiscussionAuthor & RepositoryDiscussionCommentAuthor & RepositoryOwner & Sponsorable & UniformResourceLocatable & {\n  __typename?: 'User';\n  /** Determine if this repository owner has any items that can be pinned to their profile. */\n  anyPinnableItems: Scalars['Boolean'];\n  /** A URL pointing to the user's public avatar. */\n  avatarUrl: Scalars['URI'];\n  /** The user's public profile bio. */\n  bio?: Maybe<Scalars['String']>;\n  /** The user's public profile bio as HTML. */\n  bioHTML: Scalars['HTML'];\n  /** Could this user receive email notifications, if the organization had notification restrictions enabled? */\n  canReceiveOrganizationEmailsWhenNotificationsRestricted: Scalars['Boolean'];\n  /** A list of commit comments made by this user. */\n  commitComments: CommitCommentConnection;\n  /** The user's public profile company. */\n  company?: Maybe<Scalars['String']>;\n  /** The user's public profile company as HTML. */\n  companyHTML: Scalars['HTML'];\n  /** The collection of contributions this user has made to different repositories. */\n  contributionsCollection: ContributionsCollection;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The user's publicly visible profile email. */\n  email: Scalars['String'];\n  /** The estimated next GitHub Sponsors payout for this user/organization in cents (USD). */\n  estimatedNextSponsorsPayoutInCents: Scalars['Int'];\n  /** A list of users the given user is followed by. */\n  followers: FollowerConnection;\n  /** A list of users the given user is following. */\n  following: FollowingConnection;\n  /** Find gist by repo name. */\n  gist?: Maybe<Gist>;\n  /** A list of gist comments made by this user. */\n  gistComments: GistCommentConnection;\n  /** A list of the Gists the user has created. */\n  gists: GistConnection;\n  /** True if this user/organization has a GitHub Sponsors listing. */\n  hasSponsorsListing: Scalars['Boolean'];\n  /** The hovercard information for this user in a given context */\n  hovercard: Hovercard;\n  id: Scalars['ID'];\n  /** The interaction ability settings for this user. */\n  interactionAbility?: Maybe<RepositoryInteractionAbility>;\n  /** Whether or not this user is a participant in the GitHub Security Bug Bounty. */\n  isBountyHunter: Scalars['Boolean'];\n  /** Whether or not this user is a participant in the GitHub Campus Experts Program. */\n  isCampusExpert: Scalars['Boolean'];\n  /** Whether or not this user is a GitHub Developer Program member. */\n  isDeveloperProgramMember: Scalars['Boolean'];\n  /** Whether or not this user is a GitHub employee. */\n  isEmployee: Scalars['Boolean'];\n  /** Whether or not this user is following the viewer. Inverse of viewerIsFollowing */\n  isFollowingViewer: Scalars['Boolean'];\n  /** Whether or not this user is a member of the GitHub Stars Program. */\n  isGitHubStar: Scalars['Boolean'];\n  /** Whether or not the user has marked themselves as for hire. */\n  isHireable: Scalars['Boolean'];\n  /** Whether or not this user is a site administrator. */\n  isSiteAdmin: Scalars['Boolean'];\n  /** Whether the given account is sponsoring this user/organization. */\n  isSponsoredBy: Scalars['Boolean'];\n  /** True if the viewer is sponsored by this user/organization. */\n  isSponsoringViewer: Scalars['Boolean'];\n  /** Whether or not this user is the viewing user. */\n  isViewer: Scalars['Boolean'];\n  /** A list of issue comments made by this user. */\n  issueComments: IssueCommentConnection;\n  /** A list of issues associated with this user. */\n  issues: IssueConnection;\n  /**\n   * Showcases a selection of repositories and gists that the profile owner has\n   * either curated or that have been selected automatically based on popularity.\n   */\n  itemShowcase: ProfileItemShowcase;\n  /** The user's public profile location. */\n  location?: Maybe<Scalars['String']>;\n  /** The username used to login. */\n  login: Scalars['String'];\n  /** The estimated monthly GitHub Sponsors income for this user/organization in cents (USD). */\n  monthlyEstimatedSponsorsIncomeInCents: Scalars['Int'];\n  /** The user's public profile name. */\n  name?: Maybe<Scalars['String']>;\n  /** Find an organization by its login that the user belongs to. */\n  organization?: Maybe<Organization>;\n  /** Verified email addresses that match verified domains for a specified organization the user is a member of. */\n  organizationVerifiedDomainEmails: Array<Scalars['String']>;\n  /** A list of organizations the user belongs to. */\n  organizations: OrganizationConnection;\n  /** A list of packages under the owner. */\n  packages: PackageConnection;\n  /** A list of repositories and gists this profile owner can pin to their profile. */\n  pinnableItems: PinnableItemConnection;\n  /** A list of repositories and gists this profile owner has pinned to their profile */\n  pinnedItems: PinnableItemConnection;\n  /** Returns how many more items this profile owner can pin to their profile. */\n  pinnedItemsRemaining: Scalars['Int'];\n  /** Find project by number. */\n  project?: Maybe<Project>;\n  /** Find a project by number. */\n  projectV2?: Maybe<ProjectV2>;\n  /** A list of projects under the owner. */\n  projects: ProjectConnection;\n  /** The HTTP path listing user's projects */\n  projectsResourcePath: Scalars['URI'];\n  /** The HTTP URL listing user's projects */\n  projectsUrl: Scalars['URI'];\n  /** A list of projects under the owner. */\n  projectsV2: ProjectV2Connection;\n  /** The user's profile pronouns */\n  pronouns?: Maybe<Scalars['String']>;\n  /** A list of public keys associated with this user. */\n  publicKeys: PublicKeyConnection;\n  /** A list of pull requests associated with this user. */\n  pullRequests: PullRequestConnection;\n  /** Recent projects that this user has modified in the context of the owner. */\n  recentProjects: ProjectV2Connection;\n  /** A list of repositories that the user owns. */\n  repositories: RepositoryConnection;\n  /** A list of repositories that the user recently contributed to. */\n  repositoriesContributedTo: RepositoryConnection;\n  /** Find Repository. */\n  repository?: Maybe<Repository>;\n  /** Discussion comments this user has authored. */\n  repositoryDiscussionComments: DiscussionCommentConnection;\n  /** Discussions this user has started. */\n  repositoryDiscussions: DiscussionConnection;\n  /** The HTTP path for this user */\n  resourcePath: Scalars['URI'];\n  /** Replies this user has saved */\n  savedReplies?: Maybe<SavedReplyConnection>;\n  /** The user's social media accounts, ordered as they appear on the user's profile. */\n  socialAccounts: SocialAccountConnection;\n  /** List of users and organizations this entity is sponsoring. */\n  sponsoring: SponsorConnection;\n  /** List of sponsors for this user or organization. */\n  sponsors: SponsorConnection;\n  /** Events involving this sponsorable, such as new sponsorships. */\n  sponsorsActivities: SponsorsActivityConnection;\n  /** The GitHub Sponsors listing for this user or organization. */\n  sponsorsListing?: Maybe<SponsorsListing>;\n  /** The sponsorship from the viewer to this user/organization; that is, the sponsorship where you're the sponsor. */\n  sponsorshipForViewerAsSponsor?: Maybe<Sponsorship>;\n  /** The sponsorship from this user/organization to the viewer; that is, the sponsorship you're receiving. */\n  sponsorshipForViewerAsSponsorable?: Maybe<Sponsorship>;\n  /** List of sponsorship updates sent from this sponsorable to sponsors. */\n  sponsorshipNewsletters: SponsorshipNewsletterConnection;\n  /** The sponsorships where this user or organization is the maintainer receiving the funds. */\n  sponsorshipsAsMaintainer: SponsorshipConnection;\n  /** The sponsorships where this user or organization is the funder. */\n  sponsorshipsAsSponsor: SponsorshipConnection;\n  /** Repositories the user has starred. */\n  starredRepositories: StarredRepositoryConnection;\n  /** The user's description of what they're currently doing. */\n  status?: Maybe<UserStatus>;\n  /** Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created */\n  topRepositories: RepositoryConnection;\n  /**\n   * The amount in United States cents (e.g., 500 = $5.00 USD) that this entity has\n   * spent on GitHub to fund sponsorships. Only returns a value when viewed by the\n   * user themselves or by a user who can manage sponsorships for the requested organization.\n   */\n  totalSponsorshipAmountAsSponsorInCents?: Maybe<Scalars['Int']>;\n  /** The user's Twitter username. */\n  twitterUsername?: Maybe<Scalars['String']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this user */\n  url: Scalars['URI'];\n  /** Can the viewer pin repositories and gists to the profile? */\n  viewerCanChangePinnedItems: Scalars['Boolean'];\n  /** Can the current viewer create new projects on this owner. */\n  viewerCanCreateProjects: Scalars['Boolean'];\n  /** Whether or not the viewer is able to follow the user. */\n  viewerCanFollow: Scalars['Boolean'];\n  /** Whether or not the viewer is able to sponsor this user/organization. */\n  viewerCanSponsor: Scalars['Boolean'];\n  /** Whether or not this user is followed by the viewer. Inverse of isFollowingViewer. */\n  viewerIsFollowing: Scalars['Boolean'];\n  /** True if the viewer is sponsoring this user/organization. */\n  viewerIsSponsoring: Scalars['Boolean'];\n  /** A list of repositories the given user is watching. */\n  watching: RepositoryConnection;\n  /** A URL pointing to the user's public website/blog. */\n  websiteUrl?: Maybe<Scalars['URI']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAnyPinnableItemsArgs = {\n  type?: InputMaybe<PinnableItemType>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserAvatarUrlArgs = {\n  size?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCanReceiveOrganizationEmailsWhenNotificationsRestrictedArgs = {\n  login: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserCommitCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserContributionsCollectionArgs = {\n  from?: InputMaybe<Scalars['DateTime']>;\n  organizationID?: InputMaybe<Scalars['ID']>;\n  to?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserFollowingArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistArgs = {\n  name: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserGistsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<GistOrder>;\n  privacy?: InputMaybe<GistPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserHovercardArgs = {\n  primarySubjectId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIsSponsoredByArgs = {\n  accountLogin: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssueCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueCommentOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserIssuesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  filterBy?: InputMaybe<IssueFilters>;\n  first?: InputMaybe<Scalars['Int']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<IssueState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationArgs = {\n  login: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationVerifiedDomainEmailsArgs = {\n  login: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserOrganizationsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<OrganizationOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPackagesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  names?: InputMaybe<Array<InputMaybe<Scalars['String']>>>;\n  orderBy?: InputMaybe<PackageOrder>;\n  packageType?: InputMaybe<PackageType>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnableItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPinnedItemsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  types?: InputMaybe<Array<PinnableItemType>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectArgs = {\n  number: Scalars['Int'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectV2Args = {\n  number: Scalars['Int'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectOrder>;\n  search?: InputMaybe<Scalars['String']>;\n  states?: InputMaybe<Array<ProjectState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserProjectsV2Args = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<ProjectV2Order>;\n  query?: InputMaybe<Scalars['String']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPublicKeysArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserPullRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  baseRefName?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  headRefName?: InputMaybe<Scalars['String']>;\n  labels?: InputMaybe<Array<Scalars['String']>>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<IssueOrder>;\n  states?: InputMaybe<Array<PullRequestState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRecentProjectsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isFork?: InputMaybe<Scalars['Boolean']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoriesContributedToArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  contributionTypes?: InputMaybe<Array<InputMaybe<RepositoryContributionType>>>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeUserRepositories?: InputMaybe<Scalars['Boolean']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryArgs = {\n  followRenames?: InputMaybe<Scalars['Boolean']>;\n  name: Scalars['String'];\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionCommentsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  onlyAnswers?: InputMaybe<Scalars['Boolean']>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserRepositoryDiscussionsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  answered?: InputMaybe<Scalars['Boolean']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<DiscussionOrder>;\n  repositoryId?: InputMaybe<Scalars['ID']>;\n  states?: InputMaybe<Array<DiscussionState>>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSavedRepliesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SavedReplyOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSocialAccountsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsoringArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorOrder>;\n  tierId?: InputMaybe<Scalars['ID']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorsActivitiesArgs = {\n  actions?: InputMaybe<Array<SponsorsActivityAction>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includeAsSponsor?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorsActivityOrder>;\n  period?: InputMaybe<SponsorsActivityPeriod>;\n  since?: InputMaybe<Scalars['DateTime']>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipForViewerAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipForViewerAsSponsorableArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipNewslettersArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipNewsletterOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsMaintainerArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  includePrivate?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserSponsorshipsAsSponsorArgs = {\n  activeOnly?: InputMaybe<Scalars['Boolean']>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  maintainerLogins?: InputMaybe<Array<Scalars['String']>>;\n  orderBy?: InputMaybe<SponsorshipOrder>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserStarredRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<StarOrder>;\n  ownedByViewer?: InputMaybe<Scalars['Boolean']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTopRepositoriesArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy: RepositoryOrder;\n  since?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserTotalSponsorshipAmountAsSponsorInCentsArgs = {\n  since?: InputMaybe<Scalars['DateTime']>;\n  sponsorableLogins?: InputMaybe<Array<Scalars['String']>>;\n  until?: InputMaybe<Scalars['DateTime']>;\n};\n\n\n/** A user is an individual's account on GitHub that owns repositories and can make new content. */\nexport type UserWatchingArgs = {\n  affiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  isLocked?: InputMaybe<Scalars['Boolean']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<RepositoryOrder>;\n  ownerAffiliations?: InputMaybe<Array<InputMaybe<RepositoryAffiliation>>>;\n  privacy?: InputMaybe<RepositoryPrivacy>;\n};\n\n/** The possible durations that a user can be blocked for. */\nexport enum UserBlockDuration {\n  /** The user was blocked for 1 day */\n  OneDay = 'ONE_DAY',\n  /** The user was blocked for 30 days */\n  OneMonth = 'ONE_MONTH',\n  /** The user was blocked for 7 days */\n  OneWeek = 'ONE_WEEK',\n  /** The user was blocked permanently */\n  Permanent = 'PERMANENT',\n  /** The user was blocked for 3 days */\n  ThreeDays = 'THREE_DAYS'\n}\n\n/** Represents a 'user_blocked' event on a given user. */\nexport type UserBlockedEvent = Node & {\n  __typename?: 'UserBlockedEvent';\n  /** Identifies the actor who performed the event. */\n  actor?: Maybe<Actor>;\n  /** Number of days that the user was blocked for. */\n  blockDuration: UserBlockDuration;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  id: Scalars['ID'];\n  /** The user who was blocked. */\n  subject?: Maybe<User>;\n};\n\n/** The connection type for User. */\nexport type UserConnection = {\n  __typename?: 'UserConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<User>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edit on user content */\nexport type UserContentEdit = Node & {\n  __typename?: 'UserContentEdit';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the date and time when the object was deleted. */\n  deletedAt?: Maybe<Scalars['DateTime']>;\n  /** The actor who deleted this content */\n  deletedBy?: Maybe<Actor>;\n  /** A summary of the changes for this edit */\n  diff?: Maybe<Scalars['String']>;\n  /** When this content was edited */\n  editedAt: Scalars['DateTime'];\n  /** The actor who edited this content */\n  editor?: Maybe<Actor>;\n  id: Scalars['ID'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n};\n\n/** A list of edits to content. */\nexport type UserContentEditConnection = {\n  __typename?: 'UserContentEditConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserContentEditEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserContentEdit>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type UserContentEditEdge = {\n  __typename?: 'UserContentEditEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserContentEdit>;\n};\n\n/** Represents a user. */\nexport type UserEdge = {\n  __typename?: 'UserEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<User>;\n};\n\n/** Email attributes from External Identity */\nexport type UserEmailMetadata = {\n  __typename?: 'UserEmailMetadata';\n  /** Boolean to identify primary emails */\n  primary?: Maybe<Scalars['Boolean']>;\n  /** Type of email */\n  type?: Maybe<Scalars['String']>;\n  /** Email id */\n  value: Scalars['String'];\n};\n\n/** The user's description of what they're currently doing. */\nexport type UserStatus = Node & {\n  __typename?: 'UserStatus';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** An emoji summarizing the user's status. */\n  emoji?: Maybe<Scalars['String']>;\n  /** The status emoji as HTML. */\n  emojiHTML?: Maybe<Scalars['HTML']>;\n  /** If set, the status will not be shown after this date. */\n  expiresAt?: Maybe<Scalars['DateTime']>;\n  id: Scalars['ID'];\n  /** Whether this status indicates the user is not fully available on GitHub. */\n  indicatesLimitedAvailability: Scalars['Boolean'];\n  /** A brief message describing what the user is doing. */\n  message?: Maybe<Scalars['String']>;\n  /** The organization whose members can see this status. If null, this status is publicly visible. */\n  organization?: Maybe<Organization>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The user who has this status. */\n  user: User;\n};\n\n/** The connection type for UserStatus. */\nexport type UserStatusConnection = {\n  __typename?: 'UserStatusConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<UserStatusEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<UserStatus>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type UserStatusEdge = {\n  __typename?: 'UserStatusEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<UserStatus>;\n};\n\n/** Ordering options for user status connections. */\nexport type UserStatusOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order user statuses by. */\n  field: UserStatusOrderField;\n};\n\n/** Properties by which user status connections can be ordered. */\nexport enum UserStatusOrderField {\n  /** Order user statuses by when they were updated. */\n  UpdatedAt = 'UPDATED_AT'\n}\n\n/** A domain that can be verified or approved for an organization or an enterprise. */\nexport type VerifiableDomain = Node & {\n  __typename?: 'VerifiableDomain';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The DNS host name that should be used for verification. */\n  dnsHostName?: Maybe<Scalars['URI']>;\n  /** The unicode encoded domain. */\n  domain: Scalars['URI'];\n  /** Whether a TXT record for verification with the expected host name was found. */\n  hasFoundHostName: Scalars['Boolean'];\n  /** Whether a TXT record for verification with the expected verification token was found. */\n  hasFoundVerificationToken: Scalars['Boolean'];\n  id: Scalars['ID'];\n  /** Whether or not the domain is approved. */\n  isApproved: Scalars['Boolean'];\n  /** Whether this domain is required to exist for an organization or enterprise policy to be enforced. */\n  isRequiredForPolicyEnforcement: Scalars['Boolean'];\n  /** Whether or not the domain is verified. */\n  isVerified: Scalars['Boolean'];\n  /** The owner of the domain. */\n  owner: VerifiableDomainOwner;\n  /** The punycode encoded domain. */\n  punycodeEncodedDomain: Scalars['URI'];\n  /** The time that the current verification token will expire. */\n  tokenExpirationTime?: Maybe<Scalars['DateTime']>;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The current verification token for the domain. */\n  verificationToken?: Maybe<Scalars['String']>;\n};\n\n/** The connection type for VerifiableDomain. */\nexport type VerifiableDomainConnection = {\n  __typename?: 'VerifiableDomainConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<VerifiableDomainEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<VerifiableDomain>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type VerifiableDomainEdge = {\n  __typename?: 'VerifiableDomainEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<VerifiableDomain>;\n};\n\n/** Ordering options for verifiable domain connections. */\nexport type VerifiableDomainOrder = {\n  /** The ordering direction. */\n  direction: OrderDirection;\n  /** The field to order verifiable domains by. */\n  field: VerifiableDomainOrderField;\n};\n\n/** Properties by which verifiable domain connections can be ordered. */\nexport enum VerifiableDomainOrderField {\n  /** Order verifiable domains by their creation date. */\n  CreatedAt = 'CREATED_AT',\n  /** Order verifiable domains by the domain name. */\n  Domain = 'DOMAIN'\n}\n\n/** Types that can own a verifiable domain. */\nexport type VerifiableDomainOwner = Enterprise | Organization;\n\n/** Autogenerated input type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainInput = {\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: InputMaybe<Scalars['String']>;\n  /** The ID of the verifiable domain to verify. */\n  id: Scalars['ID'];\n};\n\n/** Autogenerated return type of VerifyVerifiableDomain */\nexport type VerifyVerifiableDomainPayload = {\n  __typename?: 'VerifyVerifiableDomainPayload';\n  /** A unique identifier for the client performing the mutation. */\n  clientMutationId?: Maybe<Scalars['String']>;\n  /** The verifiable domain that was verified. */\n  domain?: Maybe<VerifiableDomain>;\n};\n\n/** A hovercard context with a message describing how the viewer is related. */\nexport type ViewerHovercardContext = HovercardContext & {\n  __typename?: 'ViewerHovercardContext';\n  /** A string describing this context */\n  message: Scalars['String'];\n  /** An octicon to accompany this context */\n  octicon: Scalars['String'];\n  /** Identifies the user who is related to this context. */\n  viewer: User;\n};\n\n/** A subject that may be upvoted. */\nexport type Votable = {\n  /** Number of upvotes that this subject has received. */\n  upvoteCount: Scalars['Int'];\n  /** Whether or not the current user can add or remove an upvote on this subject. */\n  viewerCanUpvote: Scalars['Boolean'];\n  /** Whether or not the current user has already upvoted this subject. */\n  viewerHasUpvoted: Scalars['Boolean'];\n};\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type Workflow = Node & UniformResourceLocatable & {\n  __typename?: 'Workflow';\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  id: Scalars['ID'];\n  /** The name of the workflow. */\n  name: Scalars['String'];\n  /** The HTTP path for this workflow */\n  resourcePath: Scalars['URI'];\n  /** The runs of the workflow. */\n  runs: WorkflowRunConnection;\n  /** The state of the workflow. */\n  state: WorkflowState;\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this workflow */\n  url: Scalars['URI'];\n};\n\n\n/** A workflow contains meta information about an Actions workflow file. */\nexport type WorkflowRunsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  orderBy?: InputMaybe<WorkflowRunOrder>;\n};\n\n/** A workflow run. */\nexport type WorkflowRun = Node & UniformResourceLocatable & {\n  __typename?: 'WorkflowRun';\n  /** The check suite this workflow run belongs to. */\n  checkSuite: CheckSuite;\n  /** Identifies the date and time when the object was created. */\n  createdAt: Scalars['DateTime'];\n  /** Identifies the primary key from the database. */\n  databaseId?: Maybe<Scalars['Int']>;\n  /** The log of deployment reviews */\n  deploymentReviews: DeploymentReviewConnection;\n  /** The event that triggered the workflow run */\n  event: Scalars['String'];\n  /** The workflow file */\n  file?: Maybe<WorkflowRunFile>;\n  id: Scalars['ID'];\n  /** The pending deployment requests of all check runs in this workflow run */\n  pendingDeploymentRequests: DeploymentRequestConnection;\n  /** The HTTP path for this workflow run */\n  resourcePath: Scalars['URI'];\n  /** A number that uniquely identifies this workflow run in its parent workflow. */\n  runNumber: Scalars['Int'];\n  /** Identifies the date and time when the object was last updated. */\n  updatedAt: Scalars['DateTime'];\n  /** The HTTP URL for this workflow run */\n  url: Scalars['URI'];\n  /** The workflow executed in this workflow run. */\n  workflow: Workflow;\n};\n\n\n/** A workflow run. */\nexport type WorkflowRunDeploymentReviewsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n\n/** A workflow run. */\nexport type WorkflowRunPendingDeploymentRequestsArgs = {\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n};\n\n/** The connection type for WorkflowRun. */\nexport type WorkflowRunConnection = {\n  __typename?: 'WorkflowRunConnection';\n  /** A list of edges. */\n  edges?: Maybe<Array<Maybe<WorkflowRunEdge>>>;\n  /** A list of nodes. */\n  nodes?: Maybe<Array<Maybe<WorkflowRun>>>;\n  /** Information to aid in pagination. */\n  pageInfo: PageInfo;\n  /** Identifies the total count of items in the connection. */\n  totalCount: Scalars['Int'];\n};\n\n/** An edge in a connection. */\nexport type WorkflowRunEdge = {\n  __typename?: 'WorkflowRunEdge';\n  /** A cursor for use in pagination. */\n  cursor: Scalars['String'];\n  /** The item at the end of the edge. */\n  node?: Maybe<WorkflowRun>;\n};\n\n/** An executed workflow file for a workflow run. */\nexport type WorkflowRunFile = Node & UniformResourceLocatable & {\n  __typename?: 'WorkflowRunFile';\n  id: Scalars['ID'];\n  /** The path of the workflow file relative to its repository. */\n  path: Scalars['String'];\n  /** The direct link to the file in the repository which stores the workflow file. */\n  repositoryFileUrl: Scalars['URI'];\n  /** The repository name and owner which stores the workflow file. */\n  repositoryName: Scalars['URI'];\n  /** The HTTP path for this workflow run file */\n  resourcePath: Scalars['URI'];\n  /** The parent workflow run execution for this file. */\n  run: WorkflowRun;\n  /** The HTTP URL for this workflow run file */\n  url: Scalars['URI'];\n  /** If the viewer has permissions to push to the repository which stores the workflow. */\n  viewerCanPushRepository: Scalars['Boolean'];\n  /** If the viewer has permissions to read the repository which stores the workflow. */\n  viewerCanReadRepository: Scalars['Boolean'];\n};\n\n/** Ways in which lists of workflow runs can be ordered upon return. */\nexport type WorkflowRunOrder = {\n  /** The direction in which to order workflow runs by the specified field. */\n  direction: OrderDirection;\n  /** The field by which to order workflows. */\n  field: WorkflowRunOrderField;\n};\n\n/** Properties by which workflow run connections can be ordered. */\nexport enum WorkflowRunOrderField {\n  /** Order workflow runs by most recently created */\n  CreatedAt = 'CREATED_AT'\n}\n\n/** The possible states for a workflow. */\nexport enum WorkflowState {\n  /** The workflow is active. */\n  Active = 'ACTIVE',\n  /** The workflow was deleted from the git repository. */\n  Deleted = 'DELETED',\n  /** The workflow was disabled by default on a fork. */\n  DisabledFork = 'DISABLED_FORK',\n  /** The workflow was disabled for inactivity in the repository. */\n  DisabledInactivity = 'DISABLED_INACTIVITY',\n  /** The workflow was disabled manually. */\n  DisabledManually = 'DISABLED_MANUALLY'\n}\n\nexport type AddCommentMutationVariables = Exact<{\n  id: Scalars['ID'];\n  body: Scalars['String'];\n}>;\n\n\nexport type AddCommentMutationData = { __typename?: 'Mutation', addComment?: { __typename?: 'AddCommentPayload', subject?: { __typename?: 'AddedToMergeQueueEvent', id: string } | { __typename?: 'AddedToProjectEvent', id: string } | { __typename?: 'App', id: string } | { __typename?: 'AssignedEvent', id: string } | { __typename?: 'AutoMergeDisabledEvent', id: string } | { __typename?: 'AutoMergeEnabledEvent', id: string } | { __typename?: 'AutoRebaseEnabledEvent', id: string } | { __typename?: 'AutoSquashEnabledEvent', id: string } | { __typename?: 'AutomaticBaseChangeFailedEvent', id: string } | { __typename?: 'AutomaticBaseChangeSucceededEvent', id: string } | { __typename?: 'BaseRefChangedEvent', id: string } | { __typename?: 'BaseRefDeletedEvent', id: string } | { __typename?: 'BaseRefForcePushedEvent', id: string } | { __typename?: 'Blob', id: string } | { __typename?: 'Bot', id: string } | { __typename?: 'BranchProtectionRule', id: string } | { __typename?: 'BypassForcePushAllowance', id: string } | { __typename?: 'BypassPullRequestAllowance', id: string } | { __typename?: 'CWE', id: string } | { __typename?: 'CheckRun', id: string } | { __typename?: 'CheckSuite', id: string } | { __typename?: 'ClosedEvent', id: string } | { __typename?: 'CodeOfConduct', id: string } | { __typename?: 'CommentDeletedEvent', id: string } | { __typename?: 'Commit', id: string } | { __typename?: 'CommitComment', id: string } | { __typename?: 'CommitCommentThread', id: string } | { __typename?: 'Comparison', id: string } | { __typename?: 'ConnectedEvent', id: string } | { __typename?: 'ConvertToDraftEvent', id: string } | { __typename?: 'ConvertedNoteToIssueEvent', id: string } | { __typename?: 'ConvertedToDiscussionEvent', id: string } | { __typename?: 'CrossReferencedEvent', id: string } | { __typename?: 'DemilestonedEvent', id: string } | { __typename?: 'DependencyGraphManifest', id: string } | { __typename?: 'DeployKey', id: string } | { __typename?: 'DeployedEvent', id: string } | { __typename?: 'Deployment', id: string } | { __typename?: 'DeploymentEnvironmentChangedEvent', id: string } | { __typename?: 'DeploymentReview', id: string } | { __typename?: 'DeploymentStatus', id: string } | { __typename?: 'DisconnectedEvent', id: string } | { __typename?: 'Discussion', id: string } | { __typename?: 'DiscussionCategory', id: string } | { __typename?: 'DiscussionComment', id: string } | { __typename?: 'DiscussionPoll', id: string } | { __typename?: 'DiscussionPollOption', id: string } | { __typename?: 'DraftIssue', id: string } | { __typename?: 'Enterprise', id: string } | { __typename?: 'EnterpriseAdministratorInvitation', id: string } | { __typename?: 'EnterpriseIdentityProvider', id: string } | { __typename?: 'EnterpriseRepositoryInfo', id: string } | { __typename?: 'EnterpriseServerInstallation', id: string } | { __typename?: 'EnterpriseServerUserAccount', id: string } | { __typename?: 'EnterpriseServerUserAccountEmail', id: string } | { __typename?: 'EnterpriseServerUserAccountsUpload', id: string } | { __typename?: 'EnterpriseUserAccount', id: string } | { __typename?: 'Environment', id: string } | { __typename?: 'ExternalIdentity', id: string } | { __typename?: 'Gist', id: string } | { __typename?: 'GistComment', id: string } | { __typename?: 'HeadRefDeletedEvent', id: string } | { __typename?: 'HeadRefForcePushedEvent', id: string } | { __typename?: 'HeadRefRestoredEvent', id: string } | { __typename?: 'IpAllowListEntry', id: string } | { __typename?: 'Issue', id: string } | { __typename?: 'IssueComment', id: string } | { __typename?: 'Label', id: string } | { __typename?: 'LabeledEvent', id: string } | { __typename?: 'Language', id: string } | { __typename?: 'License', id: string } | { __typename?: 'LinkedBranch', id: string } | { __typename?: 'LockedEvent', id: string } | { __typename?: 'Mannequin', id: string } | { __typename?: 'MarkedAsDuplicateEvent', id: string } | { __typename?: 'MarketplaceCategory', id: string } | { __typename?: 'MarketplaceListing', id: string } | { __typename?: 'MembersCanDeleteReposClearAuditEntry', id: string } | { __typename?: 'MembersCanDeleteReposDisableAuditEntry', id: string } | { __typename?: 'MembersCanDeleteReposEnableAuditEntry', id: string } | { __typename?: 'MentionedEvent', id: string } | { __typename?: 'MergeQueue', id: string } | { __typename?: 'MergeQueueEntry', id: string } | { __typename?: 'MergedEvent', id: string } | { __typename?: 'MigrationSource', id: string } | { __typename?: 'Milestone', id: string } | { __typename?: 'MilestonedEvent', id: string } | { __typename?: 'MovedColumnsInProjectEvent', id: string } | { __typename?: 'OIDCProvider', id: string } | { __typename?: 'OauthApplicationCreateAuditEntry', id: string } | { __typename?: 'OrgAddBillingManagerAuditEntry', id: string } | { __typename?: 'OrgAddMemberAuditEntry', id: string } | { __typename?: 'OrgBlockUserAuditEntry', id: string } | { __typename?: 'OrgConfigDisableCollaboratorsOnlyAuditEntry', id: string } | { __typename?: 'OrgConfigEnableCollaboratorsOnlyAuditEntry', id: string } | { __typename?: 'OrgCreateAuditEntry', id: string } | { __typename?: 'OrgDisableOauthAppRestrictionsAuditEntry', id: string } | { __typename?: 'OrgDisableSamlAuditEntry', id: string } | { __typename?: 'OrgDisableTwoFactorRequirementAuditEntry', id: string } | { __typename?: 'OrgEnableOauthAppRestrictionsAuditEntry', id: string } | { __typename?: 'OrgEnableSamlAuditEntry', id: string } | { __typename?: 'OrgEnableTwoFactorRequirementAuditEntry', id: string } | { __typename?: 'OrgInviteMemberAuditEntry', id: string } | { __typename?: 'OrgInviteToBusinessAuditEntry', id: string } | { __typename?: 'OrgOauthAppAccessApprovedAuditEntry', id: string } | { __typename?: 'OrgOauthAppAccessDeniedAuditEntry', id: string } | { __typename?: 'OrgOauthAppAccessRequestedAuditEntry', id: string } | { __typename?: 'OrgRemoveBillingManagerAuditEntry', id: string } | { __typename?: 'OrgRemoveMemberAuditEntry', id: string } | { __typename?: 'OrgRemoveOutsideCollaboratorAuditEntry', id: string } | { __typename?: 'OrgRestoreMemberAuditEntry', id: string } | { __typename?: 'OrgUnblockUserAuditEntry', id: string } | { __typename?: 'OrgUpdateDefaultRepositoryPermissionAuditEntry', id: string } | { __typename?: 'OrgUpdateMemberAuditEntry', id: string } | { __typename?: 'OrgUpdateMemberRepositoryCreationPermissionAuditEntry', id: string } | { __typename?: 'OrgUpdateMemberRepositoryInvitationPermissionAuditEntry', id: string } | { __typename?: 'Organization', id: string } | { __typename?: 'OrganizationIdentityProvider', id: string } | { __typename?: 'OrganizationInvitation', id: string } | { __typename?: 'OrganizationMigration', id: string } | { __typename?: 'Package', id: string } | { __typename?: 'PackageFile', id: string } | { __typename?: 'PackageTag', id: string } | { __typename?: 'PackageVersion', id: string } | { __typename?: 'PinnedDiscussion', id: string } | { __typename?: 'PinnedEvent', id: string } | { __typename?: 'PinnedIssue', id: string } | { __typename?: 'PrivateRepositoryForkingDisableAuditEntry', id: string } | { __typename?: 'PrivateRepositoryForkingEnableAuditEntry', id: string } | { __typename?: 'Project', id: string } | { __typename?: 'ProjectCard', id: string } | { __typename?: 'ProjectColumn', id: string } | { __typename?: 'ProjectV2', id: string } | { __typename?: 'ProjectV2Field', id: string } | { __typename?: 'ProjectV2Item', id: string } | { __typename?: 'ProjectV2ItemFieldDateValue', id: string } | { __typename?: 'ProjectV2ItemFieldIterationValue', id: string } | { __typename?: 'ProjectV2ItemFieldNumberValue', id: string } | { __typename?: 'ProjectV2ItemFieldSingleSelectValue', id: string } | { __typename?: 'ProjectV2ItemFieldTextValue', id: string } | { __typename?: 'ProjectV2IterationField', id: string } | { __typename?: 'ProjectV2SingleSelectField', id: string } | { __typename?: 'ProjectV2View', id: string } | { __typename?: 'ProjectV2Workflow', id: string } | { __typename?: 'PublicKey', id: string } | { __typename?: 'PullRequest', id: string } | { __typename?: 'PullRequestCommit', id: string } | { __typename?: 'PullRequestCommitCommentThread', id: string } | { __typename?: 'PullRequestReview', id: string } | { __typename?: 'PullRequestReviewComment', id: string } | { __typename?: 'PullRequestReviewThread', id: string } | { __typename?: 'PullRequestThread', id: string } | { __typename?: 'Push', id: string } | { __typename?: 'PushAllowance', id: string } | { __typename?: 'Reaction', id: string } | { __typename?: 'ReadyForReviewEvent', id: string } | { __typename?: 'Ref', id: string } | { __typename?: 'ReferencedEvent', id: string } | { __typename?: 'Release', id: string } | { __typename?: 'ReleaseAsset', id: string } | { __typename?: 'RemovedFromMergeQueueEvent', id: string } | { __typename?: 'RemovedFromProjectEvent', id: string } | { __typename?: 'RenamedTitleEvent', id: string } | { __typename?: 'ReopenedEvent', id: string } | { __typename?: 'RepoAccessAuditEntry', id: string } | { __typename?: 'RepoAddMemberAuditEntry', id: string } | { __typename?: 'RepoAddTopicAuditEntry', id: string } | { __typename?: 'RepoArchivedAuditEntry', id: string } | { __typename?: 'RepoChangeMergeSettingAuditEntry', id: string } | { __typename?: 'RepoConfigDisableAnonymousGitAccessAuditEntry', id: string } | { __typename?: 'RepoConfigDisableCollaboratorsOnlyAuditEntry', id: string } | { __typename?: 'RepoConfigDisableContributorsOnlyAuditEntry', id: string } | { __typename?: 'RepoConfigDisableSockpuppetDisallowedAuditEntry', id: string } | { __typename?: 'RepoConfigEnableAnonymousGitAccessAuditEntry', id: string } | { __typename?: 'RepoConfigEnableCollaboratorsOnlyAuditEntry', id: string } | { __typename?: 'RepoConfigEnableContributorsOnlyAuditEntry', id: string } | { __typename?: 'RepoConfigEnableSockpuppetDisallowedAuditEntry', id: string } | { __typename?: 'RepoConfigLockAnonymousGitAccessAuditEntry', id: string } | { __typename?: 'RepoConfigUnlockAnonymousGitAccessAuditEntry', id: string } | { __typename?: 'RepoCreateAuditEntry', id: string } | { __typename?: 'RepoDestroyAuditEntry', id: string } | { __typename?: 'RepoRemoveMemberAuditEntry', id: string } | { __typename?: 'RepoRemoveTopicAuditEntry', id: string } | { __typename?: 'Repository', id: string } | { __typename?: 'RepositoryInvitation', id: string } | { __typename?: 'RepositoryMigration', id: string } | { __typename?: 'RepositoryRule', id: string } | { __typename?: 'RepositoryRuleset', id: string } | { __typename?: 'RepositoryRulesetBypassActor', id: string } | { __typename?: 'RepositoryTopic', id: string } | { __typename?: 'RepositoryVisibilityChangeDisableAuditEntry', id: string } | { __typename?: 'RepositoryVisibilityChangeEnableAuditEntry', id: string } | { __typename?: 'RepositoryVulnerabilityAlert', id: string } | { __typename?: 'ReviewDismissalAllowance', id: string } | { __typename?: 'ReviewDismissedEvent', id: string } | { __typename?: 'ReviewRequest', id: string } | { __typename?: 'ReviewRequestRemovedEvent', id: string } | { __typename?: 'ReviewRequestedEvent', id: string } | { __typename?: 'SavedReply', id: string } | { __typename?: 'SecurityAdvisory', id: string } | { __typename?: 'SponsorsActivity', id: string } | { __typename?: 'SponsorsListing', id: string } | { __typename?: 'SponsorsListingFeaturedItem', id: string } | { __typename?: 'SponsorsTier', id: string } | { __typename?: 'Sponsorship', id: string } | { __typename?: 'SponsorshipNewsletter', id: string } | { __typename?: 'Status', id: string } | { __typename?: 'StatusCheckRollup', id: string } | { __typename?: 'StatusContext', id: string } | { __typename?: 'SubscribedEvent', id: string } | { __typename?: 'Tag', id: string } | { __typename?: 'Team', id: string } | { __typename?: 'TeamAddMemberAuditEntry', id: string } | { __typename?: 'TeamAddRepositoryAuditEntry', id: string } | { __typename?: 'TeamChangeParentTeamAuditEntry', id: string } | { __typename?: 'TeamDiscussion', id: string } | { __typename?: 'TeamDiscussionComment', id: string } | { __typename?: 'TeamRemoveMemberAuditEntry', id: string } | { __typename?: 'TeamRemoveRepositoryAuditEntry', id: string } | { __typename?: 'Topic', id: string } | { __typename?: 'TransferredEvent', id: string } | { __typename?: 'Tree', id: string } | { __typename?: 'UnassignedEvent', id: string } | { __typename?: 'UnlabeledEvent', id: string } | { __typename?: 'UnlockedEvent', id: string } | { __typename?: 'UnmarkedAsDuplicateEvent', id: string } | { __typename?: 'UnpinnedEvent', id: string } | { __typename?: 'UnsubscribedEvent', id: string } | { __typename?: 'User', id: string } | { __typename?: 'UserBlockedEvent', id: string } | { __typename?: 'UserContentEdit', id: string } | { __typename?: 'UserStatus', id: string } | { __typename?: 'VerifiableDomain', id: string } | { __typename?: 'Workflow', id: string } | { __typename?: 'WorkflowRun', id: string } | { __typename?: 'WorkflowRunFile', id: string } | null, commentEdge?: { __typename?: 'IssueCommentEdge', cursor: string, node?: { __typename?: 'IssueComment', id: string } | null } | null, timelineEdge?: { __typename?: 'IssueTimelineItemEdge', cursor: string, node?: { __typename: 'AssignedEvent' } | { __typename: 'ClosedEvent' } | { __typename: 'Commit' } | { __typename: 'CrossReferencedEvent' } | { __typename: 'DemilestonedEvent' } | { __typename: 'IssueComment' } | { __typename: 'LabeledEvent' } | { __typename: 'LockedEvent' } | { __typename: 'MilestonedEvent' } | { __typename: 'ReferencedEvent' } | { __typename: 'RenamedTitleEvent' } | { __typename: 'ReopenedEvent' } | { __typename: 'SubscribedEvent' } | { __typename: 'TransferredEvent' } | { __typename: 'UnassignedEvent' } | { __typename: 'UnlabeledEvent' } | { __typename: 'UnlockedEvent' } | { __typename: 'UnsubscribedEvent' } | { __typename: 'UserBlockedEvent' } | null } | null } | null };\n\nexport type AddLabelsToLabelableMutationVariables = Exact<{\n  input: AddLabelsToLabelableInput;\n}>;\n\n\nexport type AddLabelsToLabelableMutationData = { __typename?: 'Mutation', addLabelsToLabelable?: { __typename?: 'AddLabelsToLabelablePayload', labelable?: { __typename?: 'Discussion', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | { __typename?: 'Issue', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | { __typename?: 'PullRequest', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | null } | null };\n\nexport type AddPullRequestReviewCommentMutationVariables = Exact<{\n  input: AddPullRequestReviewCommentInput;\n}>;\n\n\nexport type AddPullRequestReviewCommentMutationData = { __typename?: 'Mutation', addPullRequestReviewComment?: { __typename?: 'AddPullRequestReviewCommentPayload', comment?: { __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null } | null } | null };\n\nexport type AddPullRequestReviewMutationVariables = Exact<{\n  input: AddPullRequestReviewInput;\n}>;\n\n\nexport type AddPullRequestReviewMutationData = { __typename?: 'Mutation', addPullRequestReview?: { __typename?: 'AddPullRequestReviewPayload', pullRequestReview?: { __typename?: 'PullRequestReview', id: string } | null } | null };\n\nexport type RemoveLabelsFromLabelableMutationVariables = Exact<{\n  input: RemoveLabelsFromLabelableInput;\n}>;\n\n\nexport type RemoveLabelsFromLabelableMutationData = { __typename?: 'Mutation', removeLabelsFromLabelable?: { __typename?: 'RemoveLabelsFromLabelablePayload', labelable?: { __typename?: 'Discussion', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | { __typename?: 'Issue', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | { __typename?: 'PullRequest', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | null } | null };\n\nexport type RequestReviewsMutationVariables = Exact<{\n  input: RequestReviewsInput;\n}>;\n\n\nexport type RequestReviewsMutationData = { __typename?: 'Mutation', requestReviews?: { __typename?: 'RequestReviewsPayload', requestedReviewersEdge?: { __typename?: 'UserEdge', node?: { __typename?: 'User', id: string } | null } | null } | null };\n\nexport type SubmitPullRequestReviewMutationVariables = Exact<{\n  input: SubmitPullRequestReviewInput;\n}>;\n\n\nexport type SubmitPullRequestReviewMutationData = { __typename?: 'Mutation', submitPullRequestReview?: { __typename?: 'SubmitPullRequestReviewPayload', pullRequestReview?: { __typename?: 'PullRequestReview', id: string } | null } | null };\n\nexport type ActorFragment_Bot_ = { __typename?: 'Bot', login: string, avatarUrl: string };\n\nexport type ActorFragment_EnterpriseUserAccount_ = { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string };\n\nexport type ActorFragment_Mannequin_ = { __typename?: 'Mannequin', login: string, avatarUrl: string };\n\nexport type ActorFragment_Organization_ = { __typename?: 'Organization', login: string, avatarUrl: string };\n\nexport type ActorFragment_User_ = { __typename?: 'User', id: string, login: string, avatarUrl: string };\n\nexport type ActorFragment = ActorFragment_Bot_ | ActorFragment_EnterpriseUserAccount_ | ActorFragment_Mannequin_ | ActorFragment_Organization_ | ActorFragment_User_;\n\nexport type CheckRunFragment = { __typename?: 'CheckRun', conclusion?: CheckConclusionState | null, name: string, status: CheckStatusState, url: string };\n\nexport type CommitFragment = { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } };\n\nexport type CommitQueryVariables = Exact<{\n  org: Scalars['String'];\n  repo: Scalars['String'];\n  oid: Scalars['GitObjectID'];\n  numParents: Scalars['Int'];\n}>;\n\n\nexport type CommitQueryData = { __typename?: 'Query', repositoryOwner?: { __typename?: 'Organization', repository?: { __typename?: 'Repository', object?: { __typename?: 'Blob' } | { __typename: 'Commit', id: string, oid: string, committedDate: string, url: string, message: string, messageBody: string, messageBodyHTML: string, messageHeadline: string, messageHeadlineHTML: string, tree: { __typename?: 'Tree', id: string, oid: string, entries?: Array<{ __typename?: 'TreeEntry', oid: string, name: string, path?: string | null, type: string, mode: number }> | null }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | { __typename?: 'Tag' } | { __typename?: 'Tree' } | null } | null } | { __typename?: 'User', repository?: { __typename?: 'Repository', object?: { __typename?: 'Blob' } | { __typename: 'Commit', id: string, oid: string, committedDate: string, url: string, message: string, messageBody: string, messageBodyHTML: string, messageHeadline: string, messageHeadlineHTML: string, tree: { __typename?: 'Tree', id: string, oid: string, entries?: Array<{ __typename?: 'TreeEntry', oid: string, name: string, path?: string | null, type: string, mode: number }> | null }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | { __typename?: 'Tag' } | { __typename?: 'Tree' } | null } | null } | null };\n\nexport type HomePagePullRequestFragment = { __typename: 'PullRequest', number: number, titleHTML: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, repository: { __typename?: 'Repository', nameWithOwner: string } };\n\nexport type LabelFragment = { __typename?: 'Label', id: string, name: string, color: string, description?: string | null };\n\nexport type PageInfoFragment = { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null, hasPreviousPage: boolean, hasNextPage: boolean };\n\nexport type PullRequestQueryVariables = Exact<{\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  pr: Scalars['Int'];\n  numComments: Scalars['Int'];\n  numTimelineItems: Scalars['Int'];\n}>;\n\n\nexport type PullRequestQueryData = { __typename?: 'Query', repository?: { __typename?: 'Repository', pullRequest?: { __typename?: 'PullRequest', id: string, number: number, url: string, title: string, titleHTML: string, body: string, bodyHTML: string, baseRefOid: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, viewerDidAuthor: boolean, timelineItems: { __typename?: 'PullRequestTimelineItemsConnection', nodes?: Array<{ __typename: 'AddedToMergeQueueEvent' } | { __typename: 'AddedToProjectEvent' } | { __typename: 'AssignedEvent' } | { __typename: 'AutoMergeDisabledEvent' } | { __typename: 'AutoMergeEnabledEvent' } | { __typename: 'AutoRebaseEnabledEvent' } | { __typename: 'AutoSquashEnabledEvent' } | { __typename: 'AutomaticBaseChangeFailedEvent' } | { __typename: 'AutomaticBaseChangeSucceededEvent' } | { __typename: 'BaseRefChangedEvent' } | { __typename: 'BaseRefDeletedEvent' } | { __typename: 'BaseRefForcePushedEvent' } | { __typename: 'ClosedEvent', actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, closable: { __typename: 'Discussion' } | { __typename: 'Issue' } | { __typename: 'Milestone' } | { __typename: 'Project' } | { __typename: 'ProjectV2' } | { __typename: 'PullRequest', merged: boolean } } | { __typename: 'CommentDeletedEvent' } | { __typename: 'ConnectedEvent' } | { __typename: 'ConvertToDraftEvent' } | { __typename: 'ConvertedNoteToIssueEvent' } | { __typename: 'ConvertedToDiscussionEvent' } | { __typename: 'CrossReferencedEvent' } | { __typename: 'DemilestonedEvent' } | { __typename: 'DeployedEvent' } | { __typename: 'DeploymentEnvironmentChangedEvent' } | { __typename: 'DisconnectedEvent' } | { __typename: 'HeadRefDeletedEvent' } | { __typename: 'HeadRefForcePushedEvent', createdAt: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, beforeCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null, afterCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null } | { __typename: 'HeadRefRestoredEvent' } | { __typename: 'IssueComment', bodyHTML: string, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null } | { __typename: 'LabeledEvent' } | { __typename: 'LockedEvent' } | { __typename: 'MarkedAsDuplicateEvent' } | { __typename: 'MentionedEvent' } | { __typename: 'MergedEvent', mergeRefName: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, mergedCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null } | { __typename: 'MilestonedEvent' } | { __typename: 'MovedColumnsInProjectEvent' } | { __typename: 'PinnedEvent' } | { __typename: 'PullRequestCommit', commit: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } } | { __typename: 'PullRequestCommitCommentThread' } | { __typename: 'PullRequestReview', id: string, state: PullRequestReviewState, bodyHTML: string, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, comments: { __typename?: 'PullRequestReviewCommentConnection', nodes?: Array<{ __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null } | null> | null } } | { __typename: 'PullRequestReviewThread' } | { __typename: 'PullRequestRevisionMarker' } | { __typename: 'ReadyForReviewEvent' } | { __typename: 'ReferencedEvent' } | { __typename: 'RemovedFromMergeQueueEvent' } | { __typename: 'RemovedFromProjectEvent' } | { __typename: 'RenamedTitleEvent', previousTitle: string, currentTitle: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null } | { __typename: 'ReopenedEvent' } | { __typename: 'ReviewDismissedEvent' } | { __typename: 'ReviewRequestRemovedEvent', actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, requestedReviewer?: { __typename: 'Mannequin', login: string } | { __typename: 'Team' } | { __typename: 'User', login: string } | null } | { __typename: 'ReviewRequestedEvent', createdAt: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, requestedReviewer?: { __typename: 'Mannequin', login: string } | { __typename: 'Team' } | { __typename: 'User', login: string } | null } | { __typename: 'SubscribedEvent' } | { __typename: 'TransferredEvent' } | { __typename: 'UnassignedEvent' } | { __typename: 'UnlabeledEvent' } | { __typename: 'UnlockedEvent' } | { __typename: 'UnmarkedAsDuplicateEvent' } | { __typename: 'UnpinnedEvent' } | { __typename: 'UnsubscribedEvent' } | { __typename: 'UserBlockedEvent' } | null> | null }, reviews?: { __typename?: 'PullRequestReviewConnection', nodes?: Array<{ __typename?: 'PullRequestReview', author?: { __typename?: 'Bot' } | { __typename?: 'EnterpriseUserAccount' } | { __typename?: 'Mannequin' } | { __typename?: 'Organization' } | { __typename: 'User', id: string, login: string, avatarUrl: string } | null } | null> | null } | null, reviewThreads: { __typename?: 'PullRequestReviewThreadConnection', nodes?: Array<{ __typename?: 'PullRequestReviewThread', originalLine?: number | null, diffSide: DiffSide, comments: { __typename?: 'PullRequestReviewCommentConnection', nodes?: Array<{ __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null } | null> | null } } | null> | null }, reviewRequests?: { __typename?: 'ReviewRequestConnection', nodes?: Array<{ __typename?: 'ReviewRequest', requestedReviewer?: { __typename?: 'Mannequin' } | { __typename?: 'Team' } | { __typename: 'User', id: string, login: string, avatarUrl: string } | null } | null> | null } | null, labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null, commits: { __typename?: 'PullRequestCommitConnection', nodes?: Array<{ __typename?: 'PullRequestCommit', commit: { __typename?: 'Commit', checkSuites?: { __typename?: 'CheckSuiteConnection', nodes?: Array<{ __typename?: 'CheckSuite', workflowRun?: { __typename?: 'WorkflowRun', workflow: { __typename?: 'Workflow', name: string } } | null, checkRuns?: { __typename?: 'CheckRunConnection', nodes?: Array<{ __typename?: 'CheckRun', conclusion?: CheckConclusionState | null, name: string, status: CheckStatusState, url: string } | null> | null } | null } | null> | null } | null } } | null> | null } } | null } | null };\n\nexport type PullRequestReviewCommentFragment = { __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null };\n\nexport type PullRequestReviewThreadFragment = { __typename?: 'PullRequestReviewThread', originalLine?: number | null, diffSide: DiffSide, comments: { __typename?: 'PullRequestReviewCommentConnection', nodes?: Array<{ __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null } | null> | null } };\n\nexport type PullRequestTimelineItemFragment_AddedToMergeQueueEvent_ = { __typename: 'AddedToMergeQueueEvent' };\n\nexport type PullRequestTimelineItemFragment_AddedToProjectEvent_ = { __typename: 'AddedToProjectEvent' };\n\nexport type PullRequestTimelineItemFragment_AssignedEvent_ = { __typename: 'AssignedEvent' };\n\nexport type PullRequestTimelineItemFragment_AutoMergeDisabledEvent_ = { __typename: 'AutoMergeDisabledEvent' };\n\nexport type PullRequestTimelineItemFragment_AutoMergeEnabledEvent_ = { __typename: 'AutoMergeEnabledEvent' };\n\nexport type PullRequestTimelineItemFragment_AutoRebaseEnabledEvent_ = { __typename: 'AutoRebaseEnabledEvent' };\n\nexport type PullRequestTimelineItemFragment_AutoSquashEnabledEvent_ = { __typename: 'AutoSquashEnabledEvent' };\n\nexport type PullRequestTimelineItemFragment_AutomaticBaseChangeFailedEvent_ = { __typename: 'AutomaticBaseChangeFailedEvent' };\n\nexport type PullRequestTimelineItemFragment_AutomaticBaseChangeSucceededEvent_ = { __typename: 'AutomaticBaseChangeSucceededEvent' };\n\nexport type PullRequestTimelineItemFragment_BaseRefChangedEvent_ = { __typename: 'BaseRefChangedEvent' };\n\nexport type PullRequestTimelineItemFragment_BaseRefDeletedEvent_ = { __typename: 'BaseRefDeletedEvent' };\n\nexport type PullRequestTimelineItemFragment_BaseRefForcePushedEvent_ = { __typename: 'BaseRefForcePushedEvent' };\n\nexport type PullRequestTimelineItemFragment_ClosedEvent_ = { __typename: 'ClosedEvent', actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, closable: { __typename: 'Discussion' } | { __typename: 'Issue' } | { __typename: 'Milestone' } | { __typename: 'Project' } | { __typename: 'ProjectV2' } | { __typename: 'PullRequest', merged: boolean } };\n\nexport type PullRequestTimelineItemFragment_CommentDeletedEvent_ = { __typename: 'CommentDeletedEvent' };\n\nexport type PullRequestTimelineItemFragment_ConnectedEvent_ = { __typename: 'ConnectedEvent' };\n\nexport type PullRequestTimelineItemFragment_ConvertToDraftEvent_ = { __typename: 'ConvertToDraftEvent' };\n\nexport type PullRequestTimelineItemFragment_ConvertedNoteToIssueEvent_ = { __typename: 'ConvertedNoteToIssueEvent' };\n\nexport type PullRequestTimelineItemFragment_ConvertedToDiscussionEvent_ = { __typename: 'ConvertedToDiscussionEvent' };\n\nexport type PullRequestTimelineItemFragment_CrossReferencedEvent_ = { __typename: 'CrossReferencedEvent' };\n\nexport type PullRequestTimelineItemFragment_DemilestonedEvent_ = { __typename: 'DemilestonedEvent' };\n\nexport type PullRequestTimelineItemFragment_DeployedEvent_ = { __typename: 'DeployedEvent' };\n\nexport type PullRequestTimelineItemFragment_DeploymentEnvironmentChangedEvent_ = { __typename: 'DeploymentEnvironmentChangedEvent' };\n\nexport type PullRequestTimelineItemFragment_DisconnectedEvent_ = { __typename: 'DisconnectedEvent' };\n\nexport type PullRequestTimelineItemFragment_HeadRefDeletedEvent_ = { __typename: 'HeadRefDeletedEvent' };\n\nexport type PullRequestTimelineItemFragment_HeadRefForcePushedEvent_ = { __typename: 'HeadRefForcePushedEvent', createdAt: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, beforeCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null, afterCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null };\n\nexport type PullRequestTimelineItemFragment_HeadRefRestoredEvent_ = { __typename: 'HeadRefRestoredEvent' };\n\nexport type PullRequestTimelineItemFragment_IssueComment_ = { __typename: 'IssueComment', bodyHTML: string, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null };\n\nexport type PullRequestTimelineItemFragment_LabeledEvent_ = { __typename: 'LabeledEvent' };\n\nexport type PullRequestTimelineItemFragment_LockedEvent_ = { __typename: 'LockedEvent' };\n\nexport type PullRequestTimelineItemFragment_MarkedAsDuplicateEvent_ = { __typename: 'MarkedAsDuplicateEvent' };\n\nexport type PullRequestTimelineItemFragment_MentionedEvent_ = { __typename: 'MentionedEvent' };\n\nexport type PullRequestTimelineItemFragment_MergedEvent_ = { __typename: 'MergedEvent', mergeRefName: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, mergedCommit?: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } | null };\n\nexport type PullRequestTimelineItemFragment_MilestonedEvent_ = { __typename: 'MilestonedEvent' };\n\nexport type PullRequestTimelineItemFragment_MovedColumnsInProjectEvent_ = { __typename: 'MovedColumnsInProjectEvent' };\n\nexport type PullRequestTimelineItemFragment_PinnedEvent_ = { __typename: 'PinnedEvent' };\n\nexport type PullRequestTimelineItemFragment_PullRequestCommit_ = { __typename: 'PullRequestCommit', commit: { __typename?: 'Commit', oid: string, committedDate: string, tree: { __typename?: 'Tree', oid: string }, parents: { __typename?: 'CommitConnection', totalCount: number, nodes?: Array<{ __typename?: 'Commit', oid: string } | null> | null } } };\n\nexport type PullRequestTimelineItemFragment_PullRequestCommitCommentThread_ = { __typename: 'PullRequestCommitCommentThread' };\n\nexport type PullRequestTimelineItemFragment_PullRequestReview_ = { __typename: 'PullRequestReview', id: string, state: PullRequestReviewState, bodyHTML: string, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, comments: { __typename?: 'PullRequestReviewCommentConnection', nodes?: Array<{ __typename?: 'PullRequestReviewComment', id: string, bodyHTML: string, state: PullRequestReviewCommentState, outdated: boolean, path: string, originalPosition: number, position?: number | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, replyTo?: { __typename?: 'PullRequestReviewComment', id: string } | null, originalCommit?: { __typename?: 'Commit', oid: string } | null, commit?: { __typename?: 'Commit', oid: string } | null } | null> | null } };\n\nexport type PullRequestTimelineItemFragment_PullRequestReviewThread_ = { __typename: 'PullRequestReviewThread' };\n\nexport type PullRequestTimelineItemFragment_PullRequestRevisionMarker_ = { __typename: 'PullRequestRevisionMarker' };\n\nexport type PullRequestTimelineItemFragment_ReadyForReviewEvent_ = { __typename: 'ReadyForReviewEvent' };\n\nexport type PullRequestTimelineItemFragment_ReferencedEvent_ = { __typename: 'ReferencedEvent' };\n\nexport type PullRequestTimelineItemFragment_RemovedFromMergeQueueEvent_ = { __typename: 'RemovedFromMergeQueueEvent' };\n\nexport type PullRequestTimelineItemFragment_RemovedFromProjectEvent_ = { __typename: 'RemovedFromProjectEvent' };\n\nexport type PullRequestTimelineItemFragment_RenamedTitleEvent_ = { __typename: 'RenamedTitleEvent', previousTitle: string, currentTitle: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null };\n\nexport type PullRequestTimelineItemFragment_ReopenedEvent_ = { __typename: 'ReopenedEvent' };\n\nexport type PullRequestTimelineItemFragment_ReviewDismissedEvent_ = { __typename: 'ReviewDismissedEvent' };\n\nexport type PullRequestTimelineItemFragment_ReviewRequestRemovedEvent_ = { __typename: 'ReviewRequestRemovedEvent', actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, requestedReviewer?: { __typename: 'Mannequin', login: string } | { __typename: 'Team' } | { __typename: 'User', login: string } | null };\n\nexport type PullRequestTimelineItemFragment_ReviewRequestedEvent_ = { __typename: 'ReviewRequestedEvent', createdAt: string, actor?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, requestedReviewer?: { __typename: 'Mannequin', login: string } | { __typename: 'Team' } | { __typename: 'User', login: string } | null };\n\nexport type PullRequestTimelineItemFragment_SubscribedEvent_ = { __typename: 'SubscribedEvent' };\n\nexport type PullRequestTimelineItemFragment_TransferredEvent_ = { __typename: 'TransferredEvent' };\n\nexport type PullRequestTimelineItemFragment_UnassignedEvent_ = { __typename: 'UnassignedEvent' };\n\nexport type PullRequestTimelineItemFragment_UnlabeledEvent_ = { __typename: 'UnlabeledEvent' };\n\nexport type PullRequestTimelineItemFragment_UnlockedEvent_ = { __typename: 'UnlockedEvent' };\n\nexport type PullRequestTimelineItemFragment_UnmarkedAsDuplicateEvent_ = { __typename: 'UnmarkedAsDuplicateEvent' };\n\nexport type PullRequestTimelineItemFragment_UnpinnedEvent_ = { __typename: 'UnpinnedEvent' };\n\nexport type PullRequestTimelineItemFragment_UnsubscribedEvent_ = { __typename: 'UnsubscribedEvent' };\n\nexport type PullRequestTimelineItemFragment_UserBlockedEvent_ = { __typename: 'UserBlockedEvent' };\n\nexport type PullRequestTimelineItemFragment = PullRequestTimelineItemFragment_AddedToMergeQueueEvent_ | PullRequestTimelineItemFragment_AddedToProjectEvent_ | PullRequestTimelineItemFragment_AssignedEvent_ | PullRequestTimelineItemFragment_AutoMergeDisabledEvent_ | PullRequestTimelineItemFragment_AutoMergeEnabledEvent_ | PullRequestTimelineItemFragment_AutoRebaseEnabledEvent_ | PullRequestTimelineItemFragment_AutoSquashEnabledEvent_ | PullRequestTimelineItemFragment_AutomaticBaseChangeFailedEvent_ | PullRequestTimelineItemFragment_AutomaticBaseChangeSucceededEvent_ | PullRequestTimelineItemFragment_BaseRefChangedEvent_ | PullRequestTimelineItemFragment_BaseRefDeletedEvent_ | PullRequestTimelineItemFragment_BaseRefForcePushedEvent_ | PullRequestTimelineItemFragment_ClosedEvent_ | PullRequestTimelineItemFragment_CommentDeletedEvent_ | PullRequestTimelineItemFragment_ConnectedEvent_ | PullRequestTimelineItemFragment_ConvertToDraftEvent_ | PullRequestTimelineItemFragment_ConvertedNoteToIssueEvent_ | PullRequestTimelineItemFragment_ConvertedToDiscussionEvent_ | PullRequestTimelineItemFragment_CrossReferencedEvent_ | PullRequestTimelineItemFragment_DemilestonedEvent_ | PullRequestTimelineItemFragment_DeployedEvent_ | PullRequestTimelineItemFragment_DeploymentEnvironmentChangedEvent_ | PullRequestTimelineItemFragment_DisconnectedEvent_ | PullRequestTimelineItemFragment_HeadRefDeletedEvent_ | PullRequestTimelineItemFragment_HeadRefForcePushedEvent_ | PullRequestTimelineItemFragment_HeadRefRestoredEvent_ | PullRequestTimelineItemFragment_IssueComment_ | PullRequestTimelineItemFragment_LabeledEvent_ | PullRequestTimelineItemFragment_LockedEvent_ | PullRequestTimelineItemFragment_MarkedAsDuplicateEvent_ | PullRequestTimelineItemFragment_MentionedEvent_ | PullRequestTimelineItemFragment_MergedEvent_ | PullRequestTimelineItemFragment_MilestonedEvent_ | PullRequestTimelineItemFragment_MovedColumnsInProjectEvent_ | PullRequestTimelineItemFragment_PinnedEvent_ | PullRequestTimelineItemFragment_PullRequestCommit_ | PullRequestTimelineItemFragment_PullRequestCommitCommentThread_ | PullRequestTimelineItemFragment_PullRequestReview_ | PullRequestTimelineItemFragment_PullRequestReviewThread_ | PullRequestTimelineItemFragment_PullRequestRevisionMarker_ | PullRequestTimelineItemFragment_ReadyForReviewEvent_ | PullRequestTimelineItemFragment_ReferencedEvent_ | PullRequestTimelineItemFragment_RemovedFromMergeQueueEvent_ | PullRequestTimelineItemFragment_RemovedFromProjectEvent_ | PullRequestTimelineItemFragment_RenamedTitleEvent_ | PullRequestTimelineItemFragment_ReopenedEvent_ | PullRequestTimelineItemFragment_ReviewDismissedEvent_ | PullRequestTimelineItemFragment_ReviewRequestRemovedEvent_ | PullRequestTimelineItemFragment_ReviewRequestedEvent_ | PullRequestTimelineItemFragment_SubscribedEvent_ | PullRequestTimelineItemFragment_TransferredEvent_ | PullRequestTimelineItemFragment_UnassignedEvent_ | PullRequestTimelineItemFragment_UnlabeledEvent_ | PullRequestTimelineItemFragment_UnlockedEvent_ | PullRequestTimelineItemFragment_UnmarkedAsDuplicateEvent_ | PullRequestTimelineItemFragment_UnpinnedEvent_ | PullRequestTimelineItemFragment_UnsubscribedEvent_ | PullRequestTimelineItemFragment_UserBlockedEvent_;\n\nexport type PullsPullRequestFragment = { __typename?: 'PullRequest', number: number, title: string, updatedAt: string, reviewDecision?: PullRequestReviewDecision | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, comments: { __typename?: 'IssueCommentConnection', totalCount: number }, labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null };\n\nexport type PullsQueryVariables = Exact<{\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  after?: InputMaybe<Scalars['String']>;\n  before?: InputMaybe<Scalars['String']>;\n  first?: InputMaybe<Scalars['Int']>;\n  last?: InputMaybe<Scalars['Int']>;\n  labels?: InputMaybe<Array<Scalars['String']> | Scalars['String']>;\n  states: Array<PullRequestState> | PullRequestState;\n}>;\n\n\nexport type PullsQueryData = { __typename?: 'Query', repository?: { __typename?: 'Repository', pullRequests: { __typename?: 'PullRequestConnection', totalCount: number, nodes?: Array<{ __typename?: 'PullRequest', number: number, title: string, updatedAt: string, reviewDecision?: PullRequestReviewDecision | null, author?: { __typename?: 'Bot', login: string, avatarUrl: string } | { __typename?: 'EnterpriseUserAccount', login: string, avatarUrl: string } | { __typename?: 'Mannequin', login: string, avatarUrl: string } | { __typename?: 'Organization', login: string, avatarUrl: string } | { __typename?: 'User', id: string, login: string, avatarUrl: string } | null, comments: { __typename?: 'IssueCommentConnection', totalCount: number }, labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', startCursor?: string | null, endCursor?: string | null, hasPreviousPage: boolean, hasNextPage: boolean } } } | null };\n\nexport type RepoAssignableUsersQueryVariables = Exact<{\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  query?: InputMaybe<Scalars['String']>;\n}>;\n\n\nexport type RepoAssignableUsersQueryData = { __typename?: 'Query', repository?: { __typename?: 'Repository', assignableUsers: { __typename?: 'UserConnection', nodes?: Array<{ __typename: 'User', id: string, login: string, avatarUrl: string } | null> | null } } | null };\n\nexport type RepoLabelsQueryVariables = Exact<{\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  query?: InputMaybe<Scalars['String']>;\n}>;\n\n\nexport type RepoLabelsQueryData = { __typename?: 'Query', repository?: { __typename?: 'Repository', labels?: { __typename?: 'LabelConnection', nodes?: Array<{ __typename?: 'Label', id: string, name: string, color: string, description?: string | null } | null> | null } | null } | null };\n\nexport type RequestedReviewerFragment_Mannequin_ = { __typename: 'Mannequin', login: string };\n\nexport type RequestedReviewerFragment_Team_ = { __typename: 'Team' };\n\nexport type RequestedReviewerFragment_User_ = { __typename: 'User', login: string };\n\nexport type RequestedReviewerFragment = RequestedReviewerFragment_Mannequin_ | RequestedReviewerFragment_Team_ | RequestedReviewerFragment_User_;\n\nexport type StackPullRequestFragment = { __typename?: 'PullRequest', number: number, title: string, updatedAt: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, headRefOid: string, comments: { __typename?: 'IssueCommentConnection', totalCount: number } };\n\nexport type StackPullRequestQueryVariables = Exact<{\n  name: Scalars['String'];\n  owner: Scalars['String'];\n  pr: Scalars['Int'];\n}>;\n\n\nexport type StackPullRequestQueryData = { __typename?: 'Query', repository?: { __typename?: 'Repository', pullRequest?: { __typename?: 'PullRequest', number: number, title: string, updatedAt: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, headRefOid: string, comments: { __typename?: 'IssueCommentConnection', totalCount: number } } | null } | null };\n\nexport type TreeFragment = { __typename?: 'Tree', id: string, oid: string, entries?: Array<{ __typename?: 'TreeEntry', oid: string, name: string, path?: string | null, type: string, mode: number }> | null };\n\nexport type TreeQueryVariables = Exact<{\n  org: Scalars['String'];\n  repo: Scalars['String'];\n  oid: Scalars['GitObjectID'];\n}>;\n\n\nexport type TreeQueryData = { __typename?: 'Query', repositoryOwner?: { __typename?: 'Organization', repository?: { __typename?: 'Repository', object?: { __typename?: 'Blob' } | { __typename?: 'Commit' } | { __typename?: 'Tag' } | { __typename?: 'Tree', id: string, oid: string, entries?: Array<{ __typename?: 'TreeEntry', oid: string, name: string, path?: string | null, type: string, mode: number }> | null } | null } | null } | { __typename?: 'User', repository?: { __typename?: 'Repository', object?: { __typename?: 'Blob' } | { __typename?: 'Commit' } | { __typename?: 'Tag' } | { __typename?: 'Tree', id: string, oid: string, entries?: Array<{ __typename?: 'TreeEntry', oid: string, name: string, path?: string | null, type: string, mode: number }> | null } | null } | null } | null };\n\nexport type UserFragment = { __typename: 'User', id: string, login: string, avatarUrl: string };\n\nexport type UserHomePageQueryVariables = Exact<{\n  reviewRequestedQuery: Scalars['String'];\n}>;\n\n\nexport type UserHomePageQueryData = { __typename?: 'Query', viewer: { __typename?: 'User', repositories: { __typename?: 'RepositoryConnection', nodes?: Array<{ __typename?: 'Repository', nameWithOwner: string } | null> | null }, pullRequests: { __typename?: 'PullRequestConnection', nodes?: Array<{ __typename: 'PullRequest', number: number, titleHTML: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, repository: { __typename?: 'Repository', nameWithOwner: string } } | null> | null } }, search: { __typename?: 'SearchResultItemConnection', nodes?: Array<{ __typename?: 'App' } | { __typename?: 'Discussion' } | { __typename?: 'Issue' } | { __typename?: 'MarketplaceListing' } | { __typename?: 'Organization' } | { __typename: 'PullRequest', number: number, titleHTML: string, state: PullRequestState, reviewDecision?: PullRequestReviewDecision | null, repository: { __typename?: 'Repository', nameWithOwner: string } } | { __typename?: 'Repository' } | { __typename?: 'User' } | null> | null } };\n\nexport type UsernameQueryVariables = Exact<{ [key: string]: never; }>;\n\n\nexport type UsernameQueryData = { __typename?: 'Query', viewer: { __typename?: 'User', login: string } };\n\nexport const CheckRunFragment = `\n    fragment CheckRunFragment on CheckRun {\n  conclusion\n  name\n  status\n  url\n}\n    `;\nexport const HomePagePullRequestFragment = `\n    fragment HomePagePullRequestFragment on PullRequest {\n  __typename\n  number\n  titleHTML\n  repository {\n    nameWithOwner\n  }\n  state\n  reviewDecision\n}\n    `;\nexport const PageInfoFragment = `\n    fragment PageInfoFragment on PageInfo {\n  startCursor\n  endCursor\n  hasPreviousPage\n  hasNextPage\n}\n    `;\nexport const ActorFragment = `\n    fragment ActorFragment on Actor {\n  login\n  avatarUrl(size: 24)\n  ... on User {\n    id\n  }\n}\n    `;\nexport const PullRequestReviewCommentFragment = `\n    fragment PullRequestReviewCommentFragment on PullRequestReviewComment {\n  id\n  author {\n    ...ActorFragment\n  }\n  replyTo {\n    id\n  }\n  bodyHTML\n  state\n  outdated\n  path\n  originalCommit {\n    oid\n  }\n  originalPosition\n  commit {\n    oid\n  }\n  position\n}\n    `;\nexport const PullRequestReviewThreadFragment = `\n    fragment PullRequestReviewThreadFragment on PullRequestReviewThread {\n  originalLine\n  diffSide\n  comments(first: $numComments) {\n    nodes {\n      ...PullRequestReviewCommentFragment\n    }\n  }\n}\n    `;\nexport const CommitFragment = `\n    fragment CommitFragment on Commit {\n  oid\n  committedDate\n  tree {\n    oid\n  }\n  parents(first: 10) {\n    nodes {\n      oid\n    }\n    totalCount\n  }\n}\n    `;\nexport const RequestedReviewerFragment = `\n    fragment RequestedReviewerFragment on RequestedReviewer {\n  ... on User {\n    login\n  }\n  ... on Mannequin {\n    login\n  }\n  __typename\n}\n    `;\nexport const PullRequestTimelineItemFragment = `\n    fragment PullRequestTimelineItemFragment on PullRequestTimelineItems {\n  ... on PullRequestCommit {\n    commit {\n      ...CommitFragment\n    }\n  }\n  ... on PullRequestReview {\n    id\n    author {\n      ...ActorFragment\n    }\n    state\n    bodyHTML\n    comments(first: $numComments) {\n      nodes {\n        ...PullRequestReviewCommentFragment\n      }\n    }\n  }\n  ... on HeadRefForcePushedEvent {\n    actor {\n      ...ActorFragment\n    }\n    createdAt\n    beforeCommit {\n      ...CommitFragment\n    }\n    afterCommit {\n      ...CommitFragment\n    }\n  }\n  ... on ReviewRequestedEvent {\n    actor {\n      ...ActorFragment\n    }\n    createdAt\n    requestedReviewer {\n      ...RequestedReviewerFragment\n    }\n  }\n  ... on ReviewRequestRemovedEvent {\n    actor {\n      ...ActorFragment\n    }\n    requestedReviewer {\n      ...RequestedReviewerFragment\n    }\n  }\n  ... on IssueComment {\n    author {\n      ...ActorFragment\n    }\n    bodyHTML\n  }\n  ... on RenamedTitleEvent {\n    actor {\n      ...ActorFragment\n    }\n    previousTitle\n    currentTitle\n  }\n  ... on MergedEvent {\n    actor {\n      ...ActorFragment\n    }\n    mergedCommit: commit {\n      ...CommitFragment\n    }\n    mergeRefName\n  }\n  ... on ClosedEvent {\n    actor {\n      ...ActorFragment\n    }\n    closable {\n      __typename\n      ... on PullRequest {\n        merged\n      }\n    }\n  }\n  __typename\n}\n    `;\nexport const LabelFragment = `\n    fragment LabelFragment on Label {\n  id\n  name\n  color\n  description\n}\n    `;\nexport const PullsPullRequestFragment = `\n    fragment PullsPullRequestFragment on PullRequest {\n  number\n  title\n  updatedAt\n  author {\n    ...ActorFragment\n  }\n  comments {\n    totalCount\n  }\n  reviewDecision\n  labels(first: 20, orderBy: {field: NAME, direction: ASC}) {\n    nodes {\n      ...LabelFragment\n    }\n  }\n}\n    `;\nexport const StackPullRequestFragment = `\n    fragment StackPullRequestFragment on PullRequest {\n  number\n  title\n  updatedAt\n  state\n  reviewDecision\n  headRefOid\n  comments {\n    totalCount\n  }\n}\n    `;\nexport const TreeFragment = `\n    fragment TreeFragment on Tree {\n  id\n  oid\n  entries {\n    oid\n    name\n    path\n    type\n    mode\n  }\n}\n    `;\nexport const UserFragment = `\n    fragment UserFragment on User {\n  __typename\n  id\n  ...ActorFragment\n}\n    `;\nexport const AddCommentMutation = `\n    mutation AddCommentMutation($id: ID!, $body: String!) {\n  addComment(input: {subjectId: $id, body: $body}) {\n    subject {\n      id\n    }\n    commentEdge {\n      cursor\n      node {\n        id\n      }\n    }\n    timelineEdge {\n      cursor\n      node {\n        __typename\n      }\n    }\n  }\n}\n    `;\nexport const AddLabelsToLabelableMutation = `\n    mutation AddLabelsToLabelableMutation($input: AddLabelsToLabelableInput!) {\n  addLabelsToLabelable(input: $input) {\n    labelable {\n      labels(first: 100) {\n        nodes {\n          ...LabelFragment\n        }\n      }\n    }\n  }\n}\n    ${LabelFragment}`;\nexport const AddPullRequestReviewCommentMutation = `\n    mutation AddPullRequestReviewCommentMutation($input: AddPullRequestReviewCommentInput!) {\n  addPullRequestReviewComment(input: $input) {\n    comment {\n      ...PullRequestReviewCommentFragment\n    }\n  }\n}\n    ${PullRequestReviewCommentFragment}\n${ActorFragment}`;\nexport const AddPullRequestReviewMutation = `\n    mutation AddPullRequestReviewMutation($input: AddPullRequestReviewInput!) {\n  addPullRequestReview(input: $input) {\n    pullRequestReview {\n      id\n    }\n  }\n}\n    `;\nexport const RemoveLabelsFromLabelableMutation = `\n    mutation RemoveLabelsFromLabelableMutation($input: RemoveLabelsFromLabelableInput!) {\n  removeLabelsFromLabelable(input: $input) {\n    labelable {\n      labels(first: 100) {\n        nodes {\n          ...LabelFragment\n        }\n      }\n    }\n  }\n}\n    ${LabelFragment}`;\nexport const RequestReviewsMutation = `\n    mutation RequestReviewsMutation($input: RequestReviewsInput!) {\n  requestReviews(input: $input) {\n    requestedReviewersEdge {\n      node {\n        id\n      }\n    }\n  }\n}\n    `;\nexport const SubmitPullRequestReviewMutation = `\n    mutation SubmitPullRequestReviewMutation($input: SubmitPullRequestReviewInput!) {\n  submitPullRequestReview(input: $input) {\n    pullRequestReview {\n      id\n    }\n  }\n}\n    `;\nexport const CommitQuery = `\n    query CommitQuery($org: String!, $repo: String!, $oid: GitObjectID!, $numParents: Int!) {\n  repositoryOwner(login: $org) {\n    repository(name: $repo) {\n      object(oid: $oid) {\n        ... on Commit {\n          __typename\n          id\n          oid\n          committedDate\n          url\n          message\n          messageBody\n          messageBodyHTML\n          messageHeadline\n          messageHeadlineHTML\n          tree {\n            ...TreeFragment\n          }\n          parents(first: $numParents) {\n            nodes {\n              oid\n            }\n            totalCount\n          }\n        }\n      }\n    }\n  }\n}\n    ${TreeFragment}`;\nexport const PullRequestQuery = `\n    query PullRequestQuery($name: String!, $owner: String!, $pr: Int!, $numComments: Int!, $numTimelineItems: Int!) {\n  repository(name: $name, owner: $owner) {\n    pullRequest(number: $pr) {\n      id\n      number\n      url\n      title\n      titleHTML\n      body\n      bodyHTML\n      baseRefOid\n      state\n      reviewDecision\n      viewerDidAuthor\n      timelineItems(\n        first: $numTimelineItems\n        itemTypes: [PULL_REQUEST_COMMIT, PULL_REQUEST_REVIEW, HEAD_REF_FORCE_PUSHED_EVENT, REVIEW_REQUESTED_EVENT, REVIEW_REQUEST_REMOVED_EVENT, ISSUE_COMMENT, RENAMED_TITLE_EVENT, MERGED_EVENT, CLOSED_EVENT]\n      ) {\n        nodes {\n          ...PullRequestTimelineItemFragment\n        }\n      }\n      reviews(first: 100) {\n        nodes {\n          author {\n            ...UserFragment\n          }\n        }\n      }\n      reviewThreads(first: 100) {\n        nodes {\n          ...PullRequestReviewThreadFragment\n        }\n      }\n      reviewRequests(first: 100) {\n        nodes {\n          requestedReviewer {\n            ...UserFragment\n          }\n        }\n      }\n      labels(first: 100, orderBy: {field: NAME, direction: ASC}) {\n        nodes {\n          ...LabelFragment\n        }\n      }\n      commits(last: 1) {\n        nodes {\n          commit {\n            checkSuites(last: 100) {\n              nodes {\n                workflowRun {\n                  workflow {\n                    name\n                  }\n                }\n                checkRuns(last: 100) {\n                  nodes {\n                    ...CheckRunFragment\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n    ${PullRequestTimelineItemFragment}\n${CommitFragment}\n${ActorFragment}\n${PullRequestReviewCommentFragment}\n${RequestedReviewerFragment}\n${UserFragment}\n${PullRequestReviewThreadFragment}\n${LabelFragment}\n${CheckRunFragment}`;\nexport const PullsQuery = `\n    query PullsQuery($name: String!, $owner: String!, $after: String, $before: String, $first: Int, $last: Int, $labels: [String!], $states: [PullRequestState!]!) {\n  repository(name: $name, owner: $owner) {\n    pullRequests(\n      after: $after\n      before: $before\n      first: $first\n      last: $last\n      labels: $labels\n      states: $states\n      orderBy: {field: UPDATED_AT, direction: DESC}\n    ) {\n      nodes {\n        ...PullsPullRequestFragment\n      }\n      pageInfo {\n        ...PageInfoFragment\n      }\n      totalCount\n    }\n  }\n}\n    ${PullsPullRequestFragment}\n${ActorFragment}\n${LabelFragment}\n${PageInfoFragment}`;\nexport const RepoAssignableUsersQuery = `\n    query RepoAssignableUsersQuery($name: String!, $owner: String!, $query: String) {\n  repository(name: $name, owner: $owner) {\n    assignableUsers(first: 20, query: $query) {\n      nodes {\n        ...UserFragment\n      }\n    }\n  }\n}\n    ${UserFragment}\n${ActorFragment}`;\nexport const RepoLabelsQuery = `\n    query RepoLabelsQuery($name: String!, $owner: String!, $query: String) {\n  repository(name: $name, owner: $owner) {\n    labels(first: 20, query: $query) {\n      nodes {\n        ...LabelFragment\n      }\n    }\n  }\n}\n    ${LabelFragment}`;\nexport const StackPullRequestQuery = `\n    query StackPullRequestQuery($name: String!, $owner: String!, $pr: Int!) {\n  repository(name: $name, owner: $owner) {\n    pullRequest(number: $pr) {\n      ...StackPullRequestFragment\n    }\n  }\n}\n    ${StackPullRequestFragment}`;\nexport const TreeQuery = `\n    query TreeQuery($org: String!, $repo: String!, $oid: GitObjectID!) {\n  repositoryOwner(login: $org) {\n    repository(name: $repo) {\n      object(oid: $oid) {\n        ...TreeFragment\n      }\n    }\n  }\n}\n    ${TreeFragment}`;\nexport const UserHomePageQuery = `\n    query UserHomePageQuery($reviewRequestedQuery: String!) {\n  viewer {\n    repositories(first: 10, orderBy: {field: UPDATED_AT, direction: DESC}) {\n      nodes {\n        nameWithOwner\n      }\n    }\n    pullRequests(first: 10, orderBy: {field: UPDATED_AT, direction: DESC}) {\n      nodes {\n        ...HomePagePullRequestFragment\n      }\n    }\n  }\n  search(first: 10, query: $reviewRequestedQuery, type: ISSUE) {\n    nodes {\n      ...HomePagePullRequestFragment\n    }\n  }\n}\n    ${HomePagePullRequestFragment}`;\nexport const UsernameQuery = `\n    query UsernameQuery {\n  viewer {\n    login\n  }\n}\n    `;","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {IRawTheme} from 'vscode-textmate';\n\n// Theme data fetched from:\n// https://github.com/microsoft/vscode/raw/a716714a88891cad69c0753fb95923870df295f5/extensions/theme-defaults/themes/dark_plus.json\n\nconst theme: IRawTheme = {\n  name: 'Dark+ (default dark)',\n  settings: [\n    {\n      settings: {\n        foreground: '#D4D4D4',\n        background: '#1E1E1E',\n      },\n    },\n    {\n      name: 'Function declarations',\n      scope: [\n        'entity.name.function',\n        'support.function',\n        'support.constant.handlebars',\n        'source.powershell variable.other.member',\n        'entity.name.operator.custom-literal',\n      ],\n      settings: {\n        foreground: '#DCDCAA',\n      },\n    },\n    {\n      name: 'Types declaration and references',\n      scope: [\n        'meta.return-type',\n        'support.class',\n        'support.type',\n        'entity.name.type',\n        'entity.name.namespace',\n        'entity.other.attribute',\n        'entity.name.scope-resolution',\n        'entity.name.class',\n        'storage.type.numeric.go',\n        'storage.type.byte.go',\n        'storage.type.boolean.go',\n        'storage.type.string.go',\n        'storage.type.uintptr.go',\n        'storage.type.error.go',\n        'storage.type.rune.go',\n        'storage.type.cs',\n        'storage.type.generic.cs',\n        'storage.type.modifier.cs',\n        'storage.type.variable.cs',\n        'storage.type.annotation.java',\n        'storage.type.generic.java',\n        'storage.type.java',\n        'storage.type.object.array.java',\n        'storage.type.primitive.array.java',\n        'storage.type.primitive.java',\n        'storage.type.token.java',\n        'storage.type.groovy',\n        'storage.type.annotation.groovy',\n        'storage.type.parameters.groovy',\n        'storage.type.generic.groovy',\n        'storage.type.object.array.groovy',\n        'storage.type.primitive.array.groovy',\n        'storage.type.primitive.groovy',\n      ],\n      settings: {\n        foreground: '#4EC9B0',\n      },\n    },\n    {\n      name: 'Types declaration and references, TS grammar specific',\n      scope: [\n        'meta.type.cast.expr',\n        'meta.type.new.expr',\n        'support.constant.math',\n        'support.constant.dom',\n        'support.constant.json',\n        'entity.other.inherited-class',\n      ],\n      settings: {\n        foreground: '#4EC9B0',\n      },\n    },\n    {\n      name: 'Control flow / Special keywords',\n      scope: [\n        'keyword.control',\n        'source.cpp keyword.operator.new',\n        'keyword.operator.delete',\n        'keyword.other.using',\n        'keyword.other.operator',\n        'entity.name.operator',\n      ],\n      settings: {\n        foreground: '#C586C0',\n      },\n    },\n    {\n      name: 'Variable and parameter name',\n      scope: [\n        'variable',\n        'meta.definition.variable.name',\n        'support.variable',\n        'entity.name.variable',\n      ],\n      settings: {\n        foreground: '#9CDCFE',\n      },\n    },\n    {\n      name: 'Constants and enums',\n      scope: ['variable.other.constant', 'variable.other.enummember'],\n      settings: {\n        foreground: '#51B6C4',\n      },\n    },\n    {\n      name: 'Object keys, TS grammar specific',\n      scope: 'meta.object-literal.key',\n      settings: {\n        foreground: '#9CDCFE',\n      },\n    },\n    {\n      name: 'CSS property value',\n      scope: [\n        'support.constant.property-value',\n        'support.constant.font-name',\n        'support.constant.media-type',\n        'support.constant.media',\n        'constant.other.color.rgb-value',\n        'constant.other.rgb-value',\n        'support.constant.color',\n      ],\n      settings: {\n        foreground: '#CE9178',\n      },\n    },\n    {\n      name: 'Regular expression groups',\n      scope: [\n        'punctuation.definition.group.regexp',\n        'punctuation.definition.group.assertion.regexp',\n        'punctuation.definition.character-class.regexp',\n        'punctuation.character.set.begin.regexp',\n        'punctuation.character.set.end.regexp',\n        'keyword.operator.negation.regexp',\n        'support.other.parenthesis.regexp',\n      ],\n      settings: {\n        foreground: '#CE9178',\n      },\n    },\n    {\n      scope: [\n        'constant.character.character-class.regexp',\n        'constant.other.character-class.set.regexp',\n        'constant.other.character-class.regexp',\n        'constant.character.set.regexp',\n      ],\n      settings: {\n        foreground: '#d16969',\n      },\n    },\n    {\n      scope: ['keyword.operator.or.regexp', 'keyword.control.anchor.regexp'],\n      settings: {\n        foreground: '#DCDCAA',\n      },\n    },\n    {\n      scope: 'keyword.operator.quantifier.regexp',\n      settings: {\n        foreground: '#d7ba7d',\n      },\n    },\n    {\n      scope: 'constant.character',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'constant.character.escape',\n      settings: {\n        foreground: '#d7ba7d',\n      },\n    },\n    {\n      scope: 'entity.name.label',\n      settings: {\n        foreground: '#C8C8C8',\n      },\n    },\n    {\n      scope: ['meta.embedded', 'source.groovy.embedded'],\n      settings: {\n        foreground: '#D4D4D4',\n      },\n    },\n    {\n      scope: 'emphasis',\n      settings: {\n        fontStyle: 'italic',\n      },\n    },\n    {\n      scope: 'strong',\n      settings: {\n        fontStyle: 'bold',\n      },\n    },\n    {\n      scope: 'header',\n      settings: {\n        foreground: '#000080',\n      },\n    },\n    {\n      scope: 'comment',\n      settings: {\n        foreground: '#6A9955',\n      },\n    },\n    {\n      scope: 'constant.language',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: [\n        'constant.numeric',\n        'entity.name.operator.custom-literal.number',\n        'keyword.operator.plus.exponent',\n        'keyword.operator.minus.exponent',\n      ],\n      settings: {\n        foreground: '#b5cea8',\n      },\n    },\n    {\n      scope: 'constant.regexp',\n      settings: {\n        foreground: '#646695',\n      },\n    },\n    {\n      scope: 'entity.name.tag',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'entity.name.tag.css',\n      settings: {\n        foreground: '#d7ba7d',\n      },\n    },\n    {\n      scope: 'entity.other.attribute-name',\n      settings: {\n        foreground: '#9cdcfe',\n      },\n    },\n    {\n      scope: [\n        'entity.other.attribute-name.class.css',\n        'entity.other.attribute-name.class.mixin.css',\n        'entity.other.attribute-name.id.css',\n        'entity.other.attribute-name.parent-selector.css',\n        'entity.other.attribute-name.pseudo-class.css',\n        'entity.other.attribute-name.pseudo-element.css',\n        'source.css.less entity.other.attribute-name.id',\n        'entity.other.attribute-name.attribute.scss',\n        'entity.other.attribute-name.scss',\n      ],\n      settings: {\n        foreground: '#d7ba7d',\n      },\n    },\n    {\n      scope: 'invalid',\n      settings: {\n        foreground: '#f44747',\n      },\n    },\n    {\n      scope: 'markup.underline',\n      settings: {\n        fontStyle: 'underline',\n      },\n    },\n    {\n      scope: 'markup.bold',\n      settings: {\n        fontStyle: 'bold',\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'markup.heading',\n      settings: {\n        fontStyle: 'bold',\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'markup.italic',\n      settings: {\n        fontStyle: 'italic',\n      },\n    },\n    {\n      scope: 'markup.inserted',\n      settings: {\n        foreground: '#b5cea8',\n      },\n    },\n    {\n      scope: 'markup.deleted',\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      scope: 'markup.changed',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'punctuation.definition.quote.begin.markdown',\n      settings: {\n        foreground: '#6A9955',\n      },\n    },\n    {\n      scope: 'punctuation.definition.list.begin.markdown',\n      settings: {\n        foreground: '#6796e6',\n      },\n    },\n    {\n      scope: 'markup.inline.raw',\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      name: 'brackets of XML/HTML tags',\n      scope: 'punctuation.definition.tag',\n      settings: {\n        foreground: '#808080',\n      },\n    },\n    {\n      scope: ['meta.preprocessor', 'entity.name.function.preprocessor'],\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'meta.preprocessor.string',\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      scope: 'meta.preprocessor.numeric',\n      settings: {\n        foreground: '#b5cea8',\n      },\n    },\n    {\n      scope: 'meta.structure.dictionary.key.python',\n      settings: {\n        foreground: '#9cdcfe',\n      },\n    },\n    {\n      scope: 'meta.diff.header',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'storage',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'storage.type',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: ['storage.modifier', 'keyword.operator.noexcept'],\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: ['string', 'entity.name.operator.custom-literal.string', 'meta.embedded.assembly'],\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      scope: 'string.tag',\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      scope: 'string.value',\n      settings: {\n        foreground: '#ce9178',\n      },\n    },\n    {\n      scope: 'string.regexp',\n      settings: {\n        foreground: '#d16969',\n      },\n    },\n    {\n      name: 'String interpolation',\n      scope: [\n        'punctuation.definition.template-expression.begin',\n        'punctuation.definition.template-expression.end',\n        'punctuation.section.embedded',\n      ],\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      name: 'Reset JavaScript string interpolation expression',\n      scope: 'meta.template.expression',\n      settings: {\n        foreground: '#d4d4d4',\n      },\n    },\n    {\n      scope: [\n        'support.type.vendored.property-name',\n        'support.type.property-name',\n        'variable.css',\n        'variable.scss',\n        'variable.other.less',\n        'source.coffee.embedded',\n      ],\n      settings: {\n        foreground: '#9cdcfe',\n      },\n    },\n    {\n      scope: 'keyword',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'keyword.operator',\n      settings: {\n        foreground: '#d4d4d4',\n      },\n    },\n    {\n      scope: [\n        'keyword.operator.new',\n        'keyword.operator.expression',\n        'keyword.operator.cast',\n        'keyword.operator.sizeof',\n        'keyword.operator.alignof',\n        'keyword.operator.typeid',\n        'keyword.operator.alignas',\n        'keyword.operator.instanceof',\n        'keyword.operator.logical.python',\n        'keyword.operator.wordlike',\n      ],\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'keyword.other.unit',\n      settings: {\n        foreground: '#b5cea8',\n      },\n    },\n    {\n      scope: ['punctuation.section.embedded.begin.php', 'punctuation.section.embedded.end.php'],\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n    {\n      scope: 'support.function.git-rebase',\n      settings: {\n        foreground: '#9cdcfe',\n      },\n    },\n    {\n      scope: 'constant.sha.git-rebase',\n      settings: {\n        foreground: '#b5cea8',\n      },\n    },\n    {\n      name: 'coloring of the Java import and package identifiers',\n      scope: [\n        'storage.modifier.import.java',\n        'variable.language.wildcard.java',\n        'storage.modifier.package.java',\n      ],\n      settings: {\n        foreground: '#d4d4d4',\n      },\n    },\n    {\n      name: 'this.self',\n      scope: 'variable.language',\n      settings: {\n        foreground: '#569cd6',\n      },\n    },\n  ],\n};\n\nexport default theme;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {IRawTheme} from 'vscode-textmate';\n\n// Theme data fetched from:\n// https://github.com/microsoft/vscode/raw/a716714a88891cad69c0753fb95923870df295f5/extensions/theme-defaults/themes/light_plus.json\n\nconst theme: IRawTheme = {\n  name: 'Light+ (default light)',\n  settings: [\n    {\n      settings: {\n        foreground: '#000000',\n        background: '#FFFFFF',\n      },\n    },\n    {\n      name: 'Function declarations',\n      scope: [\n        'entity.name.function',\n        'support.function',\n        'support.constant.handlebars',\n        'source.powershell variable.other.member',\n        'entity.name.operator.custom-literal',\n      ],\n      settings: {\n        foreground: '#795E26',\n      },\n    },\n    {\n      name: 'Types declaration and references',\n      scope: [\n        'meta.return-type',\n        'support.class',\n        'support.type',\n        'entity.name.type',\n        'entity.name.namespace',\n        'entity.other.attribute',\n        'entity.name.scope-resolution',\n        'entity.name.class',\n        'storage.type.numeric.go',\n        'storage.type.byte.go',\n        'storage.type.boolean.go',\n        'storage.type.string.go',\n        'storage.type.uintptr.go',\n        'storage.type.error.go',\n        'storage.type.rune.go',\n        'storage.type.cs',\n        'storage.type.generic.cs',\n        'storage.type.modifier.cs',\n        'storage.type.variable.cs',\n        'storage.type.annotation.java',\n        'storage.type.generic.java',\n        'storage.type.java',\n        'storage.type.object.array.java',\n        'storage.type.primitive.array.java',\n        'storage.type.primitive.java',\n        'storage.type.token.java',\n        'storage.type.groovy',\n        'storage.type.annotation.groovy',\n        'storage.type.parameters.groovy',\n        'storage.type.generic.groovy',\n        'storage.type.object.array.groovy',\n        'storage.type.primitive.array.groovy',\n        'storage.type.primitive.groovy',\n      ],\n      settings: {\n        foreground: '#267f99',\n      },\n    },\n    {\n      name: 'Types declaration and references, TS grammar specific',\n      scope: [\n        'meta.type.cast.expr',\n        'meta.type.new.expr',\n        'support.constant.math',\n        'support.constant.dom',\n        'support.constant.json',\n        'entity.other.inherited-class',\n      ],\n      settings: {\n        foreground: '#267f99',\n      },\n    },\n    {\n      name: 'Control flow / Special keywords',\n      scope: [\n        'keyword.control',\n        'source.cpp keyword.operator.new',\n        'source.cpp keyword.operator.delete',\n        'keyword.other.using',\n        'keyword.other.operator',\n        'entity.name.operator',\n      ],\n      settings: {\n        foreground: '#AF00DB',\n      },\n    },\n    {\n      name: 'Variable and parameter name',\n      scope: [\n        'variable',\n        'meta.definition.variable.name',\n        'support.variable',\n        'entity.name.variable',\n      ],\n      settings: {\n        foreground: '#001080',\n      },\n    },\n    {\n      name: 'Constants and enums',\n      scope: ['variable.other.constant', 'variable.other.enummember'],\n      settings: {\n        foreground: '#328267',\n      },\n    },\n    {\n      name: 'Object keys, TS grammar specific',\n      scope: 'meta.object-literal.key',\n      settings: {\n        foreground: '#001080',\n      },\n    },\n    {\n      name: 'CSS property value',\n      scope: [\n        'support.constant.property-value',\n        'support.constant.font-name',\n        'support.constant.media-type',\n        'support.constant.media',\n        'constant.other.color.rgb-value',\n        'constant.other.rgb-value',\n        'support.constant.color',\n      ],\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      name: 'Regular expression groups',\n      scope: [\n        'punctuation.definition.group.regexp',\n        'punctuation.definition.group.assertion.regexp',\n        'punctuation.definition.character-class.regexp',\n        'punctuation.character.set.begin.regexp',\n        'punctuation.character.set.end.regexp',\n        'keyword.operator.negation.regexp',\n        'support.other.parenthesis.regexp',\n      ],\n      settings: {\n        foreground: '#d16969',\n      },\n    },\n    {\n      scope: [\n        'constant.character.character-class.regexp',\n        'constant.other.character-class.set.regexp',\n        'constant.other.character-class.regexp',\n        'constant.character.set.regexp',\n      ],\n      settings: {\n        foreground: '#811f3f',\n      },\n    },\n    {\n      scope: 'keyword.operator.quantifier.regexp',\n      settings: {\n        foreground: '#000000',\n      },\n    },\n    {\n      scope: ['keyword.operator.or.regexp', 'keyword.control.anchor.regexp'],\n      settings: {\n        foreground: '#ff0000',\n      },\n    },\n    {\n      scope: 'constant.character',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'constant.character.escape',\n      settings: {\n        foreground: '#ff0000',\n      },\n    },\n    {\n      scope: 'entity.name.label',\n      settings: {\n        foreground: '#000000',\n      },\n    },\n    {\n      scope: ['meta.embedded', 'source.groovy.embedded'],\n      settings: {\n        foreground: '#000000ff',\n      },\n    },\n    {\n      scope: 'emphasis',\n      settings: {\n        fontStyle: 'italic',\n      },\n    },\n    {\n      scope: 'strong',\n      settings: {\n        fontStyle: 'bold',\n      },\n    },\n    {\n      scope: 'meta.diff.header',\n      settings: {\n        foreground: '#000080',\n      },\n    },\n    {\n      scope: 'comment',\n      settings: {\n        foreground: '#008000',\n      },\n    },\n    {\n      scope: 'constant.language',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: [\n        'constant.numeric',\n        'entity.name.operator.custom-literal.number',\n        'keyword.operator.plus.exponent',\n        'keyword.operator.minus.exponent',\n      ],\n      settings: {\n        foreground: '#098658',\n      },\n    },\n    {\n      scope: 'constant.regexp',\n      settings: {\n        foreground: '#811f3f',\n      },\n    },\n    {\n      name: 'css tags in selectors, xml tags',\n      scope: 'entity.name.tag',\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: 'entity.name.selector',\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: 'entity.other.attribute-name',\n      settings: {\n        foreground: '#ff0000',\n      },\n    },\n    {\n      scope: [\n        'entity.other.attribute-name.class.css',\n        'entity.other.attribute-name.class.mixin.css',\n        'entity.other.attribute-name.id.css',\n        'entity.other.attribute-name.parent-selector.css',\n        'entity.other.attribute-name.pseudo-class.css',\n        'entity.other.attribute-name.pseudo-element.css',\n        'source.css.less entity.other.attribute-name.id',\n        'entity.other.attribute-name.attribute.scss',\n        'entity.other.attribute-name.scss',\n      ],\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: 'invalid',\n      settings: {\n        foreground: '#cd3131',\n      },\n    },\n    {\n      scope: 'markup.underline',\n      settings: {\n        fontStyle: 'underline',\n      },\n    },\n    {\n      scope: 'markup.bold',\n      settings: {\n        fontStyle: 'bold',\n        foreground: '#000080',\n      },\n    },\n    {\n      scope: 'markup.heading',\n      settings: {\n        fontStyle: 'bold',\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: 'markup.italic',\n      settings: {\n        fontStyle: 'italic',\n      },\n    },\n    {\n      scope: 'markup.inserted',\n      settings: {\n        foreground: '#098658',\n      },\n    },\n    {\n      scope: 'markup.deleted',\n      settings: {\n        foreground: '#a31515',\n      },\n    },\n    {\n      scope: 'markup.changed',\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      scope: [\n        'punctuation.definition.quote.begin.markdown',\n        'punctuation.definition.list.begin.markdown',\n      ],\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      scope: 'markup.inline.raw',\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      name: 'brackets of XML/HTML tags',\n      scope: 'punctuation.definition.tag',\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: ['meta.preprocessor', 'entity.name.function.preprocessor'],\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'meta.preprocessor.string',\n      settings: {\n        foreground: '#a31515',\n      },\n    },\n    {\n      scope: 'meta.preprocessor.numeric',\n      settings: {\n        foreground: '#098658',\n      },\n    },\n    {\n      scope: 'meta.structure.dictionary.key.python',\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      scope: 'storage',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'storage.type',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: ['storage.modifier', 'keyword.operator.noexcept'],\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: ['string', 'entity.name.operator.custom-literal.string', 'meta.embedded.assembly'],\n      settings: {\n        foreground: '#a31515',\n      },\n    },\n    {\n      scope: [\n        'string.comment.buffered.block.pug',\n        'string.quoted.pug',\n        'string.interpolated.pug',\n        'string.unquoted.plain.in.yaml',\n        'string.unquoted.plain.out.yaml',\n        'string.unquoted.block.yaml',\n        'string.quoted.single.yaml',\n        'string.quoted.double.xml',\n        'string.quoted.single.xml',\n        'string.unquoted.cdata.xml',\n        'string.quoted.double.html',\n        'string.quoted.single.html',\n        'string.unquoted.html',\n        'string.quoted.single.handlebars',\n        'string.quoted.double.handlebars',\n      ],\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'string.regexp',\n      settings: {\n        foreground: '#811f3f',\n      },\n    },\n    {\n      name: 'String interpolation',\n      scope: [\n        'punctuation.definition.template-expression.begin',\n        'punctuation.definition.template-expression.end',\n        'punctuation.section.embedded',\n      ],\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      name: 'Reset JavaScript string interpolation expression',\n      scope: 'meta.template.expression',\n      settings: {\n        foreground: '#000000',\n      },\n    },\n    {\n      scope: [\n        'support.type.vendored.property-name',\n        'support.type.property-name',\n        'variable.css',\n        'variable.scss',\n        'variable.other.less',\n        'source.coffee.embedded',\n      ],\n      settings: {\n        foreground: '#ff0000',\n      },\n    },\n    {\n      scope: 'support.type.property-name.json',\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      scope: 'keyword',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'keyword.operator',\n      settings: {\n        foreground: '#000000',\n      },\n    },\n    {\n      scope: [\n        'keyword.operator.new',\n        'keyword.operator.expression',\n        'keyword.operator.cast',\n        'keyword.operator.sizeof',\n        'keyword.operator.alignof',\n        'keyword.operator.typeid',\n        'keyword.operator.alignas',\n        'keyword.operator.instanceof',\n        'keyword.operator.logical.python',\n        'keyword.operator.wordlike',\n      ],\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n    {\n      scope: 'keyword.other.unit',\n      settings: {\n        foreground: '#098658',\n      },\n    },\n    {\n      scope: ['punctuation.section.embedded.begin.php', 'punctuation.section.embedded.end.php'],\n      settings: {\n        foreground: '#800000',\n      },\n    },\n    {\n      scope: 'support.function.git-rebase',\n      settings: {\n        foreground: '#0451a5',\n      },\n    },\n    {\n      scope: 'constant.sha.git-rebase',\n      settings: {\n        foreground: '#098658',\n      },\n    },\n    {\n      name: 'coloring of the Java import and package identifiers',\n      scope: [\n        'storage.modifier.import.java',\n        'variable.language.wildcard.java',\n        'storage.modifier.package.java',\n      ],\n      settings: {\n        foreground: '#000000',\n      },\n    },\n    {\n      name: 'this.self',\n      scope: 'variable.language',\n      settings: {\n        foreground: '#0000ff',\n      },\n    },\n  ],\n};\n\nexport default theme;\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {TextMateGrammar} from 'shared/textmate-lib/types';\n\nexport default async function fetchGrammar(\n  moduleName: string,\n  type: 'json' | 'plist',\n): Promise<TextMateGrammar> {\n  const uri = `/generated/textmate/${moduleName}.${type}`;\n  const response = await fetch(uri);\n  const grammar = await response.text();\n  return {type, grammar};\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {IGrammar, Registry} from 'vscode-textmate';\n\nexport default class GrammarStore {\n  /**\n   * See `createTextMateRegistry()` in this directory to create a Registry.\n   */\n  constructor(private registry: Registry) {}\n\n  /**\n   * Load the grammar for `initialScopeName` and all referenced included\n   * grammars asynchronously.\n   */\n  loadGrammar(initialScopeName: string): Promise<IGrammar | null> {\n    return this.registry.loadGrammar(initialScopeName);\n  }\n\n  /**\n   * Returns a lookup array for color ids.\n   */\n  getColorMap(): string[] {\n    return this.registry.getColorMap();\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Grammar} from 'shared/textmate-lib/types';\nimport type {IRawTheme} from 'vscode-textmate';\n\nimport fetchGrammar from './fetchGrammar';\nimport GrammarStore from 'shared/textmate-lib/GrammarStore';\nimport createTextMateRegistry from 'shared/textmate-lib/createTextMateRegistry';\nimport {loadWASM} from 'vscode-oniguruma';\n\n/**\n * The site that hosts the ReviewStack UI must make onig.wasm available on\n * the host at this path.\n */\nconst URL_TO_ONIG_WASM = '/generated/textmate/onig.wasm';\n\nexport default async function createGrammarStore(\n  theme: IRawTheme,\n  grammars: {[scopeName: string]: Grammar},\n): Promise<GrammarStore> {\n  await ensureOnigurumaIsLoaded();\n  const registry = createTextMateRegistry(theme, grammars, fetchGrammar);\n  return new GrammarStore(registry);\n}\n\nlet onigurumaLoadingJob: Promise<void> | null = null;\n\nfunction ensureOnigurumaIsLoaded(): Promise<void> {\n  if (onigurumaLoadingJob === null) {\n    onigurumaLoadingJob = loadOniguruma();\n  }\n\n  return onigurumaLoadingJob;\n}\n\nasync function loadOniguruma(): Promise<void> {\n  const onigurumaWASMRequest = fetch(URL_TO_ONIG_WASM);\n  const response = await onigurumaWASMRequest;\n\n  const contentType = response.headers.get('content-type');\n  const useStreamingParser = contentType === 'application/wasm';\n\n  if (useStreamingParser) {\n    await loadWASM(response);\n  } else {\n    const dataOrOptions = {\n      data: await response.arrayBuffer(),\n      print(str: string): void {\n        // eslint-disable-next-line no-console\n        console.info(str);\n      },\n    };\n    await loadWASM(dataOrOptions);\n  }\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {Grammar, TextMateGrammar} from './types';\nimport type {IRawGrammar, IRawTheme} from 'vscode-textmate';\n\nimport {createOnigScanner, createOnigString} from 'vscode-oniguruma';\nimport {Registry, parseRawGrammar} from 'vscode-textmate';\n\n/**\n * Caller is responsible for ensuring `loadWASM()` from `vscode-oniguruma` has\n * been called (and resolved successfully) before calling this function.\n */\nexport default function createTextMateRegistry(\n  theme: IRawTheme,\n  grammars: {[scopeName: string]: Grammar},\n  fetchGrammar: (fileName: string, fileFormat: 'json' | 'plist') => Promise<TextMateGrammar>,\n): Registry {\n  return new Registry({\n    theme,\n    onigLib: Promise.resolve({\n      createOnigScanner,\n      createOnigString,\n    }),\n\n    async loadGrammar(scopeName: string): Promise<IRawGrammar | undefined | null> {\n      const config = grammars[scopeName];\n      if (config != null) {\n        const {type, grammar} = await fetchGrammar(config.fileName, config.fileFormat);\n        // If this is a JSON grammar, filePath must be specified with a `.json`\n        // file extension or else parseRawGrammar() will assume it is a PLIST\n        // grammar.\n        const filePath = `example.${type}`;\n        return parseRawGrammar(grammar, filePath);\n      } else {\n        // text.html.markdown supports a ton of embedded languages, but we do\n        // not bundle all of them, so we can expect to get requests for\n        // languages we cannot satisfy. Because this this expected, we return\n        // null rather than throw an error.\n        return Promise.resolve(null);\n      }\n    },\n\n    /**\n     * For the given scope, returns a list of additional grammars that should be\n     * \"injected into\" it (i.e., a list of grammars that want to extend the\n     * specified `scopeName`). The most common example is other grammars that\n     * want to \"inject themselves\" into the `text.html.markdown` scope so they\n     * can be used with fenced code blocks.\n     *\n     * In the manifest of a VS Code extension, a grammar signals that it wants\n     * to do this via the \"injectTo\" property:\n     * https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide#injection-grammars\n     */\n    getInjections(scopeName: string): Array<string> | undefined {\n      const grammar = grammars[scopeName];\n      return grammar?.injections ?? undefined;\n    },\n  });\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {IGrammar} from 'vscode-textmate';\n\nimport {INITIAL} from 'vscode-textmate';\n\n// The following values come from the MetadataConsts enum in vscode-textmate.\n// Although they are decalred in the main.d.ts file, our TypeScript/Webpack\n// setup does not appear to be able to inline them properly.\nconst FOREGROUND_MASK = 8372224;\nconst FOREGROUND_OFFSET = 14;\n\n/**\n * Specify a timeout when tokenizing a line to prevent a long line from locking\n * up the main thread. Note this is used in VS Code:\n * https://github.com/microsoft/vscode/blob/504c5a768a001b2099dd2b44e9dc39e10ccdfb56/src/vs/workbench/services/textMate/common/TMTokenization.ts#L39\n */\nconst DEFAULT_TOKENIZE_TIMEOUT_MS = 500;\n\nexport type HighlightedToken = {\n  /** Start index within a line, inclusive. */\n  start: number;\n\n  /** End index within a line, exclusive. */\n  end: number;\n\n  /** Index into a color map. */\n  color: number;\n};\n\nexport function tokenizeFileContents(\n  fileContents: string,\n  grammar: IGrammar,\n  timeLimit: number = DEFAULT_TOKENIZE_TIMEOUT_MS,\n): Array<Array<HighlightedToken>> {\n  // As fileContents could be quite large, we are assuming that, even though\n  // split() generates a potentially large array, because it is one native\n  // call, it is likely to be more efficient than us doing our own bookkeeping\n  // to slice off one substring at a time (though that would avoid the array\n  // allocation).\n  return tokenizeLines(fileContents.split('\\n'), grammar, timeLimit);\n}\n\nexport function tokenizeLines(\n  lines: ReadonlyArray<string>,\n  grammar: IGrammar,\n  timeLimit: number = DEFAULT_TOKENIZE_TIMEOUT_MS,\n): Array<Array<HighlightedToken>> {\n  let state = INITIAL;\n  return lines.map((line: string) => {\n    // Line-processing logic taken from:\n    // https://github.com/microsoft/vscode-textmate/blob/cc8ae321cfb47940470bd82c87a8ac61366fbd80/src/tests/themedTokenizer.ts#L20-L41\n    const result = grammar.tokenizeLine2(line, state, timeLimit);\n\n    // Note that even if `result.stoppedEarly` is true, we still use the list of\n    // tokens that were returned to tokenize as much of the line as possible.\n    // eslint-disable-next-line no-bitwise\n    const tokensLength = result.tokens.length >> 1;\n    const singleLine = [];\n    for (let j = 0; j < tokensLength; j++) {\n      const startIndex = result.tokens[2 * j];\n      const nextStartIndex = j + 1 < tokensLength ? result.tokens[2 * j + 2] : line.length;\n      const tokenText = line.substring(startIndex, nextStartIndex);\n      if (tokenText === '') {\n        continue;\n      }\n\n      const metaData = result.tokens[2 * j + 1];\n\n      // Get foreground index from metaData so that we can index into TokensCSS\n      // (a map from className to styles). Note this code comes from:\n      // https://github.com/microsoft/vscode-textmate/blob/cc8ae321cfb47940470bd82c87a8ac61366fbd80/src/grammar.ts#L1032-L1034\n      // We have to inline it here because StackElementMetadata does not appear\n      // to be exported as part of the vscode-textmate npm module.\n      // eslint-disable-next-line no-bitwise\n      const foregroundIdx = (metaData & FOREGROUND_MASK) >>> FOREGROUND_OFFSET;\n\n      singleLine.push({\n        start: startIndex,\n        end: nextStartIndex,\n        color: foregroundIdx,\n      });\n    }\n\n    // If we get result.stoppedEarly, continue tokenizing using the state used\n    // to tokenize this line as a \"best guess\" of what state tokenizing this\n    // line would have left us in had it completed.\n    state = result.stoppedEarly ? state : result.ruleStack;\n    return singleLine;\n  });\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport type {BroadcastMessage} from './broadcast';\nimport type GitHubClient from './github/GitHubClient';\nimport type {Blob, GitObjectID} from './github/types';\nimport type {LineToPosition} from './lineToPosition';\nimport type {SupportedPrimerColorMode} from './themeState';\nimport type {ParsedDiff} from 'diff';\nimport type GrammarStore from 'shared/textmate-lib/GrammarStore';\nimport type {HighlightedToken} from 'shared/textmate-lib/tokenize';\n\nimport {AVAILABILITY_METHOD, createDiffServiceBroadcastChannel} from './broadcast';\nimport {NUM_LINES_OF_CONTEXT} from './constants';\nimport {grammars} from './generated/textmate/TextMateGrammarManifest';\nimport CachingGitHubClient, {openDatabase} from './github/CachingGitHubClient';\nimport RejectingGitHubClient from './github/RejectingGitHubClient';\nimport {subscribeToLogout} from './github/logoutBroadcastChannel';\nimport lineToPosition from './lineToPosition';\nimport VSCodeDarkPlusTheme from './textmate/VSCodeDarkPlusTheme';\nimport VSCodeLightPlusTheme from './textmate/VSCodeLightPlusTheme';\nimport createGrammarStore from './textmate/createGrammarStore';\nimport {structuredPatch} from 'diff';\nimport lazyInit from 'shared/lazyInit';\nimport {tokenizeFileContents} from 'shared/textmate-lib/tokenize';\n\n/*\n * This file is the entry point for a SharedWorker that provides support for\n * various diff-related computations so they can be offloaded from the main\n * thread.\n *\n * Clients should post a message matching the type `Message` defined in this\n * file where:\n * - `id` is a property that will be included in the response so the client can\n *   pair a response with a request\n * - `method` is the name of the method in the service to call\n * - `params` is an object with the properties the method expects\n *\n * The result of the remote method call will be sent as type `Response` via\n * `postMessage()`.\n */\n\nexport type Message =\n  | {\n      id: number;\n      method: 'lineToPosition';\n      params: LineToPositionParams;\n    }\n  | {\n      id: number;\n      method: 'colorMap';\n      params: ColorMapParams;\n    }\n  | {\n      id: number;\n      method: 'diffAndTokenize';\n      params: DiffAndTokenizeParams;\n    }\n  | {\n      id: number;\n      method: 'lineRange';\n      params: LineRangeParams;\n    }\n  | {\n      id: -1;\n      method: 'publishAvailabilty';\n      params: null;\n    };\n\nexport type LineToPositionParams = {\n  oldOID: GitObjectID | null;\n  newOID: GitObjectID | null;\n};\n\nexport type ColorMapParams = {\n  colorMode: SupportedPrimerColorMode;\n};\n\nexport type DiffAndTokenizeParams = {\n  path: string;\n  scopeName: string | null;\n  colorMode: SupportedPrimerColorMode;\n  before: GitObjectID | null;\n  after: GitObjectID | null;\n};\n\nexport type DiffAndTokenizeResponse = {\n  patch: ParsedDiff;\n  tokenization: TokenizedSplitDiff;\n};\n\nexport type TokenizedSplitDiff = {\n  before: HighlightedToken[][] | null;\n  after: HighlightedToken[][] | null;\n};\n\n/**\n * Caller is responsible for ensuring a Blob matching the specified oid is\n * available in IndexedDB.\n */\nexport type LineRangeParams = {\n  oid: GitObjectID;\n  // 1-based line number.\n  start: number;\n  numLines: number;\n};\n\nexport type LineRangeResponse = {\n  /**\n   * Caller must call unsplitLines.split('\\n') to get the individual lines.\n   *\n   * Note this will be null if `notFound` or `isBinary` is true.\n   */\n  unsplitLines: string | null;\n  /**\n   * The Blob for the specified oid was not found in IndexedDB. Note this does\n   * not mean no such Blob exists on GitHub (or will never exist), just that no\n   * Blob matching the specified GitObjectID is cached locally.\n   */\n  notFound: boolean;\n  /**\n   * true if the Blob is binary and therefore does not support a LineRange\n   * query.\n   */\n  isBinary: boolean;\n};\n\nexport type Response = {\n  id: number;\n} & Result;\n\nexport type Result = {\n  ok: unknown;\n  err?: Error | null;\n};\n\nconst globalScope = self as unknown as SharedWorkerGlobalScope;\n\n// If the user logs out, we should shut this worker down immediately.\n// It will get re-created if the user logs back in.\nsubscribeToLogout(() => globalScope.close());\n\n/**\n * When a user loads ReviewStack, even if they are logged out, they will create\n * one SharedWorker because a colorMap will be requested as a byproduct of\n * requesting the theme for the page. We do not want a visit from a logged out\n * user to have the side-effect of opening/creating an IndexedDB, so we only\n * create the CachingGitHubClient once a logged-in user sends a request that\n * needs it.\n */\nconst getGitHubClient: () => Promise<GitHubClient> = lazyInit(async () => {\n  const db = await openDatabase();\n  return new CachingGitHubClient(\n    db,\n    new RejectingGitHubClient(),\n    /* owner */ null,\n    /* name */ null,\n  );\n});\n\nconst broadcastChannel = createDiffServiceBroadcastChannel();\n\nlet numActiveRequests = 0;\n\nfunction broadcastAvailability() {\n  const message: BroadcastMessage = {\n    method: AVAILABILITY_METHOD,\n    workerName: globalScope.name,\n    available: numActiveRequests == 0,\n  };\n  broadcastChannel.postMessage(message);\n}\n\nfunction updateRequestCount(delta: 1 | -1) {\n  numActiveRequests += delta;\n  if (numActiveRequests === 0 || (numActiveRequests === 1 && delta === 1)) {\n    broadcastAvailability();\n  }\n}\n\nfunction onMessage(port: MessagePort, {data}: {data: Message}) {\n  const {id, method, params} = data;\n  switch (method) {\n    case 'lineToPosition': {\n      updateRequestCount(1);\n      fetchLineToPosition(params)\n        .then(ok => port.postMessage({id, ok}))\n        .finally(() => updateRequestCount(-1));\n      break;\n    }\n    case 'colorMap': {\n      updateRequestCount(1);\n      const {colorMode} = params;\n      getGrammarStore(colorMode)\n        .then(store => {\n          const colorMap = store.getColorMap();\n          port.postMessage({id, ok: colorMap});\n        })\n        .finally(() => updateRequestCount(-1));\n      break;\n    }\n    case 'diffAndTokenize': {\n      updateRequestCount(1);\n      diffAndTokenize(params)\n        .then(ok => port.postMessage({id, ok}))\n        .finally(() => updateRequestCount(-1));\n      break;\n    }\n    case 'lineRange': {\n      updateRequestCount(1);\n      findlineRange(params)\n        .then(ok => port.postMessage({id, ok}))\n        .finally(() => updateRequestCount(-1));\n      break;\n    }\n    case 'publishAvailabilty': {\n      broadcastAvailability();\n      break;\n    }\n  }\n}\n\nglobalScope.addEventListener('connect', (event: MessageEvent) => {\n  const port = event.ports[0];\n  port.onmessage = (event: MessageEvent) => onMessage(port, event);\n});\n\nbroadcastAvailability();\n\nasync function diffAndTokenize({\n  path,\n  scopeName,\n  colorMode,\n  before,\n  after,\n}: DiffAndTokenizeParams): Promise<DiffAndTokenizeResponse> {\n  const [beforeBlob, afterBlob] = await getBlobPair(before, after);\n  const beforeContents = beforeBlob?.text ?? '';\n  const afterContents = afterBlob?.text ?? '';\n  const patch = structuredPatch(path, path, beforeContents, afterContents, undefined, undefined, {\n    context: NUM_LINES_OF_CONTEXT,\n  });\n\n  const tokenization =\n    scopeName == null\n      ? {before: null, after: null}\n      : await tokenizeSplitDiff(scopeName, colorMode, beforeContents, afterContents);\n  return {patch, tokenization};\n}\n\nasync function tokenizeSplitDiff(\n  scopeName: string,\n  colorMode: SupportedPrimerColorMode,\n  beforeContents: string,\n  afterContents: string,\n): Promise<TokenizedSplitDiff> {\n  const store = await getGrammarStore(colorMode);\n  const grammar = await store.loadGrammar(scopeName);\n  if (grammar == null) {\n    return {before: null, after: null};\n  }\n\n  return {\n    before: tokenizeFileContents(beforeContents, grammar),\n    after: tokenizeFileContents(afterContents, grammar),\n  };\n}\n\nasync function fetchLineToPosition({\n  oldOID,\n  newOID,\n}: LineToPositionParams): Promise<LineToPosition> {\n  const [beforeBlob, afterBlob] = await getBlobPair(oldOID, newOID);\n  const beforeContents = beforeBlob?.text ?? '';\n  const afterContents = afterBlob?.text ?? '';\n  return lineToPosition(beforeContents, afterContents);\n}\n\nasync function getBlobPair(\n  left: GitObjectID | null,\n  right: GitObjectID | null,\n): Promise<[Blob | null, Blob | null]> {\n  const client = await getGitHubClient();\n  return Promise.all([\n    left != null ? client.getBlob(left) : null,\n    right != null ? client.getBlob(right) : null,\n  ]);\n}\n\nconst colorModeToGrammarStore = new Map<SupportedPrimerColorMode, Promise<GrammarStore>>();\n\nfunction getGrammarStore(colorMode: SupportedPrimerColorMode): Promise<GrammarStore> {\n  const existingRequest = colorModeToGrammarStore.get(colorMode);\n  if (existingRequest != null) {\n    return existingRequest;\n  }\n\n  const theme = colorMode === 'day' ? VSCodeLightPlusTheme : VSCodeDarkPlusTheme;\n  const store = createGrammarStore(theme, grammars);\n  colorModeToGrammarStore.set(colorMode, store);\n  return store;\n}\n\nasync function findlineRange({oid, start, numLines}: LineRangeParams): Promise<LineRangeResponse> {\n  const client = await getGitHubClient();\n  const blob = await client.getBlob(oid);\n  const notFound = blob == null;\n  // TODO: Check other fields, like isTruncated?\n  const isBinary = blob?.isBinary ?? false;\n  // TODO: Compute this without creating a giant array.\n  const unsplitLines =\n    blob?.text\n      ?.split('\\n')\n      ?.slice(start - 1, start + numLines - 1)\n      .join('\\n') ?? null;\n  return {unsplitLines, notFound, isBinary};\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// See https://advancedweb.hu/the-async-lazy-initializer-pattern-in-javascript/\n\n/**\n * Because Promises are eager in JavaScript, we need to introduce an extra layer\n * to lazily invoke an async operation. lazyInit() takes a function that\n * represents the async operation, but does not call it until the function\n * returned by lazyInit() itself is called. Note that lazyInit() is idempotent:\n * once it is called, it will always return the original Promise created by\n * calling the async operation.\n *\n * ```\n * // Note getObj is a *function*, not a *Promise*.\n * const getObj = lazyInit(async () => {\n *   const value = await expensiveOperation();\n *   return value + 1;\n * });\n *\n * ...\n *\n * // expensiveObjCreation() will not be called until getObj() is called, and if\n * // it is called, it will only be called once.\n * const objRef1 = await getObj();\n * const objRef2 = await getObj();\n * ```\n */\nexport default function lazyInit<T>(init: () => Promise<T>): () => Promise<T> {\n  let promise: Promise<T> | null = null;\n  return () => (promise = promise ?? init());\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n * The SharedWorkers running the code for diffServiceWorker.ts broadcast their\n * availability to the host page via a BroadcastChannel. This file codifies the\n * protocol for the channel.\n */\n\nexport const AVAILABILITY_METHOD = 'diff-service-availability';\n\n/** Union type with one variant, as only one message type is currently used. */\nexport type BroadcastMessage = {\n  method: typeof AVAILABILITY_METHOD;\n  workerName: string;\n  available: boolean;\n};\n\n/**\n * Use this to create the BroadcastChannel to ensure the name is specified\n * consistently on both ends of the channel.\n */\nexport function createDiffServiceBroadcastChannel(): BroadcastChannel {\n  return new BroadcastChannel('diff-service');\n}\n\n/** When creating new SharedWorkers, the index should start at 0. */\nexport function createWorkerName(index: number) {\n  return `diff-service-worker-${index}`;\n}\n\nexport function parseWorkerIndex(workerName: string): number | null {\n  const match = workerName.match(/^diff-service-worker-(\\d+)$/);\n  return match != null ? parseInt(match[1], 10) : null;\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {NUM_LINES_OF_CONTEXT} from './constants';\nimport {DiffSide} from './generated/graphql';\nimport {structuredPatch} from 'diff';\nimport organizeLinesIntoGroups from 'shared/SplitDiffView/organizeLinesIntoGroups';\n\nexport type LineToPosition = {[key in DiffSide]: {[key: number]: number}};\n\n/**\n * Returns mapping of line number to \"position\" in a diff.\n *\n * From the GitHub REST API docs: The position value equals the number of lines\n * down from the first \"@@\" hunk header in the file you want to add a comment.\n * The line just below the \"@@\" line is position 1, the next line is position\n * 2, and so on. The position in the diff continues to increase through lines\n * of whitespace and additional hunks until the beginning of a new file.\n *\n * See https://docs.github.com/en/rest/pulls/comments#create-a-review-comment-for-a-pull-request\n *\n * According to the above definition of \"position\", we can assign positions for\n * each line of the below diff. Additional \"@@\" hunk header lines also occupy a\n * position. GitHub diffs appear to include NUM_LINES_OF_CONTEXT lines of context.\n *\n *  0 @@ -1,4 +1,4 @@\n *  1 -a\n *  2 +c\n *  3 common\n *  4 common\n *  5 common\n *  6 @@ -6,4 +6,4 @@\n *  7 common\n *  8 common\n *  9 common\n * 10 -b\n * 11 +d\n */\nexport default function lineToPosition(left: string, right: string): LineToPosition {\n  const leftMapping: {[key: number]: number} = {};\n  const rightMapping: {[key: number]: number} = {};\n\n  // Because the patch is never returned to the user, the file name does not\n  // matter.\n  const patch = structuredPatch(\n    '' /* oldFileName */,\n    '' /* newFileName */,\n    left,\n    right,\n    undefined,\n    undefined,\n    {\n      context: NUM_LINES_OF_CONTEXT,\n    },\n  );\n\n  let position = 0;\n  patch.hunks.forEach(({lines, oldStart, newStart}) => {\n    const groups = organizeLinesIntoGroups(lines);\n    let leftLine = oldStart;\n    let rightLine = newStart;\n    ++position;\n\n    groups.forEach(({common, removed, added}) => {\n      let count = common.length;\n      while (--count >= 0) {\n        leftMapping[leftLine] = position;\n        rightMapping[rightLine] = position;\n        ++leftLine;\n        ++rightLine;\n        ++position;\n      }\n      count = removed.length;\n      while (--count >= 0) {\n        leftMapping[leftLine] = position;\n        ++leftLine;\n        ++position;\n      }\n      count = added.length;\n      while (--count >= 0) {\n        rightMapping[rightLine] = position;\n        ++rightLine;\n        ++position;\n      }\n    });\n  });\n\n  return {\n    [DiffSide.Left]: leftMapping,\n    [DiffSide.Right]: rightMapping,\n  };\n}\n","/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\ntype HunkGroup = {\n  common: string[];\n  removed: string[];\n  added: string[];\n};\n\n/**\n * We must find the groups within `lines` so that multiline sequences of\n * modified lines are displayed correctly. A group is defined by:\n *\n * - a sequence of 0 or more \"common lines\" that start with ' '\n * - a sequence of 0 or more \"removed lines\" that start with '-'\n * - a sequence of 0 or more \"added lines\" that start with '+'\n *\n * Therefore, the end of a group is determined by either:\n *\n * - reaching the end of a list of lines\n * - encountering a \"common line\" after an \"added\" or \"removed\" line.\n */\nexport default function organizeLinesIntoGroups(lines: string[]): HunkGroup[] {\n  const groups = [];\n  let group = newGroup();\n  lines.forEach(fullLine => {\n    const firstChar = fullLine.charAt(0);\n    const line = fullLine.slice(1);\n    if (firstChar === ' ') {\n      if (hasDeltas(group)) {\n        // This must be the start of a new group!\n        groups.push(group);\n        group = newGroup();\n      }\n      group.common.push(line);\n    } else if (firstChar === '-') {\n      group.removed.push(line);\n    } else if (firstChar === '+') {\n      group.added.push(line);\n    }\n  });\n\n  groups.push(group);\n\n  return groups;\n}\n\nfunction hasDeltas(group: HunkGroup): boolean {\n  return group.removed.length !== 0 || group.added.length !== 0;\n}\n\nfunction newGroup(): HunkGroup {\n  return {\n    common: [],\n    removed: [],\n    added: [],\n  };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [233], () => (__webpack_require__(20)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"c74a6686\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t20: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = globalThis[\"webpackChunkReviewStack\"] = globalThis[\"webpackChunkReviewStack\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(233).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["root","factory","exports","module","define","amd","globalThis","grammars","language","undefined","injections","embeddedLanguages","fileName","fileFormat","globalCacheStats","cacheBlobReads","cacheTreeReads","cacheCommitReads","duplicateKeyBlob","duplicateKeyTree","duplicateKeyCommit","gitHubGetBlob","gitHubGetTree","gitHubGetCommit","gitHubGetCommitComparison","gitHubGetPullRequest","gitHubGetPullRequests","getReviewStackCacheStats","printReviewStackCacheStats","console","log","DB_NAME","INTERNAL_LOGOUT_EVENT_NAME","logoutBroadcastChannel","BroadcastChannel","localSubscribers","EventTarget","subscribeToLogout","callback","includeLogoutEventsFromThisWindow","unsubscribeCalls","channelListener","data","logout","addEventListener","push","removeEventListener","localSubscribersListener","_event","forEach","DB_COMMIT_STORE_NAME","DB_TREE_STORE_NAME","DB_BLOB_STORE_NAME","PR_FRAGMENT_STORE_NAME","OpenTransaction","constructor","db","storeName","this","tx","transaction","store","objectStore","txResult","Promise","resolve","reject","oncomplete","onerror","event","target","error","name","add","obj","request","e","onsuccess","identifier","implementsGitObject","oid","pr","owner","number","info","commit","CachingGitHubClient","client","async","cachedCommit","getCachedCommit","getCommit","tree","normalizedCommit","id","url","message","messageHeadline","messageHeadlineHTML","messageBody","messageBodyHTML","parents","committedDate","tree_oid","normalizeCommit","getCommitComparison","base","head","cachedTree","getCachedTree","getTree","cachedBlob","getCachedBlob","blob","getBlob","getPullRequest","getPullRequests","input","getRepoAssignableUsers","query","getRepoLabels","prs","cachedFragments","getCachedPRFragments","prsToFetch","prsToFetchIndex","fragment","index","fetchedFragments","getStackPullRequests","getOwnerAndName","all","map","originalIndex","normalizedFragment","title","updatedAt","state","reviewDecision","headRefOid","comments","numComments","totalCount","normalizePullRequestFragment","addComment","body","addLabels","addPullRequestReview","addPullRequestReviewComment","removeLabels","requestReviews","submitPullRequestReview","get","result","key","__typename","Error","OPEN_DATABASE_TIMEOUT_MS","openDatabase","openDatabaseRequest","self","indexedDB","open","onblocked","onupgradeneeded","commitStore","createObjectStore","keyPath","autoIncrement","createIndex","unique","treeStore","blobStore","pullRequestFragmentStore","database","promise","timeoutInMillis","race","_resolve","setTimeout","IDBDatabase","_openDatabase","then","close","RejectingGitHubClient","_oid","_base","_head","_pr","_input","_query","_prs","_id","_body","ActorType","AuditLogOrderField","CheckAnnotationLevel","CheckConclusionState","CheckRunState","CheckRunType","CheckStatusState","CollaboratorAffiliation","CommentAuthorAssociation","CommentCannotUpdateReason","CommitContributionOrderField","ComparisonStatus","ContributionLevel","DefaultRepositoryPermissionField","DependencyGraphEcosystem","DeploymentOrderField","DeploymentProtectionRuleType","DeploymentReviewState","DeploymentState","DeploymentStatusState","DiffSide","DiscussionCloseReason","DiscussionOrderField","DiscussionPollOptionOrderField","DiscussionState","DiscussionStateReason","DismissReason","EnterpriseAdministratorInvitationOrderField","EnterpriseAdministratorRole","EnterpriseAllowPrivateRepositoryForkingPolicyValue","EnterpriseDefaultRepositoryPermissionSettingValue","EnterpriseEnabledDisabledSettingValue","EnterpriseEnabledSettingValue","EnterpriseMemberOrderField","EnterpriseMembersCanCreateRepositoriesSettingValue","EnterpriseMembersCanMakePurchasesSettingValue","EnterpriseServerInstallationOrderField","EnterpriseServerUserAccountEmailOrderField","EnterpriseServerUserAccountOrderField","EnterpriseServerUserAccountsUploadOrderField","EnterpriseServerUserAccountsUploadSyncState","EnterpriseUserAccountMembershipRole","EnterpriseUserDeployment","FileViewedState","FundingPlatform","GistOrderField","GistPrivacy","GitSignatureState","IdentityProviderConfigurationState","IpAllowListEnabledSettingValue","IpAllowListEntryOrderField","IpAllowListForInstalledAppsEnabledSettingValue","IssueClosedStateReason","IssueCommentOrderField","IssueOrderField","IssueState","IssueStateReason","IssueTimelineItemsItemType","LabelOrderField","LanguageOrderField","LockReason","MannequinOrderField","MergeCommitMessage","MergeCommitTitle","MergeQueueEntryState","MergeQueueMergingStrategy","MergeStateStatus","MergeableState","MigrationSourceType","MigrationState","MilestoneOrderField","MilestoneState","NotificationRestrictionSettingValue","OidcProviderType","OauthApplicationCreateAuditEntryState","OperationType","OrderDirection","OrgAddMemberAuditEntryPermission","OrgCreateAuditEntryBillingPlan","OrgEnterpriseOwnerOrderField","OrgRemoveBillingManagerAuditEntryReason","OrgRemoveMemberAuditEntryMembershipType","OrgRemoveMemberAuditEntryReason","OrgRemoveOutsideCollaboratorAuditEntryMembershipType","OrgRemoveOutsideCollaboratorAuditEntryReason","OrgUpdateDefaultRepositoryPermissionAuditEntryPermission","OrgUpdateMemberAuditEntryPermission","OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility","OrganizationInvitationRole","OrganizationInvitationSource","OrganizationInvitationType","OrganizationMemberRole","OrganizationMembersCanCreateRepositoriesSettingValue","OrganizationMigrationState","OrganizationOrderField","PackageFileOrderField","PackageOrderField","PackageType","PackageVersionOrderField","PatchStatus","PinnableItemType","PinnedDiscussionGradient","PinnedDiscussionPattern","ProjectCardArchivedState","ProjectCardState","ProjectColumnPurpose","ProjectOrderField","ProjectState","ProjectTemplate","ProjectV2CustomFieldType","ProjectV2FieldOrderField","ProjectV2FieldType","ProjectV2ItemFieldValueOrderField","ProjectV2ItemOrderField","ProjectV2ItemType","ProjectV2OrderField","ProjectV2Roles","ProjectV2SingleSelectFieldOptionColor","ProjectV2State","ProjectV2ViewLayout","ProjectV2ViewOrderField","ProjectV2WorkflowsOrderField","PullRequestMergeMethod","PullRequestOrderField","PullRequestReviewCommentState","PullRequestReviewDecision","PullRequestReviewEvent","PullRequestReviewState","PullRequestReviewThreadSubjectType","PullRequestState","PullRequestTimelineItemsItemType","PullRequestUpdateState","ReactionContent","ReactionOrderField","RefOrderField","ReleaseOrderField","RepoAccessAuditEntryVisibility","RepoAddMemberAuditEntryVisibility","RepoArchivedAuditEntryVisibility","RepoChangeMergeSettingAuditEntryMergeType","RepoCreateAuditEntryVisibility","RepoDestroyAuditEntryVisibility","RepoRemoveMemberAuditEntryVisibility","ReportedContentClassifiers","RepositoryAffiliation","RepositoryContributionType","RepositoryInteractionLimit","RepositoryInteractionLimitExpiry","RepositoryInteractionLimitOrigin","RepositoryInvitationOrderField","RepositoryLockReason","RepositoryMigrationOrderDirection","RepositoryMigrationOrderField","RepositoryOrderField","RepositoryPermission","RepositoryPrivacy","RepositoryRuleType","RepositoryRulesetTarget","RepositoryVisibility","RepositoryVulnerabilityAlertDependencyScope","RepositoryVulnerabilityAlertState","RequestableCheckStatusState","RoleInOrganization","RuleBypassMode","RuleEnforcement","SamlDigestAlgorithm","SamlSignatureAlgorithm","SavedReplyOrderField","SearchType","SecurityAdvisoryClassification","SecurityAdvisoryEcosystem","SecurityAdvisoryIdentifierType","SecurityAdvisoryOrderField","SecurityAdvisorySeverity","SecurityVulnerabilityOrderField","SocialAccountProvider","SponsorOrderField","SponsorableOrderField","SponsorsActivityAction","SponsorsActivityOrderField","SponsorsActivityPeriod","SponsorsCountryOrRegionCode","SponsorsGoalKind","SponsorsListingFeaturedItemFeatureableType","SponsorsTierOrderField","SponsorshipNewsletterOrderField","SponsorshipOrderField","SponsorshipPrivacy","SquashMergeCommitMessage","SquashMergeCommitTitle","StarOrderField","StatusState","SubscriptionState","TeamDiscussionCommentOrderField","TeamDiscussionOrderField","TeamMemberOrderField","TeamMemberRole","TeamMembershipType","TeamNotificationSetting","TeamOrderField","TeamPrivacy","TeamRepositoryOrderField","TeamReviewAssignmentAlgorithm","TeamRole","TopicSuggestionDeclineReason","TrackedIssueStates","UserBlockDuration","UserStatusOrderField","VerifiableDomainOrderField","WorkflowRunOrderField","WorkflowState","settings","foreground","background","scope","fontStyle","fetchGrammar","moduleName","type","uri","response","fetch","grammar","text","GrammarStore","registry","loadGrammar","initialScopeName","getColorMap","URL_TO_ONIG_WASM","createGrammarStore","theme","onigurumaLoadingJob","onigurumaWASMRequest","contentType","headers","loadWASM","dataOrOptions","arrayBuffer","print","str","loadOniguruma","ensureOnigurumaIsLoaded","Registry","onigLib","createOnigScanner","createOnigString","scopeName","config","filePath","parseRawGrammar","getInjections","createTextMateRegistry","FOREGROUND_MASK","tokenizeFileContents","fileContents","timeLimit","lines","INITIAL","line","tokenizeLine2","tokensLength","tokens","length","singleLine","j","startIndex","nextStartIndex","substring","foregroundIdx","start","end","color","stoppedEarly","ruleStack","tokenizeLines","split","globalScope","getGitHubClient","init","lazyInit","broadcastChannel","numActiveRequests","broadcastAvailability","method","workerName","available","postMessage","updateRequestCount","delta","onMessage","port","params","oldOID","newOID","beforeBlob","afterBlob","getBlobPair","left","right","leftMapping","rightMapping","patch","context","position","hunks","oldStart","newStart","groups","group","common","removed","added","fullLine","firstChar","charAt","slice","hasDeltas","organizeLinesIntoGroups","leftLine","rightLine","count","Left","Right","lineToPosition","fetchLineToPosition","ok","finally","colorMode","getGrammarStore","colorMap","path","before","after","beforeContents","afterContents","tokenization","tokenizeSplitDiff","diffAndTokenize","numLines","notFound","isBinary","unsplitLines","join","findlineRange","ports","onmessage","colorModeToGrammarStore","Map","existingRequest","VSCodeLightPlusTheme","VSCodeDarkPlusTheme","set","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call","m","x","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","Infinity","i","fulfilled","Object","keys","every","splice","r","d","definition","o","defineProperty","enumerable","f","chunkId","reduce","promises","u","miniCssF","prop","prototype","hasOwnProperty","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","pop","next"],"sourceRoot":""}