[{"title":"ReviewStack","type":0,"sectionRef":"#","url":"/docs/addons/reviewstack","content":"","keywords":"","version":"Next"},{"title":"Keyboard shortcuts​","type":1,"pageTitle":"ReviewStack","url":"/docs/addons/reviewstack#keyboard-shortcuts","content":" ReviewStack supports the following keyboard shortcuts:  key\tactionshift+N\tnext PR in stack shift+P\tprevious PR in stack ctrl+. (cmd+. on macOS)\ttoggle timeline view alt+A\tselect Approve Changes action alt+R\tselect Request Changes action alt+C\tselect Comment action ","version":"Next","tagName":"h2"},{"title":"Visual Studio extension","type":0,"sectionRef":"#","url":"/docs/addons/vs","content":"","keywords":"","version":"Next"},{"title":"Embedded interactive smartlog​","type":1,"pageTitle":"Visual Studio extension","url":"/docs/addons/vs#embedded-interactive-smartlog","content":" Access the Interactive Smartlog (ISL) interface directly within Visual Studio, without needing to launch it with sl web. Just launch the tool window via View -&gt; Other Windows -&gt; Interactive Smartlog or use keyboard shortcut ctrl + shift + I. ","version":"Next","tagName":"h3"},{"title":"VS Code extension","type":0,"sectionRef":"#","url":"/docs/addons/vscode","content":"","keywords":"","version":"Next"},{"title":"Embedded interactive smartlog​","type":1,"pageTitle":"VS Code extension","url":"/docs/addons/vscode#embedded-interactive-smartlog","content":" Access the Interactive Smartlog (ISL) interface directly within VS Code, without needing to launch it with sl web. Just run the Sapling: Open Interactive Smartlog command from the command palette.  ","version":"Next","tagName":"h3"},{"title":"VS Code source control API​","type":1,"pageTitle":"VS Code extension","url":"/docs/addons/vscode#vs-code-source-control-api","content":" Sapling also implements the VS Code API for source control:  You can see your uncommitted changes in the Source Control sidebar.Files you change will have gutters that show what lines of code have changed.You can open an editable diff viewer from the command palette withSapling SCM: Open Diff View For Current File. ","version":"Next","tagName":"h3"},{"title":"Interactive Smartlog (ISL)","type":0,"sectionRef":"#","url":"/docs/addons/isl","content":"","keywords":"","version":"Next"},{"title":"What can you do with ISL?​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#what-can-you-do-with-isl","content":" As the name suggests, Interactive Smartlog is an interactive form of the smartlog command. ISL shows you a tree of your commits, with each commit including information about Pull Requests, bookmarks, and more. Rather than typing commit hashes, you can directly click on commits to interact with them. For example, rebasing a commit is as simple as dragging and dropping.  While ISL doesn't provide every single feature of the Sapling CLI, it is designed to simplify everyday workflows and provide an extremely clear picture of your local changes, which is often all that's needed.  ","version":"Next","tagName":"h2"},{"title":"Working with commits and stacks​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#working-with-commits-and-stacks","content":" The main commit tree in ISL has an indicator that says You are here, showing which commit you are currently on. You can go to different commits by hovering on them and clicking Goto to run sl goto.     As you create new commits, they will be created on top of each other, forming stacks. This is similar to branches in Git. A commit can also have more than one commit stacked on top of it.  You can drag and drop commits to rebase them. This is the easiest way to re-arrange commits and manipulate stacks.    Note that drag-and-drop rebasing is not allowed while you have uncommitted changes, since it's harder to deal with merge conflicts. Commit any uncommitted changes first to work around this.  Drag-and-drop performs a sl rebase, including all commits stacked on top of the commit being dragged. If you want to re-arrange commits within your stack, consider using sl histedit.  ","version":"Next","tagName":"h3"},{"title":"Running commands​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#running-commands","content":" Buttons in ISL run Sapling commands for you. For example, there is a Pull button at the top left to pull the latest changes from upstream.  While a command is running, you will see progress information at the bottom of the screen. This is also where you can see error messages if something goes wrong when running a command. ISL shows the arguments used to run commands, so you could replicate the behavior on the CLI if you want to.     Some commands like sl status will run automatically in the background to fetch data so the UI is always up to date.  Commands will automatically queue up to be run as you interact with the UI. ISL allows you to continue to perform additional actions while previous commands are running or queued up. This is kind of like chaining together commands on the CLI: sl pull &amp;&amp; sl rebase main &amp;&amp; sl goto main. Similar to &amp;&amp; on the CLI, if any command along the way fails or hits merge conflicts, all further queued commands will be cancelled.  ","version":"Next","tagName":"h3"},{"title":"Making commits and amending​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#making-commits-and-amending","content":" Changes to files in your working copy appear automatically in ISL, just like if you had run sl status. The color and icon next to files shows you if a file was modified, added, or removed. You can click on files to open them in your Operating System's default program for that file type.     Underneath your uncommitted changes, there's a Commit button and an Amend button.Commit will create a new commit out of your changes.Amend will update the previous commit with your newest changes.  When hovering on these buttons, you'll see there's also additional Commit as... and Amend as... buttons to first write or update the commit message before running commit/amend. Clicking these buttons opens up the commit form sidebar on the right side, where you can write a detailed commit message. When you're satisfied with your message, the Commit and Amend buttons at the bottom right will let you create or amend your commit using your message.     ","version":"Next","tagName":"h3"},{"title":"Interacting with code review​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#interacting-with-code-review","content":" tip In order to interact with GitHub for code review in ISL, be sure to install the gh GitHub CLI. Learn more.  ISL considers code review an integral part of the source control workflow. When making commits, you usually want to submit it for review. In the commit form on the right, ISL has a button to Commit and Submit, as well as Amend and Submit.  These will run a submit command on your stack of commits to submit them for code review on GitHub.  You have two options for which command to use to submit for GitHub, sl ghstack and sl pr. ISL will prompt you for your choice the first time you try to submit. This can also be controlled by setting github.preferred_submit_command to ghstack or pr:  sl config --local github.preferred_submit_command &lt;ghstack or pr&gt;   See documentation on Using Sapling with GitHub for more information.     Commits in your tree which are associated with a GitHub Pull Request will show a badge underneath showing the status of that Pull Request. You can click this badge to open the Pull Request in GitHub (or configure it to open alternate domains).  This badge also shows the CI build status and how many comments there are.  ","version":"Next","tagName":"h3"},{"title":"Resolving merge conflicts​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#resolving-merge-conflicts","content":" Running some commands like sl rebase can sometimes lead to merge conflicts. When merge conflicts are detected, ISL will change the list of uncommitted changes into a list of unresolved conflicts.     After opening each file and resolving the conflict markers, you can click the checkmark next to each file in ISL to mark it as resolved. When all files have been resolved, you are free to continue the command that led to conflicts.  It is possible to hit merge conflicts multiple times, for example, when rebasing an entire stack of commits, as each commit is checked for conflicts one-by-one.     ","version":"Next","tagName":"h3"},{"title":"Comparing changes​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#comparing-changes","content":" ISL includes a comparison view to quickly see all your changes, similar to sl diffOne common use case is to look over all your uncommitted local changes before you submit them for code review.  Just above your uncommitted changes, there's a View Changes button to open the comparison view in Uncommitted Changes mode. In the comparison view, you'll see a split diff view of each file you've changed. You can also access this view with the shortcut Command+'.     The comparison view supports other comparisons as well.  Uncommitted Changes: As mentioned, shows changes to your working copy that haven't been committed or amended yet. This is all the changes of the files sl status shows by default. Shortcut: Command+'.Head Changes: Shows all the changes in the current commit, plus any uncommitted changes on top of that. Useful to see what the most recent commit will look like after amending. Shortcut: Command+Shift+'Stack Changes: Shows all the changes in your stack of commits going back to the main branch, plus any uncommitted changes. Useful to see absolutely everything you've changed.Committed Changes: Shows the changes in a specific commit. This is accessible by selecting a commit then clicking on &quot;View Changes in &lt;hash&gt;&quot;. Unlike the other comparisons, this does not include your uncommitted changes.  The comparison view is currently read-only.  ","version":"Next","tagName":"h3"},{"title":"Speeding up change detection with Watchman​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#speeding-up-change-detection-with-watchman","content":" In order to detect when files have changed in your repository, ISL must occasionally run sl commands to check for changes. To reduce resource usage and speed up how quickly changes are detected, ISL can optionally use Watchman, a file watching service. If Watchman is installed on your path, it will automatically be used. Note that your repository must also have a .watchmanconfig in the root directory to make use of this feature.  ","version":"Next","tagName":"h2"},{"title":"Connecting to ISL running on another machine​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#connecting-to-isl-running-on-another-machine","content":" If you are using Sapling on a remote machine, but want to use ISL, you have two options:  ","version":"Next","tagName":"h2"},{"title":"Host with available ports​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#host-with-available-ports","content":" If you are using Sapling on a remote machine that is able to open ports to the outside world, choose a port like 5000 and pass it as the -p argument to web when launching it on the remote host:  alyssa@example.com:/home/alyssa/sapling$ sl isl --no-open -p 5000 launching web server for Interactive Smartlog... Listening on http://localhost:5000/?token=a6d646073f28ef2fd09a89bed93e89f4&amp;cwd=%2Fhome%2Falyssa%2Fsapling Server logs will be written to /dev/shm/tmp/isl-server-logqrqvvN/isl-server.log   Assuming your remote hostname is example.com, take the URL that sl web printed out and replace localhost with the hostname like so:  http://example.com:5000/?token=a6d646073f28ef2fd09a89bed93e89f4&amp;cwd=%2Fhome%2Falyssa%2Fsapling   You should be able to open this URL in your local browser to access ISL.  ","version":"Next","tagName":"h3"},{"title":"Host with no available ports​","type":1,"pageTitle":"Interactive Smartlog (ISL)","url":"/docs/addons/isl#host-with-no-available-ports","content":" If you are running Sapling on a host where you do not have permissions to open ports to the outside world, you may be able to leverage SSH port forwarding to access ISL.  On the server:  alyssa@example.com:/home/alyssa/sapling$ sl isl --no-open -p 5000 launching web server for Interactive Smartlog... Listening on http://localhost:5000/?token=a6d646073f28ef2fd09a89bed93e89f4&amp;cwd=%2Fhome%2Falyssa%2Fsapling Server logs will be written to /dev/shm/tmp/isl-server-logqrqvvN/isl-server.log   On your local machine where you have SSH access to the server:  ssh -L 4000:localhost:5000 -N alyssa@example.com   Note that this command will stay running in the foreground so long as you remain connected to the remote host. If you lose the connection (perhaps because your computer has gone to sleep), then you will have to run the ssh command again to re-establish the connection.  Then take the original URL that you saw on the server and change the port from 5000 to 4000 before trying to open it on your local machine:  http://localhost:4000/?token=a6d646073f28ef2fd09a89bed93e89f4&amp;cwd=%2Fhome%2Falyssa%2Fsapling  ","version":"Next","tagName":"h3"},{"title":"absorb","type":0,"sectionRef":"#","url":"/docs/commands/absorb","content":"","keywords":"","version":"Next"},{"title":"absorb | ab​","type":1,"pageTitle":"absorb","url":"/docs/commands/absorb#absorb--ab","content":" intelligently integrate pending changes into current stack  Attempt to amend each pending change to the proper commit in your stack. Absorb does not write to the working copy.  If absorb cannot find an unambiguous commit to amend for a change, that change will be left in the working copy, untouched. The unabsorbed changes can be observed by sl status or sl diff afterwards.  Commits outside the revset ::. and not public() and not merge() will not be changed.  Commits that become empty after applying the changes will be deleted.  By default, absorb will show what it plans to do and prompt for confirmation. If you are confident that the changes will be absorbed to the correct place, run sl absorb -a to apply the changes immediately.  Returns 0 if anything was absorbed, 1 if nothing was absorbed.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"absorb","url":"/docs/commands/absorb#arguments","content":" shortname\tfullname\tdefault\tdescription-a\t--apply-changes apply changes without prompting for confirmation -d\t--date record the specified date as commit date -n\t--dry-run do not perform actions, just print output -T\t--template display with template -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"add","type":0,"sectionRef":"#","url":"/docs/commands/add","content":"","keywords":"","version":"Next"},{"title":"add​","type":1,"pageTitle":"add","url":"/docs/commands/add#add","content":" start tracking the specified files  Specify files to be tracked by Sapling. The files will be added to the repository at the next commit.  To undo an add before files have been committed, use sl forget. To undo an add after files have been committed, use sl rm.  If no names are given, add all files to the repository (except files matching .gitignore).  Examples:  New (unknown) files are added automatically by sl add:  $ ls foo.c $ sl status ? foo.c $ sl add adding foo.c $ sl status A foo.c   Add specific files:  $ ls bar.c foo.c $ sl status ? bar.c ? foo.c $ sl add bar.c $ sl status A bar.c ? foo.c   Returns 0 if all files are successfully added.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"add","url":"/docs/commands/add#arguments","content":" shortname\tfullname\tdefault\tdescription-I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -n\t--dry-run do not perform actions, just print output -s\t--sparse also include directories of added files in sparse config ","version":"Next","tagName":"h2"},{"title":"amend","type":0,"sectionRef":"#","url":"/docs/commands/amend","content":"","keywords":"","version":"Next"},{"title":"amend | am​","type":1,"pageTitle":"amend","url":"/docs/commands/amend#amend--am","content":" meld pending changes into the current commit  Replace your current commit with a new commit that contains the contents of the original commit, plus any pending changes.  By default, all pending changes (in other words, those reported bysl status) are committed. To commit only some of your changes, you can:  Specify an exact list of files for which you want changes committed. Use the -I or -X flags to match file names to exclude or include using patterns or filesets. See sl help patterns and sl help filesets. Specify the --interactive flag to open a UI where you can select individual hunks for inclusion.  By default, sl amend reuses your existing commit message and does not prompt you for changes. To change your commit message, you can:  Specify --edit/-e to open your configured editor to update the existing commit message. Specify --message/-m to replace the entire commit message, including any commit template fields, with a string that you specify.  Specifying -m overwrites all information in the commit message, including information specified as part of a pre-loaded commit template. For example, any information associating this commit with a code review system will be lost and might result in breakages.  When you amend a commit that has descendants, those descendants are rebased on top of the amended version of the commit, unless doing so would result in merge conflicts. If this happens, run sl restackto manually trigger the rebase so that you can go through the merge conflict resolution process. Alternatively:  Specify --rebase to always trigger the rebase and resolve merge conflicts. Specify --no-rebase to prevent the automatic rebasing of descendants.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"amend","url":"/docs/commands/amend#arguments","content":" shortname\tfullname\tdefault\tdescription-A\t--addremove mark new/missing files as added/removed before committing -e\t--edit prompt to edit the commit message -i\t--interactive use interactive mode --no-move-detection disable automatic file move detection --rebase rebases children after the amend --to amend to a specific commit in the current stack -T\t--template display with template -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer --stack incorporate corrections into stack. see 'sl help absorb' for details ","version":"Next","tagName":"h2"},{"title":"annotate","type":0,"sectionRef":"#","url":"/docs/commands/annotate","content":"","keywords":"","version":"Next"},{"title":"annotate | blame | an​","type":1,"pageTitle":"annotate","url":"/docs/commands/annotate#annotate--blame--an","content":" show per-line commit information for given files  Show file contents where each line is annotated with information about the commit that last changed that line.  This command is useful for discovering when a change was made and by whom.  If you include --file, --user, or --date, the revision number is suppressed unless you also include --number.  Without the -a/--text option, annotate will skip binary files. With -a, binary files will be annotated anyway.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"annotate","url":"/docs/commands/annotate#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev annotate the specified revision --no-follow\tfalse\tdon't follow copies and renames -a\t--text treat all files as text -u\t--user list the author (long with -v) -f\t--file list the filename -d\t--date list the date (short with -q) -n\t--number list the revision number -c\t--changeset list the changeset (default) -l\t--line-number show line number at the first appearance -w\t--ignore-all-space ignore white space when comparing lines -b\t--ignore-space-change ignore changes in the amount of white space -B\t--ignore-blank-lines ignore changes whose lines are all blank -Z\t--ignore-space-at-eol ignore changes in whitespace at EOL -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -p\t--phabdiff list phabricator diff id ","version":"Next","tagName":"h2"},{"title":"addremove","type":0,"sectionRef":"#","url":"/docs/commands/addremove","content":"","keywords":"","version":"Next"},{"title":"addremove | addrm​","type":1,"pageTitle":"addremove","url":"/docs/commands/addremove#addremove--addrm","content":" add all new files, delete all missing files  Start tracking all new files and stop tracking all missing files in the working copy. As with sl add, these changes take effect at the next commit.  Unless file names are given, new files are ignored if they match any of the patterns in .gitignore.  Use the -s/--similarity option to detect renamed files. This option takes a percentage between 0 (disabled) and 100 (files must be identical) as its parameter. With a parameter greater than 0, this compares every removed file with every added file and records those similar enough as renames. Detecting renamed files this way can be expensive. After using this option, sl status -C can be used to check which files were identified as moved or renamed. If not specified, -s/--similarity defaults to 100, only marking identical files renamed.  Examples:  Files bar.c and foo.c are new, while foobar.c has been removed (without using sl remove) from the repository:  $ ls bar.c foo.c $ sl status ! foobar.c ? bar.c ? foo.c $ sl addremove adding bar.c adding foo.c removing foobar.c $ sl status A bar.c A foo.c R foobar.c   A file foobar.c was moved to foo.c without using sl rename. Afterwards, it was edited slightly:  $ ls foo.c $ sl status ! foobar.c ? foo.c $ sl addremove --similarity 90 removing foobar.c adding foo.c recording removal of foobar.c as rename to foo.c (94% similar) $ sl status -C A foo.c foobar.c R foobar.c   Returns 0 if all files are successfully added/removed.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"addremove","url":"/docs/commands/addremove#arguments","content":" shortname\tfullname\tdefault\tdescription-s\t--similarity guess renamed files by similarity (0&lt;=s&lt;=100) -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -n\t--dry-run do not perform actions, just print output ","version":"Next","tagName":"h2"},{"title":"backout","type":0,"sectionRef":"#","url":"/docs/commands/backout","content":"","keywords":"","version":"Next"},{"title":"backout​","type":1,"pageTitle":"backout","url":"/docs/commands/backout#backout","content":" reverse the effects of an earlier commit  Create an inverse commit of the specified commit. Backout is commonly used to undo the effects of a public commit.  By default, sl backout creates a new commit on top of the current commit. Specify --no-commit to skip making a new commit, leaving the changes outstanding in your working copy.  If merge conflicts are encountered during the backout, changes will be left in the working copy with conflict markers inserted. When this occurs, resolve the conflicts and then run sl commit.  By default, sl backout will abort if pending changes are present in the working copy. Specify --merge to combine changes from the backout with your pending changes.  Examples:  Reverse the effect of the parent of the working copy. This backout will be committed immediately:  sl backout -r .   Reverse the effect of previous bad commit 42e8dde:  sl backout -r 42e8ddebe   Reverse the effect of previous bad revision 42e8dde and leave changes uncommitted:  sl backout -r 42e8ddebe --no-commit sl commit -m &quot;Backout 42e8ddebe&quot;   By default, the new commit will have one parent, maintaining a linear history. With --merge, the commit will instead have two parents: the old parent of the working copy and a new child of REV that simply undoes REV.  See sl help dates for a list of formats valid for -d/--date.  See sl help revert for a way to restore files to the state of another revision.  Returns 0 on success, 1 if nothing to backout or there are unresolved files.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"backout","url":"/docs/commands/backout#arguments","content":" shortname\tfullname\tdefault\tdescription\t--merge combine existing pending changes with backout changes --no-commit\tfalse\tdo not commit -r\t--rev revision to back out -e\t--edit\tfalse\topen editor to specify custom commit message -t\t--tool specify merge tool -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer ","version":"Next","tagName":"h2"},{"title":"clone","type":0,"sectionRef":"#","url":"/docs/commands/clone","content":"","keywords":"","version":"Next"},{"title":"clone​","type":1,"pageTitle":"clone","url":"/docs/commands/clone#clone","content":" make a copy of an existing repository  Create a copy of an existing repository in a new directory.  If no destination directory name is specified, it defaults to the basename of the source.  The location of the source is added to the new repository's config file as the default to be used for future pulls.  Sources are typically URLs. The following URL schemes are assumed to be a Git repo: git, git+file, git+ftp, git+ftps,git+http, git+https, git+ssh, ssh and https.  Scp-like URLs of the form user@host:path are converted tossh://user@host/path.  Other URL schemes are assumed to point to an SaplingRemoteAPI capable repo.  The --git option forces the source to be interpreted as a Git repo.  To check out a particular version, use -u/--update, or-U/--noupdate to create a clone with no working copy.  If specified, the --enable-profile option should refer to a sparse profile within the source repo to filter the contents of the new working copy. See sl help -e sparse for details.  Examples:  clone a remote repository to a new directory named some_repo:  sl clone https://example.com/some_repo   As an experimental feature, if specified the source URL fragment is persisted as the repo's main bookmark.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"clone","url":"/docs/commands/clone#arguments","content":" shortname\tfullname\tdefault\tdescription-U\t--noupdate\tfalse\tclone an empty working directory -u\t--updaterev revision or branch to check out --enable-profile enable a sparse profile ","version":"Next","tagName":"h2"},{"title":"clean","type":0,"sectionRef":"#","url":"/docs/commands/clean","content":"","keywords":"","version":"Next"},{"title":"clean | purge​","type":1,"pageTitle":"clean","url":"/docs/commands/clean#clean--purge","content":" delete untracked files  Delete all untracked files in your working copy. Untracked files are files that are unknown to Sapling. They are marked with &quot;?&quot; when you runsl status.  By default, sl clean implies --files, so only untracked files are deleted. If you add --ignored, ignored files are also deleted. If you add --dirs, empty directories are deleted and--files is no longer implied.  If directories are given on the command line, only files in these directories are considered.  Caution: sl clean is irreversible. To avoid accidents, first perform a dry run with sl clean --print.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"clean","url":"/docs/commands/clean#arguments","content":" shortname\tfullname\tdefault\tdescription-a\t--abort-on-err abort if an error occurs --ignored delete ignored files too --dirs delete empty directories --files delete files -p\t--print print filenames instead of deleting them -0\t--print0 end filenames with NUL, for use with xargs (implies -p/--print) -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"cat","type":0,"sectionRef":"#","url":"/docs/commands/cat","content":"","keywords":"","version":"Next"},{"title":"cat​","type":1,"pageTitle":"cat","url":"/docs/commands/cat#cat","content":" output the current or given revision of files  Print the specified files as they were at the given revision. If no revision is given, the parent of the working directory is used.  Output may be to a file, in which case the name of the file is given using a format string. The formatting rules as follows:  %%literal &quot;%&quot; character  %sbasename of file being printed  %ddirname of file being printed, or '.' if in repository root  %proot-relative path name of file being printed  %Hchangeset hash (40 hexadecimal digits)  %Rchangeset revision number  %hshort-form changeset hash (12 hexadecimal digits)  %rzero-padded changeset revision number  %bbasename of the exporting repository  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"cat","url":"/docs/commands/cat#arguments","content":" shortname\tfullname\tdefault\tdescription-o\t--output print output to file with formatted name -r\t--rev print the given revision -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"bookmark","type":0,"sectionRef":"#","url":"/docs/commands/bookmark","content":"","keywords":"","version":"Next"},{"title":"bookmark | bo | book | bookmarks​","type":1,"pageTitle":"bookmark","url":"/docs/commands/bookmark#bookmark--bo--book--bookmarks","content":" create a new bookmark or list existing bookmarks  Bookmarks are labels on changesets to help track lines of development. Bookmarks are unversioned and can be moved, renamed and deleted. Deleting or moving a bookmark has no effect on the associated changesets.  Creating or updating to a bookmark causes it to be marked as 'active'. The active bookmark is indicated with a '*'. When a commit is made, the active bookmark will advance to the new commit. A plain sl goto will also advance an active bookmark, if possible. Updating away from a bookmark will cause it to be deactivated.  Bookmarks can be pushed and pulled between repositories (seesl help push and sl help pull). If a shared bookmark has diverged, a new 'divergent bookmark' of the form 'name@path' will be created. Using sl merge will resolve the divergence.  Specifying bookmark as '.' to -m or -d options is equivalent to specifying the active bookmark's name.  Examples:  create an active bookmark for a new line of development:  sl book new-feature   create an inactive bookmark as a place marker:  sl book -i reviewed   create an inactive bookmark on another changeset:  sl book -r .^ tested   rename bookmark turkey to dinner:  sl book -m turkey dinner   move the '@' bookmark from another branch:  sl book -f @   In Git repos, bookmarks correspond to branches. Remote Git branches can be listed using the --remote flag.  Examples:  list remote branches:  sl bookmark --remote   list remote tags:  sl bookmark --remote tags   list all refs:  sl bookmark --remote 'refs/*'   list branches from specified path:  sl bookmark --remote --remote-path my-fork   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"bookmark","url":"/docs/commands/bookmark#arguments","content":" shortname\tfullname\tdefault\tdescription-f\t--force\tfalse\tforce -r\t--rev revision for bookmark action -d\t--delete\tfalse\tdelete a given bookmark -D\t--strip like --delete, but also strip changesets -m\t--rename rename a given bookmark -i\t--inactive\tfalse\tmark a bookmark inactive -t\t--track track this bookmark or remote name -u\t--untrack remove tracking for this bookmark -a\t--all show both remote and local bookmarks --remote fetch remote Git refs --remote-path remote path from which to fetch bookmarks --list-subscriptions show only remote bookmarks that are available locally ","version":"Next","tagName":"h2"},{"title":"config","type":0,"sectionRef":"#","url":"/docs/commands/config","content":"","keywords":"","version":"Next"},{"title":"config | conf​","type":1,"pageTitle":"config","url":"/docs/commands/config#config--conf","content":" show config settings  With no arguments, print names and values of all config items.  With one argument of the form section.name, print just the value of that config item.  With multiple arguments, print names and values of all config items with matching section names.  With --user, edit the user-level config file. With --system, edit the system-wide config file. With --local, edit the repository-level config file. If there are no arguments, spawn an editor to edit the config file. If there are arguments insection.name=value or section.name value format, the appropriate config file will be updated directly without spawning an editor.  With --delete, the specified config items are deleted from the config file.  With --debug, the source (filename and line number) is printed for each config item.  See sl help config for more information about config files.  Returns 0 on success, 1 if NAME does not exist.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"config","url":"/docs/commands/config#arguments","content":" shortname\tfullname\tdefault\tdescription-u\t--user\tfalse\tedit user config, opening in editor if no args given -l\t--local\tfalse\tedit repository config, opening in editor if no args given -s\t--system\tfalse\tedit system config, opening in editor if no args given -d\t--delete\tfalse\tdelete specified config items ","version":"Next","tagName":"h2"},{"title":"commit","type":0,"sectionRef":"#","url":"/docs/commands/commit","content":"","keywords":"","version":"Next"},{"title":"commit | ci​","type":1,"pageTitle":"commit","url":"/docs/commands/commit#commit--ci","content":" save all pending changes or specified files in a new commit  Commit changes to the given files to your local repository.  By default, all pending changes (in other words, those reported bysl status) are committed. If you want to commit only some of your changes, choose one of the following options:  Specify an exact list of files for which you want changes committed. Use the -I or -X flags to match or exclude file names using a pattern or fileset. See sl help patterns and sl help filesets for details. Specify the --interactive flag to open a UI to select individual files, hunks, or lines.  To meld pending changes into the current commit instead of creating a new commit, see sl amend.  If you are committing the result of a merge, such as when merge conflicts occur during sl goto, commit all pending changes. Do not specify files or use -I, -X, or -i.  Specify the -m flag to include a free-form commit message. If you do not specify -m, Sapling opens your configured editor where you can enter a message based on a pre-loaded commit template.  Returns 0 on success, 1 if nothing changed.  If your commit fails, you can find a backup of your commit message in.sl/last-message.txt.  Examples:  commit all files ending in .py:  sl commit --include &quot;glob:**.py&quot;   commit all non-binary files:  sl commit --exclude &quot;set:binary()&quot;   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"commit","url":"/docs/commands/commit#arguments","content":" shortname\tfullname\tdefault\tdescription-A\t--addremove mark new/missing files as added/removed before committing -e\t--edit invoke editor on commit messages -i\t--interactive use interactive mode -M\t--reuse-message reuse commit message from REV --no-move-detection disable automatic file move detection -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer ","version":"Next","tagName":"h2"},{"title":"forget","type":0,"sectionRef":"#","url":"/docs/commands/forget","content":"","keywords":"","version":"Next"},{"title":"forget​","type":1,"pageTitle":"forget","url":"/docs/commands/forget#forget","content":" stop tracking the specified files  Mark the specified files so they will no longer be tracked after the next commit.  Forget does not delete the files from the working copy. To delete the file from the working copy, see sl remove.  Forget does not remove files from the repository history. The files will only be removed in the next commit and its descendants.  To undo a forget before the next commit, see sl add.  Examples:  forget newly-added binary files:  sl forget &quot;set:added() and binary()&quot;   forget files that would be excluded by .gitignore:  sl forget &quot;set:gitignore()&quot;   Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"forget","url":"/docs/commands/forget#arguments","content":" shortname\tfullname\tdefault\tdescription-I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"diff","type":0,"sectionRef":"#","url":"/docs/commands/diff","content":"","keywords":"","version":"Next"},{"title":"diff | d​","type":1,"pageTitle":"diff","url":"/docs/commands/diff#diff--d","content":" show differences between commits  Show the differences between two commits. If only one commit is specified, show the differences between the specified commit and your working copy. If no commits are specified, show your pending changes.  Specify -c to see the changes in the specified commit relative to its parent.  By default, this command skips binary files. To override this behavior, specify -a to include binary files in the diff.  By default, diffs are shown using the unified diff format. Specify -gto generate diffs in the git extended diff format. For more information, see sl help diffs.  --from-path and --to-path allow diffing between directories. Files outside --from-path in the left side are ignored. Seesl help directorybranching for more information.  sl diff might generate unexpected results during merges because it defaults to comparing against your working copy's first parent commit if no commits are specified.  Examples:  compare a file in the current working directory to its parent:  sl diff foo.c   compare two historical versions of a directory, with rename info:  sl diff --git -r 5be761874:431ec8e07 lib/   get change stats relative to the last change on some date:  sl diff --stat -r &quot;date('may 2')&quot;   diff all newly-added files that contain a keyword:  sl diff &quot;set:added() and grep(GNU)&quot;   compare a revision and its parents:  sl diff -c 340f3fef5 # compare against first parent sl diff -r 340f3fef5^:340f3fef5 # same using revset syntax sl diff -r 340f3fef5^2:340f3fef5 # compare against the second parent   Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"diff","url":"/docs/commands/diff#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revision -c\t--change change made by revision -a\t--text treat all files as text -g\t--git use git extended diff format --binary generate binary diffs in git mode (default) --nodates omit dates from diff headers --noprefix omit a/ and b/ prefixes from filenames -p\t--show-function show which function each change is in --reverse produce a diff that undoes the changes -w\t--ignore-all-space ignore white space when comparing lines -b\t--ignore-space-change ignore changes in the amount of white space -B\t--ignore-blank-lines ignore changes whose lines are all blank -Z\t--ignore-space-at-eol ignore changes in whitespace at EOL -U\t--unified number of lines of context to show --stat output diffstat-style summary of changes --root produce diffs relative to subdirectory --only-files-in-revs only show changes for files modified in the requested revisions -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -s\t--sparse only show changes in files in the sparse config ","version":"Next","tagName":"h2"},{"title":"fold","type":0,"sectionRef":"#","url":"/docs/commands/fold","content":"","keywords":"","version":"Next"},{"title":"fold | squash​","type":1,"pageTitle":"fold","url":"/docs/commands/fold#fold--squash","content":" combine multiple commits into a single commit  With --from, fold all of the commit linearly between the current commit and the specified commit.  With --exact, fold only the specified commits while ignoring the current commit. The given commits must form a linear, continuous chain.  Some examples:  Fold from the current commit to its parent:  sl fold --from .^   Fold all draft commits into the current commit:  sl fold --from 'draft()'   See sl help phases for more about draft commits andsl help revsets for more about the draft() keyword.  Fold commits between e254371 and be57079 into the current commit:  sl fold --from e254371c1::be57079e4   Fold commits e254371 and be57079:  sl fold &quot;e254371c1 + be57079e4&quot; --exact   Only fold commits linearly between foo and .:  sl fold foo::. --exact   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"fold","url":"/docs/commands/fold#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revision to fold --exact only fold specified revisions --from fold linearly from current revision to specified revision --no-rebase\tfalse\tdon't rebase descendants after fold -M\t--reuse-message reuse commit message from REV -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer ","version":"Next","tagName":"h2"},{"title":"githelp","type":0,"sectionRef":"#","url":"/docs/commands/githelp","content":"","keywords":"","version":"Next"},{"title":"githelp | git​","type":1,"pageTitle":"githelp","url":"/docs/commands/githelp#githelp--git","content":" suggests the Sapling equivalent of the given git command  Usage: sl githelp -- $COMMAND  Example:  $ sl git -- checkout my_file.txt baef104  sl revert -r my_file.txt baef104  The translation is best effort, and if an unknown command or parameter combination is detected, it simply returns an error. ","version":"Next","tagName":"h2"},{"title":"help","type":0,"sectionRef":"#","url":"/docs/commands/help","content":"","keywords":"","version":"Next"},{"title":"help​","type":1,"pageTitle":"help","url":"/docs/commands/help#help","content":" show help for a given topic or a help overview  With no arguments, print a list of commands with short help messages.  Given a topic, extension, or command name, print help for that topic.  Returns 0 if successful.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"help","url":"/docs/commands/help#arguments","content":" shortname\tfullname\tdefault\tdescription-e\t--extension show help for extensions -c\t--command show help for commands -k\t--keyword show topics matching keyword -s\t--system show help for specific platform(s) ","version":"Next","tagName":"h2"},{"title":"hide","type":0,"sectionRef":"#","url":"/docs/commands/hide","content":"","keywords":"","version":"Next"},{"title":"hide​","type":1,"pageTitle":"hide","url":"/docs/commands/hide#hide","content":" hide commits and their descendants  Mark the specified commits as hidden. Hidden commits are not included in the output of most Sapling commands, including sl log andsl smartlog. Any descendants of the specified commits will also be hidden.  Hidden commits are not deleted. They will remain in the repo indefinitely and are still accessible by their hashes. However, sl hide will delete any bookmarks pointing to hidden commits.  Use the sl unhide command to make hidden commits visible again. Seesl help unhide for more information.  To view hidden commits, run sl journal.  When you hide the current commit, the most recent visible ancestor is checked out.  To hide obsolete stacks (stacks that have a newer version), runsl hide --cleanup. This command is equivalent to:  sl hide &amp;#x27;obsolete() - ancestors(draft() &amp;amp; not obsolete())&amp;#x27;  --cleanup skips obsolete commits with non-obsolete descendants.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"hide","url":"/docs/commands/hide#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revisions to hide -c\t--cleanup clean up commits with newer versions, and non-essential remote bookmarks -B\t--bookmark hide commits only reachable from a bookmark ","version":"Next","tagName":"h2"},{"title":"graft","type":0,"sectionRef":"#","url":"/docs/commands/graft","content":"","keywords":"","version":"Next"},{"title":"graft​","type":1,"pageTitle":"graft","url":"/docs/commands/graft#graft","content":" copy commits from a different location  Use Sapling's merge logic to copy individual commits from other locations without making merge commits. This is sometimes known as 'backporting' or 'cherry-picking'. By default, graft will also copy user and description from the source commits. If you want to keep the date of the source commits, you can add below config to your configuration file:  [tweakdefaults] graftkeepdate = True   Source commits will be skipped if they are ancestors of the current commit, have already been grafted, or are merges.  If --log is specified, commit messages will have a comment appended of the form:  (grafted from COMMITHASH)   If --force is specified, commits will be grafted even if they are already ancestors of, or have been grafted to, the destination. This is useful when the commits have since been backed out.  If a graft results in conflicts, the graft process is interrupted so that the current merge can be manually resolved. Once all conflicts are resolved, the graft process can be continued with the -c/--continue option.  --from-path and --to-path allow copying commits between directories. Files in the grafted commit(s) outside of--from-path are ignored. See sl help directorybranching for more information.  The -c/--continue operation does not remember options from the original invocation, except for --force.  Examples:  copy a single change to the stable branch and edit its description:  sl goto stable sl graft --edit ba7e89595   graft a range of changesets with one exception, updating dates:  sl graft -D &quot;0e13e529c::224010e02 and not 85c0535a4&quot;   continue a graft after resolving conflicts:  sl graft -c   abort an interrupted graft:  sl graft --abort   show the source of a grafted changeset:  sl log --debug -r .   See sl help revisions for more about specifying revisions.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"graft","url":"/docs/commands/graft#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revisions to graft -c\t--continue\tfalse\tresume interrupted graft --abort\tfalse\tabort an interrupted graft -e\t--edit\tfalse\tinvoke editor on commit messages --log append graft info to log message -f\t--force\tfalse\tforce graft -D\t--currentdate\tfalse\trecord the current date as commit date -U\t--currentuser\tfalse\trecord the current user as committer -d\t--date record the specified date as commit date -u\t--user record the specified user as committer -t\t--tool specify merge tool -n\t--dry-run do not perform actions, just print output ","version":"Next","tagName":"h2"},{"title":"goto","type":0,"sectionRef":"#","url":"/docs/commands/goto","content":"","keywords":"","version":"Next"},{"title":"goto | go​","type":1,"pageTitle":"goto","url":"/docs/commands/goto#goto--go","content":" update working copy to a given commit  Update your working copy to the given destination commit. More precisely, make the destination commit the current commit and update the contents of all files in your working copy to match their state in the destination commit.  By default, if you attempt to go to a commit while you have pending changes, and the destination commit is not an ancestor or descendant of the current commit, the checkout will abort. However, if the destination commit is an ancestor or descendant of the current commit, the pending changes will be merged with the destination.  Use one of the following flags to modify this behavior:  --check: abort if there are pending changes   --clean: permanently discard any pending changes (use with caution)   --merge: always attempt to merge the pending changes into the destination   If merge conflicts occur during update, Sapling enters an unfinished merge state. If this happens, fix the conflicts manually and then runsl commit to exit the unfinished merge state and save your changes in a new commit. Alternatively, run sl goto --clean to discard your pending changes.  Specify null as the destination commit to get an empty working copy (sometimes known as a bare repository).  Returns 0 on success, 1 if there are unresolved files.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"goto","url":"/docs/commands/goto#arguments","content":" shortname\tfullname\tdefault\tdescription-C\t--clean\tfalse\tdiscard uncommitted changes (no backup) -c\t--check\tfalse\trequire clean working copy -m\t--merge\tfalse\tmerge uncommitted changes -r\t--rev revision --inactive\tfalse\tupdate without activating bookmarks -B\t--bookmark create new bookmark -t\t--tool specify merge tool ","version":"Next","tagName":"h2"},{"title":"init","type":0,"sectionRef":"#","url":"/docs/commands/init","content":"","keywords":"","version":"Next"},{"title":"init​","type":1,"pageTitle":"init","url":"/docs/commands/init#init","content":" create a new repository in the given directory  Initialize a new repository in the given directory. If the given directory does not exist, it will be created. If no directory is given, the current directory is used.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"init","url":"/docs/commands/init#arguments","content":" shortname\tfullname\tdefault\tdescription ","version":"Next","tagName":"h2"},{"title":"journal","type":0,"sectionRef":"#","url":"/docs/commands/journal","content":"","keywords":"","version":"Next"},{"title":"journal | jo​","type":1,"pageTitle":"journal","url":"/docs/commands/journal#journal--jo","content":" show the history of the checked out commit or a bookmark  Show the history of all the commits that were once the current commit. In other words, shows a list of your previously checked out commits.sl journal can be used to find older versions of commits (for example, when you want to revert to a previous state). It can also be used to discover commits that were previously hidden.  By default, sl journal displays the history of the current commit. To display a list of commits pointed to by a bookmark, specify a bookmark name.  Specify --all to show the history of both the current commit and all bookmarks. In the output for --all, bookmarks are listed by name, and. indicates the current commit.  Specify -Tjson to produce machine-readable output.  By default, sl journal only shows the commit hash and the corresponding command. Specify --verbose to also include the previous commit hash, user, and timestamp.  Use -c/--commits to output log information about each commit hash. To customize the log output, you can also specify switches like --patch, git, --stat, and --template.  If a bookmark name starts with re:, the remainder of the name is treated as a regular expression. To match a name that actually starts with re:, use the prefix literal:.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"journal","url":"/docs/commands/journal#arguments","content":" shortname\tfullname\tdefault\tdescription\t--all show history for all names -c\t--commits show commit metadata -p\t--patch show patch -g\t--git use git extended diff format -l\t--limit limit number of changes displayed --stat output diffstat-style summary of changes -T\t--template display with template ","version":"Next","tagName":"h2"},{"title":"histedit","type":0,"sectionRef":"#","url":"/docs/commands/histedit","content":"","keywords":"","version":"Next"},{"title":"histedit​","type":1,"pageTitle":"histedit","url":"/docs/commands/histedit#histedit","content":" interactively reorder, combine, or delete commits  This command lets you edit a linear series of commits up to and including the working copy, which should be clean. You can:  pick to (re)order a commit drop to omit a commit mess to reword a commit message fold to combine a commit with the preceding commit, using the later date roll like fold, but discarding this commit's description and date edit to edit a commit, preserving date base to checkout a commit and continue applying subsequent commits  There are multiple ways to select the root changeset:  Specify ANCESTOR directly Otherwise, the value from the histedit.defaultrev config option is used as a revset to select the base commit when ANCESTOR is not specified. The first commit returned by the revset is used. By default, this selects the editable history that is unique to the ancestry of the working directory.  Examples:  A number of changes have been made. Commit a113a4006 is no longer needed.  Start history editing from commit a:  sl histedit -r a113a4006   An editor opens, containing the list of commits, with specific actions specified:  pick a113a4006 Zworgle the foobar pick 822478b68 Bedazzle the zerlog pick d275e7ed9 5 Morgify the cromulancy   Additional information about the possible actions to take appears below the list of commits.  To remove commit a113a40 from the history, its action (at the beginning of the relevant line) is changed to drop:  drop a113a4006 Zworgle the foobar pick 822478b68 Bedazzle the zerlog pick d275e7ed9 Morgify the cromulancy   A number of changes have been made. Commit fe2bff2 and c9116c0 need to be swapped.  Start history editing from commit fe2bff2:  sl histedit -r fe2bff2ce   An editor opens, containing the list of commits, with specific actions specified:  pick fe2bff2ce Blorb a morgwazzle pick 99a93da65 Zworgle the foobar pick c9116c09e Bedazzle the zerlog   To swap commits fe2bff2 and c9116c0, simply swap their lines:  pick 8ef592ce7cc4 4 Bedazzle the zerlog pick 5339bf82f0ca 3 Zworgle the foobar pick 252a1af424ad 2 Blorb a morgwazzle   Returns 0 on success, 1 if user intervention is required foredit command or to resolve merge conflicts.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"histedit","url":"/docs/commands/histedit#arguments","content":" shortname\tfullname\tdefault\tdescription\t--commands read history edits from the specified file -c\t--continue\tfalse\tcontinue an edit already in progress --edit-plan\tfalse\tedit remaining actions list -k\t--keep\tfalse\tdon't strip old nodes after edit is complete --abort\tfalse\tabort an edit in progress -r\t--rev first revision to be edited -x\t--retry\tfalse\tretry exec command that failed and try to continue --show-plan\tfalse\tshow remaining actions list ","version":"Next","tagName":"h2"},{"title":"metaedit","type":0,"sectionRef":"#","url":"/docs/commands/metaedit","content":"","keywords":"","version":"Next"},{"title":"metaedit | meta | me​","type":1,"pageTitle":"metaedit","url":"/docs/commands/metaedit#metaedit--meta--me","content":" edit commit message and other metadata  sl metaedit lets you edit commit messages. With no arguments, the current commit message is modified. To edit the commit message for a different commit, specify -r REV. To edit the commit messages for multiple commits, specify --batch.  By default, sl metaedit launches your default editor so that you can interactively edit the commit message. Specify -m to specify the commit message on the command line.  You can edit other pieces of commit metadata such as the user or date, by specifying -u or -d, respectively. The expected format for the user is 'Full Name &lt;user@example.com&gt;'.  There is also an automation-friendly JSON input mode which allows the caller to provide the mapping between commit and new message and username in the following format:  { &quot;&lt;commit_hash&gt;&quot;: { &quot;message&quot;: &quot;&lt;message&gt;&quot;, &quot;user&quot;: &quot;&lt;user&gt;&quot; // optional } }   You can specify --fold to fold multiple revisions into one when the given revisions form a linear unbroken chain. However, sl fold is the preferred command for this purpose. See sl help fold for more information.  Some examples:  Edit the commit message for the current commit:  sl metaedit   Change the username for the current commit:  sl metaedit --user 'New User &lt;new-email@example.com&gt;'   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"metaedit","url":"/docs/commands/metaedit#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revision to edit --fold\tfalse\tfold specified revisions into one --batch\tfalse\tedit messages of multiple commits in one editor invocation --json-input-file read commit messages and users from JSON file -M\t--reuse-message reuse commit message from another commit -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer ","version":"Next","tagName":"h2"},{"title":"next","type":0,"sectionRef":"#","url":"/docs/commands/next","content":"","keywords":"","version":"Next"},{"title":"next​","type":1,"pageTitle":"next","url":"/docs/commands/next#next","content":" check out a descendant commit  Update to a descendant commit of the current commit. When working with a stack of commits, you can use sl next to move up your stack with ease.  Use the --newest flag to always pick the newest of multiple child commits. You can set amend.alwaysnewest to true in your global Sapling config file to make this the default. Use the --merge flag to bring along uncommitted changes to the destination commit. Use the --bookmark flag to move to the next commit with a bookmark. Use the --rebase flag to rebase any child commits that were left behind after amend, split, fold, or histedit.  Examples:  Move 1 level up the stack:  sl next   Move 2 levels up the stack:  sl next 2   Move to the top of the stack:  sl next --top   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"next","url":"/docs/commands/next#arguments","content":" shortname\tfullname\tdefault\tdescription\t--newest\tfalse\talways pick the newest child when a commit has multiple children --rebase\tfalse\trebase each commit if necessary --top\tfalse\tupdate to the head of the current stack --bookmark\tfalse\tupdate to the first commit with a bookmark --no-activate-bookmark\tfalse\tdo not activate the bookmark on the destination commit --towards move linearly towards the specified head -C\t--clean\tfalse\tdiscard uncommitted changes (no backup) -B\t--move-bookmark\tfalse\tmove active bookmark -m\t--merge\tfalse\tmerge uncommitted changes -c\t--check\tfalse\trequire clean working directory ","version":"Next","tagName":"h2"},{"title":"log","type":0,"sectionRef":"#","url":"/docs/commands/log","content":"","keywords":"","version":"Next"},{"title":"log​","type":1,"pageTitle":"log","url":"/docs/commands/log#log","content":" show commit history  Print the revision history of the specified files or the entire project.  If no revision range is specified, the default is the current commit and all of its ancestors (::.).  File history is shown without following the rename or copy history of files. To follow file history across renames and copies, use the -f/-- follow option. If the --followoption is used without a filename, only the ancestors or descendants of the starting revision are shown.  By default, sl log prints the commit's hash, non-trivial parents, user, date, time, and the single-line summary. When the-v/--verbose option is used, the list of changed files and full commit message are shown.  With the --graph option, revisions are shown as an ASCII art graph with the most recent commit at the top. The graph nodes are depicted as follows: o is a commit, @ is a working directory parent, x is obsolete, and + represents a fork where the commit from the lines below is a parent of the omerge on the same line. Paths in the graph are represented with|, / and so forth. : in place of a | indicates one or more revisions in a path are omitted.  Use the -L/--line-range FILE,M:N option to follow the history of lines from M to N in FILE. With the -p/-- patch option, only diff hunks affecting specified line range will be shown. The -L option can be specified multiple times and requires the --follow option. Currently, the line range option is not compatible with --graph and is an experimental feature.  sl log --patch may generate unexpected diff output for merge commits, as it will only compare the merge commit against its first parent. Also, only files different from BOTH parents will appear in the files: section.  For performance reasons, sl log FILE may omit duplicate changes made on branches and will not show removals or mode changes. To see all such changes, use the --removed switch.  The history resulting from -L/--line-range options depends on diff options: for instance, if white-spaces are ignored, respective changes with only white-spaces in specified line range will not be listed.  Some examples:  commits with full descriptions and file lists:  sl log -v   commits ancestral to the working directory:  sl log -f   last 10 commits on the current branch:  sl log -l 10 -b .   commits showing all modifications of a file, including removals:  sl log --removed file.c   all commits that touch a directory, with diffs, excluding merges:  sl log -Mp lib/   all revision numbers that match a keyword:  sl log -k bug --template &quot;{rev}\\n&quot;   the full hash identifier of the working directory parent:  sl log -r . --template &quot;{node}\\n&quot;   list available log templates:  sl log -T list   check if a given commit is included in a bookmarked release:  sl log -r &quot;a21ccf and ancestor(release_1.9)&quot;   find all commits by some user in a date range:  sl log -k alice -d &quot;may 2008 to jul 2008&quot;   commits touching lines 13 to 23 for file.c:  sl log -L file.c,13:23   commits touching lines 13 to 23 for file.c and lines 2 to 6 of main.c with patch:  sl log -L file.c,13:23 -L main.c,2:6 -p   See sl help dates for a list of formats valid for -d/--date.  See sl help revisions for more about specifying and ordering revisions.  See sl help templates for more about pre-packaged styles and specifying custom templates. The default template used by the log command can be customized via the ui.logtemplate configuration setting.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"log","url":"/docs/commands/log#arguments","content":" shortname\tfullname\tdefault\tdescription-f\t--follow follow changeset history, or file history across copies and renames -d\t--date show revisions matching date spec -C\t--copies show copied files -k\t--keyword do case-insensitive search for a given text -r\t--rev show the specified revision or revset --removed include revisions where files were removed -u\t--user revisions committed by user -P\t--prune do not display revision or any of its ancestors -p\t--patch show patch -g\t--git use git extended diff format -l\t--limit limit number of changes displayed -M\t--no-merges do not show merges --stat output diffstat-style summary of changes -G\t--graph show the revision DAG -T\t--template display with template -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns --all shows all changesets in the repo --sparse limit to changesets affecting the sparse checkout --remote show remote names even if hidden ","version":"Next","tagName":"h2"},{"title":"pr","type":0,"sectionRef":"#","url":"/docs/commands/pr","content":"","keywords":"","version":"Next"},{"title":"pr​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#pr","content":" exchange local commit data with GitHub pull requests  ","version":"Next","tagName":"h2"},{"title":"subcommands​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#subcommands","content":" ","version":"Next","tagName":"h2"},{"title":"s|submit​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#ssubmit","content":" create or update GitHub pull requests from local commits  Commit(s) will be pushed to default-push, if configured, elsedefault (see sl help urls and sl help path).  Pull request(s) will be created against default. Ifdefault is a fork, they will be created against default's upstream repository.  Returns 0 on success.  shortname\tfullname\tdefault\tdescription-s\t--stack\tfalse\talso include draft ancestors -m\t--message message describing changes to updated commits -d\t--draft\tfalse\tmark new pull requests as draft  ","version":"Next","tagName":"h3"},{"title":"pull​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#pull","content":" import a pull request into your working copy  The PULL_REQUEST can be specified as either a URL:https://github.com/facebook/sapling/pull/321or just the PR number within the GitHub repository identified bysl config paths.default.  shortname\tfullname\tdefault\tdescription-g\t--goto\tfalse\tgoto the pull request after importing it  ","version":"Next","tagName":"h3"},{"title":"link​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#link","content":" identify a commit as the head of a GitHub pull request  A PULL_REQUEST can be specified in a number of formats:  GitHub URL to the PR: facebook/react#42 Integer: Number for the PR. Uses 'paths.upstream' as the target repo, if specified; otherwise, falls back to 'paths.default'.  shortname\tfullname\tdefault\tdescription-r\t--rev revision to link  ","version":"Next","tagName":"h3"},{"title":"unlink​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#unlink","content":" remove a commit's association with a GitHub pull request  shortname\tfullname\tdefault\tdescription-r\t--rev revisions to unlink  ","version":"Next","tagName":"h3"},{"title":"follow​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#follow","content":" join the nearest desecendant's pull request  Marks commits to become part of their nearest desecendant's pull request instead of starting as the head of a new pull request.  Use pr unlink to undo.  shortname\tfullname\tdefault\tdescription-r\t--rev revisions to follow the next pull request  ","version":"Next","tagName":"h3"},{"title":"list​","type":1,"pageTitle":"pr","url":"/docs/commands/pr#list","content":" calls gh pr list [flags] with the current repo as the value of --repo  shortname\tfullname\tdefault\tdescription\t--app filter by GitHub App author -a\t--assignee filter by assignee -A\t--author filter by author -B\t--base filter by base branch -d\t--draft\tfalse\tfilter by draft state -H\t--head filter by head branch -q\t--jq filter JSON output using a jq expression --json output JSON with the specified fields -l\t--label filter by label -L\t--limit\t30\tmaximum number of items to fetch -S\t--search search pull requests with query -s\t--state\t&quot;open&quot;\tfilter by state: open, closed, merged, all -t\t--template format JSON output using a Go template; see &quot;gh help formatting&quot; -w\t--web\tfalse\tlist pull requests in the web browser ","version":"Next","tagName":"h3"},{"title":"prev","type":0,"sectionRef":"#","url":"/docs/commands/prev","content":"","keywords":"","version":"Next"},{"title":"previous | prev​","type":1,"pageTitle":"prev","url":"/docs/commands/prev#previous--prev","content":" check out an ancestor commit  Update to an ancestor commit of the current commit. When working with a stack of commits, you can use sl previous to move down your stack with ease.  Use the --newest flag to always pick the newest of multiple parents commits. You can set amend.alwaysnewest to true in your global Sapling config file to make this the default. Use the --merge flag to bring along uncommitted changes to the destination commit. Use the --bookmark flag to move to the first ancestor commit with a bookmark.  Examples:  Move 1 level down the stack:  sl prev   Move 2 levels down the stack:  sl prev 2   Move to the bottom of the stack:  sl prev --bottom   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"prev","url":"/docs/commands/prev#arguments","content":" shortname\tfullname\tdefault\tdescription\t--newest\tfalse\talways pick the newest parent when a commit has multiple parents --bottom\tfalse\tupdate to the lowest non-public ancestor of the current commit --bookmark\tfalse\tupdate to the first ancestor with a bookmark --no-activate-bookmark\tfalse\tdo not activate the bookmark on the destination commit -C\t--clean\tfalse\tdiscard uncommitted changes (no backup) -B\t--move-bookmark\tfalse\tmove active bookmark -m\t--merge\tfalse\tmerge uncommitted changes -c\t--check\tfalse\trequire clean working directory ","version":"Next","tagName":"h2"},{"title":"pull","type":0,"sectionRef":"#","url":"/docs/commands/pull","content":"","keywords":"","version":"Next"},{"title":"pull​","type":1,"pageTitle":"pull","url":"/docs/commands/pull#pull","content":" pull commits from the specified source  Pull commits from a remote repository to a local one. This command modifies the commit graph, but doesn't mutate local commits or the working copy.  Use -B/--bookmark to specify a remote bookmark to pull. For Git repos, remote bookmarks correspond to branches. If no bookmark is specified, a default set of relevant remote names are pulled.  If SOURCE is omitted, the default path is used. Use sl path --add to add a named source.  See sl help urls and sl help path for more information.  Examples:  pull relevant remote bookmarks from default source:  sl pull   pull a bookmark named my-branch from source my-fork:  sl pull my-fork --bookmark my-branch   You can use . for BOOKMARK to specify the active bookmark.  Returns 0 on success, 1 on failure, including if --update was specified but the update had unresolved conflicts.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"pull","url":"/docs/commands/pull#arguments","content":" shortname\tfullname\tdefault\tdescription-u\t--update update to new branch head if new descendants were pulled -f\t--force run even when remote repository is unrelated -r\t--rev a remote commit to pull -B\t--bookmark a bookmark to pull --rebase rebase current commit or current stack onto master -t\t--tool specify merge tool for rebase -d\t--dest destination for rebase or update ","version":"Next","tagName":"h2"},{"title":"push","type":0,"sectionRef":"#","url":"/docs/commands/push","content":"","keywords":"","version":"Next"},{"title":"push​","type":1,"pageTitle":"push","url":"/docs/commands/push#push","content":" push commits to the specified destination  Push commits from the local repository to the specified destination.  Use -t/--to to specify the remote bookmark. For Git repos, remote bookmarks correspond to Git branches.  To add a named remote destination, see sl path --add.  -r/--rev specifies the commit(s) (including ancestors) to push to the remote repository. Defaults to the current commit.  Add --create to create the remote bookmark if it doesn't already exist.  The -f/--force flag allows non-fast-forward pushes.  If DESTINATION is omitted, the default path will be used. Seesl help urls and sl help path for more information.  Examples:  push your current commit to &quot;main&quot; on the default destination:  sl push --to main   force push commit 05a8232 to &quot;my-branch&quot; on the &quot;my-fork&quot; destination:  sl push --rev 05a82320d my-fork --to my-branch --force   The --pushvars flag sends key-value metadata to the server. For example, --pushvars ENABLE_SOMETHING=true. Push vars are typically used to override commit hook behavior, or enable extra debugging. Push vars are not supported for Git repos.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"push","url":"/docs/commands/push#arguments","content":" shortname\tfullname\tdefault\tdescription-f\t--force force push -r\t--rev a commit to push -t\t--to push commits to this bookmark --delete delete remote bookmark --create create a new remote bookmark ","version":"Next","tagName":"h2"},{"title":"rebase","type":0,"sectionRef":"#","url":"/docs/commands/rebase","content":"","keywords":"","version":"Next"},{"title":"rebase​","type":1,"pageTitle":"rebase","url":"/docs/commands/rebase#rebase","content":" move commits from one location to another  Move commits from one part of the commit graph to another. This behavior is achieved by creating a copy of the commit at the destination and hiding the original commit.  Use -k/--keep to skip the hiding and keep the original commits visible.  If the commits being rebased have bookmarks, rebase moves the bookmarks onto the new versions of the commits. Bookmarks are moved even if --keepis specified.  Public commits cannot be rebased unless you use the --keep option to copy them.  Use the following options to select the commits you want to rebase:  -r/--rev to explicitly select commits -s/--source to select a root commit and include all of its descendants -b/--base to select a commit and its ancestors and descendants  If no option is specified to select commits, -b . is used by default.  If --source or --rev is used, special names SRC and ALLSRCcan be used in --dest. Destination would be calculated per source revision with SRC substituted by that single source revision andALLSRC substituted by all source revisions.  If multiple --revs are specified, they can be paired with multiple--dests. For example:  rebase -r A+B -d X -r C::E -d Y   will rebase A+B to X, and rebase C::E to Y.  If commits that you are rebasing consist entirely of changes that are already present in the destination, those commits are not moved (in other words, they are rebased out).  Sometimes conflicts can occur when you rebase. When this happens, by default, Sapling launches an editor for every conflict. Conflict markers are inserted into affected files, like:  &lt;&lt;&lt;&lt; dest ==== source &gt;&gt;&gt;&gt;   To fix the conflicts, for each file, remove the markers and replace the whole block of code with the correctly merged code.  If you close the editor without resolving the conflict, the rebase is interrupted and you are returned to the command line. At this point, you can resolve conflicts in manual resolution mode. See sl help resolve for details.  After manually resolving conflicts, resume the rebase withsl rebase --continue. If you are not able to successfully resolve all conflicts, run sl rebase --abort to abort the entire rebase; or run sl rebase --quit to quit the interrupted rebase state and keep the already rebased commits.  Alternatively, you can use a custom merge tool to automate conflict resolution. To specify a custom merge tool, use the --tool flag. Seesl help merge-tools for a list of available tools and for information about configuring the default merge behavior.  Examples:  Move a single commit to master:  sl rebase -r 5f493448 -d master   Move a commit and all its descendants to another part of the commit graph:  sl rebase --source c0c3 --dest 4cf9   Rebase everything on a local branch marked by a bookmark to master:  sl rebase --base myfeature --dest master   Rebase orphaned commits onto the latest version of their parents:  sl rebase --restack   Configuration Options:  By default, rebase will close the transaction after each commit. For performance purposes, you can configure rebase to use a single transaction across the entire rebase. WARNING: This setting introduces a significant risk of losing the work you've done in a rebase if the rebase aborts unexpectedly:  [rebase] singletransaction = True   By default, rebase writes to the working copy, but you can configure it to run in-memory for for better performance, and to allow it to run if the current checkout is dirty:  [rebase] experimental.inmemory = True   It will also print a configurable warning:  [rebase] experimental.inmemorywarning = Using experimental in-memory rebase   Returns 0 on success (also when nothing to rebase), 1 if there are unresolved conflicts.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"rebase","url":"/docs/commands/rebase#arguments","content":" shortname\tfullname\tdefault\tdescription-s\t--source rebase the specified commit and descendants -b\t--base rebase everything from branching point of specified commit -r\t--rev rebase these revisions -d\t--dest rebase onto the specified revision --collapse\tfalse\tcollapse the rebased commits -m\t--message use text as collapse commit message -e\t--edit\tfalse\tinvoke editor on commit messages -l\t--logfile read collapse commit message from file -k\t--keep\tfalse\tkeep original commits -t\t--tool specify merge tool -c\t--continue\tfalse\tcontinue an interrupted rebase -a\t--abort\tfalse\tabort an interrupted rebase --quit\tfalse\tquit an interrupted rebase and keep the already rebased commits --restack\tfalse\trebase all changesets in the current stack onto the latest version of their respective parents -i\t--interactive\tfalse\tinteractive rebase ","version":"Next","tagName":"h2"},{"title":"restack","type":0,"sectionRef":"#","url":"/docs/commands/restack","content":"","keywords":"","version":"Next"},{"title":"restack​","type":1,"pageTitle":"restack","url":"/docs/commands/restack#restack","content":" rebase all commits in the current stack onto the latest version of their respective parents  restack is a built-in alias for rebase --restack  When commits are modified by commands like amend and absorb, their descendant commits may be left behind as orphans. Rebase these orphaned commits onto the newest versions of their ancestors, making the stack linear again. ","version":"Next","tagName":"h2"},{"title":"redo","type":0,"sectionRef":"#","url":"/docs/commands/redo","content":"","keywords":"","version":"Next"},{"title":"redo​","type":1,"pageTitle":"redo","url":"/docs/commands/redo#redo","content":" undo the last undo  Reverse the effects of an sl undo operation.  You can run sl redo multiple times to undo a series of sl undocommands. Alternatively, you can explicitly specify the number ofsl undo commands to undo by providing a number as a positional argument.  Specify --preview to see a graphical display that shows what your smartlog will look like after you run the command.  For an interactive interface, run sl undo --interactive. This command enables you to visually step backwards and forwards in the undo history. Run sl help undo for more information.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"redo","url":"/docs/commands/redo#arguments","content":" shortname\tfullname\tdefault\tdescription-p\t--preview\tfalse\tsee smartlog-like preview of future redo state ","version":"Next","tagName":"h2"},{"title":"remove","type":0,"sectionRef":"#","url":"/docs/commands/remove","content":"","keywords":"","version":"Next"},{"title":"remove | rm​","type":1,"pageTitle":"remove","url":"/docs/commands/remove#remove--rm","content":" delete the specified tracked files  Remove the specified tracked files from the repository and delete them. The files will be deleted from the repository at the next commit.  To undo a remove before files have been committed, use sl revert. To stop tracking files without deleting them, use sl forget.  --mark can be used to remove only files that have already been deleted, -f/--force can be used to force deletion, and -Afcan be used to remove files from the next revision without deleting them from the working directory.  The following table details the behavior of remove for different file states (columns) and option combinations (rows). The file states are Added (A), Clean (C), Modified (M) and Missing (!) (as reported by sl status). The actions are Warn (W), Remove (R) (from branch) and Delete (D) (from disk):   opt/state\tA\tC\tM\t! none\tW\tRD\tW\tR -f\tR\tRD\tRD\tR -A\tW\tW\tW\tR -Af\tR\tR\tR\tR  sl remove never deletes files in Added state from the working directory, not even if --force is specified.  Returns 0 on success, 1 if any warnings encountered.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"remove","url":"/docs/commands/remove#arguments","content":" shortname\tfullname\tdefault\tdescription\t--mark mark as a deletion for already missing files -f\t--force forget added files, delete modified files -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"revert","type":0,"sectionRef":"#","url":"/docs/commands/revert","content":"","keywords":"","version":"Next"},{"title":"revert​","type":1,"pageTitle":"revert","url":"/docs/commands/revert#revert","content":" change the specified files to match a commit  With no revision specified, restore the contents of files to an unmodified state and unschedule adds, removes, copies, and renames. In other words, revert the specified files or directories to the contents they had in the current commit. If you are in the middle of an unfinished merge state, you must explicitly specify a revision.  Use the -r/--rev option to revert the given files or directories to their states as of a specific commit. Because revert does not actually check out the specified commit, the files appear as modified and show up as pending changes in sl status.  Revert causes files to match their contents in another commit. If instead you want to undo a specific landed commit, use sl backoutinstead. Run sl help backout for more information.  Modified files are saved with an .orig suffix before reverting. To disable these backups, use --no-backup. You can configure Sapling to store these backup files in a custom directory relative to the root of the repository by setting the ui.origbackuppath configuration option.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"revert","url":"/docs/commands/revert#arguments","content":" shortname\tfullname\tdefault\tdescription-a\t--all revert all changes when no arguments given -d\t--date tipmost revision matching date -r\t--rev revert to the specified revision -C\t--no-backup do not save backup copies of files -i\t--interactive interactively select the changes -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns -n\t--dry-run do not perform actions, just print output ","version":"Next","tagName":"h2"},{"title":"shelve","type":0,"sectionRef":"#","url":"/docs/commands/shelve","content":"","keywords":"","version":"Next"},{"title":"shelve​","type":1,"pageTitle":"shelve","url":"/docs/commands/shelve#shelve","content":" save pending changes and revert working copy to a clean state  Shelving takes files that sl status reports as not clean, saves the modifications to a bundle (a shelved change), and reverts the files to a clean state in the working copy.  To restore the changes to the working copy, use sl unshelveregardless of your current commit.  When no files are specified, sl shelve saves all not-clean files. If specific files or directories are named, only changes to those files are shelved.  Each shelved change has a name that makes it easier to find later. The name of a shelved change by default is based on the active bookmark. To specify a different name, use --name.  To see a list of existing shelved changes, use the --listoption. For each shelved change, this will print its name, age, and description. Use --patch or --stat for more details.  To delete specific shelved changes, use --delete. To delete all shelved changes, use --cleanup.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"shelve","url":"/docs/commands/shelve#arguments","content":" shortname\tfullname\tdefault\tdescription-A\t--addremove mark new/missing files as added/removed before shelving -u\t--unknown store unknown files in the shelve --cleanup delete all shelved changes --date shelve with the specified commit date -d\t--delete delete the named shelved change(s) -e\t--edit\tfalse\tinvoke editor on commit messages -l\t--list list current shelves -m\t--message use text as shelve message -n\t--name use the given name for the shelved commit -p\t--patch show patch -i\t--interactive interactive mode - only works while creating a shelve --stat output diffstat-style summary of changes -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"root","type":0,"sectionRef":"#","url":"/docs/commands/root","content":"","keywords":"","version":"Next"},{"title":"root​","type":1,"pageTitle":"root","url":"/docs/commands/root#root","content":" print the repository's root (top) of the current working directory  Print the root directory of the current repository.  Frequently useful in shells scripts and automation to run commands like:  $ $(sl root)/bin/script.py   Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"root","url":"/docs/commands/root#arguments","content":" shortname\tfullname\tdefault\tdescription\t--shared\tfalse\tshow root of the shared repo ","version":"Next","tagName":"h2"},{"title":"sl","type":0,"sectionRef":"#","url":"/docs/commands/sl","content":"","keywords":"","version":"Next"},{"title":"show","type":0,"sectionRef":"#","url":"/docs/commands/show","content":"","keywords":"","version":"Next"},{"title":"show​","type":1,"pageTitle":"show","url":"/docs/commands/show#show","content":" show commit in detail  Show the commit message and contents for the specified commit. If no commit is specified, shows the current commit.  sl show behaves similarly to sl log -vp -r REV [OPTION]... [FILE]..., or if called without a REV, sl log -vp -r . [OPTION]... Usesl log for more powerful operations than supported by sl show.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"show","url":"/docs/commands/show#arguments","content":" shortname\tfullname\tdefault\tdescription\t--nodates omit dates from diff headers (but keeps it in commit header) --noprefix omit a/ and b/ prefixes from filenames --stat output diffstat-style summary of changes -g\t--git use git extended diff format -U\t--unified\t3\tnumber of lines of diff context to show -w\t--ignore-all-space ignore white space when comparing lines -b\t--ignore-space-change ignore changes in the amount of white space -B\t--ignore-blank-lines ignore changes whose lines are all blank -Z\t--ignore-space-at-eol ignore changes in whitespace at EOL -T\t--template display with template -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"sl​","type":1,"pageTitle":"sl","url":"/docs/commands/sl#sl","content":" show a graph of the commits that are relevant to you  sl is a built-in alias for smartlog -T {sl}  Smartlog is one of most important features in Sapling, it provides you with a succinct view of your work by hiding all commits that aren’t relevant to you. ","version":"Next","tagName":"h2"},{"title":"split","type":0,"sectionRef":"#","url":"/docs/commands/split","content":"","keywords":"","version":"Next"},{"title":"split | spl​","type":1,"pageTitle":"split","url":"/docs/commands/split#split--spl","content":" split a commit into smaller commits  Prompt for hunks to be selected until exhausted. Each selection of hunks will form a separate commit, in order from parent to child: the first selection will form the first commit, the second selection will form the second commit, and so on.  Operates on the current revision by default. Use --rev to split a given commit instead.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"split","url":"/docs/commands/split#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revision to split --no-rebase\tfalse\tdon't rebase descendants after split -m\t--message use text as commit message -l\t--logfile read commit message from file -d\t--date record the specified date as commit date -u\t--user record the specified user as committer ","version":"Next","tagName":"h2"},{"title":"unamend","type":0,"sectionRef":"#","url":"/docs/commands/unamend","content":"","keywords":"","version":"Next"},{"title":"unamend | una​","type":1,"pageTitle":"unamend","url":"/docs/commands/unamend#unamend--una","content":" undo the last amend operation on the current commit  Reverse the effects of an sl amend operation. Hides the current commit and checks out the previous version of the commit. sl unamend does not revert the state of the working copy, so changes that were added to the commit in the last amend operation become pending changes in the working copy.  sl unamend cannot be run on amended commits that have children. In other words, you cannot unamend an amended commit in the middle of a stack.  Running sl unamend is similar to running sl undo --keepimmediately after sl amend. However, unlike sl undo, which can only undo an amend if it was the last operation you performed,sl unamend can unamend any draft amended commit in the graph that does not have children.  Although sl unamend is typically used to reverse the effects ofsl amend, it actually rolls back the current commit to its previous version, regardless of whether the changes resulted from an sl amendoperation or from another operation. We disallow sl unamend if the predecessor's parents don't match the current commit's parents to avoid unexpected behavior after, for example, sl rebase. ","version":"Next","tagName":"h2"},{"title":"uncommit","type":0,"sectionRef":"#","url":"/docs/commands/uncommit","content":"","keywords":"","version":"Next"},{"title":"uncommit | unc​","type":1,"pageTitle":"uncommit","url":"/docs/commands/uncommit#uncommit--unc","content":" uncommit part or all of the current commit  Reverse the effects of an sl commit operation. When run with no arguments, hides the current commit and checks out the parent commit, but does not revert the state of the working copy. Changes that were contained in the uncommitted commit become pending changes in the working copy.  sl uncommit cannot be run on commits that have children. In other words, you cannot uncommit a commit in the middle of a stack. Similarly, by default, you cannot run sl uncommit if there are pending changes in the working copy.  You can selectively uncommit files from the current commit by optionally specifying a list of files to remove. The specified files are removed from the list of changed files in the current commit, but are not modified on disk, so they appear as pending changes in the working copy.  Running sl uncommit is similar to running sl undo --keepimmediately after sl commit. However, unlike sl undo, which can only undo a commit if it was the last operation you performed,sl uncommit can uncommit any draft commit in the graph that does not have children.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"uncommit","url":"/docs/commands/uncommit#arguments","content":" shortname\tfullname\tdefault\tdescription\t--keep\tfalse\tallow an empty commit after uncommiting -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"ssl","type":0,"sectionRef":"#","url":"/docs/commands/ssl","content":"","keywords":"","version":"Next"},{"title":"ssl​","type":1,"pageTitle":"ssl","url":"/docs/commands/ssl#ssl","content":" show a graph of your commits and associated GitHub pull request status  ssl is not a subcommand, but a built-in alias for smartlog -T {ssl}. If you have used Sapling to create pull requests for your commits, then you can use sl ssl to include the pull request status in your Smartlog:  $ sl ssl @ 4d9180fd8 6 minutes ago alyssa #178 Unreviewed │ adding baz │ o 3cc43c835 6 minutes ago alyssa #177 Approved │ adding bar │ o 4f1243a8b 6 minutes ago alyssa #176 Closed ╭─╯ adding foo │ o f22585511 Oct 06 at 17:40 remote/main │ ~  ","version":"Next","tagName":"h2"},{"title":"status","type":0,"sectionRef":"#","url":"/docs/commands/status","content":"","keywords":"","version":"Next"},{"title":"status | st​","type":1,"pageTitle":"status","url":"/docs/commands/status#status--st","content":" list files with pending changes  Show status of files in the working copy using the following status indicators:  M = modified A = added R = removed C = clean ! = missing (deleted by a non-sl command, but still tracked) ? = not tracked I = ignored = origin of the previous file (with --copies)   By default, shows files that have been modified, added, removed, deleted, or that are unknown (corresponding to the options -mardu, respectively). Files that are unmodified, ignored, or the source of a copy/move operation are not listed.  To control the exact statuses that are shown, specify the relevant flags (like -rd to show only files that are removed or deleted). Additionally, specify -q/--quiet to hide both unknown and ignored files.  To show the status of specific files, provide a list of files to match. To include or exclude files using patterns or filesets, use-I or -X.  If --rev is specified and only one revision is given, it is used as the base revision. If two revisions are given, the differences between them are shown. The --change option can also be used as a shortcut to list the changed files of a revision from its first parent.  sl status might appear to disagree with sl diff if permissions have changed or a merge has occurred, because the standard diff format does not report permission changes and sl diff only reports changes relative to one merge parent.  The -t/--terse option abbreviates the output by showing only the directory name if all the files in it share the same status. The option takes an argument indicating the statuses to abbreviate: 'm' for 'modified', 'a' for 'added', 'r' for 'removed', 'd' for 'deleted', 'u' for 'unknown', 'i' for 'ignored' and 'c' for clean.  It abbreviates only those statuses which are passed. Note that clean and ignored files are not displayed with --terse ic unless the -c/--cleanand -i/--ignored options are also used.  The -v/--verbose option shows information when the repository is in an unfinished merge, shelve, rebase state, etc. You can have this behavior turned on by default by enabling the commands.status.verbose config option.  You can skip displaying some of these states by settingcommands.status.skipstates to one or more of: 'bisect', 'graft', 'histedit', 'merge', 'rebase', or 'unshelve'.  Examples:  show changes in the working directory relative to a commit:  sl status --rev 88a692db8   show changes in the working copy relative to the current directory (see sl help patterns for more information):  sl status re:   show all changes including copies in a commit:  sl status --copies --change 88a692db8   get a NUL separated list of added files, suitable for xargs:  sl status -an0   show more information about the repository status, abbreviating added, removed, modified, deleted, and untracked paths:  sl status -v -t mardu   Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"status","url":"/docs/commands/status#arguments","content":" shortname\tfullname\tdefault\tdescription-A\t--all\tfalse\tshow status of all files -m\t--modified\tfalse\tshow only modified files -a\t--added\tfalse\tshow only added files -r\t--removed\tfalse\tshow only removed files -d\t--deleted\tfalse\tshow only deleted (but tracked) files -c\t--clean\tfalse\tshow only files without changes -u\t--unknown\tfalse\tshow only unknown (not tracked) files -i\t--ignored\tfalse\tshow only ignored files -n\t--no-status\tfalse\thide status prefix -C\t--copies\tfalse\tshow source of copied files -0\t--print0\tfalse\tend filenames with NUL, for use with xargs --rev show difference from revision --change list the changed files of a revision --root-relative show status relative to root -I\t--include include files matching the given patterns -X\t--exclude exclude files matching the given patterns ","version":"Next","tagName":"h2"},{"title":"undo","type":0,"sectionRef":"#","url":"/docs/commands/undo","content":"","keywords":"","version":"Next"},{"title":"undo​","type":1,"pageTitle":"undo","url":"/docs/commands/undo#undo","content":" undo the last local command  Reverse the effects of the last local command. A local command is one that changed the currently checked out commit, that modified the contents of local commits, or that changed local bookmarks. Examples of local commands include sl goto, sl commit, sl amend, and sl rebase.  You cannot use sl undo to undo uncommitted changes in the working copy, or changes to remote bookmarks.  You can run sl undo multiple times to undo a series of local commands. Alternatively, you can explicitly specify the number of local commands to undo using --step. This number can also be specified as a positional argument.  To undo the effects of sl undo, run sl redo. Runsl help redo for more information.  Include --keep to preserve the state of the working copy. For example, specify --keep when running sl undo to reverse the effects of ansl commit or sl amend operation while still preserving changes in the working copy. These changes will appear as pending changes.  Specify --preview to see a graphical display that shows what your smartlog will look like after you run the command. Specify--interactive for an interactive version of this preview in which you can step backwards and forwards in the undo history.  sl undo cannot be used with non-local commands, or with commands that are read-only. sl undo will skip over these commands in the undo history.  For hybrid commands that result in both local and remote changes,sl undo will undo the local changes, but not the remote changes. For example, sl pull --rebase might move remote/master and also rebase local commits. In this situation, sl undo will revert the rebase, but not the change to remote/master.  Branch limits the scope of an undo to a group of local (draft) changectxs, identified by any one member of this group.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"undo","url":"/docs/commands/undo#arguments","content":" shortname\tfullname\tdefault\tdescription-a\t--absolute\tfalse\tabsolute based on command index instead of relative undo -i\t--interactive\tfalse\tuse interactive ui for undo -k\t--keep\tfalse\tkeep working copy changes -n\t--step\t1\thow many steps to undo back -p\t--preview\tfalse\tsee smartlog-like preview of future undo state ","version":"Next","tagName":"h2"},{"title":"unshelve","type":0,"sectionRef":"#","url":"/docs/commands/unshelve","content":"","keywords":"","version":"Next"},{"title":"unshelve​","type":1,"pageTitle":"unshelve","url":"/docs/commands/unshelve#unshelve","content":" restore a shelved change to the working copy  This command accepts an optional name of a shelved change to restore. If none is given, the most recent shelved change is used.  If a shelved change is applied successfully, the bundle that contains the shelved changes is moved to a backup location (.sl/shelve-backup).  Since you can restore a shelved change on top of an arbitrary commit, it is possible that unshelving will result in a conflict. If this occurs, you must resolve the conflict, then use --continueto complete the unshelve operation. The bundle will not be moved until you successfully complete the unshelve.  Alternatively, you can use --abort to cancel the conflict resolution and undo the unshelve, leaving the shelve bundle intact.  After a successful unshelve, the shelved changes are stored in a backup directory. Only the N most recent backups are kept. N defaults to 10 but can be overridden using the shelve.maxbackupsconfiguration option.  Timestamp in seconds is used to decide the order of backups. More than maxbackups backups are kept if same timestamp prevents from deciding exact order of them, for safety.  Returns 0 on success.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"unshelve","url":"/docs/commands/unshelve#arguments","content":" shortname\tfullname\tdefault\tdescription-a\t--abort abort an incomplete unshelve operation -c\t--continue continue an incomplete unshelve operation -k\t--keep keep shelve after unshelving -n\t--name restore shelved change with given name -t\t--tool specify merge tool ","version":"Next","tagName":"h2"},{"title":"unhide","type":0,"sectionRef":"#","url":"/docs/commands/unhide","content":"","keywords":"","version":"Next"},{"title":"unhide​","type":1,"pageTitle":"unhide","url":"/docs/commands/unhide#unhide","content":" unhide commits and their ancestors  Mark the specified commits as visible. Any ancestors of the specified commits will also become visible.  ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"unhide","url":"/docs/commands/unhide#arguments","content":" shortname\tfullname\tdefault\tdescription-r\t--rev revisions to unhide ","version":"Next","tagName":"h2"},{"title":"Sapling Developer Guide","type":0,"sectionRef":"#","url":"/docs/dev/","content":"Sapling Developer Guide This is a Work-In-Progress! Content below might be rewritten entirely. 🗃️ Process 1 item 🗃️ Internals 8 items","keywords":"","version":"Next"},{"title":"Bisect-Based Copy Tracing","type":0,"sectionRef":"#","url":"/docs/dev/internals/copytracing","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#background","content":" Historically, Sapling has used two copy-tracing solutions. However, as our monorepos grow (tens of millions of files, tens of millions of commits), the previous solutions have become too slow for production use:  Full copy tracing finds all the new files (M) that were added from merge base up to the top commit and for each file it checks if this file was copied from another file (N). For each pair of files, Sapling was walking through the file history (H) to check the copy-from the relationship. The time complexity of this algorithm is O(M * N * H), where N and H are huge. Typically M (source) &lt;&lt; N (destination) Sapling records rename information directly in file headers, eliminating the need to compute file content similarity, which is different from Git's approach. Heuristics copy tracing assumes that moves or renames fall into one of two categories: (1) Within the same directory (same directory name but different file names); (2) Move from one directory to another (same file names but different directory names) This approach reduces N to K (K is a configured constant value), resulting in a time complexity of O(M * H), where H remains large and there is a large constant factor for reducing N to K.Another issue is that if the renames do not match the heuristics, they cannot be found.  Before we explore bisect-based copy tracing, let's first examine howGit's rename detectionworks. Git's rename detection is similar to the heuristics copy tracing mentioned earlier, but it includes additional heuristics and strategies to enhance performance, such as &quot;Remembering previous work&quot;, &quot;Exact renames&quot;.  The time complexity is O(M * S), where M is the same as above, S is the complexity of file content similarity computation.It also shares the disadvantage of Sapling heuristics copy tracing when renames do not match heuristics. Otherwise, the time complexity will be O(M * N * S).  Bisect-based copy tracing is built to achieve the following desired properties:  Scalability: O(M * log H) time complexity, it bisects the file history rather than scanning commits sequentially.Flexibility: Not restricted by heuristics like 'Move from one directory to another'.Abstracted: Support both Sapling and Git backend repositories.Efficiency: Provides fast content similarity checks for cases where renames are not recorded in Sapling or when working with Git repositories.User-Friendly: Informative message when renames cannot be found, such as delete/modified conflicts.  ","version":"Next","tagName":"h2"},{"title":"How?​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#how","content":" ","version":"Next","tagName":"h2"},{"title":"Scalability​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#scalability","content":" The problem that copy tracing solves is: given two commits, C1 and C2, and a path P1 in C1, we need to find the renamed path P2 in C2.  This problem required a new algorithmic design to scale efficiently. The basic idea is to break the problem into two steps:  Bisect a commit C3 that deletes P1 in the C1 to C2 range.Examine C3, find what path P1 was renamed to. If that path exists in C2, then we’re done. Otherwise recursively trace renames in the C3 to C2 range.  The efficient bisect is based on the Segmented Changelog we developed for lazy commit graph downloading and improving DAG operations, please check this blog postto learn more about Segmented Changelog.  ","version":"Next","tagName":"h3"},{"title":"Flexibility​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#flexibility","content":" Since Sapling can efficiently trace rename commits by bisecting the history, and then find the renames in a rename commit, we don't need heuristics to reduce the large number N on destination side. This approach allows Sapling to detect renames that would otherwise be missed by heuristics-based methods.  ","version":"Next","tagName":"h3"},{"title":"Abstracted​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#abstracted","content":" We made the rename detection inside a commit abstracted. Whether it’s Sapling’s tracked rename, or Git’s implicit content similar rename, or a combination of them, they fit in the same abstraction and can be flexibly configured.  ","version":"Next","tagName":"h3"},{"title":"Efficiency​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#efficiency","content":" Typical content similarity libraries often degrade to O(N^2) in the worst case, where N is the line count (O(N^2) is the worst case for the Myers diff algorithm). Our approach, xdiff::edit_cost, imposes a max cost limit, reducing the complexity to O(N).  ","version":"Next","tagName":"h3"},{"title":"User-Friendly​","type":1,"pageTitle":"Bisect-Based Copy Tracing","url":"/docs/dev/internals/copytracing#user-friendly","content":" When renames cannot be found, for example, file a.txt was renamed to a.mdand then deleted on the destination branch, the new copy tracing can identify both the commit that renamed the file and also the commit that eventually deleted it. This allows us to provide additional context to help resolve the conflict:  $ sl rebase -s 108b59d42 -d a1fcdc96b ... other [source (being rebased)] changed a.txt which local [dest (rebasing onto)] is missing hint: the missing file was probably deleted by commit 7f48dc97d540 with name 'a.md' in the branch rebasing onto use (c)hanged version, leave (d)eleted, or leave (u)nresolved, or input (r)enamed path?  ","version":"Next","tagName":"h3"},{"title":"web","type":0,"sectionRef":"#","url":"/docs/commands/web","content":"","keywords":"","version":"Next"},{"title":"web | isl​","type":1,"pageTitle":"web","url":"/docs/commands/web#web--isl","content":" launch Sapling Web GUI on localhost  Sapling Web is a collection of web-based tools including Interactive Smartlog, which is a GUI that facilitates source control operations such as creating, reordering, or rebasing commits. Running this command launches a web server that makes Sapling Web and Interactive Smartlog available in a local web browser. When possible, this command opens a separate OS window, either using a webview or a Chrome-like browser with --app.  Examples:  Launch Sapling Web locally on port 8081:  $ sl web --port 8081 Listening on http://localhost:8081/?token=bbe168b7b4af1614dd5b9ddc48e7d30e&amp;cwd=%2Fhome%2Falice%2Fsapling Server logs will be written to /dev/shm/tmp/isl-server-logrkrmxp/isl-server.log   Using the --json option to get the current status of Sapling Web:  $ sl web --port 8081 --json | jq { &quot;url&quot;: &quot;http://localhost:8081/?token=bbe168b7b4af1614dd5b9ddc48e7d30e&amp;cwd=%2Fhome%2Falice%2Fsapling&quot;, &quot;port&quot;: 8081, &quot;token&quot;: &quot;bbe168b7b4af1614dd5b9ddc48e7d30e&quot;, &quot;pid&quot;: 1521158, &quot;wasServerReused&quot;: true, &quot;logFileLocation&quot;: &quot;/dev/shm/tmp/isl-server-logrkrmxp/isl-server.log&quot;, &quot;cwd&quot;: &quot;/home/alice/sapling&quot; }   Using the --kill option to shut down the server:  $ sl web --port 8081 --kill killed ISL server process 1521158   ","version":"Next","tagName":"h2"},{"title":"arguments​","type":1,"pageTitle":"web","url":"/docs/commands/web#arguments","content":" shortname\tfullname\tdefault\tdescription-p\t--port\t3011\tport for Sapling Web --json\tfalse\toutput machine-readable JSON --open\ttrue\topen Sapling Web in a local browser -f\t--foreground\tfalse\tkeep the server process in the foreground --kill\tfalse\tkill any running server process, but do not start a new server --force\tfalse\tkill any running server process, then start a new server --app Use a native OS window or Chrome-like browser to open ISL in a standalone window. Use --no-app to use a normal browser tab instead. ","version":"Next","tagName":"h2"},{"title":"DrawDag","type":0,"sectionRef":"#","url":"/docs/dev/internals/drawdag","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#background","content":" When creating tests, we often need to create a repo with a particular layout. For example, to create a linear graph with three commits, we could use the following sequence of commands:  $ sl commit -m A $ sl commit -m B $ sl commit -m C   If the graph is nonlinear, extra commands such as merge and goto are needed:  $ sl commit -m A $ sl commit -m B $ sl goto -q '.^' $ sl commit -m C $ sl merge -q 'desc(B)' $ sl commit -m D   As you can see, creating the desired graph shape via writing out a sequence of commands is tedious, potentially error prone, and not immediately obvious what the resulting graph looks like.  To help aid people in writing tests (and those reviewing the tests!), we've created DrawDag to simply and intuitively create repos with the desired shape.  ","version":"Next","tagName":"h2"},{"title":"DrawDag language​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#drawdag-language","content":" DrawDag is a domain specific language to describe a DAG (Directed Acyclic Graph).  ","version":"Next","tagName":"h2"},{"title":"Basic​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#basic","content":" In this example, the DrawDag code looks like a hexagon and generates the graph to the right:   -B- / \\ A--C--D \\ / E-F -B- / \\ A--C--D \\ / E-F  The DrawDag code forms a 2D matrix of characters. There are three types of characters:  Space characters.Connect characters: -, \\, and /.Name characters: alpha, numeric, and some other characters.  Names define vertices in the graph. Connect characters define edges in the graph.  If two vertices are directly connected, the one to the left becomes a parent of the other vertex. For a commit graph, this behaves like making commits from left to right.  If a vertex has multiple parents, those parents are sorted in lexicographical order.  ","version":"Next","tagName":"h3"},{"title":"Name at multiple locations​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#name-at-multiple-locations","content":" A single name can be used in multiple locations and will represent the same vertex in the graph.  For example, the code below uses C in two locations to create criss-cross merges.  A-C \\ B-D \\ C A-C \\ B-D \\ C  ","version":"Next","tagName":"h3"},{"title":"Range generation​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#range-generation","content":" You can use .. (or more dots) to generate a range of vertices and connect them. This works for simple alphabet names like A..Z or numbers likeA01..A99:  A..C...F \\ / K A..C...F \\ / K  The range expansion under the hood works similarly toRuby's Range.  ","version":"Next","tagName":"h3"},{"title":"Vertical layout​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#vertical-layout","content":" By default, DrawDag assumes a horizontal layout. You can opt-in the alternative vertical layout by using |, or :. It has a few differences:  | is a valid connect character. - becomes invalid.: is used for range generation. . becomes a valid name character.  Z :\\ C B |/ A Z :\\ C B |/ A  Commits are created from bottom to top. This is similar to sl log -G output order.  ","version":"Next","tagName":"h3"},{"title":"Try DrawDag​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#try-drawdag","content":" Try editing the DrawDag code above. We draw the output live in the browser.  ","version":"Next","tagName":"h3"},{"title":"DrawDag in tests​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#drawdag-in-tests","content":" ","version":"Next","tagName":"h2"},{"title":".t integration tests​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#t-integration-tests","content":" You can use the drawdag shell function in .t tests to create commits and change the repo.  $ drawdag &lt;&lt; 'EOS' &gt; C &gt; | &gt; B1 B2 # amend: B1 -&gt; B2 &gt; \\| &gt; A &gt; EOS   # starts a comment till the end of the line. Comments won't be parsed as DrawDag code but might have other meanings:  # A/dir/file = 1: In commit A, update path dir/file to content 1.# amend: X -&gt; Y -&gt; Z: Mark Y as amended from X, Z as amended from Y.# bookmark FOO = A: Create bookmark FOO that points to commit A.  You can also use revset expressions to refer to existing commits. For example,. in vertical layout refers to the working parent.  Check test-drawdag.t for more examples.  ","version":"Next","tagName":"h3"},{"title":"Rust unit tests​","type":1,"pageTitle":"DrawDag","url":"/docs/dev/internals/drawdag#rust-unit-tests","content":" You can use the drawdag crate to parse DrawDag code into graph vertices and edges.  The dag crate might also be useful to run complex queries on a graph, and render it as ASCII. ","version":"Next","tagName":"h3"},{"title":"IndexedLog","type":0,"sectionRef":"#","url":"/docs/dev/internals/indexedlog","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#background","content":" Historically, revlog was the main storage format, but it has a few limitations:  Revisions have to be topologically ordered. When revisions are fetched on demand, if a later revision was fetched first, then it's impossible to append an older (ancestor) revision.Lookup by hash can trigger a linear scan. The slowness this causes becomes noticeable when there are lots of revisions. It can be worked around by building separate indexes.Not general purpose enough to fit various use-cases. For example, theobsstore would require looking up a record by various indexes: predecessors or successors, and one record can have multiple predecessors or successors. In Revlog, one record can only have one SHA1 hash as its key.  Git's format (loose and pack files) does not have the topological order limitation, and lookup by hash is ideally O(log N), unless there are too many pack files. But it requires periodical repack to maintain performance, and does not support the multi-index use-case.  SQLite is a powerful library that satisfies the multi-index use-cases, and can maintain time complexity without &quot;repack&quot;. However, the main problem is that historically we use the &quot;append-only&quot; strategy to achieve lock-free reads, but SQLite requires locking for both read and write.  IndexedLog is built to achieve the following desired properties:  O(log N) lookup and does not require repack to maintain performance.Insertion by hash without topological order limitation.Lock-free reading which primarily means &quot;append-only larger files&quot; and &quot;atomic-replace small files&quot; using the filesystem APIs we have today. Transactional filesystem or chunk-level copy-on-write could make a difference but they are generally not available.General purpose with multi-index and multi-key per entry support.  In addition, we think the property below is nice to have:  Data integrity. In case of hard reboots, or accidental sed -i on the repository data, we want to understand exactly what parts of the data are corrupted, and have a way to recover.  ","version":"Next","tagName":"h2"},{"title":"Log​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#log","content":" An IndexedLog consists of a Log and multiple surrounding Indexes. The Log is the single source of truth for the data. The indexes are derived purely from the Log and index functions. Corrupted indexes can be deleted and rebuilt as long as the Log is fine.  A Log stores entries in insertion order. An entry consists of a slice of bytes. Log is interface-wise similar to LinkedList&lt;Vec&lt;u8&gt;&gt;, but only accepts push_back, not push_front.  A Log supports the following operations:  Iterate through all entries in insertion order.Append a new entry to the end.  A Log does not support:  Read an entry by its offset (random access).Remove an entry.  Unlike a relational or document database, Log itself does not define the meaning of the bytes in an entry. The meaning is up to the application to decide.  ","version":"Next","tagName":"h2"},{"title":"Index​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#index","content":" A Log can have multiple indexes. An index has a name, and a pure function that takes the byte slice of an entry, and outputs a list of IndexOutputs.  Each IndexOutput is an enum that instructs IndexedLog to do one of the following:  Insert a key (in bytes) that points to the current entry.Remove a key or remove keys with a given prefix.  Unlike databases, the index function is in native Rust and not a separate language like SQL or JSON. Note that it is impossible to serialize a compiled Rust function to disk, so applications need to provide the exact same index functions when loading an IndexedLog from disk.  If you change an index function, you need to also change the index name to prevent the IndexedLog from picking up the wrong index data.  ","version":"Next","tagName":"h2"},{"title":"Standalone index​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#standalone-index","content":" The Index can be used independently from Log. Its interface is similar to BTreeMap&lt;Vec&lt;u8&gt;, LinkedList&lt;u64&gt;&gt;, but uses the filesystem instead of memory for the main storage.  An Index supports:  Insert (key, value). The value is inserted at the front of the existing linked list. Alternatively, the existing linked list can be dropped.Lookup keys by a range.Delete keys in a range.  Internally, the key portion of the index is aradix tree where a node has 16 children (4 bits). This is used to support hex prefix lookup. The value portion is a singly-linked list which supports push_front, but not push_back.  The on-disk format uses persistent data structureto achieve lock-free reading. The main index is append-only. The pointer to the root tree node is a small piece of data tracked separately using atomic-replace.  When used together with a Log, the u64 part of LinkedList&lt;u64&gt; is used as file offsets. The offsets are not exposed in public APIs of Log to avoid misuse. The Log allows the on-disk indexes to lag for some entries because updating the index for 1 entry takes O(log N) space, inefficient for frequent small writes. The lagging portion of index will be built on demand in memory.  ","version":"Next","tagName":"h2"},{"title":"Concurrent writes​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#concurrent-writes","content":" When an IndexedLog (or a standalone Index) gets loaded from disk, it is like taking a snapshot. Changes on disk afterwards won't affect the already loaded IndexedLog (as long as all writes to the files go through IndexedLog APIs).  Writes are buffered in memory, lock-free. They are invisible to other processes or other already loaded IndexedLogs.  A sync operation is needed to write data to disk, or load changed data from disk. The sync will take a filesystem lock to prevent other writers, pick up the latest filesystem state if anything has changed on disk, write the updated log and indexes to disk, then release the lock.  If 2 processes (or 2 IndexedLogs in one process) are sync()-ing to the same IndexedLog on disk concurrently, both their pending changes will be written. The order of the written data is unspecified, depends on which one obtains the filesystem lock first.  ","version":"Next","tagName":"h2"},{"title":"Data integrity​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#data-integrity","content":" Both Log and Index use xxhash for data integrity. Log writes a XXH32 or XXH64 checksum per entry depending on the size of the entry. Index internally maintains checksum entries per 1MB data. All data reading triggers integrity checks. Errors will be reported to the application.  IndexedLog supports a &quot;repair&quot; operation which truncates the Log to entries that pass the integrity check and then rebuilds the corrupted or outdated indexes.  ","version":"Next","tagName":"h2"},{"title":"RotateLog​","type":1,"pageTitle":"IndexedLog","url":"/docs/dev/internals/indexedlog#rotatelog","content":" RotateLog applies thelog rotation idea to IndexedLog. RotateLog maintains a list of Logs. When a Log exceeds certain size limit, RotateLog creates a new Log and optionally delete the oldest ones.  RotateLog is intended to be used for client-side caching, where the client wants space usage to be bounded, and the data can be re-fetched from the server. ","version":"Next","tagName":"h2"},{"title":"Internal differences from Mercurial","type":0,"sectionRef":"#","url":"/docs/dev/internals/internal-difference-hg","content":"","keywords":"","version":"Next"},{"title":"Visibility​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#visibility","content":" Mercurial treats all commits as visible by default, using obsolescence data to mark obsoleted commits as invisible.  Sapling treats all commits as invisible by default, using &quot;visible heads&quot;and bookmark references to mark commits and their ancestors as visible. This is similar to Git.  Performance wise, too much obsolescence data can slow down a Mercurial repo. Similarly, too many bookmarks and visible heads can slow down a Sapling repo. However, obsolescence data can grow over time unbounded while bookmarks and visible heads can shrink using commands like sl bookmark -d and sl hide. Practically, we assume a bounded number of bookmarks and visible heads.  Mercurial has a &quot;repo view&quot; layer to forbid access to hidden commits. Accessing them (for example, using the predecessors() revset) requires a global flag --hidden. Sapling removes the &quot;repo view&quot; layer. Revsets likeall(), children(), descendants() handle the visibility transparently by not including invisible commits. Revsets like predecessors() do not care about visibility and return invisible commits. If the user explicitly requests them using commit hashes, they will be included.  ","version":"Next","tagName":"h2"},{"title":"Phase​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#phase","content":" Mercurial tracks phases (public, draft, secret) explicitly using &quot;phase roots&quot;. Commits are public by default. Draft and secret roots are explicitly listed. The &quot;phase roots&quot; can grow unbounded and slow down the repo over time.  Sapling infers phases from remote bookmarks and visibility. Commits are secret (invisible) by default. Main remote bookmarks and their ancestors are marked public. Other visible commits are draft.  In Mercurial visibility and phase are separate concepts. A secret commit can be visible or invisible. In Sapling &quot;secret&quot; is just an alias to &quot;invisible&quot; - there are no &quot;visible secret&quot; commits.  ","version":"Next","tagName":"h2"},{"title":"Obsolescence​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#obsolescence","content":" Mercurial uses the &quot;obsstore&quot; to track commit rewrites. Sapling uses&quot;mutation&quot;. Their differences are:  Obsstore decides visibility. Mutation does not decide visibility.Obsstore supports &quot;prune&quot; operation to remove a commit without a successor commit. Mutation requires at least one successor commit so it cannot track &quot;prune&quot; rewrites.If all successors of a mutation are invisible, then the mutation is ignored. This means mutation can be implicitly tracked by visibility. Restoring visibility to a previous state during an undo operation effectively restores the commit rewrite state.  Implementation wise, mutation uses IndexedLog for O(log N) lookup. Nothing in Sapling requires O(N) loading of the entire mutation data.  ","version":"Next","tagName":"h2"},{"title":"Storage format​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#storage-format","content":" Mercurial uses Revlog as its main file format. Sapling uses IndexedLog instead.  For working copy state, Mercurial uses Dirstate. Sapling switched to TreeState in 2017. Mercurial 5.9 released in 2021 introduced Dirstate v2that improves performance in a similar way.  For repo references such as bookmarks and remote bookmarks, Mercurial tracks them in individual files like .hg/bookmarks. Sapling uses MetaLogto track them so changes across state files are atomic.  ","version":"Next","tagName":"h2"},{"title":"Protocols​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#protocols","content":" Mercurial supports ssh and http wireprotocols. Sapling's main protocol is defined in a Rust EdenApi trait. It is very different from the original wireprotocols.  There are two implementations of the EdenApi trait: an HTTP client that talks to a supported server and an EagerRepo for lightweight local testing. The HTTP implementation uses multiple connections to saturate network bandwidth for better performance.  ","version":"Next","tagName":"h2"},{"title":"Python 3 and Unicode​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#python-3-and-unicode","content":" Python 3 switched the str type from bytes to unicode. This affects keyword arguments, and stdlib APIs like os.listdir, sys.argv.  Sapling adopts Unicode more aggressively. Command line arguments, bookmark names, file names, config files are considered Unicode and are encoded using utf-8 during serialization. Sapling does not turn Python keyword arguments and stdlib output back to bytes.  Treating file names as utf-8 allows Sapling to read and write correct file names between Windows and *nix systems for a given repo.  ","version":"Next","tagName":"h2"},{"title":"Pure Python support​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#pure-python-support","content":" Mercurial maintains a pure Python implementation. It can run without building with a C or Rust compiler by setting HGMODULEPOLICY to py. This is not possible for Sapling.  ","version":"Next","tagName":"h2"},{"title":"Ignore files​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#ignore-files","content":" Mercurial supports .hgignore, optionally .gitignore through extensions. Sapling only supports .gitignore.  ","version":"Next","tagName":"h2"},{"title":"Git support​","type":1,"pageTitle":"Internal differences from Mercurial","url":"/docs/dev/internals/internal-difference-hg#git-support","content":" There are 2 extensions that add Git support to Mercurial:  hg-githgext/git  hg-git mirrors the bare Git repo to a regular hg repo. Therefore it double stores file content, and produces different hashes.  hgext/git tries to be compatible with an existing Git repo. Therefore it is limited to git specifications like what the .git directory should contain and in what format.  Sapling treats Git as an implementation of its repo data abstraction. This means:  The working copy implementation is Sapling's. It can integrate with our virtualized working copy filesystem in the future.The repo data implementation can adopt Sapling's components in the future for benefits like on-demand fetching, data bookkeeping without repack.Git commands are not supported in Sapling's Git repo. ","version":"Next","tagName":"h2"},{"title":"LineLog","type":0,"sectionRef":"#","url":"/docs/dev/internals/linelog","content":"","keywords":"","version":"Next"},{"title":"Bytecode​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#bytecode","content":" LineLog uses a bytecode format that is interpreted to produce content. There are 5 instructions:  Name\tOperand 1\tOperand 2\tMeaningJGE\tRev\tAddr\tJump to Addr if Current Rev &gt;= Rev J\t0\tAddr\tJump to Addr unconditionally JL\tRev\tAddr\tJump to Addr if Current Rev &lt; Rev LINE\tRev\tLine\tAppend the Line + 1-th line in Rev END\t-\t-\tStop execution  Instructions are fixed-sized. The opcode takes 2 bits. J and JGE share the same opcode (J Addr is just JGE 0 Addr). Operand 1 takes 30 bits. Operand 2 takes 32 bits.  ","version":"Next","tagName":"h2"},{"title":"Interpretation​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#interpretation","content":" ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#example","content":" It is easier to understand with an example. Given a file with 3 revisions:  Rev 1 a b c Rev 2: Inserted 2 lines. a b 1 2 c Rev 3: Deleted 2 lines. a 2 c  It can be encoded in LineLog bytecode like:  # Addr: Instruction 0: JL 1 8 1: LINE 1 0 2: JGE 3 6 3: LINE 1 1 4: JL 2 7 5: LINE 2 2 6: LINE 2 3 7: LINE 1 2 8: END   To check out a specified revision, set Current Rev to the revision to check out, then execute the instructions from the beginning.  Here are the steps to check out each revision:  Rev 0Rev 1Rev 2Rev 3 Address 0: JL 1 8: Do nothing, because Current Rev (1) is not &lt; 1.Address 1: LINE 1 0: Append the first line from rev 1 (&quot;a&quot;).Address 2: JGE 3 6: Do nothing, because 1 is not ≥ 3.Address 3: LINE 1 1: Append the second line from rev 1 (&quot;b&quot;).Address 4: JL 2 7: Jump to address 7, because 1 &lt; 2.Address 7: LINE 1 2: Append the third line from rev 1 (&quot;c&quot;).Address 8: END: Stop. The final content is &quot;abc&quot;.  ","version":"Next","tagName":"h3"},{"title":"Checkout and annotate​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#checkout-and-annotate","content":" Note the lines that are not changed across multiple revisions, such as &quot;a&quot; only occurs once as LINE 1 0 in the bytecode. The LINE instruction points to the revision and line that introduces the line. By tracking the operands of LINEinstructions in addition to line contents, LineLog could also produce theannotate (also called blame) result at the same time.  In LineLog, the checkout and annotate operation are basically the same.  ","version":"Next","tagName":"h3"},{"title":"Range of revisions​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#range-of-revisions","content":" A variation of the interpretation is to treat &quot;Current Rev&quot; as a range, not a single fixed revision number. More specifically, given an inclusive range fromminRev to maxRev, treat JL as &quot;&lt; maxRev&quot;, JGE as &quot;&gt;= minRev&quot;. This can produce all lines that existed in the revision range, in a reasonable order, like:  rev 1: a rev 1: b rev 2: 1 rev 2: 2 rev 1: c  ","version":"Next","tagName":"h3"},{"title":"Linear history​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#linear-history","content":" LineLog assumes linear history. The revision comparisons are done using direct integer comparisons. It might be not too difficult to support non-linear history (i.e. with merges) by changing the revision comparisons to consider the graph topology. But that hasn't been attempted due to lack of use-cases so far.  ","version":"Next","tagName":"h3"},{"title":"Editing LineLog​","type":1,"pageTitle":"LineLog","url":"/docs/dev/internals/linelog#editing-linelog","content":" LineLog provides a method for editing: replace_lines(brev, a1, a2, b1, b2). It means replacing the line range [a1, a2) from the current checkout to line range [b1, b2) in the given brev revision. This covers insertion and deletion too. If a1 equals to a2, it is an insertion. If b1 equals tob2, it means lines from a1 to a2 are deleted in revision brev.  This is implemented by appending a block that appends the lines from thebrev, and removes lines from a. Then change the LINE instruction for thea1 line to point to the added block.  # Before # After # Addr: Instruction # Addr: Instruction : ... : ... a1: &lt;a1's LINE&gt; a1 : J len a1+1: ... a1+1 : ... : ... : ... a2: ... a2 : ... : ... : ... len: N/A len : JL brev p : LINE brev b1 : LINE brev b1+1 : ... : LINE brev b2-1 p : JGE brev a2 : &lt;a1's LINE&gt; (copied) : J a1+1   To construct LineLog for a file, one needs to run through the contents of revisions of the file in commit order, calculate diffs for adjacent revisions, and then feed LineLog the diffs using the replace_lines method.  Usually replace_lines is used to edit the latest revision. However, it can also be used to edit past revisions, if past revisions are checked out. This is how the absorb command works under the hood. ","version":"Next","tagName":"h2"},{"title":"Visibility and mutation","type":0,"sectionRef":"#","url":"/docs/dev/internals/visibility-and-mutation","content":"","keywords":"","version":"Next"},{"title":"Commit visibility​","type":1,"pageTitle":"Visibility and mutation","url":"/docs/dev/internals/visibility-and-mutation#commit-visibility","content":" A Sapling repository can contain more commits than the commits you're currently working on. For example, when you amend a commit, the old version of the commit remains in the repository. You can still access it directly using its hash, but otherwise the commit is hidden.  Sapling tracks visibility of commits in a couple of ways:  Any commit that is an ancestor of a remote bookmark is visible. These commits are public and cannot be modified.Sapling also tracks a set of visible heads. Any commit that is an ancestor of a visible head is visible. These commits are draft, and may be modified by commands like sl amend. When a commit is created or modified, Sapling automatically removes any old versions of the commits from this set, and adds the new ones to it.  This is similar to how Git tracks which commits are reachable in the repository using the local and remote branches, except that Sapling maintains your local branches for you automatically.  While most visibility operations are automatic, you can also manually hide and unhide commits using the sl hide and sl unhide commands.  In order to scale to thousands of developers contributing to the same repository, commit visibility is entirely local. Which commits are visible to you are not shared with other developers, so if you hide a commit, it is only hidden for you.  ","version":"Next","tagName":"h2"},{"title":"Commit mutation​","type":1,"pageTitle":"Visibility and mutation","url":"/docs/dev/internals/visibility-and-mutation#commit-mutation","content":" Sapling tracks whenever commits are modified using commands like rebase or amend. The records of these changes are called mutations.  This is similar to some parts of the Evolve extension of Mercurial, however it is designed to be more lightweight to allow scaling to very large repositories with millions of modified commits.  A mutation record is a record of how a modified commit came to exist. For example, if you run sl amend on commit A to produce commit B, Sapling will store a record that says &quot;commit B was created by amending commit A&quot;. It will also record who performed the mutation, and the timestamp.  For the most part, mutation records are purely informational. They affect Sapling operations in two ways:  In smartlog, if both a commit that has been modified and its modified version are visible, the earlier commit will show as obsolete and the latest version's hash will be shown next to the commit, along with whatever operation caused the modification.When restacking commits after modifying a commit in the middle of stack, Sapling will use the mutation information of a commit's parent to determine the latest commits that should be used as the destination for each restack.  You can also find earlier and later versions of a commit using the predecessors and successors revsets.  When used with the Sapling server, commit mutation information can be shared with other developers working on the same commits. When pushing or pulling draft commits to or from the server, Sapling includes records covering the full mutation history of the pushed or pulled commits. It's not necessary for the older commits themselves to be shared, as Sapling can skip over commits in the history that are not present in the local repository. In order for this to scale to thousands of developers making millions of changes, Sapling only considers mutation records in the mutation history of the draft commits that you are currently working on, i.e., those that are visible in your local repository. ","version":"Next","tagName":"h2"},{"title":"MetaLog","type":0,"sectionRef":"#","url":"/docs/dev/internals/metalog","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#background","content":" Historically, repo metadata like bookmarks, remote bookmarks, and phases are stored in separate files. Because reading is designed to be lock-free, and the filesystem is not transactional, updating these files is not atomic and readers might see inconsistent state where some files are updated but others aren't. This requires careful design of file write order to reduce issues. The write order can be subtle and fragile to maintain.  The other motivation is to help debug user issues. Sometimes it's really helpful to understand what happened in the past. Metalog tracks this historical data to answer questions like how and when bookmarks changed, etc.  ","version":"Next","tagName":"h2"},{"title":"MetaLog​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#metalog-1","content":" ","version":"Next","tagName":"h2"},{"title":"Structure​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#structure","content":" MetaLog maintains 2 structures:  A blob store backed by ZStore. Blobs are keyed by their content SHA1s. There are 2 kinds of blobs: root, and content.A log of keys of roots. It provides a way to get the latest root, and also historical roots.  A root blob contains:  A description of why this root was created.A map from (file) names to keys of content blobs.Keys of parent roots.  You might notice that MetaLog is kind of like a lightweight source control system itself. That is part of the reason for the naming.  ","version":"Next","tagName":"h3"},{"title":"Concurrent writes​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#concurrent-writes","content":" Similar to IndexedLog, changes are buffered in memory until an explicit flush to disk.  Unlike IndexedLog, if MetaLog notices that the latest root is changed on disk, it will attempt to perform a merge defined using a merge function specified by the application. A merge failure will prevent MetaLog from committing the changes to disk.  This means the application might not need extra locking, instead relying on MetaLog's merge feature to detect races.  ","version":"Next","tagName":"h3"},{"title":"Usage in Sapling​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#usage-in-sapling","content":" ","version":"Next","tagName":"h2"},{"title":"Integration with transaction​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#integration-with-transaction","content":" In Sapling, code like:  with repo.lock(), repo.transaction(&quot;transaction-name&quot;) as tr: ...   Reloads the latest MetaLog root at the beginning of the transaction, and writes changes back to disk at end of the transaction.  ","version":"Next","tagName":"h3"},{"title":"Source of truth​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#source-of-truth","content":" To avoid invalidation issues, if performance allows, avoid storing states from the MetaLog:  class Repo: def __init__(self): self._foo = None def foo(self): # Fragile: Requires extra effort to ensure repo._foo is always synced # with source of truth. if self._foo is None: self._foo = decode_foo(self.metalog()['foo']) return self._foo def foo(self): # Less fragile: foo() is always synced with metalog source of truth. return decode_foo(self.metalog()['foo'])   ","version":"Next","tagName":"h3"},{"title":"Other storage data​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#other-storage-data","content":" MetaLog is only intended to store lightweight metadata that deltas very well.  There are other kinds of data that are not so lightweight. For example, files, trees, commits, and mutation records.  Sapling's strategy to maintain consistency is to ensure orphaned data in the heavywight storage won't visibly affect the user experience. For example,  Files or Trees: If there are unused files or trees stored, they do not affect the output of sl or status, etc. They are simply not referred to.Commits: Similarly, if there are extra commits stored in the commit graph, they are invisible because they are not referred to by visible heads or bookmarks. The orphaned commits are transparent to common commands.Mutation Records: If there are unused mutation records, since the successors are invisible, the records are simply ignored. It will not turn a commit from o to x in log -G output.  This means that Sapling can just flush these kinds of data without going through MetaLog, and there is no need to undo or truncate them to a previous state.  Write order​  Write MetaLog last. MetaLog tracks references to other data.  Different kinds of data have dependencies. This requires a write order. Commits refer to trees. Trees refer to files. Bookmarks in MetaLog refer to commits.  If MetaLog is written before writing commits, it might refer to unknown commits and cause issues.  Whether commits or trees are written first does not matter, since there are no references to them and they are just unused data described above.  ","version":"Next","tagName":"h3"},{"title":"Export to Git​","type":1,"pageTitle":"MetaLog","url":"/docs/dev/internals/metalog#export-to-git","content":" You can export MetaLog content to a Git repo:  sl debugexportmetalog /path/to/git-repo  From there you can run commands like git annotate remotenames andgit log -p remotenames to see what commands changed a specific remote bookmark and when. ","version":"Next","tagName":"h3"},{"title":"ZstDelta","type":0,"sectionRef":"#","url":"/docs/dev/internals/zstdelta","content":"","keywords":"","version":"Next"},{"title":"ZstDelta​","type":1,"pageTitle":"ZstDelta","url":"/docs/dev/internals/zstdelta#zstdelta-1","content":" The zstdelta Rust library provides diff and apply to calculate such compressed deltas and restore content from deltas. You can get delta fromdiff(a, b), then restore the content of b using apply(a, delta).  In Python, bindings.zstd provides access to the diff and apply functions:  &gt;&gt;&gt; import bindings, hashlib &gt;&gt;&gt; a = b&quot;&quot;.join(hashlib.sha256(str(i).encode()).digest() for i in range(1000)) &gt;&gt;&gt; len(a) 32000 &gt;&gt;&gt; b = a[:10000] + b'x' * 10000 + a[11000:] &gt;&gt;&gt; diff = bindings.zstd.diff(a, b) &gt;&gt;&gt; len(diff) 29 &gt;&gt;&gt; bindings.zstd.apply(a, diff) == b True   ","version":"Next","tagName":"h2"},{"title":"ZStore​","type":1,"pageTitle":"ZstDelta","url":"/docs/dev/internals/zstdelta#zstore","content":" The zstore Rust library provides an on-disk content store with internal delta-chain management. It uses the above zstdelta library for delta calculation and IndexedLog for on-disk storage. It is used byMetaLog. ","version":"Next","tagName":"h2"},{"title":"FAQs","type":0,"sectionRef":"#","url":"/docs/faqs","content":"","keywords":"","version":"Next"},{"title":"How do I use Sapling while maintaining compatibility with \"steamlocomotive\"?​","type":1,"pageTitle":"FAQs","url":"/docs/faqs#how-do-i-use-sapling-while-maintaining-compatibility-with-steamlocomotive","content":" Sapling provides a way for you to configure its behaviour when it's run without any subcommands inside or outside a repository.  To make sl resolve to the steam locomotive UNIX command (the original sl), you can create an alias and configure the no-repo behaviour to call it, by running:  sl config --user 'alias.steamlocomotive=!/full/path/to/steamlocomotive' 'commands.naked-default.no-repo=steamlocomotive'   If you also want to run the steamlocomotive when inside a repo, you can also add 'commands.naked-default.in-repo=steamlocomotive' to the end of the command. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/git/intro","content":"","keywords":"","version":"Next"},{"title":"Git integration​","type":1,"pageTitle":"Introduction","url":"/docs/git/intro#git-integration","content":" Sapling supports Git in 2 modes: .git mode, and .sl mode.  If you'd like to also run git commands, use git clone or git init to create the repo, then run sl commands in it. If you'd like to use sl exclusively, benefit more from Sapling's scalability features, use sl clone or sl init instead.  Refer to Git support modes for details.  ","version":"Next","tagName":"h2"},{"title":"Code review system integration​","type":1,"pageTitle":"Introduction","url":"/docs/git/intro#code-review-system-integration","content":" ","version":"Next","tagName":"h2"},{"title":"GitHub​","type":1,"pageTitle":"Introduction","url":"/docs/git/intro#github","content":" Sapling has builtin support for GitHub. It enables features like showing whether a GitHub Pull Request is accepted or not.  Refer to Using Sapling with GitHub for details. ","version":"Next","tagName":"h3"},{"title":"Git support modes","type":0,"sectionRef":"#","url":"/docs/git/git_support_modes","content":"","keywords":"","version":"Next"},{"title":".git mode​","type":1,"pageTitle":"Git support modes","url":"/docs/git/git_support_modes#git-mode","content":" In this mode, Sapling tries to be compatible with .git/ file formats so you can run git commands. For features not natively supported by Git like mutation, Sapling will store them in the .git/sl directory.  There are some caveats using the .git mode:  Mixing sl and git commands might not work in all cases. For example: If your sl rebase is interrupted, use sl rebase --continue to continue, you cannot use git rebase --continue.Similarity, use git rebase --continue for an interrupted git rebase.If you run sl add to mark a file as tracked, use sl status and sl commit to commit the change. sl add might not affect git status or git commit. sl might put the repo in a &quot;detached head&quot; state. This is okay if you only run sl commands. However, if you use git commands, be sure to run git branch some_name to create a branch before git checkout away to avoid losing commits.LFS 1 or other .gitattributes features are partially supported. sl goto runs git checkout under the hood. Other sl commands like commit or diff do not respect .gitattributes. You can use git instead.sl does not have local tags. You can use origin/tags/v1.0 to refer to the v1.0 tag stored on the origin server.Currently, sub-modules are not fully supported.Currently, ISL might not detect repo changes as quickly or automatically as other modes. Use the refresh button to recheck manually if necessary.  ","version":"Next","tagName":"h2"},{"title":".sl mode​","type":1,"pageTitle":"Git support modes","url":"/docs/git/git_support_modes#sl-mode","content":" In this mode, Sapling can utilize more scalability features, although some are not yet built in the public release. For example:  For the working copy implementation, Sapling can use its own implementations:  Physical filesystem: together with watchman, add or remove operations can be O(changed files) instead of O(total files). There is no need to re-write a potentially large file like .git/index.Virtual filesystem (EdenFS): With eden, and sl built with Thrift support, you can run eden clone &lt;sl_git_working_copy&gt; &lt;new_working_copy&gt; to get a virtual working copy which has much better goto performance.  For server protocols, Sapling can use dedicated lazy commit graph protocols so clone and pull are roughly O(merges) both in time and space usage.  For local storage, Sapling can use its own structure and compression so the file count is bounded and there is no need to repack. Note: This is not fully implemented for the git format yet but is the direction we'd like to go.    Footnotes​ Sapling can write Git LFS files to disk on goto. However, if you need to make changes or create new LFS files, or view their diffs, you need to use git commands. ↩ ↩2 Source code to support those exists on GitHub. However, EdenFS, Mononoke, and Sapling with EdenFS support are not yet part of the public GitHub releases yet. ↩ ↩2 ","version":"Next","tagName":"h2"},{"title":"Using Sapling with GitHub","type":0,"sectionRef":"#","url":"/docs/git/github","content":"","keywords":"","version":"Next"},{"title":"Cloning a repo​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#cloning-a-repo","content":" Once you have authenticated via gh auth login --git-protocol https, you should be able to clone any GitHub repository via its HTTPS URL that you have access to using Sapling:  sl clone https://github.com/facebook/sapling   With the GitHub CLI caching your credentials, you will be able to run commands like sl ssl to see the status of any linked pull requests in your Smartlog, as it uses your PAT behind the scenes to query their current state.  ","version":"Next","tagName":"h2"},{"title":"Pull requests​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#pull-requests","content":" When it comes to working with pull requests from Sapling, you have two options: sl pr and sl push. Each has its tradeoffs, so you may opt to use a different solution, depending on the scenario:  ","version":"Next","tagName":"h2"},{"title":"sl pr (aka \"Sapling stack\")​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#sl-pr-aka-sapling-stack","content":" See the dedicated Sapling Stack page for more information.  Pros:  Works with any GitHub repo.  Cons:  Creates &quot;overlapping&quot; pull requests that may be confusing to reviewers using the GitHub pull request UI. Reviewers are strongly encouraged to use ReviewStack for code review instead of GitHub.  tip You can use the pr revset to automatically pull and checkout GitHub pull request. For example, sl goto pr123. See sl help revsets for more info.  ","version":"Next","tagName":"h3"},{"title":"sl push​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#sl-push","content":" The GitHub website provides a way to turn a Git branch into a pull request. You can use sl push to create branches, then use the GitHub website to create pull requests.  If you have write access to the repo, you can push to a new branch:  sl push --to remote/my-new-feature   If you don't have write access to the repo, you can fork the repo from the GitHub website, add your fork as a remote, then push to your fork:  sl paths --add my-fork ssh://git@github.com/my-username/sapling.git sl push --to my-fork/my-new-feature   After push, open the repo webpage. You will see GitHub detected the push:  my-new-feature had recent pushes less than a minute ago Compare &amp; pull request  Click the &quot;Compare &amp; pull request&quot; button to create a pull request.  You can also manually specify a Git branch and create a pull request. Read Creating a pull request from a fork for instructions.  To update an existing pull request, use sl push -f to force push to the same branch.  Pros:  Take control of commits (one or more) the pull request contains more explicitly.Use GitHub website to edit the pull request summary. It is easy to preview and auto-complete.  Cons:  Need a few more clicks on the GitHub webpage.Only create a single pull request per branch.  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#troubleshooting","content":" ","version":"Next","tagName":"h2"},{"title":"could not read Username error when trying to git push​","type":1,"pageTitle":"Using Sapling with GitHub","url":"/docs/git/github#could-not-read-username-error-when-trying-to-git-push","content":" If you see an error like the following:  stderr: fatal: could not read Username for 'https://github.com': No such device or address   Then you likely need to run gh auth setup-git [--hostname HOST] to configure gh as a Git credential helper. This will add the following to your .gitconfig (though the host will be different if you used --hostname to specify your GitHub Enterprise hostname):  [credential &quot;https://github.com&quot;] helper = helper = !/usr/bin/gh auth git-credential [credential &quot;https://gist.github.com&quot;] helper = helper = !/usr/bin/gh auth git-credential   See gh issue #3796 for details ","version":"Next","tagName":"h3"},{"title":"Sapling stack","type":0,"sectionRef":"#","url":"/docs/git/sapling-stack","content":"Sapling stack Sapling comes with a pr subcommand to help you work with GitHub pull requests. Once you have a stack of commits, you can use sl pr submit --stack (or sl pr s -s) to create a pull request for each commit in the stack, or to update existing pull requests linked to the commits. caution Make sure you have followed the instructions to authenticate with GitHub using the GitHub CLI gh before using sl pr. caution sl pr submit creates overlapping commits where each pull request contains the commit that is intended to be reviewed as part of the pull request as well as all commits below it in the stack. This will not &quot;look right&quot; on GitHub, so collaborators who use this command are encouraged to use ReviewStack to review these pull requests, as ReviewStack will present only the commit that is intended to be reviewed for each pull request. If you get into a funny state, try using sl pr link or sl pr unlink to add or remove associations between commits and pull requests, as appropriate.","keywords":"","version":"Next"},{"title":"Writing Tests","type":0,"sectionRef":"#","url":"/docs/dev/process/writing_tests","content":"","keywords":"","version":"Next"},{"title":".t Tests​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#t-tests","content":" .t tests live in tests/. They can be run byrun-tests.py &lt;.t file name&gt;.  ","version":"Next","tagName":"h2"},{"title":"Basic​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#basic","content":" Each test looks like indented blocks of bash scripts with commentary. For example  Test 'echo' works. This line is a comment. $ echo A A   The test engine will execute echo A and verify its output is A.  The .t format also supports multi-line commands, Python scripts and testing exit code:  Multi-line commands (with heredoc):   $ sha1sum &lt;&lt; EOF &gt; hello &gt; EOF f572d396fae9206628714fb2ce00f72e94f2258f   Python code blocks:   &gt;&gt;&gt; import sys &gt;&gt;&gt; for i in &quot;hello world&quot;.split(): ... sys.stdout.write(&quot;%s\\n&quot; % i) hello world   Exit code can be tested using [code]:   $ false [1]   To get started with creating a test, you can set PS1='$ ' in your shell and experiment with the reproducing commands. When done, just copy them to a .t file and prefix them with two spaces.  You can also just edit the $ command lines in test-foo.t directly, and use run-tests.py -i test-foo.t to fill in the output. This is also a good way to edit tests.  ","version":"Next","tagName":"h3"},{"title":"Best practice​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#best-practice","content":" Recommended test setup​  tl;dr: Write tests as follows:   $ newclientrepo &lt;&lt;'EOS' &gt; B &gt; | &gt; A &gt; EOS This is a comment $ touch something $ hg st # this is another comment ? something $ hg go $A -q   The recommended way to create new repos is to use newclientrepo.  By default new tests test against:  Sapling without WatchmanSapling and WatchmanSapling and EdenFS  If it's necessary to specify just one of them, #require eden / #require no-eden / #require fsmonitor / #require no-fsmonitorcan be added at the top of the file for specifying only one of them.  Create a new repo for each sub-test-case​  Creating a new repo is a very cheap operation and can help untangle future issues caused by overusing the same one. It's possible to specify the names of new repos when using newclientrepo; the name of the server for the repo can also be specified. For example:   $ newclientrepo $ pwd # the name of the repo is repo&lt;N&gt; by default $TESTTMP/repo1 $ hg config paths.default # similarly, the repo names are repo&lt;N&gt; test:repo1_server   Running tests against Watchman or EdenFS​  Currently these two can only be run through Buck. - and . in test names have to be converted to _. For instance,  # Runs test-rust-checkout.t with Watchman enabled $ buck2 test '@fbcode//mode/opt' :hg_watchman_run_tests -- test_rust_checkout_t # Runs test-rust-checkout.t with EdenFS enabled $ buck2 test '@fbcode//mode/opt' :hg_edenfs_run_tests -- test_rust_checkout_t   On EdenFS tests the EdenFS CLI is available through the eden command; it's recommended for new repos (cloned or newly created) to be created throughnewclientrepo. See the previous section for an example on how to do this.  Silence uninteresting output​  Not all output is interesting to the test. For example, when testinghg log, the output of hg update is not interesting. Use -qto silence it   $ hg update -q commit-x   This makes the test cleaner and easier to codemod update output.  Similarity, avoid testing revision numbers, or branch names, if they are not interesting to the test. It will make deprecation of those features easier.  Use drawdag to create commits​  hg debugdrawdag (or drawdag defined in tinit.sh) can be used to create commits in a more readable, and efficient way. newclientrepo (also defined on tinit.sh) can also take the same input as drawdag. Seethe drawdag page for more info.  Avoid depending on context​  As the test file grows longer, it could become difficult to follow or modify. It's often caused by commands depending on the context (ex. the current repo state, or the current directory) and the context is not obvious by just reading the code. Here are some tips to make tests easier to understand:  Avoid .. in filesystem paths. Instead of cd ../repo1, use cd $TESTTMP/repo1.Avoid using a list of hg commit, hg update to create a repo. Use drawdag if possible. If drawdag cannot be used, insert a hg log -Gcommand to print the repo content out.  ","version":"Next","tagName":"h3"},{"title":"Advanced features​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#advanced-features","content":" Test environment​  A test starts inside a temporary directory, which can be obtained usingTESTTMP environment variable. The TESTDIR environment variable contains the path to the tests/ directory, which can be handy to refer to other scripts.  tests/tinit.sh is sourced. Functions defined in it can be used to make tests shorter. For example  Use functions in tinit.sh: $ setconfig lfs.url=file://$TESTTMP/lfs lfs.threshold=10B $ enable lfs rebase $ newrepo   Equivalent to:   $ cat &gt;&gt; $HGRCPATH &lt;&lt; EOF &gt; [extensions] &gt; lfs= &gt; rebase= &gt; [lfs] &gt; url=file://$TESTTMP/lfs &gt; threshold=10B &gt; EOF $ hg init repo1 $ cd repo1   A particularly important function is newclientrepo. It also allows specifying different repo and server names:   $ newclientrepo foo $ newclientrepo bar test:customservername $ cd $TESTTMP/foo # this goes back to the foo repo   Similarly, there are some default Sapling configs defined intests/default_hgrc.py. These defaults change depending on whether tests are compatible with debugruntest or not.  Conditional logic​  Certain tests might require some features (ex. POSIX, case insensitive filesystem, or certain programs to be installed). Run python tests/hghave --list to get a list of features that can be tested. Example use in .tlooks like  #require fsmonitor icasefs The test will be skipped if any of the requirement is not satisfied. #if symlink This block is skipped if symlink is not supported. $ ln -s a b #else This block is skipped if symlink is supported. $ cp a b #endif   &quot;If&quot; statements can be nested as well and multiple statements can be put in a single statement:  #if symlink no-osx This block will only be run if symlinks are supported and macOS is not being used $ ln -s a b #if execbit This block will only be run if symlinks are supported, macOS is not being used, and execbit is supported $ chmod +x a #endif #else This block will only be run if symlinks are not supported or macOS is being used $ cp a b #endif   Features can be prefixed with no- meaning it should not be selected  #require no-fsmonitor Skip this test on 'run-tests.py --watchman'.   Multiple test cases​  Sometimes it's feasible to reuse the most of the test code for different code paths. #testcases can be used to define test case names that can be used for feature testing  #testcases innodb rocksdb #if innodb $ setconfig db.engine=inno #else $ setconfig db.engine=rocks #endif   This runs the test once for each test case.  Hybrid Python code blocks​  If using debugruntest, it's possible to combine Python code blocks with shell-like input. For instance,   if True: $ echo 1 1   Processing previous command output in Python​  Sometimes it can be useful to process some command's output on Python rather than just to expect some value. If debugruntest is used, last command's output can is stored in the _ variable in Python. For example,   $ echo 123 123 &gt;&gt;&gt; _ == &quot;123\\n&quot; True &gt;&gt;&gt; assert _ == &quot;True\\n&quot;   Matching dynamic output​  To filter noisy output that changes on each run (ex. timestamps), use glob patterns and put a space and (glob) at the end of the output line   $ hg parents -r null --time time: real * secs (user * sys *) (glob)   In the same vein, regular expressions can be also used with (re):   $ echo &quot; 3&quot; \\s*3 (re)   Escape sequences can be expected as well:   $ hg debugtemplate '{label(\\&quot;test.test\\&quot;, \\&quot;output\\n\\&quot;)}' --config color.test.test=blue \\x1b[34moutput\\x1b[39m (esc)   You can match different output based on which features are available. Use(feature-name !) to mark a line as required if the feature was turned on, or optional otherwise.   $ hg debugfsinfo | grep eden fstype: eden (eden !)   More than one feature can be expected here (all of them will be &quot;and&quot;-end), and globs can be used as well:   $ hg go $B update failed to remove foo: Can't remove file &quot;*foo&quot;: The process cannot access the file because it is being used by another process. (os error 32)! (glob) (windows !) (no-eden !) 2 files updated, 0 files merged, 1 files removed, 0 files unresolved   Use (?) to mark output as optional unconditionally   $ maybe-output-foobar foobar (?)   There is an additional mechanism for matching output more or less arbitrarily; this is done through registerfallbackmatch, and this is what .t tests to be ok with non-EdenFS and EdenFS outputs from hg goto. That makes   $ hg goto foo 2 files updated, 0 files merged, 1 files removed, 0 files unresolved   work without having to resort to  #if no-eden $ hg goto foo 2 files updated, 0 files merged, 1 files removed, 0 files unresolved #else $ hg goto foo update complete #endif   Available commands and binaries​  For making a test only run if a certain binary is available, the #requirestatements, #if blocks, or ( !) line matching can be used. For instance,  #require git $ git --version | wc -l 1 1 #if node $ node --version | wc -l 1 1 #endif $ lldb -P 2&gt;&amp;1 | wc -l 1 1 (lldb !) [255] (no-lldb !)   As mentioned previously, there are two different engines for .t tests.  On the old test engine, commands are run using Bash on macOS and Linux, and all usual commands (ls, echo) are the ones that the new test engine implements. For other binaries (e.g., git, unzip, etc.) the ones provided by the system are used; whichever commands are in PATH can actually be used.  In the case of debugruntest tests, Bash is not actually used and Shell builtins / coreutils are implemented by the test runner. Additionally, certain commands such as unzip are actually implemented within the test runner itself. This is done for improving compatibility with non-POSIX OSes and for performance reasons.  Test-level settings​  Currently we have four test-level settings:  #debugruntest-incompatible :: Makes the test use the legacy test engine.#inprocess-hg-incompatible :: To be used on debugruntest tests. Without this, a new Sapling process is used every time Sapling is invoked in .ttests. There are a few more caveats, see the documentation underscm/sapling/testing.#chg-compatible :: To be used on non-debugruntest tests. This is similar to not using #inprocess-hg-incompatible from above, making .t tests use the chg daemon for Sapling processes.#modern-config-incompatible :: Only compatible with debugruntest tests andnot* intended te be used on new tests. This exists for legacy reasons, making tests use much older configs by default.  ","version":"Next","tagName":"h3"},{"title":"Rust tests​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#rust-tests","content":" Follow the Rust community standard.  For modules that are likely to be used by other developers, Rustdoc is a good choice to show examples about how to use a function. Especially when it's not obvious.  For native Rust code, prefer unit tests inside modules  /* module code */ #[cfg(test)] mod tests { use super::*; #[test] fn test_feature_x() { assert!(...); } }   Use tests/ for independent integration tests, and benches/ for benchmarks.  ","version":"Next","tagName":"h2"},{"title":"Python tests​","type":1,"pageTitle":"Writing Tests","url":"/docs/dev/process/writing_tests#python-tests","content":" run-tests.py supports not only .t tests, but also standard Python unit tests in .py files. See test-lock.py for an example.  Python functions can have doctests, run by run-tests.py test-doctest.py. See D822107 for an example. ","version":"Next","tagName":"h2"},{"title":"Submodule","type":0,"sectionRef":"#","url":"/docs/git/submodule","content":"","keywords":"","version":"Next"},{"title":"Concepts​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#concepts","content":" ","version":"Next","tagName":"h2"},{"title":"Git submodule​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#git-submodule","content":" A Git submodule has three basic properties: URL (where to fetch the submodule), path (where to write to), and commit hash (which commit to use).  The URL and path are specified in the check-in file .gitmodules. The commit hash is stored specially at the given path.  Depending on operations, a submodule might behave like a file or a repository.  ","version":"Next","tagName":"h3"},{"title":"Submodule as a single file​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#submodule-as-a-single-file","content":" When you run diff, cat, status or commands that directly or indirectly ask for the content of a submodule, the submodule behaves like a single file with the content Subproject commit HASH, it will not behave like a directory.  For example, status and diff only shows the commit hash change of submodules. They do not show individual file changes inside the submodules.sl cat treats file paths inside submodules as non existent.  When you run commit, a submodule is also treated as a single file with just its commit hash. commit will not recursively make commits in submodules. Same for amend.  ","version":"Next","tagName":"h3"},{"title":"Submodule as a repository​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#submodule-as-a-repository","content":" When you run goto, revert or commands that ask Sapling to change the working copy to match the content of a submodule, Sapling will pull the submodule on demand, create the submodule repository on demand, and ask the submodule repository to checkout the specified commit.  When you use cd to enter a submodule, the submodule works like a standalone repository.  ","version":"Next","tagName":"h3"},{"title":"Common operations​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#common-operations","content":" ","version":"Next","tagName":"h2"},{"title":"Clone a repository with submodules​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#clone-a-repository-with-submodules","content":" Sapling clones submodules recursively 1; there is no need to use flags like--recurse, or use additional commands to initialize the submodules.  ","version":"Next","tagName":"h3"},{"title":"Use a different commit in a submodule​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#use-a-different-commit-in-a-submodule","content":" Imagine you have a submodule at third_party/fmt. The submodule is currently at commit a337011, and you want to use commit 1f575fd instead. You can make such change by running sl goto in the submodule:  $ cd third_party/fmt $ sl goto 1f575fd   Now the parent repo will notice the change. sl status will showthird_party/fmt as &quot;modified&quot;:  $ cd ../.. $ sl status M third_party/fmt   You can run sl diff to double check the commit hash change is froma337011 to 1f575fd:  $ sl diff diff --git a/third_party/fmt b/third_party/fmt --- a/third_party/fmt +++ b/third_party/fmt @@ -1,1 +1,1 @@ -Subproject commit a33701196adfad74917046096bf5a2aa0ab0bb50 +Subproject commit 1f575fd5c90278bcf723f72737f0f63c1951bea3   If you need to abandon changes in a submodule, use revert:  $ sl revert third_party/fmt   Finally, remember to commit the submodule change:  $ sl commit -m &quot;Update third_party/fmt to 1f575fd&quot;   Note commit only makes a single commit in the parent repo. It does not recursively make commits in submodules. This is because the parent repo only tracks the commit hashes of submodules and does not directly care about changed files in submodules.  ","version":"Next","tagName":"h3"},{"title":"Show changed files in a submodule​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#show-changed-files-in-a-submodule","content":" You can use sl status within a submodule to list changed files in that submodule:  $ cd third_party/fmt $ sl status   Running sl status from the parent repo will not list changed files in submodule. Although changed files are not shown, changed commits are always shown. You might want to always sl commit changes in submodules so submodule changes can be detected from the parent repo when usingsl status or sl diff.  If you do need to list changed files in all submodules, you might want to use a shell script like:  for i in `grep 'path =' .gitmodules | sed 's/.*=//'`; do sl status --pager=off --cwd $i; done   In the future we might add a convenient way to run status recursively in submodules.  ","version":"Next","tagName":"h3"},{"title":"Pull submodule changes​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#pull-submodule-changes","content":" When you run sl goto from the parent repo, Sapling will pull required submodule repos on demand in order to complete the goto operation.  Right now, Sapling might only pull the commit needed and will not pull branches like main or master. If you want to pull branches explicitly, you can pull it within the submodule:  $ cd path/to/submodule $ sl pull -B main   If you run sl pull from the parent repo, Sapling does not pull submodule repos recursively.  ","version":"Next","tagName":"h3"},{"title":"Push submodule changes​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#push-submodule-changes","content":" You can push submodule changes to the remote server by running sl push within the submodule:  $ cd path/to/submodule $ sl push --to main   If you run sl push from the parent repo, Sapling does not push submodule repos recursively.  ","version":"Next","tagName":"h3"},{"title":"Add, remove, or rename a submodule​","type":1,"pageTitle":"Submodule","url":"/docs/git/submodule#add-remove-or-rename-a-submodule","content":" Right now, these are not supported. In the future we might make sl clonedetect the submodule use-case, and write the repo data to the right location, and update sl add, sl mv, sl rm to update .gitmodules automatically.    Footnotes​ Submodules are not cloned like regular repos where there is usually aremote/main branch after clone. This is because Sapling attempts to pull by the commit hash to complete the working copy update. To obtainremote/main in a submodule, you can run sl pull -B main. ↩ ","version":"Next","tagName":"h3"},{"title":"Signing Commits","type":0,"sectionRef":"#","url":"/docs/git/signing","content":"","keywords":"","version":"Next"},{"title":"Limitations​","type":1,"pageTitle":"Signing Commits","url":"/docs/git/signing#limitations","content":" Support for signing commits is relatively new in Sapling, so we only support a subset of Git's functionality, for now. Specifically:  There is no -S option for sl commit or other commands, as signing is expected to be set for the repository. To disable signing for an individual action, leveraging the --config flag like so should work, but has not been heavily tested:  sl --config gpg.enabled=false &lt;command&gt; &lt;args&gt;   While Git supports multiple signing schemes (GPG, SSH, or X.509), Sapling supports only GPG at this time.  ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Signing Commits","url":"/docs/git/signing#troubleshooting","content":" The Git documentation on GPG is a bit light on detail when it comes to ensuring you have GPG configured correctly.  First, make sure that gpg is available on your $PATH and that gpg --list-secret-keys --keyid-format LONG lists the keys you expect. Note that you will have to run gpg --gen-key to create a key that matches your Sapling identity if you do not have one available already.  A basic test to ensure that gpg is setup correctly is to use it to sign a piece of test data:  echo &quot;test&quot; | gpg --clearsign   If you see error: gpg failed to sign the data, try this StackOverflow article:  https://stackoverflow.com/questions/39494631/gpg-failed-to-sign-the-data-fatal-failed-to-write-commit-object-git-2-10-0  If you see gpg: signing failed: Inappropriate ioctl for device, try:  export GPG_TTY=$(tty)  ","version":"Next","tagName":"h2"},{"title":"Debugging Sapling SCM","type":0,"sectionRef":"#","url":"/docs/introduction/debugging","content":"","keywords":"","version":"Next"},{"title":"Logging​","type":1,"pageTitle":"Debugging Sapling SCM","url":"/docs/introduction/debugging#logging","content":" Set the ui.debug setting to true to get debug logging of the Python interface surface:  sl config --user ui.debug true   The tracing-based logging can be configured with the EDENSCM_LOGenvironment variable. It follows theformat of tracing-subscriber.  Some examples include:  EDENSCM_LOG=debug to get debug logs for every component.EDENSCM_LOG=warn,configparser=debug to log configparser at debug level, and everything else at the warning level.  ","version":"Next","tagName":"h2"},{"title":"Editing Python code​","type":1,"pageTitle":"Debugging Sapling SCM","url":"/docs/introduction/debugging#editing-python-code","content":" Sapling uses a background service, which can sometimes get in the way of hacking on Python code. You can run with CHGDISABLE=1 to stop this.  ","version":"Next","tagName":"h2"},{"title":"Editing Rust code​","type":1,"pageTitle":"Debugging Sapling SCM","url":"/docs/introduction/debugging#editing-rust-code","content":" The Rust components are normally built in release mode, but you can switch to building in debug mode with RUST_DEBUG=1, which will build faster:  eden/scm$ make RUST_DEBUG=1 oss  ","version":"Next","tagName":"h2"},{"title":"Differences from Mercurial","type":0,"sectionRef":"#","url":"/docs/introduction/differences-hg","content":"Differences from Mercurial While Sapling began 10 years ago as a variant of Mercurial, it has evolved into its own source control system and has many incompatible differences with Mercurial. The list of differences below is not comprehensive, nor is it meant to be a competitive comparison of Mercurial and Sapling. It just highlights some interesting differences for curious people who are already familiar with Mercurial. Many of the differences from Git also apply to Mercurial and that list should be referred to as well. Sapling has substantial scaling, implementation, and format differences as well that are not covered here. Sapling has different default behavior and options for many commands.​ Sapling removes or changes the behavior of a number of Mercurial commands in order to make the behavior more consistent with modern expectations. For instance, in Sapling ‘sl log’ by default shows the history from your current commit. In Mercurial hg log shows the history of the entire repository at once. Features that are off by default in Mercurial, like rebase, are enabled by default in Sapling. Sapling has no “named branches”.​ In Mercurial, a user may create bookmarks or branches. In Sapling, there are only bookmarks. “Named Branches” in the Mercurial sense do not exist. Sapling has remote bookmarks.​ In Mercurial, there are only local bookmarks which are synchronized with the server during push and pull. In Sapling, there are local bookmarks which only ever exist locally, and there are remote bookmarks, such as remote/main, which are immutable local representations of the location of the server bookmark at the time of the last sl pull. Sapling allows hiding/unhiding commits.​ In Mercurial, to remove a commit you must either strip the commit entirely, or use an extension like “Evolve” to semi-permanently prune the commit. In Sapling, commits are never removed/stripped from your repository and can easily be hidden/unhidden at will. Sapling makes editing commits a first-class operation.​ The original Mercurial design avoided editing commits. While later extensions added some ability to edit commits (rebase, amend, strip, etc), it can still feel like a second-class feature. Sapling treats editing commits as a first-class concept and provides a variety of commands for manipulating commits and recovering from manipulation mistakes. Similarities to Mercurial Sapling supports the same revset and template features as Mercurial.​ Revsets and templates largely work the same as they do in Mercurial.","keywords":"","version":"Next"},{"title":"Differences from Git","type":0,"sectionRef":"#","url":"/docs/introduction/differences-git","content":"Differences from Git While Sapling is similar to Git in that it is distributed, uses hash-addressed commits, has branches (called bookmarks), and uses a clone/pull/push/commit/rebase model, there are a number of behavioral differences. The list of differences below is not comprehensive, nor is it meant to be a competitive comparison of Git and Sapling. Rather, it highlights some interesting differences for curious people who are already familiar with Git. Sapling has substantial scaling differences as well, which are not covered here. Sapling does not require or encourage using named local branches.​ In Git, your repository is defined by the location of your branches, and you pretty much must be on a local branch whenever you do work. In addition, any amend/rebase you do to one branch has no impact on any other branch. In Sapling, local bookmarks (the equivalent to a Git branch) are completely optional and generally not even used. You do have &quot;branches&quot; in the sense that you can make a stack of commits that fork off the main line of the commit graph, but there is no need to put a label on it. All of your commits are easily visible in your “smartlog” and can be accessed via its hash. Instead of deleting a branch to delete commits, you can “hide” and “unhide” commits. Not requiring bookmarks simplifies the mental model of the repo and has generally been well regarded by our users. Local bookmarks may still be used as a convenient label for commits, but note that rebasing a commit will move all local bookmarks along with the commit. Remote bookmarks are still required and are locally immutable, similar to origin/main in Git. Sapling has no staging area.​ In Git, you must add changes to the staging area before you commit them. This can be used to commit/amend just part of your changes. In Sapling, there is no staging area. If you want to commit/amend just part of your changes you can use commit/amend -i to interactively choose which changes to commit/amend. Alternatively, you can simulate a staging area by making a temporary commit and amending to it as if it was the staging area, then use fold to collapse it into the real commit. Sapling may not download all the repository data during clone/pull.​ In Git, a clone or pull will generally fetch all new repository data. In Sapling, a clone or pull will only fetch the main branches of a repo. Other branches will be fetched on demand. push only updates one remote branch. When used with a supported server, Sapling might fetch commit data (messages, date, or even hashes), tree and file data on demand. These avoid downloading unnecessary data, at the cost of requiring the user to be online more often. Sapling has first-class support for undo commands.​ In Git, to undo many operations requires a deeper understanding of the Git commit model and how git checkout/reset/reflog interact with that model. In Sapling, there are uncommit, unamend, unhide, and undo commands for undoing common operations. Additionally, undo -i allows you to go back across multiple operations and gives a visual preview of the post-undo state of the repository before you do it. Sapling does not use rebase -i for editing stacked commits.​ In Git, when working with a stack of commits, you are generally required to use git rebase -i to edit commits in the middle of the stack, which is a notably complex flow. In Sapling, when working with a stack of commits you can just checkout the commit you want to work on and run “amend”, “split”, “fold”, etc to modify the middle of the stack. The top of the stack is automatically kept track of and restacked for you so your stack remains together. Additionally, absorb allows automatically sucking pending changes down into the appropriate commit in your stack. histedit can be used to provide a rebase -i like experience if desired. Sapling generally does one thing per command.​ In Git, a command may do multiple seemingly unrelated things. checkout may be used to move to another commit, revert the contents of an individual file, and create a branch. reset may be used to move a branch and undo certain operations. rebase can be used to move commits or edit a stack. In Sapling, each command generally does one thing. pull fetches remote commits without merging. goto moves you to another commit. revert adjusts the contents of files in the working copy. bookmark create a bookmark. rebase moves commits, etc. Sapling allows pushing “onto” a bookmark (when used with a Sapling compatible server).​ In Git, pushing involves sending your commits to the server and updating the server branches to point at the new commits. In Sapling, when used with a Sapling compatible server, a push sends your commits to the server then the server rebases your commit onto the target bookmark (as long as the rebase would not require merging file changes) and moves the target bookmark forward. This allows many pushes to succeed at once, without requiring people to pull-then-rebase-then-push again to win a push race. Sapling supports “sparse profiles” for sharing sparse configuration (when not using the Sapling virtual filesystem).​ In Git, users are responsible for manually managing their own sparse configuration. In Sapling, sparse configuration can be checked into the repo as a &quot;sparse profile&quot; file which lists all the paths to include/exclude. This allows all users on a team or in an org to use the same sparse profile. As dependencies change, the shared profile can be updated so that everyone always has the correct files without every engineer having to update their setup. Sapling tracks the history of a commit as it’s changed over time.​ In Git, if you amend or rebase a file, there is no record that the new version of the commit came from the old version. In Sapling, when you modify a commit via operations such as amend, rebase, fold, or split, the record of the operation is kept which allows you to view the mutation history of that commit. This history is used to automate certain rebases for you: for instance, if you have a stack of five commits and the first commit gets rebased and pushed to main by your CI system, Sapling will know that your local commit #1 became commit X in main and can automatically rebase commits 2-5 onto the new main version. The record of the mutations becomes particularly powerful when working across multiple machines or with multiple people on a stack, as it allows the stack to stay together even as different people/machines edit different parts of it.","keywords":"","version":"Next"},{"title":"Git cheat sheet","type":0,"sectionRef":"#","url":"/docs/introduction/git-cheat-sheet","content":"","keywords":"","version":"Next"},{"title":"Cloning, pulling, and pushing​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#cloning-pulling-and-pushing","content":" \tGit\tSaplingClone\tgit clone http://github.com/foo my_repo\tsl clone http://github.com/foo my_repo Pull\tgit fetch\tsl pull Pull a branch\tgit fetch origin REFSPEC\tsl pull -B BRANCH Pull and rebase\tgit pull --rebase\tsl pull --rebase Push to a branch\tgit push HEAD:BRANCH\tsl push --to BRANCH Add a remote\tgit remote add REMOTE URL\tsl path --add REMOTE URL Pull from a remote\tgit fetch REMOTE\tsl pull REMOTE  Sapling only clones and pulls a subset of remote branches.  ","version":"Next","tagName":"h3"},{"title":"Understanding the repository​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#understanding-the-repository","content":" \tGit\tSaplingYour commits\tN/A\tsl Current history\tgit log\tsl log Edited files\tgit status\tsl status Current hash\tgit rev-parse HEAD\tsl whereami Pending changes\tgit diff\tsl diff Current commit\tgit show\tsl show  ","version":"Next","tagName":"h3"},{"title":"Referring to commits​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#referring-to-commits","content":" \tGit\tSaplingCurrent commit\tHEAD\t. Parent commit\tHEAD^\t.^ All local commits\tN/A\tdraft() Commits in branch X but not Y\tY..X\tX % Y  See sl help revset for more ways of referencing commits.  ","version":"Next","tagName":"h3"},{"title":"Working with files​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#working-with-files","content":" \tGit\tSaplingAdd new file\tgit add FILE\tsl add FILE Un-add new File\tgit rm --cached FILE\tsl forget FILE Remove file\tgit rm FILE\tsl rm FILE Rename file\tgit mv OLD NEW\tsl mv OLD NEW Copy file\tcp OLD NEW\tsl cp OLD NEW Add/remove all files\tgit add -A .\tsl addremove Undo changes\tgit checkout -- FILE\tsl revert FILE Undo all changes\tgit reset --hard\tsl revert --all Delete untracked files\tgit clean -f\tsl clean Output file content\tgit cat-file -p COMMIT:FILE\tsl cat -r COMMIT FILE Show blame\tgit blame FILE\tsl blame FILE  ","version":"Next","tagName":"h3"},{"title":"Working with commits​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#working-with-commits","content":" \tGit\tSaplingCommit changes\tgit commit -a\tsl commit Modify commit\tgit commit -a --amend\tsl amend Move to commit\tgit checkout COMMIT\tsl goto COMMIT Remove current commit\tgit reset --hard HEAD^\tsl hide . Edit message\tgit commit --amend\tsl metaedit Rebase commits\tgit rebase main\tsl rebase -d main Complex rebase\tgit rebase --onto DEST BOTTOM^ TOP\tsl rebase -d DEST -r BOTTOM::TOP Rebase all\tN/A\tsl rebase -d main -r 'draft()' Interactive rebase\tgit rebase -i\tsl histedit Interactive commit\tgit add -p\tsl commit -i / sl amend -i Cherry-pick\tgit cherry-pick COMMIT\tsl graft COMMIT Stash changes\tgit stash\tsl shelve Unstash changes\tgit stash pop\tsl unshelve  ","version":"Next","tagName":"h3"},{"title":"Undo, redo, and reverting​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#undo-redo-and-reverting","content":" \tGit\tSaplingUndo commit\tgit reset --soft HEAD^\tsl uncommit Undo partial commit\tgit reset --soft HEAD^ FILE\tsl uncommit FILE Undo amend\tgit reset HEAD@{1}\tsl unamend Undo rebase/etc\tgit reset --hard HEAD@{1}\tsl undo Revert already landed commit\tgit revert COMMIT\tsl backout COMMIT View recent commits\tgit reflog\tsl journal Recover commit\tgit reset COMMIT\tsl unhide COMMIT  ","version":"Next","tagName":"h3"},{"title":"Working with stacks​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#working-with-stacks","content":" \tGit\tSaplingModify middle commit\tgit rebase -i\tsl goto COMMIT &amp;&amp; sl amend Move up/down the stack\tgit rebase -i\tsl prev / sl next Squash last two commits\tgit reset --soft HEAD^ &amp;&amp; git commit --amend\tsl fold --from .^ Split a commit into two\tN/A\tsl split Reorder commits\tgit rebase -i\tsl histedit Amend down into stack\tN/A\tsl absorb  ","version":"Next","tagName":"h3"},{"title":"Giving commits names​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#giving-commits-names","content":" \tGit\tSaplingListing branches\tgit branch\tsl bookmark Create branch/bookmark\tgit branch NAME\tsl book NAME Switch to branch\tgit checkout NAME\tsl goto NAME Delete a branch\tgit branch -d NAME\tsl book -d NAME (deletes just the bookmark name) / sl book -D NAME (deletes the bookmark name and hides the commits)  ","version":"Next","tagName":"h3"},{"title":"Resolving conflicts​","type":1,"pageTitle":"Git cheat sheet","url":"/docs/introduction/git-cheat-sheet#resolving-conflicts","content":" \tGit\tSaplingList unresolved conflicts\tgit diff --name-only --diff-filter=U\tsl resolve --list Mark a file resolved\tgit add FILE\tsl resolve -m FILE ","version":"Next","tagName":"h3"},{"title":"Sapling SCM","type":0,"sectionRef":"#","url":"/docs/introduction/","content":"","keywords":"","version":"Next"},{"title":"Why make a new version control?​","type":1,"pageTitle":"Sapling SCM","url":"/docs/introduction/#why-make-a-new-version-control","content":" Sapling began 10 years ago as an effort to make Meta’s monorepo scale in the face of ever increasing engineering growth. Publicly available source control systems were not, and still are not, capable of handling repositories of this size. Instead of moving away from the monorepo and sacrificing engineering velocity, we decided to build the source control system we needed.  Along the way we realized there were also large opportunities to increase developer velocity by improving the source control experience. By investing in new UX, we’ve made it possible for even new engineers to understand their repository and do things that were previously only possible for power users.  Additionally, as we developed Sapling we ended up with internal abstractions that happened to make it straightforward for us to add Git support. This idea that the UX and scale of your version control could be separated from the repository format has allowed us to, in effect, have our cake and eat it too by letting us use our scalable system internally, and still interact with Git repositories where needed. We hope that this pattern might also provide an example path for how source control could evolve beyond the current industry wide status quo.  ","version":"Next","tagName":"h3"},{"title":"Basic concepts​","type":1,"pageTitle":"Sapling SCM","url":"/docs/introduction/#basic-concepts","content":" The easiest way to understand the basic usage of Sapling is to see it in action. Below we clone a repo, make some commits/amends, undo some changes, and push the work.  # Clones the repository into the sapling directory. # For git support, it uses git under the hood for clone/push/pull. $ sl clone --git https://github.com/facebook/sapling remote: Enumerating objects: 639488, done. ... $ cd sapling # 'sl' with no arguments prints the smartlog. # It shows the commit you are on (@) and all of your local commits # (none in this example since we just cloned). For each local commit it shows # the short hash, the commit date, who made it, any remote bookmarks, # and the commit title. With some configuration it can also show # information from inside the commit message, like task numbers or # pull request numbers. $ sl @ c448e50fe Today at 11:06 aaron remote/main │ Use cached values ~ # Checkout a commit in main that I want to debug. # The dashed line in smartlog indicates we're not showing some commits # between main and my checked out commit. $ sl goto a555d064c $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ @ a555d064c Today at 09:06 jordan │ workingcopy: Give Rust status exclusive ownership of TreeState ~ $ vim broken_file.rs $ vim new_file.txt # 'sl status' shows which files have pending changes. 'sl st' also works. # 'M' indicates the file is modified. '?' indicates it is present but not tracked. $ sl status M broken_file.rs ? new_file.txt # 'sl add' marks the untracked file as new and tracked. # It will now show up as 'A' in status. $ sl add new_file.txt $ sl commit -m &quot;Fix bug&quot; $ vim broken_file.rs $ sl commit -m &quot;Add test&quot; $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ @ 13811857c 1 second ago mary ╷ │ Add test ╷ │ ╷ o 95e6c6b86 10 seconds ago mary ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # Go to the previous commit. $ sl prev $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ o 13811857c 21 seconds ago mary ╷ │ Add test ╷ │ ╷ @ 95e6c6b86 30 seconds ago mary ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # Amend the first commit $ vim build.sh $ sl amend 95e6c6b863b7 -&gt; 35740664b28a &quot;Fix bug&quot; automatically restacking children! rebasing 13811857cc1e &quot;Add test&quot; 13811857cc1e -&gt; d9368dec77e1 &quot;Add test&quot; # Note how the stack remained together, despite editing the first commit. $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ o d9368dec7 81 seconds ago mary ╷ │ Add test ╷ │ ╷ @ 35740664b 17 seconds ago mary ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # You can optionally create a local bookmark if you want. $ sl bookmark my_task $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ o d9368dec7 107 seconds ago mary ╷ │ Add test ╷ │ ╷ @ 35740664b 43 seconds ago mary my_task* ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # Abandon the second commit. $ sl hide -r d9368dec7 $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ @ 35740664b 68 seconds ago mary my_task* ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # Let's bring back the original version of the first commit. # Note how smartlog marks the original commit as obsolete ('x') # and explains how 95e6c6b86 was amended to become 35740664b. $ sl unhide -r 95e6c6b86 $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ @ 35740664b 110 seconds ago mary my_task* ╭─╯ Fix bug │ │ x 95e6c6b86 [Amended as 35740664b28a] 3 minutes ago mary ├─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ # Rollback the amend we did earlier. $ sl unamend $ sl o c448e50fe Today at 11:06 remote/main ╷ ╷ @ 95e6c6b86 4 minutes ago mary my_task* ╭─╯ Fix bug │ o a555d064c Today at 09:06 │ ~ $ sl status M build.sh $ sl revert --all # Push the commit to the remote main branch. # Note, when pushing to Git you would have to rebase onto main # first via 'sl rebase --dest main'. When pushing to a Sapling server, # the server would perform the rebase for you, as shown here. $ sl push --to main $ sl @ e97a27666 1 minute ago mary remote/main │ Fix bug ~   ","version":"Next","tagName":"h3"},{"title":"Caveats​","type":1,"pageTitle":"Sapling SCM","url":"/docs/introduction/#caveats","content":" Some noteworthy caveats about Sapling:  Some of the design decisions are geared towards corporate, always-online, single-master, rebase-instead-of-merge, monorepo environments. While Sapling is flexible enough to work outside of these constraints, it is most polished and battle tested in that kind of environment.Git support may have some remaining kinks to be worked out.  ","version":"Next","tagName":"h3"},{"title":"","type":1,"pageTitle":"Sapling SCM","url":"/docs/introduction/##","content":"","version":"Next","tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/introduction/installation","content":"","keywords":"","version":"Next"},{"title":"Prebuilt binaries​","type":1,"pageTitle":"Installation","url":"/docs/introduction/installation#prebuilt-binaries","content":" ","version":"Next","tagName":"h2"},{"title":"macOS​","type":1,"pageTitle":"Installation","url":"/docs/introduction/installation#macos","content":" First, make sure that Homebrew is installed on your system. Then either install directly from Homebrew-core or install the bottle released by us:  Installing from Homebrew-core​  Just run:  brew install sapling   Installing from our prebuilt bottles​  Follow the instructions depending on your architecture.  Apple silicon (arm64)​  Download using curl:  curl -L -o sapling_0.2.20250521-115337+25ed6ac4.arm64_ventura.bottle.tar.gz https://github.com/facebook/sapling/releases/download/0.2.20250521-115337%2B25ed6ac4/sapling_0.2.20250521-115337%2B25ed6ac4.arm64_ventura.bottle.tar.gz  Then install:  brew install ./sapling_0.2.20250521-115337+25ed6ac4.arm64_ventura.bottle.tar.gz  caution Downloading the bottle using a web browser instead of curl will cause macOS to tag Sapling as &quot;untrusted&quot; and the security manager will prevent you from running it. You can remove this annotation as follows: xattr -r -d com.apple.quarantine ~/Downloads/sapling_0.2.20250521-115337+25ed6ac4.arm64_ventura.bottle.tar.gz  Note that to clone larger repositories, you need to change the open files limit. We recommend doing it now so it doesn't bite you in the future:  echo &quot;ulimit -n 1048576&quot; &gt;&gt; ~/.bash_profile{'\\n'} echo &quot;ulimit -n 1048576&quot; &gt;&gt; ~/.zshrc   ","version":"Next","tagName":"h3"},{"title":"Windows​","type":1,"pageTitle":"Installation","url":"/docs/introduction/installation#windows","content":" After downloading the sapling_windows ZIP from the latest release, run the following in PowerShell as Administrator (substituting the name of the .zip file you downloaded, as appropriate):  Expand-Archive ~/Downloads/sapling_windows_0.2.20250521-115337+25ed6ac4_amd64.zip 'C:\\Program Files'   This will create C:\\Program Files\\Sapling, which you likely want to add to your %PATH% environment variable using:  setx PATH &quot;$env:PATH;C:\\Program Files\\Sapling&quot; -m   Note the following tools must be installed to leverage Sapling's full feature set:  Git for Windows is required to use Sapling with Git repositoriesNode.js (v16 or later) is required to use sl web  Note that the name of the Sapling CLI sl.exe conflicts with the sl shell built-in in PowerShell (sl is an alias for Set-Location, which is equivalent to cd). If you want to use sl to run sl.exe in PowerShell, you must reassign the alias. Again, you must run the following as Administrator:  Set-Alias -Name sl -Value 'C:\\Program Files\\Sapling\\sl.exe' -Force -Option Constant,ReadOnly,AllScope sl --version Sapling 0.2.20250521-115337+25ed6ac4  ","version":"Next","tagName":"h3"},{"title":"Linux​","type":1,"pageTitle":"Installation","url":"/docs/introduction/installation#linux","content":" Ubuntu 22.04​  Download using curl:  curl -L -o sapling_0.2.20250521-115337+25ed6ac4_amd64.Ubuntu22.04.deb https://github.com/facebook/sapling/releases/download/0.2.20250521-115337%2B25ed6ac4/sapling_0.2.20250521-115337%2B25ed6ac4_amd64.Ubuntu22.04.deb  Then install:  sudo apt install -y ./sapling_0.2.20250521-115337+25ed6ac4_amd64.Ubuntu22.04.deb  Arch Linux (AUR)​  yay -S sapling-scm-bin   Other Linux distros​  Sapling can be installed from Homebrew on Linux. First install Homebrew on your machine, then run  brew install sapling   ","version":"Next","tagName":"h3"},{"title":"Building from source​","type":1,"pageTitle":"Installation","url":"/docs/introduction/installation#building-from-source","content":" In order to build from source, you need at least the following tools available in your environment:  Makeg++RustNode.jsYarn  For the full list, find the appropriate Dockerfile for your platform that defines the image that is used for Sapling builds in automation to see which tools it installs. For example, .github/workflows/sapling-cli-ubuntu-22.04.Dockerfile reveals all of the packages you need to install via apt-get in the host environment in order to build Sapling from source.  Once you have your environment set up, you can do a build on macOS or Linux as follows:  git clone https://github.com/facebook/sapling cd sapling/eden/scm make oss ./sl --help   To build on FreeBSD, you'll also need to setup a terminfo database and use GNU Make for the build:  pkg install gmake terminfo-db export TERMINFO=/usr/local/share/terminfo git clone https://github.com/facebook/sapling cd sapling/eden/scm gmake oss ./sl --help   The Windows build has some additional dependencies and a separate build script. From the GitHub Action used to build the Windows release, perform the steps that use vcpkg on your local machine to install the additional dependencies. Then you can build and run Sapling on Windows as follows:  git clone https://github.com/facebook/sapling cd sapling/eden/scm git config --system core.longpaths true python3 .\\packaging\\windows\\build_windows_zip.py .\\build\\embedded\\sl.exe --help   Once you have Sapling installed, follow the Getting Started instructions. ","version":"Next","tagName":"h2"},{"title":"Release notes","type":0,"sectionRef":"#","url":"/docs/introduction/release-notes","content":"","keywords":"","version":"Next"},{"title":"Feb 28, 2023​","type":1,"pageTitle":"Release notes","url":"/docs/introduction/release-notes#feb-28-2023","content":" This release mainly brings better file move detection as well as various improvements to the sl pr submit command  Added file moves detection for sl diff.@discentem added a config option to disable the ReviewStack message in PRs created by sl pr submit (#427). The ReviewStack message is auto disabled for single-commit stack.Fixed &quot;mark landed PRs&quot; hook to work when sl not in PATH (71d6e67)Fixed sl pr submit to not try to update closed PRs (5a354f7)Fixed sl pr submit to use &quot;overlapping&quot; PR strategy by default (a050359)Fix sl pr submit crash using non-placeholder issue approach (18a1987)@vegerot added and improved shell completion and prompt (#369 #349 #348).@vegerot added support for sl init --git on a non-empty directory.Fixed not being able to launch sl web just after building with make oss.  ","version":"Next","tagName":"h2"},{"title":"Jan 24, 2023​","type":1,"pageTitle":"Release notes","url":"/docs/introduction/release-notes#jan-24-2023","content":" This release focuses on bug fixes and improvements around the pr and ghstack commands.  Fixed an issue where sl pr list did not work correctly in combination with chg (a1187e8).@discentem (BK) Updated sl pr pull to throw an appropriate error if no args were specified (#357).Reverted the behavior introduced in the previous release that introduced the practice of using placeholder issues when creating GitHub pull requests. While this approach made it possible to create pull requests in parallel and had desirable guarantees with respect to PR numbers and branch names, it turned out to have a number of downsides that outweighed the benefits, as explained in 7ce516d .@discentem (BK) Fixed a bug where sl clone silently failed for some repositories (#375) with (#386).Added a PR revset (4720a2e). Now commands such as sl goto pr123 , sl log -r PR456 should work, even without having to manually download some pull request. Using sl pr pull is still necessary, however, if one wants to get the most recent version of some PR.Fix sl ghstack land to properly rebase, avoiding spurious &quot;non-fast forward&quot; push errors (ebbe7d8), resolving #333 .  ","version":"Next","tagName":"h2"},{"title":"Dec 22, 2022​","type":1,"pageTitle":"Release notes","url":"/docs/introduction/release-notes#dec-22-2022","content":" This release focuses on correct issues around handling submodules as well as various usability/workflow improvements.  We made a number of improvements to working in repos with submodules: Rebasing past an update to a submodule no longer adds the submodule change to the bottom of the stack that was rebased: 2f0f0fdRebasing a stack that contains a submodule change will preserve the change in the destination if the destination does not change the submodules: 1f5424dRebasing a stack with a conflicting submodule change no longer crashes: 2b94b6f Improvements to the sl pr command: You must now specify sl pr submit explicitly: submit is no longer the default subcommand for sl pr, but s can be used as an alias for submit: 56b5e3eThe sl pr submit command now supports a --draft flag: 6e9c3d7New sl pr pull subcommand: if you use sl pr submit to create a stack of pull requests, now you can use sl pr pull to import the stack back into your working copy: d09d598New sl pr list subcommand that mirrors the functionality of gh pr list: 8f0a657Experimental new command for creating stacks: sl -c github.pr_workflow=single pr submit. See #302 and 166e264 for details.sl pr submit now appends the stack information to the end of the pull request body instead of prepending it to the top: 8910d18The branch name for a PR created by sl pr submit is now guaranteed to match the PR number: e77e67b Improvements to commands involving remote names and bookmarks: SCP-style URIs (such as git@github.com:git/git-reference) are now supported for remote names: 67fa848sl clone --git &lt;URL&gt; --updaterev &lt;branch/commit&gt; can now be used to clone a specific branch or commit: 9804c66sl rebase -b was reworked for better selecting branching points by avoiding public commits (reverse rebase now works): 96b767esl bookmark --remote can be used to list remote branches. Further, sl bookmark --remote-path my-fork --remote tags will list tags from remote myfork:e8f57d7 Removed a dependency on gdbm in the Python code, that was causing crashes for some users: cfbb6a2 ","version":"Next","tagName":"h2"},{"title":"Bookmarks","type":0,"sectionRef":"#","url":"/docs/overview/bookmarks","content":"","keywords":"","version":"Next"},{"title":"Differences from Git branches​","type":1,"pageTitle":"Bookmarks","url":"/docs/overview/bookmarks#differences-from-git-branches","content":" In Git you must always be working on a local branch, otherwise you end up in the confusing &quot;detached head&quot; state and any commits you make may be hard to find later or may be garbage collected. In Sapling, you do not need a bookmark when creating a new commit, and commits are visible in smartlog regardless of whether they have a bookmark or not.In Git, deleting a branch makes it difficult to find the commits that were on that branch. In Sapling, deleting a local bookmark doesn’t hide commits, and bookmarks are safe and easy to add and delete.In Git, rebasing or amending a branch will only affect that branch. If multiple branches were pointing at the same commit, the other branches will be left behind, still pointing at the old commit. In Sapling, when you rebase or amend, every bookmark on a commit will be moved to the new version of the commit. ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/overview/intro","content":"Introduction This overview highlights a few of the interesting areas of Sapling's user experience. It is by no means exhaustive (quite the opposite, really), nor is it meant to be a complete how-to guide for using Sapling. Rather, it is aimed at people who are already familiar with using distributed version control systems such as Git and are curious about how Sapling handles common workflows and how it might differ from what you are used to. Topics will be added as areas of interest are brought to our attention.","keywords":"","version":"Next"},{"title":"Getting started","type":0,"sectionRef":"#","url":"/docs/introduction/getting-started","content":"","keywords":"","version":"Next"},{"title":"Setting your identity​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#setting-your-identity","content":" Once you have sl installed on the command line, you should start out by configuring the identity you wish to use when authoring commits:  sl config --user ui.username &quot;Alyssa P. Hacker &lt;alyssa@example.com&gt;&quot;   If you do not already have a global Sapling config file, the command above will create it for you. The location of the file varies by platform, though you can run sl configfile --user to find it.  Linux ~/.config/sapling/sapling.conf (or $XDG_CONFIG_HOME instead of ~/.config, if set)macOS ~/Library/Preferences/sapling/sapling.confWindows %APPDATA%\\sapling\\sapling.conf  ","version":"Next","tagName":"h2"},{"title":"Authenticating with GitHub​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#authenticating-with-github","content":" Sapling has a number of custom integrations with GitHub pull requests. In order to communicate with GitHub, Sapling needs a personal access token to talk to the GitHub API. Rather than have Sapling manage your token, we recommend installing the GitHub CLI (gh) and using it to authenticate with GitHub as follows:  gh auth login --git-protocol https   Note that the GitHub CLI is also GitHub's recommended solution for caching your GitHub credentials in Git so that you don't have to enter a password or token every time you sl push.  ","version":"Next","tagName":"h2"},{"title":"Cloning your first repo​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#cloning-your-first-repo","content":" Assuming you authenticated with gh using --git-protocol https, make sure to be consistent and use the HTTPS URL (as opposed to the SSH URI) for your GitHub repo as an argument to sl clone:  $ sl clone https://github.com/facebook/sapling $ cd sapling $ sl @ fafe18a24 23 minutes ago ricglz remote/main │ migrate packer to new CLI framework ~   From inside a repo, running sl with no arguments shows you your commit graph. Initially, this will contain only the head of the default branch, main.  ","version":"Next","tagName":"h2"},{"title":"Creating your first commit​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#creating-your-first-commit","content":" Sapling provides familiar add and commit/ci commands to create a commit:  $ touch hello.txt $ sl add . $ echo 'Hello, World!' &gt; hello.txt $ sl commit -m 'my first commit with Sapling' $ sl @ 5a7b44286 25 seconds ago alyssa ╭─╯ my first commit with Sapling │ o fafe18a24 27 minutes ago remote/main │ ~   Note that unlike Git, there was no need to explicitly declare a new branch before creating a commit. Sapling tracks heads automatically, which are readily visible when you run sl.  Another important difference from Git is that there is no index where changes must be staged for commit. If you had run the above commands using git instead of sl, the Git commit would contain an empty hello.txt file with the non-empty version of the file waiting to be staged.  ","version":"Next","tagName":"h2"},{"title":"Creating your first stack​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#creating-your-first-stack","content":" For illustration purposes, we'll go ahead and create a few more commits:  $ echo foo &gt; foo.txt ; sl add foo.txt ; sl ci -m 'adding foo' $ echo bar &gt; bar.txt ; sl add bar.txt ; sl ci -m 'adding bar' $ echo baz &gt; baz.txt ; sl add baz.txt ; sl ci -m 'adding baz' $ sl @ 4d9180fd8 1 second ago alyssa │ adding baz │ o 3cc43c835 7 seconds ago alyssa │ adding bar │ o 4f1243a8b 11 seconds ago alyssa ╭─╯ adding foo │ o f22585511 Oct 06 at 17:40 remote/main │ ~   After creating your stack, sl uses @ to indicate that you are at the top of the stack of commits you just created. The go command supports a number of special aliases, such as sl go top and sl go bottom to navigate to the top and bottom of your stack, respectively.  You can also use the next and prev commands to move up and down the stack. Both of these commands take an optional number of &quot;steps&quot; to take, e.g., sl next 2 will move two commits up the stack.  ","version":"Next","tagName":"h2"},{"title":"Manipulating your stack​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#manipulating-your-stack","content":" See Basic Commands to learn more about manipulating your stack from the command line.  You may also want to try Sapling's built-in GUI that runs in the browser . Run sl web to launch it from the command line:  $ sl web Listening on http://localhost:3011/?token=929fa2b3d75aa4330e0b7b0a10822ee0&amp;cwd=%2FUsers%2Falyssa%2Fsrc%2Fsapling Server logs will be written to /var/folders/5c/f3nk25tn7gd7nds59hy_nj7r0000gn/T/isl-server-logKktwaj/isl-server.log   Sapling will open the URL automatically in your browser. See the docs on Interactive Smartlog to learn more about its many features. Interactive Smartlog is also available in our VS Code Extension.  ","version":"Next","tagName":"h2"},{"title":"Submitting pull requests​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#submitting-pull-requests","content":" Sapling supports multiple workflows for interacting with GitHub pull requests. The simplest solution is the sl pr command:  $ sl pr submit ... $ sl @ 4d9180fd8 6 minutes ago alyssa #178 │ adding baz │ o 3cc43c835 6 minutes ago alyssa #177 │ adding bar │ o 4f1243a8b 6 minutes ago alyssa #176 ╭─╯ adding foo │ o f22585511 Oct 06 at 17:40 remote/main │ ~ $ sl pr submit #178 is up-to-date #177 is up-to-date #176 is up-to-date no pull requests to update   As shown, running sl pr submit creates a pull request (PR) for every commit in your local stack. Note this creates &quot;overlapping pull requests,&quot; which means each PR uses the associated commit as the head of the PR and remote/main as the base. Reviewing overlapping pull requests on GitHub can be confusing, so we also provide ReviewStack as an alternative code review tool that handles these kinds of pull requests better.  After you have created an initial series of pull requests using pr, you will likely make local changes to your commits that need to be submitted for review. To publish these local changes to GitHub, simply run pr again to update your existing PRs. Note if you have introduced new commits in your stack that are not linked to a PR, pr will create pull requests for those, as well.  The &quot;overlapping pull requests&quot; approach may not be an appropriate solution for your project. To that end, we also support an alternative pull request workflow, ghstack, which avoids the &quot;overlapping pull requests&quot; issue, but may not be an option for all projects. See the Pull Requests section in Using Sapling with GitHub to determine which workflow is right for you.  ","version":"Next","tagName":"h2"},{"title":"Browsing pull requests​","type":1,"pageTitle":"Getting started","url":"/docs/introduction/getting-started#browsing-pull-requests","content":" If you have used Sapling to create pull requests for your commits, then you can use sl ssl to include the pull request status in your Smartlog. Note that sl ssl is not a subcommand, but a built-in alias for sl smartlog -T {ssl}:  $ sl ssl @ 4d9180fd8 6 minutes ago alyssa #178 Unreviewed │ adding baz │ o 3cc43c835 6 minutes ago alyssa #177 Approved │ adding bar │ o 4f1243a8b 6 minutes ago alyssa #176 Closed ╭─╯ adding foo │ o f22585511 Oct 06 at 17:40 remote/main │ ~   In addition to reviewing pull requests on github.com, you may also want to try ReviewStack, which is our novel user interface for GitHub pull requests with custom support for stacked changes.  To view a GitHub pull request on ReviewStack, take the original URL:  https://github.com/facebook/react/pull/25506   and replace the github.com domain with reviewstack.dev:  https://reviewstack.dev/facebook/react/pull/25506  On ReviewStack, the diff and the timeline for a pull request are displayed side-by-side rather than split across tabs. Read the ReviewStack docs to learn more about the various features it offers.    By default, pull requests in the Smartlog displayed by sl are linked to the corresponding page on github.com, but you can run the following to configure the Smartlog to link to reviewstack.dev instead:  sl config --user github.pull_request_domain reviewstack.dev  ","version":"Next","tagName":"h2"},{"title":"Navigation","type":0,"sectionRef":"#","url":"/docs/overview/navigation","content":"","keywords":"","version":"Next"},{"title":"Goto​","type":1,"pageTitle":"Navigation","url":"/docs/overview/navigation#goto","content":" sl goto COMMIT or sl go COMMIT is the standard way to checkout a commit in your repository.  # The '@' indicates your currently checked out commit. $ sl @ b84224608 13 minutes ago remote/main ╷ ╷ o 15de72785 35 seconds ago mary my_feature ╭─╯ Implement glorious features │ o a555d064c Wednesday at 09:06 │ ~ $ sl goto 15de72785 $ sl o b84224608 13 minutes ago remote/main ╷ ╷ @ 15de72785 35 seconds ago mary my_feature ╭─╯ Implement glorious features │ o a555d064c Wednesday at 09:06 │ ~   The argument passed to sl goto can be one of the following:  A full 40-character commit hash, such as b8422460814900d8f978a8a34a99ae83c6735a70.A short, unique-prefix commit hash, such as b84224608.A local bookmark name, such as my_feature in the example above.A remote bookmark name, such as main in the example above. Note, the remote/ prefix is optional.A revset query (see below).  Auto-pull​  By default, Sapling only clones the main bookmark of a repository. Even if you don’t have the remote bookmark locally yet, you can do sl goto remote/other_bookmark and it will automatically pull and checkout the remote bookmark for you.  To trigger an auto-pull, you must specify the remote/ prefix.  ","version":"Next","tagName":"h3"},{"title":"Next/Prev​","type":1,"pageTitle":"Navigation","url":"/docs/overview/navigation#nextprev","content":" When working with a stack of commits, you can use sl next and sl prev to move up and down your stack with ease.  # The '@' indicates your currently checked out commit. $ sl o 5abffb82f Wednesday at 09:39 remote/main ╷ ╷ @ 824cbba75 13 minutes ago mary ╷ │ [eden] Support long paths in Windows FSCK ╷ │ ╷ o 19340c083 Wednesday at 09:39 mary ╷ │ [eden] Close Windows file handle during Windows Fsck ╷ │ ╷ o b52192598 Wednesday at 09:39 mary ╭─╯ [eden] Use PathMap for WindowsFsck │ o 2ac18611a Wednesday at 05:00 remote/stable ╷ ~ # Move down the stack from 824cbba75 to 19340c083. $ sl prev # Move back up the stack to 824cbba75. $ sl next # Move down the stack 2 commits to b52192598. $ sl prev 2   Note, if a commit has multiple children or parents, next and prev may alert you and you have to choose.  ","version":"Next","tagName":"h3"},{"title":"Top/Bottom​","type":1,"pageTitle":"Navigation","url":"/docs/overview/navigation#topbottom","content":" When in a stack, you can jump directly to the top or bottom using sl goto top and sl goto bottom.  # The '@' indicates your currently checked out commit. $ sl o 5abffb82f Wednesday at 09:39 remote/main ╷ ╷ @ 824cbba75 13 minutes ago mary ╷ │ [eden] Support long paths in Windows FSCK ╷ │ ╷ o 19340c083 Wednesday at 09:39 mary ╷ │ [eden] Close Windows file handle during Windows Fsck ╷ │ ╷ o b52192598 Wednesday at 09:39 mary ╭─╯ [eden] Use PathMap for WindowsFsck │ o 2ac18611a Wednesday at 05:00 remote/stable ╷ ~ # Move down to b52192598 at the bottom. $ sl goto bottom # Move back up to 824cbba75 at the top. $ sl goto top   ","version":"Next","tagName":"h3"},{"title":"Revsets​","type":1,"pageTitle":"Navigation","url":"/docs/overview/navigation#revsets","content":" sl goto REVSET can use the revset query language to specify a commit to go to. See the Revset documentation for more details.  Example revsets:  . Your current commit..^ Parent of your current commit.824cbba75~2 Second ancestor of 824cbba75.19340c083~-1 Child of 19340c083.ancestor(., main) The first common ancestor of your current commit and main (that is, 2ac18611a in the examples above).pr42 Pull request #42 on GitHub repos. ","version":"Next","tagName":"h3"},{"title":"Hide/Unhide","type":0,"sectionRef":"#","url":"/docs/overview/hide-unhide","content":"Hide/Unhide One of the classic difficulties of modern version control systems is figuring out how to undo your mistakes. While Sapling contains a variety of commands to help you undo mistakes, its foundational feature is that commits can be hidden and unhidden, and that doing so is safe, easy to understand, and easy to undo. While commits can be hidden manually, they can also become hidden when they are superseded by changes to the commit, whether by amends, rebases, or other operations. But the key concept is that they are still stored permanently in your repository, even after they are no longer visible in your smartlog output. If you ever want to bring back an old commit, it’s as easy as sl unhide. And with a robust sl undo command, you can quickly and easily get to a previous state. Being able to undo just about any command gives users the confidence to try new commands and learn from their mistakes. sl hide COMMIT and sl unhide COMMIT can be used to simply and safely hide and recover commits. $ sl @ b84224608 Yesterday at 16:04 john remote/main │ Updating submodules ~ $ sl unhide 15de72785 $ sl @ b84224608 Yesterday at 16:04 john remote/main ╷ Updating submodules ╷ ╷ o 15de72785 Yesterday at 16:16 mary ╭─╯ Implement glorious features │ o a555d064c Wednesday at 09:06 │ ~ # Note, a555d064c was not unhidden. Smartlog just chose to show it # so you can see how 15de72785 relates to the main bookmark. $ sl hide 15de72785 $ sl @ b84224608 Yesterday at 16:04 john remote/main │ Updating submodules ~ Notable features: You can only hide local commits (known as “draft” commits). You cannot hide commits on bookmarks that came from the server (known as “public” commits).If you hide a commit that has commits on top of it (that is, its descendants), all of the commits will be hidden. If you unhide a commit that has commits beneath it (that is, its ancestors), all of the commits will be unhidden.You can hide/unhide many commits at once using revsets (see sl help revset). For instance, sl hide &quot;draft()&quot; will hide all of your local commits.Many commands work even on hidden commits. For instance, sl show COMMIT will let you inspect a commit before unhiding it. You can even checkout a hidden commit to temporarily work with it.Hiding a commit will also remove any local bookmarks on that commit. There is currently no way to permanently delete a commit from your local repository other than by deleting your repo and recloning. How to find a hidden commit​ There are a variety of ways to find which hidden commit you want to unhide. sl smartlog --rev &quot;hidden()&quot; to view all hidden commits using the “hidden()” revset.sl log -r &quot;predecessors(COMMIT)&quot; to view the hidden previous versions of a certain commit (that is, the version from before a rebase, amend, etc).See Undo and Journal for more ways to view your past repository actions.","keywords":"","version":"Next"},{"title":"Pull / push","type":0,"sectionRef":"#","url":"/docs/overview/push-pull","content":"","keywords":"","version":"Next"},{"title":"Pull​","type":1,"pageTitle":"Pull / push","url":"/docs/overview/push-pull#pull","content":" The sl pull command is used to download new commits from the server. By default it only pulls remote bookmarks that you are subscribed to. To subscribe to more bookmarks use sl pull -B other_bookmark_name.  sl pull only downloads commits. It does not rebase or merge anything, unless you specify --rebase.  Note, this is different from git pull which generally pulls all branches and automatically tries to merge/rebase your changes with the new branches.  $ sl @ 9f73762dd 62 minutes ago mary │ Commit Two │ o 9d550d707 62 minutes ago mary ╭─╯ Commit One │ o b5d600552 65 minutes ago remote/main ╷ ~ # Fetch new commits from main $ sl pull # The current stack is now behind main $ sl o 08a7511cc 33 seconds ago remote/main ╷ ╷ @ 9f73762dd 63 minutes ago mary ╷ │ Commit Two ╷ │ ╷ o 9d550d707 63 minutes ago mary ╭─╯ Commit One │ o b5d600552 66 minutes ago ╷ ~ $ sl pull --rebase $ sl @ e75394bbb 9 seconds ago mary │ Commit Two │ o 4eefdfe1d 9 seconds ago mary ╭─╯ Commit One │ o 59125794a 20 seconds ago remote/main ╷ ~   ","version":"Next","tagName":"h3"},{"title":"Push​","type":1,"pageTitle":"Pull / push","url":"/docs/overview/push-pull#push","content":" Use the push command to push local commits to remote. Specify the --to to specify the remote branch/bookmark to push commits to. Specify -r to specify local commit you want pushed. If -r is omitted, the currently checked out commit is pushed.  # Push current commit stack to the remote main bookmark. $ sl push -r . --to main   During a normal git push or an sl push to a Git repository, the push simply sends the commits to the server and moves the branch or bookmark forward to the newly pushed commit.  When sl push is used with the Sapling server, sl push --to BOOKMARK pushes the commits to the server and the server additionally rebases them onto the destination bookmark. This allows organizations with high push rates to avoid races where someone is unable to push because someone else pushed first. This server side rebase is simplified, in that it does not do any file content merging. If someone else touched the same files you touched, your push will fail and you will need to pull, rebase, and push again.  Notable push options (some of these may not work when working with Git repos):  -r / --rev Specifies which commit to push. Ancestors of this commit will also be pushed. Note, only one head can be pushed at a time, so you can't push 2+ branches at once.--to Specifies the remote bookmark to push onto.--non-forward-move Indicates that the push will result in the remote bookmark moving backwards or sideways, instead of moving forward to a descendant. This is used when a bookmark is in the wrong location and needs to be forced elsewhere.--create Used to indicate the bookmark being pushed to is new and should be created.-d / --delete Allows deleting a remote bookmark. ","version":"Next","tagName":"h3"},{"title":"Rebase","type":0,"sectionRef":"#","url":"/docs/overview/rebase","content":"","keywords":"","version":"Next"},{"title":"Examples​","type":1,"pageTitle":"Rebase","url":"/docs/overview/rebase#examples","content":" To illustrate the different types of rebases, assume we start with the following commit graph. Note that we are currently on Commit C, as indicated by the @symbol.  $ sl o d78f66e01 106 seconds ago remote/main ╷ ╷ o 306ce5ffb 67 seconds ago mary ╷ │ Commit F ╷ │ ╷ o 2ff5f28a1 67 seconds ago mary ╷ │ Commit E ╷ │ ╷ │ o e5513dac4 67 seconds ago mary ╷ │ │ Commit D ╷ │ │ ╷ │ @ 6f782187a 67 seconds ago mary ╷ ├─╯ Commit C ╷ │ ╷ o 3beadc099 67 seconds ago mary ╷ │ Commit B ╷ │ ╷ o b48ce5c8e 67 seconds ago mary ╭─╯ Commit A │ o 17af69994 Today at 08:33 remote/stable ╷ ~   -b / --base​  The most common use for rebase is to move your in-progress commits onto a newer version of main. The -b flag is ideal for this situation, as it will take the entire subtree of your commits and move them onto the destination.  Below we use -b . to rebase the current commit, ., and its entire related subtree onto main. In this case, the subtree is Commit A and all of its descendants.  Note that sl rebase -b . -d XXX is the same as sl rebase -d XXX, as -b .is the default behavior.  # Move entire current subtree onto main. $ sl rebase -b . -d main o 91ecebda8 12 seconds ago mary │ Commit F │ o b26b55434 12 seconds ago mary │ Commit E │ │ o a9ef0ee2d 12 seconds ago mary │ │ Commit D │ │ │ @ 37d2d0296 12 seconds ago mary ├─╯ Commit C │ o 37d536158 12 seconds ago mary │ Commit B │ o 81910236f 12 seconds ago mary ╭─╯ Commit A │ o d78f66e01 15 minutes ago remote/main ╷ o 17af69994 Today at 08:33 remote/stable ╷ ~   -s / --source​  If you don't want to rebase the entire subtree with -b, you can use -s to rebase a given commit and all of its descendants.  Below we use -s . to rebase the current commit, ., and its descendantCommit D onto main. All other commits are left behind.  # Move current commit and its descendants onto main. $ sl rebase -s . -d main o aa40b4d44 44 seconds ago mary │ Commit D │ @ 95cf1e999 44 seconds ago mary ╭─╯ Commit C │ o d78f66e01 11 minutes ago remote/main ╷ ╷ o 306ce5ffb 11 minutes ago mary ╷ │ Commit F ╷ │ ╷ o 2ff5f28a1 11 minutes ago mary ╷ │ Commit E ╷ │ ╷ o 3beadc099 11 minutes ago mary ╷ │ Commit B ╷ │ ╷ o b48ce5c8e 11 minutes ago mary ╭─╯ Commit A │ o 17af69994 Today at 08:33 remote/stable ╷ ~   -r / --revisions​  If we only want to move a specific commit or commits, we use -r to move exactly the commits we specified.  Below we move the commit we're on by specifying . as the argument to -r. We move it onto main by specifying main as the argument to -d.  # Move just the current commit to be based on main $ sl rebase -r . -d main rebasing 6f782187aa42 &quot;Commit C&quot; 6f782187aa42 -&gt; 8abef7d37f3a &quot;Commit C&quot; $ sl @ 8abef7d37 6 seconds ago mary ╭─╯ Commit C │ o d78f66e01 4 minutes ago remote/main ╷ ╷ o 306ce5ffb 3 minutes ago mary ╷ │ Commit F ╷ │ ╷ o 2ff5f28a1 3 minutes ago mary ╷ │ Commit E ╷ │ ╷ │ o e5513dac4 3 minutes ago mary ╷ │ │ Commit D ╷ │ │ ╷ │ x 6f782187a [Rebased to 8abef7d37f3a] 3 minutes ago mary ╷ ├─╯ Commit C ╷ │ ╷ o 3beadc099 3 minutes ago mary ╷ │ Commit B ╷ │ ╷ o b48ce5c8e 3 minutes ago mary ╭─╯ Commit A │ o 17af69994 Today at 08:33 remote/stable ╷ ~   Note how 6f782187a is identified with an x in the commit graph to denote that it has been rewritten to the newer version 8abef7d37f3a. However, it is still visible because commit D did not get rebased.  Other​  The rebase command can move multiple stacks and subtrees in a single invocation. The tree structure will be retained across the rebase. For example, one can use the draft() revset to rebase all of your local commits onto a newer base commit.  $ sl o b5d600552 27 seconds ago remote/main ╷ ╷ o 9d5ba71bc 2 minutes ago mary ╷ │ Commit C ╷ │ ╷ │ o 37d536158 12 minutes ago mary ╷ ├─╯ Commit B ╷ │ ╷ o 81910236f 12 minutes ago mary ╭─╯ Commit A │ o d78f66e01 27 minutes ago ╷ ╷ @ ecf227650 69 seconds ago mary ╷ │ Commit Two ╷ │ ╷ o 5da2b3e5a 91 seconds ago mary ╭─╯ Commit One │ o 17af69994 Today at 08:33 remote/stable ╷ ~ # Rebase all my commits onto new main. $ sl rebase -r 'draft()' -d main $ sl o 3c5549fb7 10 seconds ago mary │ Commit C │ │ o ed3106510 10 seconds ago mary ├─╯ Commit B │ o 23a6f6012 10 seconds ago mary ╭─╯ Commit A │ │ @ 9f73762dd 10 seconds ago mary │ │ Commit Two │ │ │ o 9d550d707 10 seconds ago mary ├─╯ Commit One │ o b5d600552 3 minutes ago remote/main ╷ o 17af69994 Today at 08:33 remote/stable ╷ ~  ","version":"Next","tagName":"h3"},{"title":"Shelve","type":0,"sectionRef":"#","url":"/docs/overview/shelve","content":"Shelve The Sapling shelve command allows you to temporarily put pending changes off to the side, then bring them back later. Any pending changes in the working copy will be saved, reverting the working copy back to a clean state. Shelves can be named with -n for easier identification. It is similar to the git stash command. $ vim myproject.cpp $ sl status M myproject.cpp $ sl shelve $ sl status You can either use sl unshelve to restore the latest shelved change to the working copy, or sl unshelve [shelved name] to specify a change to unshelve. $ sl status $ sl unshelve $ sl status M myproject.spp ","keywords":"","version":"Next"},{"title":"Smartlog","type":0,"sectionRef":"#","url":"/docs/overview/smartlog","content":"","keywords":"","version":"Next"},{"title":"Super Smartlog​","type":1,"pageTitle":"Smartlog","url":"/docs/overview/smartlog#super-smartlog","content":" Sapling can also fetch information about the repository from external sources, such as checking GitHub to know if a pull request has passed automated tests and been reviewed. Since this extra information requires waiting a few seconds for network requests, we have a separate sl ssl alias for this:  &gt; sl ssl o bc3bbba Yesterday at 12:23 remote/main ╷ ╷ @ c7ed677 Today at 11:17 jane #269 Unreviewed ✗ ╷ │ [docs] make examples consistent ╷ │ ╷ o 9f15ade Today at 10:09 jane #267 Unreviewed ✓ ╷ │ [docs] syntax-highlighting for smartlogs ╷ │ ╷ o 44df3af Yesterday at 14:07 jane #264 Approved ✓ ╭─╯ [docs] add sl-shell-example syntax-highlighting language │ o ecf6ca5 Yesterday at 12:23 │ ~   ","version":"Next","tagName":"h3"},{"title":"Interactive GUI smartlog​","type":1,"pageTitle":"Smartlog","url":"/docs/overview/smartlog#interactive-gui-smartlog","content":" An interactive smartlog GUI is available by running sl web. This shows similar information to sl smartlog while also refreshing automatically, and allows you to run commands or drag and drop commits to rebase them.  See Interactive Smartlog Documentation ","version":"Next","tagName":"h3"},{"title":"Basic commands","type":0,"sectionRef":"#","url":"/docs/overview/basic-commands","content":"","keywords":"","version":"Next"},{"title":"Working with commits​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#working-with-commits","content":" Get\tView\tChange\tMove\tRemove\tFix\tStackclone\tsl\tamend\trebase\thide\tuncommit\tfold pull\tshow\tmetaedit\tgraft\tunhide\tunamend\tsplit log undo\tabsorb web redo\thistedit restack  ","version":"Next","tagName":"h3"},{"title":"Working with your checkout​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#working-with-your-checkout","content":" View\tMove\tChange\tFix\tSavestatus\tgoto\tadd\trevert\tcommit diff\tnext\tremove\tclean\tshelve prev\tforget move copy   Examples  Many of Sapling’s basic commands will be familiar, and perhaps even unremarkable, to existing Git and Mercurial users. For example, Sapling supports clone, checkout, commit, rebase, push, etc. The goal was not to reinvent the wheel, but to make an intuitive, yet powerful, source control system.  This document is a casual introduction to some of the basic commands. It is not comprehensive, nor is it a walkthrough of an end-to-end workflow (see the Introduction for a simple, end-to-end example). Commands with interesting nuance or for more advanced cases are covered in other documents.  Many of these examples use the sl smartlog output to explain the repo state. See the Smartlog doc for an overview of the output format.  ","version":"Next","tagName":"h3"},{"title":"Cloning and checking out​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#cloning-and-checking-out","content":" Clone​  Clone the repo using the sl clone command.  # Clones into a 'sapling' directory. $ sl clone https://github.com/facebook/sapling remote: Enumerating objects: 640374, done. remote: Counting objects: 100% (5233/5233), done. remote: Compressing objects: 100% (3228/3228), done. remote: Total 640374 (delta 1749), reused 5139 (delta 1669), pack-reused 635141 Receiving objects: 100% (640374/640374), 155.18 MiB | 15.17 MiB/s, done. Resolving deltas: 100% (431325/431325), done. From https://github.com/facebook/sapling * [new ref] b8422460814900d8f978a8a34a99ae83c6735a70 -&gt; remote/main 5689 files updated, 0 files merged, 0 files removed, 0 files unresolved # Clones into a 'some_directory' directory. $ sl clone https://github.com/facebook/sapling some_directory   note For Git support, Sapling uses Git under the hood for clones, pushes, and pulls. Hence the output matches Git.  Related topics: Push/Pull, Sparse  Goto/Checkout​  sl goto or sl go allows you to checkout a specific commit. See the Navigation document for a variety of other ways to move around your repository.  # You can checkout commits by their long or short hash. # '@' in smartlog indicates your current checkout location. $ sl goto 71f7ac009 $ sl o b84224608 13 minutes ago remote/main ╷ @ 71f7ac009 Today at 10:10 john ╷ scsc: fix build on Windows ╷ ╷ o 15de72785 35 seconds ago mary my_feature ╭─╯ Implement glorious features │ o a555d064c Wednesday at 09:06 │ ~ # You can checkout remote bookmark commits, either by `name` or by `remote/name`. $ sl goto main # You can checkout commits pointed at by local bookmarks. $ sl goto my_feature   You can checkout a commit while you have pending changes, as long as the checkout does not change files with pending changes.  Notable options:  -C/--clean will remove any pending changes.  Related topics: Navigation, top/bottom, pull  ","version":"Next","tagName":"h2"},{"title":"Working copy​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#working-copy","content":" Status​  sl status or sl st shows a list of your current uncommitted files.  $ vim build.sh $ sl st M build.sh $ vim new_file.txt $ sl st M build.sh ? new_file.txt # File state indicators: # M - modified file # A - new file that has been marked with 'sl add' # R - deleted file that has been marked with 'sl remove' # ! - deleted file that has not yet been marked with 'sl remove' # ? - new file that has not yet been marked with 'sl add'   Unlike Git, Sapling does not use a staging area, so any non-? files in the status output will be committed when you run sl commit.  Notable options:  --copies shows which files have been marked as moved/copied.--change COMMIT shows the files changed in a given commit.  Diff​  sl diff shows you the diff output for your current uncommitted changes.  $ sl diff diff --git a/build.sh b/build.sh --- a/build.sh +++ b/build.sh @@ -9,6 +9,10 @@ PATH=&quot;$TOOLCHAIN_DIR:$PATH&quot; fi +if [[ -n $TEST_ENVIRONMENT ]]; then + exit 1 +fi + SCRIPT_DIR=$(dirname &quot;${BASH_SOURCE[0]}&quot;) # Specify a file to only see its changes. $ sl diff file.txt   The diff output is compatible with Git’s diff format.  Related topics: Show  Add/Remove/Forget​  sl add/remove/forget are used to add new files, remove old files, and undo added files, respectively. Only files marked M/A/R will be committed during sl commit.  $ sl st ? new_file.txt $ sl add new_file.txt $ sl st A new_file.txt $ rm old_file.txt $ sl st A new_file.txt ! old_file.txt $ sl rm old_file.txt $ sl st A new_file.txt R old_file.txt $ sl forget new_file.txt $ sl st ? new_file.txt R old_file.txt   Move/Copy​  sl mv/cp can be used to rename or copy a file.  $ sl mv old_name.txt new_name.txt $ sl st A new_name.txt R old_name.txt # Sapling-only repos track the move/copy, which can be viewed with sl st --copies. $ sl st --copies A new_name.txt old_name.txt R old_name.txt   When using Git support, file renames are not recorded since Git does not record this information. When using a normal Sapling repository, the rename/copy will be tracked inside Sapling and used to show accurate log and blame output for the file.  Related topics: AutoMove  Clean​  sl clean deletes any untracked files (? in status) in your working copy.  $ sl st ? temp_file $ sl clean $ sl st   Revert​  sl revert will revert any pending changes in your working copy.  $ sl st M build.sh $ sl revert build.sh $ sl st   Notable options:  --all will revert all pending changes, so you don’t need to specify file names.--rev COMMIT will change the file contents to match their contents in the given commit.--interactive will open an interactive editor for choosing which files or lines to revert.  ","version":"Next","tagName":"h2"},{"title":"Making commits​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#making-commits","content":" Commit​  sl commit commits your pending changes and prompts you for a commit message. While there is no staging area, the powerful --interactive option is used to select specific files or lines you want committed.  $ sl st M build.sh $ sl commit # ...opens your editor so you can write a message... $ sl @ c178f2e7f 1 second ago mary ╭─╯ Fix build.sh │ o b84224608 52 minutes ago remote/main │ ~   Notable options:  -m/--message MSG allows specifying a message instead of opening an editor.--interactive will open an interactive editor for choosing which files or lines to commit. Lines/files not chosen remain as pending changes.  Related topics: Amend  ","version":"Next","tagName":"h2"},{"title":"Viewing history​","type":1,"pageTitle":"Basic commands","url":"/docs/overview/basic-commands#viewing-history","content":" Related: smartlog  Show​  sl show shows the log message and textual diff for the current or given commit.  $ sl show commit: c178f2e7ff20447532370599051c1f1939f9dcb6 (@) parent: b8422460814900d8f978a8a34a99ae83c6735a70 user: Mary Smith &lt;mary@example.com&gt; date: Mon, 15 Aug 2022 16:56:36 -0700 My new commit diff --git a/build.sh b/build.sh --- a/build.sh +++ b/build.sh @@ -9,6 +9,10 @@ PATH=&quot;$TOOLCHAIN_DIR:$PATH&quot; fi +if [[ -n $TEST_ENVIRONMENT ]]; then + exit 1 +fi + SCRIPT_DIR=$(dirname &quot;${BASH_SOURCE[0]}&quot;) # Can also show a particular commit $ sl show COMMIT   Log​  sl log shows the commit history starting at your current commit.  Unlike in Git and Mercurial, the log command in Sapling is rarely used. Instead, smartlog is preferred for day-to-day development and understanding your repository. sl log is really only used when inspecting the deeper history of the repository or a file.  $ sl log changeset: c178f2e7ff20447532370599051c1f1939f9dcb6 (@) user: Mary Smith &lt;mary@example.com&gt; date: Mon, 15 Aug 2022 16:56:36 -0700 summary: My new commit changeset: b8422460814900d8f978a8a34a99ae83c6735a70 user: John Adams &lt;john@example.com&gt; date: Mon, 15 Aug 2022 16:04:08 -0700 summary: globalrevs: lookup globalrevs over edenapi changeset: 98f29d99b8b8b8a6562e98faa913a650bd0f0302 user: John Adams &lt;john@example.com&gt; date: Mon, 15 Aug 2022 15:14:49 -0700 summary: remove glob from scuba logging test changeset: 6bec7b92894495229635f481ba01895c869c2063 user: Mary Smith &lt;mary@example.com&gt; date: Mon, 15 Aug 2022 14:27:14 -0700 summary: fix monitoring for tailer # Specify a file or directory to see its history $ sl log src/build.rs # Use -fr with a commit to show the history starting from there. $ sl log -fr COMMIT src/build.rs  ","version":"Next","tagName":"h2"},{"title":"Axes of scale","type":0,"sectionRef":"#","url":"/docs/scale/axes","content":"","keywords":"","version":"Next"},{"title":"Working copy scale​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#working-copy-scale","content":" The working copy consists of all the files you have checked out and interact with. This is all the files in your repository directory, except the ones in the .sl directory.  ","version":"Next","tagName":"h2"},{"title":"Number of files​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#number-of-files","content":" Having millions of files in the working copy causes numerous problems for traditional version control. Checkouts are slow because we must download and write all of those files to disk. Status is slow because we must scan every file in the working copy to determine what has changed.  Sapling tackles large numbers of files in three ways:  The Watchman filesystem monitor lets Sapling monitor what files have changed, allowing it to answer status queries in O(files-you-have-changed) time instead of scanning the repository.The sparse feature allows users to only checkout the files that are relevant to them.The Sapling compatible virtual filesystem makes it appear as though you have the entire repository, but files are only downloaded when you first access them.  ","version":"Next","tagName":"h3"},{"title":"Size of files​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#size-of-files","content":" Moderately large files (10MB-2GB) are not a major source of scaling problems, but still require special consideration. Large files are downloaded from a special server that speaks the Git LFS protocol to avoid overloading the primary source control service. Large files are also stored locally in their own portion of the data cache, so that they have their own cache size limit and don’t swamp the other kinds of data.  Files larger than 2GB are currently not battle-tested in Sapling, though they may still work.  ","version":"Next","tagName":"h3"},{"title":"Size of directories​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#size-of-directories","content":" Large directories are those with thousands or tens of thousands of immediate children files or directories. It does not refer to directories which recursively contains many files or directories.  Directories up to a few thousand children are reasonably well supported in Sapling. Beyond that performance starts to degrade. Further optimizations are possible, but this is not an issue on the current Sapling-based monorepos and thus far not a priority.  ","version":"Next","tagName":"h3"},{"title":"Repository scale​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#repository-scale","content":" The repository consists of all the behind-the-scenes, non-working-copy repository data that is stored in the .sl directory. Similar to the .git directory in Git.  ","version":"Next","tagName":"h2"},{"title":"Number of commits​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#number-of-commits","content":" The total number of commits in a repository constantly grows over time, and in a large organization can easily reach millions or tens of millions of commits. This affects a wide variety of performance characteristics:  Storing all the commit data (messages, author, metadata, etc.) can take gigabytes of space. Note, this does not include the cost of storing file and tree data.Running sl log with particular constraints may have to read a large number of commits.Common graph queries, like ‘common ancestor’, used in many commands, like smartlog and rebase, can become slow.Computing the shortest unique hash prefix to provide pleasing UI output can become expensive.  Sapling takes several approaches to handle this:  History data (i.e. the graph relationships) and commit metadata (i.e. messages, authors, etc) are stored separately. This allows us to download lots of history data for graph computations, while downloading a more limited amount of commit metadata.Commit metadata is downloaded lazily. When you first clone a repository, no commit messages are downloaded. Only once you start inspecting commits, via smartlog, show, etc, individual commit metadata is downloaded as needed. This makes clones fast, and reduces the amount of disk space required to O(commits you are interested in).History data is stored using the Segmented Changelog. This is a data structure that represents the shape of the entire commit graph using segments to concisely represent large swaths of history. The segmented changelog can be represented in just a few megabytes and can answer graph query questions in O(number-of-merges) time, or just a few milliseconds even in a large monorepo.log with certain constraints, such as trying to find all commits by a certain user, may still need to inspect a lot of commits. Sapling attempts to make log more efficient by batch-fetching commit data, in order to avoid one-by-one serial fetches. Additionally, log on files and directories has special support, discussed below.Computing the shortest unique hash for a given commit is done by maintaining an incrementally updatable tree-like index of all locally-available commit hashes.  ","version":"Next","tagName":"h3"},{"title":"Number of branches/bookmarks​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#number-of-branchesbookmarks","content":" As the number of remote bookmarks (similar to a Git remote branch) in a repository grows over time, this can result in large number of remote bookmarks being downloaded and monitored by the client. This can cause slowness when talking to the server, as each bookmark needs to be checked, and generally clutters the local user experience.  Sapling defaults to not downloading every bookmark from the server. Instead, during a clone you receive the main or master bookmark, and a configurable list of specific other bookmarks. Users can choose to subscribe to specific bookmarks via sl pull -B. Sapling also transparently downloads bookmarks if the users uses them in commands. For instance, if a user runs sl goto release_123 but they don’t have that remote bookmark, Sapling will automatically download it to complete the checkout.  ","version":"Next","tagName":"h3"},{"title":"Quantity of historical file/tree data​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#quantity-of-historical-filetree-data","content":" During a normal distributed source control pull or clone you download all the new files and trees that have been changed, resulting in your local client having all of history. In a large repository, this quantity of data may be so large that it is slow and impractical to download all of it to individual clients.  Sapling, on the other hand, does not download tree and file data durings pull and clones. That data is left on the server, and the Sapling client downloads it on demand when later required, such as during a checkout. The on demand nature of Sapling commands requires carefully designed algorithms to ensure data is fetched efficiently and in parallel.  Lazily downloading data means Sapling may need network access to perform operations that would traditionally be doable offline. To support some offline work, Sapling keeps all of the downloaded data in a local cache with a bounded size. This cache generally contains enough data to move between, inspect, commit, and amend on any of your recently in-progress commits.  ","version":"Next","tagName":"h3"},{"title":"Length of file history​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#length-of-file-history","content":" In many version control systems, running commands like log and blame on a file or directory often have to walk every commit in the repository looking for commits that touched that file or directory. This is an O(size of repo) operation.  For files, Sapling makes these operations O(changes to that file) by tracking the exact history of each individual file, in addition to the history of the entire commit graph. This allows log and blame to be fast, regardless of the size of the repository.  For directories, Sapling also tracks the history of a directory, but using this information to answer history queries is not yet implemented. Instead, Sapling can query the Sapling server for a directory’s history, which allows using the server's superior indexes to answer the query quickly.  Additionally, in the case where the server isn't available, Sapling can bisect over the Segmented Changelog structure to look for the commits that changed the given file or directory. This allows figuring out an approximate history in O(log n) time, though it may miss cases where a file or directory is changed, then reverted back to a previous version.  ","version":"Next","tagName":"h3"},{"title":"Number of commits per hour​","type":1,"pageTitle":"Axes of scale","url":"/docs/scale/axes#number-of-commits-per-hour","content":" In a large organization the number of commits being pushed per minute introduces additional scaling challenges.  Rebase races  In Git or Mercurial, in order to push to the main branch you must first pull and rebase/merge onto the latest main branch. If someone pushes before you, then you have to repeat the process until you win. If there are many people competing, it can become almost impossible to actually push your commit.  In Sapling, when you push to the Sapling server, the server actually takes your commit and rebases it to be on the top of bookmark you are pushing to. So if someone else pushed before you, it’s ok because the server just moves your commit up to the top. If someone else edited a file you touched, then the push will fail and you must manually rebase to merge the file. There is still the potential for races where two people modify two different files in incompatible ways, but in practice this has not been an issue.  Code generation races  A large amount of commit throughput also introduces problems if your repository contains generated files. If you modify a file that requires regenerating, then if someone else does the same and pushes first, you need to rebase over their change and once again regenerate the files. The time taken to generate the file means the window in which you could lose the race becomes quite large, and it can become impossible to win the race if many people are changing the same generated files.  While Sapling doesn’t completely solve this, it improves the user experience by supporting calling code generators to solve rebase conflicts. This allows conflicts in generated code to be handled at rebase time and allows code-pushing automation to automatically regenerate code on the users behalf when it encounters a push failure due to a conflict. ","version":"Next","tagName":"h3"},{"title":"Organizational scale","type":0,"sectionRef":"#","url":"/docs/scale/organizational","content":"","keywords":"","version":"Next"},{"title":"Scaling customer support​","type":1,"pageTitle":"Organizational scale","url":"/docs/scale/organizational#scaling-customer-support","content":" When you have thousands of engineers, every edge case will be hit and strange issues from strange environments will need to be debugged. To stay on top of this, the Sapling team developed tools to make it easier to debug engineer issues quickly. Note, some of these are not available by default in the open source release since they require logging and services that only make sense within an organization.  sl doctor is a command that attempts to fix a number of known issues, such as repository corruption. As new issues are found, sl doctor is updated to fix them, which allows engineers to self-remediate many issues, thereby helping reduce the support burden on the Sapling team.sl rage is a command that gathers state about the engineer’s source control environment and creates a human readable text file with the information. It contains hostname, filesystem, disk usage, smartlog/status output, configuration, and recent commands, logs, errors, and profiles. This information allows the engineer to provide us with all the data we need without having to have a bunch of back and forths. The version of Sapling used inside Meta automatically uploads the rage file to a server for easy viewing by the Sapling team. The open source version does not upload any data.If an engineer complains about a slow command, adding --profile to any command allows them to produce a profile in the output. This makes it easy for the Sapling team to identify where the problem is, without having access to their machine or walking the engineer through how to use a profiler. If a command is hung, a similar traceback is written to .sl/sigtraces/ every 60 seconds, allowing us to see exactly where the current process is stuck. These tools make debugging tricky performance issues much easier, especially in a distributed environment.  ","version":"Next","tagName":"h3"},{"title":"Managing configuration​","type":1,"pageTitle":"Organizational scale","url":"/docs/scale/organizational#managing-configuration","content":" Configuration is a critical part of the Sapling experience at Meta and plays a large part in how we roll out new features. In the past we used a hierarchy of configuration files (similar to a /etc/gitconfig which recursively includes other config files) which were written by various systems (rpms, Chef, tools, etc). This became unwieldy as the logic that decides which configs are used was distributed across many systems and services, and the order of precedence for the various config files was fragile.  To make configuration more scalable, we unified all configuration into an internal dynamic configuration system, cleverly called dynamicconfig. This moved most configuration decisions from across the company into code in a single part of the code base where it could be reasoned about as a cohesive whole. For configs that need to change frequently, like a hotfix remediation or a rollout, we are able to query an internal configuration server for a signed blob of configuration. This remote blob contains a simple JSON decision-tree DSL which the client then executes to determine which configs should be applied to this particular repository.  Both the in-code and the remote portions of the configuration allow conditionally enabling configs based on operating system, data center, user, repository, tier, machine shard, user shard, time shard, etc. This allows us to rollout new features to particular machines or users, or to an automatically increasing percentage of users over time. This flexibility has been key to letting Sapling move fast, as we can quickly release or rollback new features, and get feedback in an incremental fashion.  Note, this dynamic configuration system is internal to Meta and does not apply to the open source release. No remote configs are downloaded for an open source Sapling build. The code for dynamicconfig is not currently visible in the repository as it contains internal configuration information. If external groups are interested in similar capabilities we could potentially make the capability public.  ","version":"Next","tagName":"h3"},{"title":"Incremental migrations​","type":1,"pageTitle":"Organizational scale","url":"/docs/scale/organizational#incremental-migrations","content":" Being able to make incremental breaking changes on an in-production system was a critical piece of making Sapling scale within Meta. Distributed source control repositories are particularly difficult structures to change because:  The contents are recursively hashed and the hashes are highly intertwined. Changing one byte changes every hash in the repository from there on.The data is widely distributed so a migration has to happen on many machines and there is no single source of truth.  This makes incremental migrations hard, since changing anything in the repository affects all the hashes and since everyone’s individual copy of the repo will need to be migrated.  Within Meta, these migrations fell into two categories: repository merges and format migrations.  Repository Merges  Accomplishing repository merges involving thousands of people deserves a blog post of its own. At a high level though, we developed server-side capabilities that let us “bind” directories in two repositories together so that any change to one was atomically applied to the other repository as well. These bindings could be done either for the whole repository, or for individual directories in a repository. This allowed us to make the contents of one repo available in another repo without any users having to immediately migrate. With the source control portion of the migration done transparently, the migration of users and tools could be done incrementally and in a way that was easy to rollback from. Once all users and tools had migrated, we could shut down the old repository and remove the bindings.  Format Migrations  Changing the hash scheme of the repository or the on-disk storage formats was particularly tricky since it meant migrating every single repository on every single machine for every single engineer. These migrations generally required writing to both the new and the old format for a while, often auditing that the results were equivalent, before turning off the old format. This required strong metrics (see below) to guarantee that the change had rolled out widely enough and taken effect on almost all the machines. It also required strong guarantees about the ability to roll new versions of the Sapling package to all machines. Internally we deploy new Sapling packages on a continuous basis, and prevent the execution of packages that are too old.  Hash scheme changes, while rare, required the additional step of maintaining a mapping between the new and the old hash scheme, and being able to validate past hashes which still used the old scheme.  ","version":"Next","tagName":"h3"},{"title":"Metrics and logging​","type":1,"pageTitle":"Organizational scale","url":"/docs/scale/organizational#metrics-and-logging","content":" Having real-time metrics on source control commands is critical for maintaining and improving the source control experience within Meta. Internally, we upload a wide variety of metrics for every Sapling command that is run, from command duration, to time waiting on other services, to number of files changed, network throughput, error traces, and more. This lets us not only keep an eye on long-term performance and reliability trends, but enables us to see the impact of current rollouts on performance and catch regressions before they affect everyone.  The metrics are also useful for debugging individual developer issues. If an engineer comes to us saying a given command failed yesterday, we’re able to look at the log and see exactly what Sapling commands ran around that time, where the commands spent their time, and how they exited. By combining the logs with Commit Cloud, the internal service that backs up every commit as it is made, we’re often able to reproduce the exact situation the engineer experienced, without needing further information from the engineer.  Note, none of this applies to the open source release. Neither metrics nor commits are uploaded from the open source Sapling builds. These logging and metrics tools are strictly internal to Meta. ","version":"Next","tagName":"h3"},{"title":"Undo","type":0,"sectionRef":"#","url":"/docs/overview/undo","content":"","keywords":"","version":"Next"},{"title":"Uncommit / unamend​","type":1,"pageTitle":"Undo","url":"/docs/overview/undo#uncommit--unamend","content":" The undo command is limited to undoing changes to the commit graph. To undo changes related to the working copy, like a commit or amend, use sl uncommit and sl unamend.  $ sl @ 1a22ba0e9 83 seconds ago mary ╭─╯ my feature │ o 59125794a 36 minutes ago remote/main ╷ ~ $ echo &quot;edit myproject.cpp&quot; &gt;&gt; myproject.cpp $ sl commit -m &quot;new commit&quot; $ sl @ 6024e2ffd 14 seconds ago mary │ new commit │ o 1a22ba0e9 3 minutes ago mary ╭─╯ my feature │ o 59125794a 38 minutes ago remote/main ╷ ~ # Oops! I meant to amend my changes instead. $ sl uncommit @ 1a22ba0e9 4 minutes ago mary ╭─╯ my feature │ o 59125794a 39 minutes ago remote/main ╷ ~ # Now we're back to the state prior to the commit. $ sl st M myproject.cpp $ sl amend $ sl @ 6ca2114d1 3 seconds ago mary ╭─╯ my feature │ o 59125794a 41 minutes ago remote/main ╷ ~ # Now let's say we change our mind and decide to make a new # commit after all. Let's undo the amend. $ sl unamend $ sl st M myproject.cpp # now the changes are back as pending changes in our working copy   You can limit uncommit to specific files by using sl uncommit FILE1 FILE2 .... ","version":"Next","tagName":"h3"},{"title":"Overview","type":0,"sectionRef":"#","url":"/docs/scale/overview","content":"","keywords":"","version":"Next"},{"title":"Performance challenges​","type":1,"pageTitle":"Overview","url":"/docs/scale/overview#performance-challenges","content":" This scale imposes performance challenges in various areas. Operations that require all files or all commits (O(files) or O(commits)) space or time complexities are gradually no longer affordable. Push throughput could also be an issue.  Over time, Sapling made many improvements to tackle the above challenges:  On-demand historical file fetching (remotefilelog, 2013)File system monitor for faster working copy status (watchman, 2014)In-repo sparse profile to shrink working copy (2015)Limit references to exchange (selective pull, 2016)On-demand historical tree fetching (2017)Incremental updates to working copy state (treestate, 2017)New server infrastructure for push throughput and faster indexes (Mononoke, 2017)Virtualized working copy for on-demand currently checked out file or tree fetching (EdenFS, 2018)Faster commit graph algorithms (segmented changelog, 2020)On-demand commit fetching (2021)  ","version":"Next","tagName":"h2"},{"title":"Other challenges​","type":1,"pageTitle":"Overview","url":"/docs/scale/overview#other-challenges","content":" Besides improving scale and performance, we also strove to build a robust development experience. To avoid developers losing their work due to hardware failures, we back up all commits as they are created to our &quot;commit cloud&quot;. Unlike other systems, the developer doesn't have to expressly push their commits for them to be shareable and durable.  ","version":"Next","tagName":"h2"},{"title":"Note about \"Distributed\"​","type":1,"pageTitle":"Overview","url":"/docs/scale/overview#note-about-distributed","content":" Sapling started from Mercurial as a distributed source control system, it then transitioned to a client-server architecture to solve the challenges. The server can utilize distributed storage and pre-build various kinds of indexes to provide more efficient operations.  While Sapling is less &quot;distributed&quot;, we tried to make the difference transparent to the user. For example, our lazy commit graph implementation does not require extra commands to &quot;deepen&quot; the graph. The user sees full history.  That said, we do drop support of pulling from a lazy repo. Commit cloud covers these use-cases. ","version":"Next","tagName":"h2"},{"title":"Stacks of commits","type":0,"sectionRef":"#","url":"/docs/overview/stacks","content":"","keywords":"","version":"Next"},{"title":"Amend​","type":1,"pageTitle":"Stacks of commits","url":"/docs/overview/stacks#amend","content":" You can edit any commit in your stack by going to that commit (via goto), making the desired modifications, and then running amend to edit the commit. Keep in mind that if you make a mistake, you can always Undo your changes!  $ sl o d9a5aa3c7 3 seconds ago mary │ feature two │ @ 8a644a0fd 30 seconds ago mary ╭─╯ feature one │ o ea609e1ef 7 minutes ago remote/main ╷ ~ $ echo &quot;Add feature to myproject&quot; &gt;&gt; myproject.cpp # Apply changes to the current commit $ sl amend $ sl show . ... diff --git a/myproject.cpp b/myproject.cpp new file mode 100644 --- /dev/null +++ b/myproject.cpp @@ -0,0 +1,1 @@ +&lt;amended feature one impl&gt;   ","version":"Next","tagName":"h3"},{"title":"Fold​","type":1,"pageTitle":"Stacks of commits","url":"/docs/overview/stacks#fold","content":" If you have a stack of commits, you can fold commits down into a single commit with the fold command. You can either specify --from &lt;commit id&gt; to specify a range of commits from your current commit to fold together or specify --exact &lt;list of commit ids&gt; to specify exact adjacent commits to fold together.  $ sl o 5dbd8043f 82 seconds ago mary │ commit five │ @ bd057eb7f 93 seconds ago mary │ commit four │ o b65a4efb1 113 seconds ago mary │ commit three │ o ef7915cd2 2 minutes ago mary │ commit two │ o 398748c95 2 minutes ago mary ╭─╯ commit one │ o ea609e1ef Today at 14:34 remote/main ╷ ~ $ sl fold --from ef7915cd2 # (equivalent to sl fold --exact ef7915cd2 b65a4efb1 bd057eb7f) 3 changesets folded update complete rebasing 5dbd8043fd7e &quot;commit five&quot; merging myproject.cpp 5dbd8043fd7e -&gt; debf0c562f6e &quot;commit five&quot; $ sl o debf0c562 9 minutes ago mary │ commit five │ @ 3cf9adf66 2 minutes ago mary │ commit two+three+four │ o 398748c95 10 minutes ago mary ╭─╯ commit one │ o ea609e1ef Today at 14:34 remote/main ╷ ~   ","version":"Next","tagName":"h3"},{"title":"Split​","type":1,"pageTitle":"Stacks of commits","url":"/docs/overview/stacks#split","content":" Use Sapling’s interactive editor interface to split the changes in one commit into two or more smaller commits.  $ sl @ b86c5cb40 2 seconds ago mary ╭─╯ feature one + two │ o ea609e1ef Today at 14:34 remote/main ╷ ~ # we want to split apart feature one and feature two $ sl split Select hunks to record - [x]=selected **=collapsed c: confirm q: abort arrow keys: move/expand/collapse space: deselect ?: help [~] diff --git a/myproject.cpp b/myproject.cpp new file mode 100644 [~] @@ -0,0 +1,3 @@ [x] +&lt;feature one&gt; [ ] + [ ] +&lt;feature two&gt; # &lt;press c&gt; # &lt;enter new commit message for first commit&gt; Done splitting? [yN] y # remaining unselected changes go into second commit # &lt;enter new commit message for second commit&gt; $ sl @ a305c853a 41 seconds ago mary │ feature two │ o 619efe410 2 minutes ago mary ╭─╯ feature one │ o ea609e1ef Today at 14:34 remote/main ╷ ~   ","version":"Next","tagName":"h3"},{"title":"Absorb​","type":1,"pageTitle":"Stacks of commits","url":"/docs/overview/stacks#absorb","content":" If you make changes while working at the top of a stack, the absorb command allows you to automatically amend those changes to commits lower in the stack. If there is an unambiguous commit which introduced the edited lines, the absorb command will prompt to apply those changes to that commit.  $ sl @ a305c853a 41 seconds ago mary │ feature two │ o 619efe410 2 minutes ago mary ╭─╯ feature one │ o ea609e1ef Today at 14:34 remote/main ╷ ~ # Edit part of &quot;feature one&quot;, while we are on top of &quot;feature two&quot;. $ vim myproject.cpp $ sl diff diff --git a/myproject.cpp b/myproject.cpp --- a/myproject.cpp +++ b/myproject.cpp @@ -1,3 +1,3 @@ -&lt;feature one&gt; +&lt;modified feature one&gt; &lt;feature two&gt; # Absorb knows that commit 619efe4 introduced the edited lines. $ sl absorb showing changes for myproject.cpp @@ -0,1 +0,1 @@ 619efe4 -&lt;feature one&gt; 619efe4 +&lt;modified feature one&gt; 1 commit affected 619efe4 feature one apply changes (yn)? **y** 619efe41024d -&gt; cbf60a27cae4 &quot;feature one&quot; a305c853a7b5 -&gt; f656ac8c60c8 &quot;feature two&quot; 1 of 1 chunk applied # Feature one commit now contains the modifications. $ sl @ f656ac8c8 11 seconds ago mary │ feature two │ o cbf60a274 11 seconds ago mary ╭─╯ feature one │ o ea609e1ef Today at 14:34 remote/main ╷ ~   ","version":"Next","tagName":"h3"},{"title":"Amend --to​","type":1,"pageTitle":"Stacks of commits","url":"/docs/overview/stacks#amend---to","content":" Sometimes absorb cannot predict an appropriate commit to apply changes to. In this case you can try the command sl amend --to to specify exactly which commit to apply pending changes to.  $ sl @ f656ac8c6 30 minutes ago mary │ feature two │ o cbf60a27c 30 minutes ago mary ╭─╯ feature one │ o ea609e1ef Yesterday at 14:34 remote/main ╷ ~ # Add new file for feature one. $ vim myproject2.cpp $ sl addremove adding myproject2.cpp $ sl diff diff --git a/myproject2.cpp b/myproject2.cpp new file mode 100644 --- /dev/null +++ b/myproject2.cpp @@ -0,0 +1,1 @@ +&lt;more pieces of feature one&gt; # Since the changes are in a new file, absorb can't predict # which commit to apply any changes to. $ sl absorb nothing to absorb # Use 'amend --to' to specify which commit to amend. $ sl amend --to cbf60a27c cbf60a27cae4 -&gt; 768f3b26abc3 &quot;feature one&quot; f656ac8c60c8 -&gt; fe792a25079d &quot;feature two&quot;  ","version":"Next","tagName":"h3"}]