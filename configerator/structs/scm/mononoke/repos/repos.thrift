// @generated SignedSource<<613d90f8c0d525b247d0445f8b64608e>>
// DO NOT EDIT THIS FILE MANUALLY!
// This file is a mechanical copy of the version in the configerator repo. To
// modify it, edit the copy in the configerator repo instead and copy it over by
// running the following in your fbcode directory:
//
// configerator-thrift-updater scm/mononoke/repos/repos.thrift

/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This software may be used and distributed according to the terms of the
 * GNU General Public License version 2.
 */

namespace py configerator.mononoke.repos
namespace py3 mononoke.repos

// NOTICE:
// Don't use 'defaults' for any of these values (e.g. 'bool enabled = true')
// because these structs will be deserialized by serde in rust. The following
// rules apply upon deserialization:
//   1) specified default values are ignored, default values will always be
//      the 'Default::default()' value for a given type. For example, even
//      if you specify:
//          1: bool enabled = true,
//
//       upon decoding, if the field enabled isn't present, the default value
//       will be false.
//
//   2) not specifying optional won't actually make your field required,
//      neither will specifying required make any field required. Upon decoding
//      with serde, all values will be Default::default() and no error will be
//      given.
//
//   3) the only way to detect wether a field was specified in the structure
//      being deserialized is by making a field optional. This will result in
//      a 'None' value for a Option<T> in rust. So the way we can give default
//      values other then 'Default::default()' is by making a field optional,
//      and then explicitly handle 'None' after deserialization.

struct RawRepoConfigs {
  1: map<string, RawCommitSyncConfig> (rust.type = "HashMap") commit_sync;
  2: RawCommonConfig common;
  3: map<string, RawRepoConfig> (rust.type = "HashMap") repos; # to be renamed to repo_configs
  4: map<string, RawStorageConfig> (rust.type = "HashMap") storage; # to be renamed to storage_configs
  6: map<string, RawAclRegionConfig> (rust.type = "HashMap") acl_region_configs;
  5: RawRepoDefinitions repo_definitions;
} (rust.exhaustive)

struct RawRepoDefinitions {
  // map from repo_name to a simple structure containing repo-specific data like
  // repo_id or repo_name that can be used at runtime whenever RawRepoConfig
  // needs it.
  1: map<string, RawRepoDefinition> (rust.type = "HashMap") repo_definitions;
} (rust.exhaustive)

struct RawRepoDefinition {
  // Most important - the unique ID of this Repo
  // Required - don't let the optional comment fool you, see notice above.
  1: optional i32 repo_id;

  2: optional string repo_name;

  // In case this repo is related with some other repo in other id namespace.
  3: optional i32 external_repo_id;

  // Key into RawRepoConfigs.repos
  4: optional string repo_config;

  // 5: deleted

  // Name of the ACL used for this repo.
  6: optional string hipster_acl;

  // Repo is enabled for use.
  7: optional bool enabled;

  // Repo is read-only (default false).
  8: optional bool readonly;

  // Should this repo be backed up?
  9: optional bool needs_backup;

  // In case this is a backup repo, what's the origin repo name?
  10: optional string backup_source_repo_name;

  // Key into RawRepoConfigs.acl_region_configs for the definition of
  // ACL regions for this repo.
  11: optional string acl_region_config;

  // Default hashing scheme used for revisions given by clients
  // when they interact with the repo without specifying this explicitly.
  12: optional RawCommitIdentityScheme default_commit_identity_scheme;
} (rust.exhaustive)

// The schemes by which commits can be identified.
enum RawCommitIdentityScheme {
  UNKNOWN = 0,
  /// Commits are identified by the 32-byte hash of Mononoke's bonsai
  /// changeset.
  BONSAI = 1,

  /// Commits are identified by the 20-byte hash of the Mercurial commit.
  HG = 2,

  /// Commits are identified by the 20-byte hash of the Git commit.
  GIT = 3,
}

struct RawRepoConfig {
  // Persistent storage - contains location of metadata DB and name of
  // blobstore we're using. We reference the common storage config by name.
  // Required - don't let the optional comment fool you, see notice above
  2: optional string storage_config;

  // Local definitions of storage (override the global defined storage)
  3: optional map<string, RawStorageConfig> storage;

  // Define special bookmarks with parameters
  6: optional list<RawBookmarkConfig> bookmarks;
  7: optional i64 bookmarks_cache_ttl;

  // Define hook manager
  8: optional RawHookManagerParams hook_manager_params;

  // Define hook available for use on bookmarks
  9: optional list<RawHookConfig> hooks;

  // This enables or disables verification for censored blobstores
  11: optional bool redaction;

  12: optional i64 generation_cache_size;
  13: optional string scuba_table;
  14: optional string scuba_table_hooks;
  15: optional i64 delay_mean;
  16: optional i64 delay_stddev;
  17: optional RawCacheWarmupConfig cache_warmup;
  18: optional RawPushParams push;
  19: optional RawPushrebaseParams pushrebase;
  20: optional RawLfsParams lfs;
  22: optional i64 hash_validation_percentage;
  23: optional string skiplist_index_blobstore_key;
  24: optional RawBundle2ReplayParams bundle2_replay_params;
  25: optional RawInfinitepushParams infinitepush;
  26: optional i64 list_keys_patterns_max;
  27: optional RawFilestoreParams filestore;
  28: optional i64 hook_max_file_size;
  31: optional RawSourceControlServiceParams source_control_service;
  30: optional RawSourceControlServiceMonitoring source_control_service_monitoring;
  // Types of derived data that are derived for this repo and are safe to use
  33: optional RawDerivedDataConfig derived_data_config;

  // Log Scuba samples to files. Largely only useful in tests.
  34: optional string scuba_local_path;
  35: optional string scuba_local_path_hooks;
  // 36: deleted
  // 37: deleted
  38: optional RawSegmentedChangelogConfig segmented_changelog_config;
  39: optional bool enforce_lfs_acl_check;
  // Use warm bookmark cache while serving data hg wireprotocol
  40: optional bool repo_client_use_warm_bookmarks_cache;
  // Deprecated
  41: optional bool warm_bookmark_cache_check_blobimport;
  // A collection of knobs to enable/disable functionality in repo_client module
  42: optional RawRepoClientKnobs repo_client_knobs;
  43: optional string phabricator_callsign;
  // Define parameters for backups jobs
  44: optional RawBackupRepoConfig backup_config;
  // Define parameters for repo scrub/walker jobs
  45: optional RawWalkerConfig walker_config;
  // Cross-repo commit validation config
  46: optional RawCrossRepoCommitValidationConfig cross_repo_commit_validation_config;
  // Configuration related to the sparse profiles
  47: optional RawSparseProfilesConfig sparse_profiles_config;
  // Configuration related to hg-sync job for prod repos
  48: optional RawHgSyncConfig hg_sync_config;
  // Configuration related to hg-sync job for backup repos
  49: optional RawHgSyncConfig backup_hg_sync_config;
  // Flag that determines if the repo is shallow sharded or deep sharded,
  // shallow-sharded: Requests are sharded but repo is on every server
  // deep-sharded: In addition to requests, repo is also sharded, i.e. present
  // on select servers.
  50: optional bool deep_sharded;
  // The scribe category to use for logging bookmark updates
  // (NOTE: will be replaced by update_logging_config.bookmark_logging_destination)
  51: optional string bookmark_scribe_category;
  // Configuration for logging of repo updates.
  52: optional RawUpdateLoggingConfig update_logging_config;
} (rust.exhaustive)

struct RawWalkerConfig {
  // Controls if scrub of data into history is enabled
  1: bool scrub_enabled;
  // Controls if validation of shallow walk from master enabled
  2: bool validate_enabled;
  // Controls non-standard parameter values for different walker
  // job types
  3: optional map<RawWalkerJobType, RawWalkerJobParams> params;
} (rust.exhaustive)

/// Repo-specific configuration parameters for hg sync job
/// Parameters for a specific hg sync job variant
struct RawHgSyncConfig {
  /// Remote path to hg repo to replay to
  1: string hg_repo_ssh_path;
  /// Maximum number of bundles allowed over a single hg peer
  2: i64 batch_size;
  /// If set, Mononoke repo will be locked on sync failure
  3: bool lock_on_failure;
  /// The darkstorm backup repo-id to be used as target for sync
  4: optional i32 darkstorm_backup_repo_id;
}

struct RawWalkerJobParams {
  // Controls max concurrency for MySQL and other dependencies
  1: optional i64 scheduled_max_concurrency;
  // Controls the max blobstore read QPS for a given repo
  2: optional i64 qps_limit;
  // The type of nodes to be excluded during walk
  3: optional string exclude_node_type;
  // Whether to allow remaining deferred edges after chunks complete.
  4: optional bool allow_remaining_deferred;
  // Control whether walker continues in the face of error for specified
  // node types
  5: optional string error_as_node_data_type;
}

/// The type of walker jobs deployed in production
enum RawWalkerJobType {
  UNKNOWN = 0,
  VALIDATE_ALL = 1,
  SCRUB_ALL_CHUNKED = 2,
  SCRUB_HG_ALL_CHUNKED = 3,
  SCRUB_HG_FILE_CONTENT = 4,
  SCRUB_HG_FILE_NODE = 5,
  SCRUB_UNODE_ALL_CHUNKED = 6,
  SCRUB_UNODE_BLAME = 7,
  SCRUB_DERIVED_NO_CONTENT_META = 8,
  SCRUB_DERIVED_NO_CONTENT_META_CHUNKED = 9,
  SCRUB_UNODE_FASTLOG = 10,
  SCRUB_DERIVED_CHUNKED = 11,
  SHALLOW_HG_SCRUB = 12,
}

struct RawBackupRepoConfig {
  // Enable backup verification job for this repo
  2: bool verification_enabled;
} (rust.exhaustive)

struct RawRepoClientKnobs {
  1: bool allow_short_getpack_history;
} (rust.exhaustive)

struct RawDerivedDataConfig {
  1: optional string scuba_table;
  // 2: deleted
  // 3: deleted
  // 4: deleted
  5: optional RawDerivedDataTypesConfig enabled; // deprecated
  6: optional RawDerivedDataTypesConfig backfilling; // deprecated
  7: optional map<string, RawDerivedDataTypesConfig> available_configs;
  8: optional string enabled_config_name;
} (rust.exhaustive)

struct RawDerivedDataTypesConfig {
  1: set<string> types;
  6: map<string, string> mapping_key_prefixes;
  2: optional i16 unode_version;
  3: optional i64 blame_filesize_limit;
  4: optional bool hg_set_committer_extra;
  5: optional i16 blame_version;
// 7. deleted
} (rust.exhaustive)

struct RawBlobstoreDisabled {} (rust.exhaustive)
struct RawBlobstoreFilePath {
  1: string path;
} (rust.exhaustive)
struct RawBlobstoreManifold {
  1: string manifold_bucket;
  2: string manifold_prefix;
} (rust.exhaustive)
struct RawBlobstoreMysql {
  // 1: deleted
  // 2: deleted
  3: RawDbShardableRemote remote;
} (rust.exhaustive)
struct RawBlobstoreMultiplexed {
  // The scuba table to log stats per underlying blobstore
  1: optional string scuba_table;
  2: list<RawBlobstoreIdConfig> components;
  3: optional i64 scuba_sample_rate;
  4: optional i32 multiplex_id;
  5: optional RawDbConfig queue_db;
  // The number of components that must successfully `put` a blob before the
  // multiplex as a whole claims that it successfully `put` the blob
  6: optional i64 minimum_successful_writes;
  // The scuba table to log stats of the multiplexed blobstore operations
  7: optional string multiplex_scuba_table;
  // The number of reads needed to decided a blob is not present
  8: optional i64 not_present_read_quorum;
} (rust.exhaustive)
// See docs in fbcode/eden/mononoke/metaconfig/types/src/lib.rs:BlobConfig::MultiplexedWal
struct RawBlobstoreMultiplexedWal {
  1: i32 multiplex_id;
  2: list<RawBlobstoreIdConfig> components;
  3: i64 write_quorum;
  4: RawShardedDbConfig queue_db;
  // The scuba table to log stats per underlying blobstore
  5: optional string inner_blobstores_scuba_table;
  // The scuba table to log stats for the overall multiplex
  6: optional string multiplex_scuba_table;
  // Used for both scuba tables. Write queries and read failures are not sampled.
  7: optional i64 scuba_sample_rate;
} (rust.exhaustive)
struct RawBlobstoreManifoldWithTtl {
  1: string manifold_bucket;
  2: string manifold_prefix;
  3: i64 ttl_secs;
} (rust.exhaustive)
struct RawBlobstoreLogging {
  1: optional string scuba_table;
  2: optional i64 scuba_sample_rate;
  3: RawBlobstoreConfig blobstore (rust.box);
} (rust.exhaustive)
struct RawBlobstorePackRawFormat {} (rust.exhaustive)
struct RawBlobstorePackZstdFormat {
  1: i32 compression_level;
} (rust.exhaustive)
union RawBlobstorePackFormat {
  1: RawBlobstorePackRawFormat Raw;
  2: RawBlobstorePackZstdFormat ZstdIndividual;
}
struct RawBlobstorePackConfig {
  1: RawBlobstorePackFormat put_format;
} (rust.exhaustive)
struct RawBlobstorePack {
  1: RawBlobstoreConfig blobstore (rust.box);
  2: optional RawBlobstorePackConfig pack_config;
} (rust.exhaustive)
struct RawBlobstoreS3 {
  1: string bucket;
  2: string keychain_group;
  3: string region_name;
  4: string endpoint;
  // Limit the number of concurrent operations to S3
  // blobstore.
  5: optional i32 num_concurrent_operations;
  // Name of the secret within the group
  6: optional string secret_name;
} (rust.exhaustive)

// Configuration for a single blobstore. These are intended to be defined in a
// separate blobstore.toml config file, and then referenced by name from a
// per-server config. Names are only necessary for blobstores which are going
// to be used by a server. The id field identifies the blobstore as part of a
// multiplex, and need not be defined otherwise. However, once it has been set
// for a blobstore, it must remain unchanged.
union RawBlobstoreConfig {
  1: RawBlobstoreDisabled disabled;
  2: RawBlobstoreFilePath blob_files;
  // 3: deleted
  4: RawBlobstoreFilePath blob_sqlite;
  5: RawBlobstoreManifold manifold;
  6: RawBlobstoreMysql mysql;
  7: RawBlobstoreMultiplexed multiplexed;
  8: RawBlobstoreManifoldWithTtl manifold_with_ttl;
  9: RawBlobstoreLogging logging;
  10: RawBlobstorePack pack;
  11: RawBlobstoreS3 s3;
  12: RawBlobstoreMultiplexedWal multiplexed_wal;
}

// A write-only blobstore is one that is not read from in normal operation.
// Mononoke will read from it in these cases:
// 1. Verifying that data is present in all blobstores (scrub etc)
union RawMultiplexedStoreType {
  1: RawMultiplexedStoreNormal normal;
  // TODO: delete
  2: RawMultiplexedStoreWriteMostly write_mostly;
  3: RawMultiplexedStoreWriteOnly write_only;
}

struct RawMultiplexedStoreNormal {} (rust.exhaustive)
struct RawMultiplexedStoreWriteMostly {} (rust.exhaustive)
struct RawMultiplexedStoreWriteOnly {} (rust.exhaustive)

struct RawBlobstoreIdConfig {
  1: i64 blobstore_id;
  2: RawBlobstoreConfig blobstore;
  3: optional RawMultiplexedStoreType store_type;
} (rust.exhaustive)

struct RawDbLocal {
  1: string local_db_path;
} (rust.exhaustive)

struct RawDbRemote {
  1: string db_address;
// 2: deleted
} (rust.exhaustive)

struct RawDbShardedRemote {
  1: string shard_map;
  2: i32 shard_num;
} (rust.exhaustive)

union RawDbShardableRemote {
  1: RawDbRemote unsharded;
  2: RawDbShardedRemote sharded;
}

union RawDbConfig {
  1: RawDbLocal local;
  2: RawDbRemote remote;
}

union RawShardedDbConfig {
  1: RawDbLocal local;
  2: RawDbShardedRemote remote;
}

struct RawRemoteMetadataConfig {
  1: RawDbRemote primary;
  2: RawDbShardableRemote filenodes;
  3: RawDbRemote mutation;
  4: RawDbRemote sparse_profiles;
} (rust.exhaustive)

union RawMetadataConfig {
  1: RawDbLocal local;
  2: RawRemoteMetadataConfig remote;
}

enum RawBubbleDeletionMode {
  DISABLED = 0,
  MARK_ONLY = 1,
  MARK_AND_DELETE = 2,
}

struct RawEphemeralBlobstoreConfig {
  1: RawBlobstoreConfig blobstore;
  2: RawDbConfig metadata;
  4: i64 initial_bubble_lifespan_secs;
  5: i64 bubble_expiration_grace_secs;
  6: RawBubbleDeletionMode bubble_deletion_mode;
} (rust.exhaustive)

struct RawStorageConfig {
  // 1: deleted
  3: RawMetadataConfig metadata;
  2: RawBlobstoreConfig blobstore;
  4: optional RawEphemeralBlobstoreConfig ephemeral_blobstore;
} (rust.exhaustive)

struct RawPushParams {
  1: optional bool pure_push_allowed;
  // (NOTE: will be replaced by update_logging_config.new_commit_logging_destination)
  2: optional string commit_scribe_category;
} (rust.exhaustive)

struct RawPushrebaseRemoteModeLocal {} (rust.exhaustive)
union RawPushrebaseRemoteModeRemote {
  1: string tier;
  2: string host_port;
}

union RawPushrebaseRemoteMode {
  1: RawPushrebaseRemoteModeLocal local;
  // 2: deleted
  // 3: deleted
  4: RawPushrebaseRemoteModeRemote remote_land_service;
  5: RawPushrebaseRemoteModeRemote remote_land_service_local_fallback;
}

struct RawPushrebaseParams {
  1: optional bool rewritedates;
  2: optional i64 recursion_limit;
  // (NOTE: will be replaced by update_logging_config.new_commit_logging_destination)
  3: optional string commit_scribe_category;
  4: optional bool block_merges;
  5: optional bool forbid_p2_root_rebases;
  6: optional bool casefolding_check;
  7: optional bool emit_obsmarkers;
  // This eventually will be removed and superseded by
  // globalrevs_publishing_bookmark.
  8: optional bool assign_globalrevs;
  9: optional bool populate_git_mapping;
  // A bookmark that assigns globalrevs. This bookmark can only be pushed to
  // via pushrebase. Other bookmarks can only be pushed to commits that are
  // ancestors of this bookmark.
  10: optional string globalrevs_publishing_bookmark;
  // For the case when one repo is linked to another (a.k.a. megarepo)
  // there's a special commit extra that allows changing the mapping
  // used to rewrite a commit from one repo to another.
  // Normally pushes of a commit like this are not allowed unless
  // this option is set to false.
  11: optional bool allow_change_xrepo_mapping_extra;
  // How to do pushrebase from Mononoke, remotely or local.
  12: optional RawPushrebaseRemoteMode remote_mode;
  // Pushes to which bookmark should be logged to ODS for monitoring
  // This will usually be the "main bookmark" of the repo
  13: optional string monitoring_bookmark;
} (rust.exhaustive)

struct RawBookmarkConfig {
  // Either the regex or the name should be provided, not both
  1: optional string regex;
  2: optional string name;
  3: list<RawBookmarkHook> hooks;
  // Are non fastforward moves allowed for this bookmark
  4: bool only_fast_forward;

  // If specified, and if the user's unixname is known, only users who
  // belong to this group or match allowed_users will be allowed to move this
  // bookmark.
  5: optional string allowed_users;

  // If specified, and if the user's unixname is known, only users who
  // belong to this group or match allowed_users will be allowed to move this
  // bookmark.
  9: optional string allowed_hipster_group;

  // Deprecated
  8: optional bool allow_only_external_sync;

  // Whether or not to rewrite dates when processing pushrebase pushes
  6: optional bool rewrite_dates;

  // Other bookmarks whose ancestors are skipped when running hooks
  //
  // This is used during plain bookmark pushes and other simple bookmark
  // updates to avoid running hooks on commits that have already passed the
  // hook.
  //
  // For example, if this field contains "master", and we move a release
  // bookmark like this:
  //
  //   o master
  //   :
  //   : o new
  //   :/
  //   o B
  //   :
  //   : o old
  //   :/
  //   o A
  //   :
  //
  // then changesets in the range A::B will be skipped by virtue of being
  // ancestors of master, which should mean they have already passed the
  // hook.
  7: optional list<string> hooks_skip_ancestors_of;

  // Ensure that given bookmark(s) are ancestors of `ensure_ancestor_of`
  // bookmark. That also implies that it's not longer possible to
  // pushrebase to these bookmarks.
  10: optional string ensure_ancestor_of;

  // This option allows moving a bookmark to a commit that's already
  // public while bypassing all the hooks. Note that should be fine,
  // because commit is already public, meaning that hooks already
  // should have been run when the commit was first made public.
  11: optional bool allow_move_to_public_commits_without_hooks;
} (rust.exhaustive)

struct RawAllowlistIdentity {
  1: string identity_type;
  2: string identity_data;
} (rust.exhaustive)

struct RawRedactionConfig {
  // Blobstore config for redaction config, indexed by name
  1: string blobstore;
  // Blobstore used to store backup of the redaction config, usually
  // darkstorm. Only used on admin command that creates the config.
  2: optional string darkstorm_blobstore;
  // Configerator path where RedactionSets are
  // TODO: Once the whole config is hot reloadable, move redaction
  // sets inside this struct instead
  3: string redaction_sets_location;
} (rust.exhaustive)

struct RawCommonConfig {
  // 1: deleted

  2: optional string loadlimiter_category;

  // Scuba table for logging redacted file access attempts
  3: optional string scuba_censored_table;
  // Local file to log redacted file accesses to (useful in tests).
  4: optional string scuba_local_path_censored;

  // Whether to enable the control API over HTTP. At this time, this is
  // only meant to be used in tests.
  5: bool enable_http_control_api;

  6: RawRedactionConfig redaction_config;

  // Hipster tier name containing entities that are permitted to act as
  // trusted proxies.  Mononoke will accept and use proxied authentication
  // data from entities that pass the `trusted_parties` action for this tier.
  7: optional string trusted_parties_hipster_tier;

  // List of identities that are permitted to act as trusted proxies.
  // Mononoke will accept and use proxied authentication data from these
  // entities in lieu of their own identities.
  8: optional list<RawAllowlistIdentity> trusted_parties_allowlist;

  // List of identities that are allowlisted globally, and can always access
  // all repos.
  9: optional list<RawAllowlistIdentity> global_allowlist;

  // Identity for internal Mononoke services. Requests from these services
  // can be trusted to not have been done directly by users.
  10: RawAllowlistIdentity internal_identity;
} (rust.exhaustive)

struct RawCacheWarmupConfig {
  1: string bookmark;
  2: optional i64 commit_limit;
  3: optional bool microwave_preload;
} (rust.exhaustive)

struct RawBookmarkHook {
  1: string hook_name;
} (rust.exhaustive)

struct RawHookManagerParams {
  /// Wether to disable the acl checker or not (intended for testing purposes)
  1: bool disable_acl_checker;
  2: bool all_hooks_bypassed;
  3: optional string bypassed_commits_scuba_table;
} (rust.exhaustive)

struct RawHookConfig {
  1: string name;
  4: optional string bypass_commit_string;
  5: optional string bypass_pushvar;
  6: optional map<string, string> (rust.type = "HashMap") config_strings;
  7: optional map<string, i32> (rust.type = "HashMap") config_ints;
  8: optional map<string, list<string>> (
    rust.type = "HashMap",
  ) config_string_lists;
  9: optional map<string, list<i32>> (rust.type = "HashMap") config_int_lists;
  10: optional map<string, i64> (rust.type = "HashMap") config_ints_64;
  11: optional map<string, list<i64>> (
    rust.type = "HashMap",
  ) config_int_64_lists;
} (rust.exhaustive)

struct RawLfsParams {
  1: optional i64 threshold;
  // What percentage of client host gets lfs pointers
  2: optional i32 rollout_percentage;
  // Whether to generate lfs blobs in hg sync job
  3: optional bool generate_lfs_blob_in_hg_sync_job;
// 4: deleted
} (rust.exhaustive)

struct RawBundle2ReplayParams {
  1: optional bool preserve_raw_bundle2;
} (rust.exhaustive)

struct RawInfinitepushParams {
  1: bool allow_writes;
  2: optional string namespace_pattern;
  3: optional bool hydrate_getbundle_response;
  // 4: deleted
  // (NOTE: will be replaced by update_logging_config.new_commit_logging_destination)
  5: optional string commit_scribe_category;
// 6: deleted
// 7: deleted
} (rust.exhaustive)

struct RawFilestoreParams {
  1: i64 chunk_size;
  2: i32 concurrency;
} (rust.exhaustive)

struct RawCommitSyncSmallRepoConfig {
  1: i32 repoid;
  2: string default_action;
  3: optional string default_prefix;
  4: string bookmark_prefix;
  5: map<string, string> mapping;
  6: string direction;
} (rust.exhaustive)

struct RawCommitSyncConfig {
  1: i32 large_repo_id;
  2: list<string> common_pushrebase_bookmarks;
  3: list<RawCommitSyncSmallRepoConfig> small_repos;
  4: optional string version_name;
} (rust.exhaustive)

struct RawSourceControlServiceParams {
  // Whether ordinary users can write through the source control service.
  1: bool permit_writes;

  // Whether service users can write through the source control service.
  2: bool permit_service_writes;

  // ACL to use for verifying a caller has write access on behalf of a service.
  3: optional string service_write_hipster_acl;

  // Map from service name to the restrictions that apply for that service.
  4: optional map<
    string,
    RawServiceWriteRestrictions
  > service_write_restrictions;

  // Whether users can create commits without parents.
  5: bool permit_commits_without_parents;
} (rust.exhaustive)

struct RawServiceWriteRestrictions {
  // The service is permitted to call these methods.
  1: set<string> permitted_methods;

  // The service is permitted to modify files with these path prefixes.
  2: optional set<string> permitted_path_prefixes;

  // The service is permitted to modify these bookmarks.
  3: optional set<string> permitted_bookmarks;

  // The service is permitted to modify bookmarks that match this regex.
  4: optional string permitted_bookmark_regex;
} (rust.exhaustive)

// Raw configuration for health monitoring of the
// source-control-as-a-service solutions
struct RawSourceControlServiceMonitoring {
  1: list<string> bookmarks_to_report_age;
} (rust.exhaustive)

// Raw config item of segmented changelog head configuration
union RawSegmentedChangelogHeadConfig {
  // All public bookmarks. Allows for making exceptions by naming bookmarks to
  // exclude.
  1: list<string> all_public_bookmarks_except;
  2: string bookmark;
  3: string bonsai_changeset;
}

struct RawSegmentedChangelogConfig {
  // Whether Segmented Changelog should even be initialized.
  1: optional bool enabled;

  // 2: deleted

  // The bookmark that is followed to construct the Master group of the Dag.
  // Defaults to "master".
  3: optional string master_bookmark;

  // How often the tailer should check for updates to the master_bookmark and
  // perform updates. The tailer is disabled when the period is set to 0.
  4: optional i64 tailer_update_period_secs;

  // By default a mononoke process will look for Dags to load from
  // blobstore.  In tests we may not have prebuilt Dags to load so we have
  // this setting to allow us to skip that step and initialize with an empty
  // Dag.
  // We don't want to set this in production.
  5: optional bool skip_dag_load_at_startup;

  // How often an Dag will be reloaded from saves.
  // The Dag will not reload when the period is set to 0.
  6: optional i64 reload_dag_save_period_secs;

  // How often the in process Dag will check the master bookmark to update
  // itself.  The Dag will not check master when the period is set to 0.
  7: optional i64 update_to_master_bookmark_period_secs;

  // List of bonsai changeset to include in the segmented changelog during reseeding.
  //
  // To explain why we might need `bonsai_changesets_to_include` - say we have a
  // commit graph like this:
  // ```
  //  B <- master
  //  |
  //  A
  //  |
  // ...
  // ```
  // Then we move a master bookmark backwards to A and create a new commit on top
  // (this is a very rare situation, but it might happen during sevs)
  //
  // ```
  //  C <- master
  //  |
  //  |  B
  //  | /
  //  A
  //  |
  // ...
  // ```
  //
  // Clients might have already pulled commit B, and so they assume it's present on
  // the server. However if we reseed segmented changelog then commit B won't be
  // a part of a new reseeded changelog because B is not an ancestor of master anymore.
  // It might lead to problems - clients might fail because server doesn't know about
  // a commit they assume it should know of, and server would do expensive sql requests
  // (see S242328).
  //
  // `bonsai_changesets_to_include` might help with that - if we add `B` to
  // `bonsai_changesets_to_include` then every reseeding would add B and it's
  // ancestors to the reseeded segmented changelog. (default: [])
  8: optional list<string> bonsai_changesets_to_include;
  9: list<RawSegmentedChangelogHeadConfig> heads_to_include;
  // Heads that included in segmented changelog by seeders, tailers and other
  // background but are not updated in in-memory dag by all servers.
  10: list<
    RawSegmentedChangelogHeadConfig
  > extra_heads_to_include_in_background_jobs;
} (rust.exhaustive)

// Describe ACL Regions for a repository.
//
// This is a set of rules which define regions of the repository (commits and paths)
struct RawAclRegionConfig {
  // List of rules that grant access to regions of the repo.
  1: list<RawAclRegionRule> allow_rules;
// List of regions to which default access to the repository is denied.
// 2: list<RawAclRegion> deny_default_regions, (not yet implemented)
} (rust.exhaustive)

struct RawAclRegionRule {
  // The name of this region rule.  This is used in error messages and diagnostics.
  1: string name;

  // A list of regions that this rule applies to.
  2: list<RawAclRegion> regions;

  // The hipster ACL that defines who is permitted to access the regions of
  // the repo defined by this rule.
  3: string hipster_acl;
} (rust.exhaustive)

// Define a region of the repository, in terms of commits and path prefixes.
//
// The commit range is equivalent to the Mercurial revset
//     descendants(roots) - descendants(heads)
//
// If the roots and heads lists are both empty then this region covers the
// entire repo.
struct RawAclRegion {
  // List of roots that begin this region.  Any commit that is a descendant of any
  // root, including the root itself, will be included in the region.  If this
  // list is empty then all commits are included (provided they are not the
  // descendant of a head).
  1: list<string> roots;

  // List of heads that end this region.  Any commit that is a descendant of
  // any head, includin the head itself, will NOT be included in the region.
  // If this list is empty then all commits that are descendants of the roots
  // are included.
  2: list<string> heads;

  // List of path prefixes that apply to this region.  Prefixes are in terms of
  // path elements, so the prefix a/b applies to a/b/c but not a/bb.
  3: list<string> path_prefixes;
} (rust.exhaustive)

struct RawCrossRepoCommitValidationConfig {
  // A set of bookmarks to skip when doing bookmark validation
  // Validation reads the bookmarks change log, and looks for commits
  // that could have been made public by a bookmark move.
  //
  // By listing a bookmark here, you avoid validating its commits. Useful
  // for bookmarks that are never meant to be checked out - e.g. import bookmarks,
  // where the merge will be validated when it appears under another bookmark
  1: set<string> skip_bookmarks;
} (rust.exhaustive)

struct RawSparseProfilesConfig {
  // Location where sparse profiles are stored within the repo
  1: string sparse_profiles_location;
  // Excluded paths and files from monitoring
  // used as glob patterns for pathmatchers
  2: optional list<string> excluded_paths;
  // Exact list of monitored profiles.
  // (Profile name relative to sparse_profiles_location)
  // Takes precedence over excludes. If None - monitors all profiles
  3: optional list<string> monitored_profiles;
}

struct RawLoggingDestinationLogger {} (rust.exhaustive)

struct RawLoggingDestinationScribe {
  // Scribe category to log to
  1: string scribe_category;
} (rust.exhaustive)

union RawLoggingDestination {
  // Log to Logger
  1: RawLoggingDestinationLogger logger;
  // Log to a scribe category
  2: RawLoggingDestinationScribe scribe;
}

struct RawUpdateLoggingConfig {
  // Destination to log bookmark updates to
  4: optional RawLoggingDestination bookmark_logging_destination;
  // Destination to log new commits to
  7: optional RawLoggingDestination new_commit_logging_destination;
} (rust.exhaustive)
