/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

import type {Blob, GitObjectID} from './github/types';

import {GeneratedStatus, type GitAttributePattern} from './github/types';
import {LRU} from 'shared/LRU';

/**
 * Default patterns for commonly generated files.
 * These are checked when no .gitattributes patterns match.
 */
const DEFAULT_GENERATED_PATTERNS: RegExp[] = [
  /^yarn\.lock$/,
  /^package-lock\.json$/,
  /^pnpm-lock\.yaml$/,
  /\.min\.js$/,
  /\.min\.css$/,
  /\.bundle\.js$/,
  /\.generated\.\w+$/,
  /[\\/]__generated__[\\/]/,
];

/**
 * Cache for generated status by blob OID.
 * Blob OIDs are immutable (content-addressed), so we can cache forever.
 */
const generatedStatusCache = new LRU<string, GeneratedStatus>(1500);

/**
 * localStorage key prefix for caching .gitattributes patterns per repo.
 */
const GITATTRIBUTES_CACHE_KEY_PREFIX = 'reviewstack:gitattributes:';

/**
 * Detect if a file is generated by scanning its content for markers.
 * Checks the first 1024 bytes for @generated or @partially-generated tags.
 */
export function detectGeneratedFromContent(content: string | null): GeneratedStatus {
  if (content == null) {
    return GeneratedStatus.Manual;
  }

  // Only scan first 1024 bytes
  const header = content.slice(0, 1024);

  if (header.includes('@generated')) {
    return GeneratedStatus.Generated;
  }

  if (header.includes('@partially-generated')) {
    return GeneratedStatus.PartiallyGenerated;
  }

  return GeneratedStatus.Manual;
}

/**
 * Detect if a file is generated based on its blob content.
 * Results are cached by blob OID.
 */
export function detectGeneratedFromBlob(blob: Blob): GeneratedStatus {
  // Check cache first
  const cached = generatedStatusCache.get(blob.oid);
  if (cached !== undefined) {
    return cached;
  }

  // Binary files are not considered generated (can't scan them)
  if (blob.isBinary) {
    generatedStatusCache.set(blob.oid, GeneratedStatus.Manual);
    return GeneratedStatus.Manual;
  }

  const status = detectGeneratedFromContent(blob.text);
  generatedStatusCache.set(blob.oid, status);
  return status;
}

/**
 * Check if a file path matches any of the default generated patterns.
 */
export function matchesDefaultGeneratedPattern(filePath: string): boolean {
  return DEFAULT_GENERATED_PATTERNS.some(pattern => pattern.test(filePath));
}

/**
 * Convert a gitattributes glob pattern to a RegExp.
 * Supports:
 *   - ** matches any path segment(s)
 *   - * matches any characters except /
 *   - ? matches any single character
 *   - Leading / anchors to repo root
 */
export function gitAttributePatternToRegex(pattern: string): RegExp {
  let regexStr = '';
  let i = 0;

  // Handle leading / (anchor to root)
  const anchorToRoot = pattern.startsWith('/');
  if (anchorToRoot) {
    regexStr += '^';
    i = 1;
  }

  while (i < pattern.length) {
    const char = pattern[i];

    if (char === '*') {
      if (pattern[i + 1] === '*') {
        // ** matches any path including /
        if (pattern[i + 2] === '/') {
          // **/ at start or after / means zero or more directories
          regexStr += '(?:.*/)?';
          i += 3;
        } else {
          // ** matches everything
          regexStr += '.*';
          i += 2;
        }
      } else {
        // * matches any characters except /
        regexStr += '[^/]*';
        i += 1;
      }
    } else if (char === '?') {
      // ? matches any single character except /
      regexStr += '[^/]';
      i += 1;
    } else if (char === '.') {
      regexStr += '\\.';
      i += 1;
    } else if (char === '/') {
      regexStr += '/';
      i += 1;
    } else {
      // Escape other regex special characters
      regexStr += char.replace(/[\\^$+{}[\]|()]/g, '\\$&');
      i += 1;
    }
  }

  // If pattern doesn't start with /, it can match at any depth
  if (!anchorToRoot) {
    regexStr = '(?:^|/)' + regexStr;
  }

  // Anchor to end
  regexStr += '$';

  return new RegExp(regexStr);
}

/**
 * Parse .gitattributes file content and extract linguist-generated patterns.
 *
 * Format: each line is "pattern attribute=value" or "pattern attribute"
 * We look for: linguist-generated, linguist-generated=true, -linguist-generated
 */
export function parseGitAttributes(content: string): GitAttributePattern[] {
  const patterns: GitAttributePattern[] = [];

  for (const line of content.split('\n')) {
    const trimmed = line.trim();

    // Skip comments and empty lines
    if (trimmed === '' || trimmed.startsWith('#')) {
      continue;
    }

    // Split into pattern and attributes
    // Pattern can contain spaces if quoted, but we'll handle simple cases
    const match = trimmed.match(/^(\S+)\s+(.+)$/);
    if (!match) {
      continue;
    }

    const [, pattern, attributesStr] = match;

    // Check for linguist-generated attribute
    // Formats: linguist-generated, linguist-generated=true, -linguist-generated
    if (/\blinguist-generated\b/.test(attributesStr)) {
      const isNegated = attributesStr.includes('-linguist-generated');
      const isFalse = /linguist-generated=false/.test(attributesStr);

      patterns.push({
        pattern,
        isGenerated: !isNegated && !isFalse,
      });
    }
  }

  return patterns;
}

/**
 * Check if a file path matches any gitattributes pattern.
 * Returns the matched pattern's isGenerated value, or null if no match.
 */
export function matchGitAttributePatterns(
  filePath: string,
  patterns: GitAttributePattern[],
): boolean | null {
  // Process patterns in order - last match wins (gitattributes semantics)
  let result: boolean | null = null;

  for (const {pattern, isGenerated} of patterns) {
    const regex = gitAttributePatternToRegex(pattern);
    if (regex.test(filePath)) {
      result = isGenerated;
    }
  }

  return result;
}

/**
 * Get the generated status for a file, checking (in order):
 * 1. .gitattributes patterns
 * 2. File content (@generated tag)
 * 3. Default patterns
 */
export function getGeneratedStatus(
  filePath: string,
  gitAttributePatterns: GitAttributePattern[],
  blob: Blob | null,
): GeneratedStatus {
  // 1. Check gitattributes patterns first
  const gitAttrMatch = matchGitAttributePatterns(filePath, gitAttributePatterns);
  if (gitAttrMatch === true) {
    return GeneratedStatus.Generated;
  }
  if (gitAttrMatch === false) {
    // Explicitly marked as not generated
    return GeneratedStatus.Manual;
  }

  // 2. Check blob content for @generated tag
  if (blob != null) {
    const blobStatus = detectGeneratedFromBlob(blob);
    if (blobStatus !== GeneratedStatus.Manual) {
      return blobStatus;
    }
  }

  // 3. Check default patterns
  if (matchesDefaultGeneratedPattern(filePath)) {
    return GeneratedStatus.Generated;
  }

  return GeneratedStatus.Manual;
}

/**
 * Cache .gitattributes patterns in localStorage.
 */
export function cacheGitAttributePatterns(
  owner: string,
  repo: string,
  commitOid: GitObjectID,
  patterns: GitAttributePattern[],
): void {
  const key = `${GITATTRIBUTES_CACHE_KEY_PREFIX}${owner}/${repo}:${commitOid}`;
  try {
    localStorage.setItem(key, JSON.stringify(patterns));
  } catch {
    // localStorage might be full or unavailable
  }
}

/**
 * Retrieve cached .gitattributes patterns from localStorage.
 */
export function getCachedGitAttributePatterns(
  owner: string,
  repo: string,
  commitOid: GitObjectID,
): GitAttributePattern[] | null {
  const key = `${GITATTRIBUTES_CACHE_KEY_PREFIX}${owner}/${repo}:${commitOid}`;
  try {
    const cached = localStorage.getItem(key);
    if (cached != null) {
      return JSON.parse(cached) as GitAttributePattern[];
    }
  } catch {
    // localStorage might be unavailable or corrupted
  }
  return null;
}

/**
 * Clear old .gitattributes cache entries to prevent localStorage bloat.
 * Keeps only the most recent entries per repo.
 */
export function cleanupGitAttributesCache(maxEntriesPerRepo = 5): void {
  try {
    const entries: Array<{key: string; repo: string; time: number}> = [];

    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key?.startsWith(GITATTRIBUTES_CACHE_KEY_PREFIX)) {
        const repoMatch = key.match(/^reviewstack:gitattributes:([^:]+):/);
        if (repoMatch) {
          entries.push({
            key,
            repo: repoMatch[1],
            time: i, // Use index as rough time ordering
          });
        }
      }
    }

    // Group by repo and keep only most recent
    const byRepo = new Map<string, typeof entries>();
    for (const entry of entries) {
      const repoEntries = byRepo.get(entry.repo) ?? [];
      repoEntries.push(entry);
      byRepo.set(entry.repo, repoEntries);
    }

    for (const repoEntries of byRepo.values()) {
      if (repoEntries.length > maxEntriesPerRepo) {
        // Sort by time (most recent last) and remove old entries
        repoEntries.sort((a, b) => a.time - b.time);
        for (let i = 0; i < repoEntries.length - maxEntriesPerRepo; i++) {
          localStorage.removeItem(repoEntries[i].key);
        }
      }
    }
  } catch {
    // Ignore cleanup failures
  }
}
