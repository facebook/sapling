/*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This software may be used and distributed according to the terms of the
 * GNU General Public License found in the LICENSE file in the root
 * directory of this source tree.
 */

use anyhow::Error;
use async_trait::async_trait;
use bookmarks::BookmarkTransactionError;
use context::CoreContext;
use mononoke_types::{BonsaiChangesetMut, ChangesetId};
use sql::Transaction;

use crate::RebasedChangesets;

#[async_trait]
pub trait PushrebaseHook: Send + Sync + 'static {
    /// prepushrebase is called once per pushrebase attempt, concurrently with loading the target
    /// bookmark for pushrebase. It should return a PushrebaseCommitHook for further processing of
    /// the changeset generated by pushrebase.
    async fn prepushrebase(&self) -> Result<Box<dyn PushrebaseCommitHook>, Error>;
}

pub trait PushrebaseCommitHook: Send + Sync + 'static {
    /// post_rebase_changeset is called once per pushrebased changeset, with the ID of the
    /// changeset that was rebased, and a mutable reference to the resulting changeset. This can be
    /// used to modify the pushrebased commit.
    fn post_rebase_changeset(
        &mut self,
        _bcs_old: ChangesetId,
        _bcs_new: &mut BonsaiChangesetMut,
    ) -> Result<(), Error> {
        Ok(())
    }

    /// into_transaction_hook is called after all commits have been pushrebased and we're going to
    /// attempt to move the bookmark to pushrebase onto. This should capture any data necessary and
    /// return a PushrebaseTransactionHook.
    fn into_transaction_hook(
        self: Box<Self>,
        changesets: &RebasedChangesets,
    ) -> Result<Box<dyn PushrebaseTransactionHook>, Error>;
}

#[async_trait]
pub trait PushrebaseTransactionHook: Send + Sync + 'static {
    /// populate_transaction is called once per attempt to update bookmarks in the DB (the
    /// operation might be retried if the write for reasons that are NOT another push having won
    /// the race). This can add extra writes to the transaction if desired.
    async fn populate_transaction(
        &self,
        ctx: &CoreContext,
        txn: Transaction,
    ) -> Result<Transaction, BookmarkTransactionError>;
}
