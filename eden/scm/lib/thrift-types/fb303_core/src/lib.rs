// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct fb303_status(pub ::std::primitive::i32);

    impl fb303_status {
        pub const DEAD: Self = fb303_status(0i32);
        pub const STARTING: Self = fb303_status(1i32);
        pub const ALIVE: Self = fb303_status(2i32);
        pub const STOPPING: Self = fb303_status(3i32);
        pub const STOPPED: Self = fb303_status(4i32);
        pub const WARNING: Self = fb303_status(5i32);

        pub fn variants() -> &'static [&'static str] {
            &[
                "DEAD",
                "STARTING",
                "ALIVE",
                "STOPPING",
                "STOPPED",
                "WARNING",
            ]
        }
    }

    impl ::std::default::Default for fb303_status {
        fn default() -> Self {
            fb303_status(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<fb303_status> for ::std::primitive::i32 {
        #[inline]
        fn from(x: fb303_status) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for fb303_status {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                fb303_status::DEAD => "DEAD",
                fb303_status::STARTING => "STARTING",
                fb303_status::ALIVE => "ALIVE",
                fb303_status::STOPPING => "STOPPING",
                fb303_status::STOPPED => "STOPPED",
                fb303_status::WARNING => "WARNING",
                fb303_status(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for fb303_status {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "fb303_status::{}", self)
        }
    }

    impl ::std::str::FromStr for fb303_status {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "DEAD" => ::std::result::Result::Ok(fb303_status::DEAD),
                "STARTING" => ::std::result::Result::Ok(fb303_status::STARTING),
                "ALIVE" => ::std::result::Result::Ok(fb303_status::ALIVE),
                "STOPPING" => ::std::result::Result::Ok(fb303_status::STOPPING),
                "STOPPED" => ::std::result::Result::Ok(fb303_status::STOPPED),
                "WARNING" => ::std::result::Result::Ok(fb303_status::WARNING),
                _ => ::anyhow::bail!("Unable to parse {} as fb303_status", string),
            }
        }
    }

    impl ::fbthrift::GetTType for fb303_status {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for fb303_status
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(fb303_status::from(p.read_i32()?))
        }
    }
}

pub mod dependencies {
}

pub mod services {
    pub mod base_service {

        #[derive(Clone, Debug)]
        pub enum GetStatusExn {
            Success(crate::types::fb303_status),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatus");
                match self {
                    GetStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I32,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I32, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetNameExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetNameExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetNameExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetNameExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetName");
                match self {
                    GetNameExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetNameExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetNameExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetNameExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNameExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNameExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetVersionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetVersionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetVersionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetVersionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetVersion");
                match self {
                    GetVersionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetVersionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetVersionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetVersionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatusDetailsExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatusDetailsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatusDetailsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatusDetailsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatusDetails");
                match self {
                    GetStatusDetailsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusDetailsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatusDetailsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatusDetailsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusDetailsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusDetailsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounters");
                match self {
                    GetCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetRegexCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexCounters");
                match self {
                    GetRegexCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedCountersExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedCountersExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedCountersExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSelectedCountersExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedCounters");
                match self {
                    GetSelectedCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedCountersExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedCountersExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCounterExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCounterExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCounterExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetCounterExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounter");
                match self {
                    GetCounterExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCounterExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCounterExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCounterExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCounterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCounterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValues");
                match self {
                    GetExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSelectedExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSelectedExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSelectedExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedExportedValues");
                match self {
                    GetSelectedExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSelectedExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSelectedExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexExportedValuesExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetRegexExportedValuesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetRegexExportedValuesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetRegexExportedValuesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexExportedValues");
                match self {
                    GetRegexExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetRegexExportedValuesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetRegexExportedValuesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValueExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetExportedValueExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetExportedValueExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetExportedValueExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValue");
                match self {
                    GetExportedValueExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValueExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetExportedValueExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetExportedValueExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValueExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValueExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetOptionExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetOption");
                match self {
                    SetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetOptionExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetOptionExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionExn {
            Success(::std::string::String),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetOptionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOption");
                match self {
                    GetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionsExn {
            Success(::std::collections::BTreeMap<::std::string::String, ::std::string::String>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetOptionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetOptionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetOptionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOptions");
                match self {
                    GetOptionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetOptionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Map, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetOptionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AliveSinceExn {
            Success(::std::primitive::i64),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AliveSinceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AliveSinceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AliveSinceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AliveSince");
                match self {
                    AliveSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AliveSinceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AliveSinceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(AliveSinceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AliveSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AliveSinceExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct BaseServiceImpl<P, T> {
        transport: T,
        _phantom: ::std::marker::PhantomData<fn() -> P>,
    }

    impl<P, T> BaseServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            Self {
                transport,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn transport(&self) -> &T {
            &self.transport
        }
    }

    pub trait BaseService: ::std::marker::Send {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>>;
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>>;
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>>;
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>>;
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>>;
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>>;
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>>;
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>>;
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>>;
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>>;
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>>;
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>>;
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>>;
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>>;
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>>;
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> BaseService for BaseServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getName",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetNameExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetNameExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetNameExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetNameError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetNameError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetNameError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getVersion",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetVersionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetVersionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetVersionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetVersionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatusDetails",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetStatusDetailsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetStatusDetailsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetStatusDetailsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetStatusDetailsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetCountersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetCountersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetCountersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_regex, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetRegexCountersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetRegexCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetRegexCountersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetRegexCountersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedCounters",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", ::fbthrift::TType::List, 1i16);
                    ::fbthrift::Serialize::write(&arg_keys, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetSelectedCountersExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetSelectedCountersExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetSelectedCountersExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetSelectedCountersError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounter",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetCounterExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetCounterExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetCounterExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetCounterError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetExportedValuesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetExportedValuesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetExportedValuesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", ::fbthrift::TType::List, 1i16);
                    ::fbthrift::Serialize::write(&arg_keys, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetSelectedExportedValuesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetSelectedExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetSelectedExportedValuesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexExportedValues",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_regex, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetRegexExportedValuesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetRegexExportedValuesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetRegexExportedValuesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValue",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetExportedValueExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetExportedValueExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetExportedValueExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetExportedValueError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setOption",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_begin("arg_value", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_value, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::base_service::SetOptionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::SetOptionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::SetOptionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::SetOptionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::SetOptionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOption",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_key, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetOptionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetOptionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetOptionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetOptionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOptions",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::GetOptionsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::GetOptionsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::GetOptionsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::GetOptionsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "aliveSince",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::base_service::AliveSinceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::base_service::AliveSinceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::base_service::AliveSinceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::base_service::AliveSinceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> BaseService for T
    where
        T: ::std::convert::AsRef<dyn BaseService + 'a>,
        T: ::std::marker::Send,
    {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatus(
            )
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getName(
            )
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getVersion(
            )
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatusDetails(
            )
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounters(
            )
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexCounters(
                arg_regex,
            )
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedCounters(
                arg_keys,
            )
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCounter(
                arg_key,
            )
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValues(
            )
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSelectedExportedValues(
                arg_keys,
            )
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getRegexExportedValues(
                arg_regex,
            )
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getExportedValue(
                arg_key,
            )
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setOption(
                arg_key,
                arg_value,
            )
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOption(
                arg_key,
            )
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getOptions(
            )
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().aliveSince(
            )
        }
    }

    pub struct make_BaseService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn BaseService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl BaseService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(BaseServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_BaseService {
        type Api = dyn BaseService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            BaseService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait BaseService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn getStatus(
            &self,
        ) -> ::std::result::Result<crate::types::fb303_status, crate::services::base_service::GetStatusExn> {
            ::std::result::Result::Err(crate::services::base_service::GetStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getStatus",
                ),
            ))
        }
        async fn getName(
            &self,
        ) -> ::std::result::Result<::std::string::String, crate::services::base_service::GetNameExn> {
            ::std::result::Result::Err(crate::services::base_service::GetNameExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getName",
                ),
            ))
        }
        async fn getVersion(
            &self,
        ) -> ::std::result::Result<::std::string::String, crate::services::base_service::GetVersionExn> {
            ::std::result::Result::Err(crate::services::base_service::GetVersionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getVersion",
                ),
            ))
        }
        async fn getStatusDetails(
            &self,
        ) -> ::std::result::Result<::std::string::String, crate::services::base_service::GetStatusDetailsExn> {
            ::std::result::Result::Err(crate::services::base_service::GetStatusDetailsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getStatusDetails",
                ),
            ))
        }
        async fn getCounters(
            &self,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::services::base_service::GetCountersExn> {
            ::std::result::Result::Err(crate::services::base_service::GetCountersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getCounters",
                ),
            ))
        }
        async fn getRegexCounters(
            &self,
            _regex: ::std::string::String,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::services::base_service::GetRegexCountersExn> {
            ::std::result::Result::Err(crate::services::base_service::GetRegexCountersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getRegexCounters",
                ),
            ))
        }
        async fn getSelectedCounters(
            &self,
            _keys: ::std::vec::Vec<::std::string::String>,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::services::base_service::GetSelectedCountersExn> {
            ::std::result::Result::Err(crate::services::base_service::GetSelectedCountersExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getSelectedCounters",
                ),
            ))
        }
        async fn getCounter(
            &self,
            _key: ::std::string::String,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::base_service::GetCounterExn> {
            ::std::result::Result::Err(crate::services::base_service::GetCounterExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getCounter",
                ),
            ))
        }
        async fn getExportedValues(
            &self,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::services::base_service::GetExportedValuesExn> {
            ::std::result::Result::Err(crate::services::base_service::GetExportedValuesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getExportedValues",
                ),
            ))
        }
        async fn getSelectedExportedValues(
            &self,
            _keys: ::std::vec::Vec<::std::string::String>,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::services::base_service::GetSelectedExportedValuesExn> {
            ::std::result::Result::Err(crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getSelectedExportedValues",
                ),
            ))
        }
        async fn getRegexExportedValues(
            &self,
            _regex: ::std::string::String,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::services::base_service::GetRegexExportedValuesExn> {
            ::std::result::Result::Err(crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getRegexExportedValues",
                ),
            ))
        }
        async fn getExportedValue(
            &self,
            _key: ::std::string::String,
        ) -> ::std::result::Result<::std::string::String, crate::services::base_service::GetExportedValueExn> {
            ::std::result::Result::Err(crate::services::base_service::GetExportedValueExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getExportedValue",
                ),
            ))
        }
        async fn setOption(
            &self,
            _key: ::std::string::String,
            _value: ::std::string::String,
        ) -> ::std::result::Result<(), crate::services::base_service::SetOptionExn> {
            ::std::result::Result::Err(crate::services::base_service::SetOptionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "setOption",
                ),
            ))
        }
        async fn getOption(
            &self,
            _key: ::std::string::String,
        ) -> ::std::result::Result<::std::string::String, crate::services::base_service::GetOptionExn> {
            ::std::result::Result::Err(crate::services::base_service::GetOptionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getOption",
                ),
            ))
        }
        async fn getOptions(
            &self,
        ) -> ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::services::base_service::GetOptionsExn> {
            ::std::result::Result::Err(crate::services::base_service::GetOptionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "getOptions",
                ),
            ))
        }
        async fn aliveSince(
            &self,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::base_service::AliveSinceExn> {
            ::std::result::Result::Err(crate::services::base_service::AliveSinceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "BaseService",
                    "aliveSince",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct BaseServiceProcessor<P, H, R> {
        service: H,
        supa: ::fbthrift::NullServiceProcessor<P, R>,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R> BaseServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: BaseService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: ::fbthrift::NullServiceProcessor::new(),
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_getStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatus(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatus",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getName<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getName(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetNameExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetNameExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetNameExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getName",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getName",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getVersion<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getVersion(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetVersionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetVersionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetVersionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getVersion",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getVersion",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getStatusDetails<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatusDetails(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetStatusDetailsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetStatusDetailsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetStatusDetailsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatusDetails",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatusDetails",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCounters(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetCountersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetCountersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCounters",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounters",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getRegexCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_regex = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_regex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getRegexCounters(
                field_regex.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getRegexCounters",
                        "regex",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetRegexCountersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetRegexCountersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetRegexCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getRegexCounters",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexCounters",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSelectedCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_keys = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSelectedCounters(
                field_keys.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSelectedCounters",
                        "keys",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetSelectedCountersExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetSelectedCountersExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetSelectedCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSelectedCounters",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedCounters",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getCounter<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCounter(
                field_key.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getCounter",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetCounterExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetCounterExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetCounterExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCounter",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCounter",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getExportedValues(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetExportedValuesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetExportedValuesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getExportedValues",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValues",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSelectedExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_keys = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_keys = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSelectedExportedValues(
                field_keys.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSelectedExportedValues",
                        "keys",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetSelectedExportedValuesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetSelectedExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSelectedExportedValues",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSelectedExportedValues",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getRegexExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_regex = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_regex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getRegexExportedValues(
                field_regex.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getRegexExportedValues",
                        "regex",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetRegexExportedValuesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetRegexExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getRegexExportedValues",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getRegexExportedValues",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getExportedValue<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getExportedValue(
                field_key.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getExportedValue",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetExportedValueExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetExportedValueExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetExportedValueExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getExportedValue",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getExportedValue",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_setOption<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_key = ::std::option::Option::None;
            let mut field_value = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_value = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.setOption(
                field_key.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setOption",
                        "key",
                    )
                })?,
                field_value.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setOption",
                        "value",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::SetOptionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::SetOptionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::SetOptionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setOption",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setOption",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getOption<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getOption(
                field_key.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getOption",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetOptionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetOptionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetOptionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getOption",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOption",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getOptions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getOptions(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::GetOptionsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::GetOptionsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::GetOptionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getOptions",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getOptions",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_aliveSince<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.aliveSince(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::base_service::AliveSinceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::base_service::AliveSinceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::base_service::AliveSinceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "aliveSince",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "aliveSince",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ServiceProcessor<P> for BaseServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: BaseService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"getStatus" => ::std::result::Result::Ok(0usize),
                b"getName" => ::std::result::Result::Ok(1usize),
                b"getVersion" => ::std::result::Result::Ok(2usize),
                b"getStatusDetails" => ::std::result::Result::Ok(3usize),
                b"getCounters" => ::std::result::Result::Ok(4usize),
                b"getRegexCounters" => ::std::result::Result::Ok(5usize),
                b"getSelectedCounters" => ::std::result::Result::Ok(6usize),
                b"getCounter" => ::std::result::Result::Ok(7usize),
                b"getExportedValues" => ::std::result::Result::Ok(8usize),
                b"getSelectedExportedValues" => ::std::result::Result::Ok(9usize),
                b"getRegexExportedValues" => ::std::result::Result::Ok(10usize),
                b"getExportedValue" => ::std::result::Result::Ok(11usize),
                b"setOption" => ::std::result::Result::Ok(12usize),
                b"getOption" => ::std::result::Result::Ok(13usize),
                b"getOptions" => ::std::result::Result::Ok(14usize),
                b"aliveSince" => ::std::result::Result::Ok(15usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_getStatus(_p, _r, _seqid).await,
                1usize => self.handle_getName(_p, _r, _seqid).await,
                2usize => self.handle_getVersion(_p, _r, _seqid).await,
                3usize => self.handle_getStatusDetails(_p, _r, _seqid).await,
                4usize => self.handle_getCounters(_p, _r, _seqid).await,
                5usize => self.handle_getRegexCounters(_p, _r, _seqid).await,
                6usize => self.handle_getSelectedCounters(_p, _r, _seqid).await,
                7usize => self.handle_getCounter(_p, _r, _seqid).await,
                8usize => self.handle_getExportedValues(_p, _r, _seqid).await,
                9usize => self.handle_getSelectedExportedValues(_p, _r, _seqid).await,
                10usize => self.handle_getRegexExportedValues(_p, _r, _seqid).await,
                11usize => self.handle_getExportedValue(_p, _r, _seqid).await,
                12usize => self.handle_setOption(_p, _r, _seqid).await,
                13usize => self.handle_getOption(_p, _r, _seqid).await,
                14usize => self.handle_getOptions(_p, _r, _seqid).await,
                15usize => self.handle_aliveSince(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "BaseServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R> ::fbthrift::ThriftService<P::Frame> for BaseServiceProcessor<P, H, R>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: BaseService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "BaseServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_BaseService_server<F, H, R>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: BaseService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(BaseServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R>::new(handler)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(BaseServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    pub struct BaseService<'mock> {
        pub getStatus: r#impl::base_service::getStatus<'mock>,
        pub getName: r#impl::base_service::getName<'mock>,
        pub getVersion: r#impl::base_service::getVersion<'mock>,
        pub getStatusDetails: r#impl::base_service::getStatusDetails<'mock>,
        pub getCounters: r#impl::base_service::getCounters<'mock>,
        pub getRegexCounters: r#impl::base_service::getRegexCounters<'mock>,
        pub getSelectedCounters: r#impl::base_service::getSelectedCounters<'mock>,
        pub getCounter: r#impl::base_service::getCounter<'mock>,
        pub getExportedValues: r#impl::base_service::getExportedValues<'mock>,
        pub getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues<'mock>,
        pub getRegexExportedValues: r#impl::base_service::getRegexExportedValues<'mock>,
        pub getExportedValue: r#impl::base_service::getExportedValue<'mock>,
        pub setOption: r#impl::base_service::setOption<'mock>,
        pub getOption: r#impl::base_service::getOption<'mock>,
        pub getOptions: r#impl::base_service::getOptions<'mock>,
        pub aliveSince: r#impl::base_service::aliveSince<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::BaseService {
        pub fn mock<'mock>() -> BaseService<'mock> {
            BaseService {
                getStatus: r#impl::base_service::getStatus::unimplemented(),
                getName: r#impl::base_service::getName::unimplemented(),
                getVersion: r#impl::base_service::getVersion::unimplemented(),
                getStatusDetails: r#impl::base_service::getStatusDetails::unimplemented(),
                getCounters: r#impl::base_service::getCounters::unimplemented(),
                getRegexCounters: r#impl::base_service::getRegexCounters::unimplemented(),
                getSelectedCounters: r#impl::base_service::getSelectedCounters::unimplemented(),
                getCounter: r#impl::base_service::getCounter::unimplemented(),
                getExportedValues: r#impl::base_service::getExportedValues::unimplemented(),
                getSelectedExportedValues: r#impl::base_service::getSelectedExportedValues::unimplemented(),
                getRegexExportedValues: r#impl::base_service::getRegexExportedValues::unimplemented(),
                getExportedValue: r#impl::base_service::getExportedValue::unimplemented(),
                setOption: r#impl::base_service::setOption::unimplemented(),
                getOption: r#impl::base_service::getOption::unimplemented(),
                getOptions: r#impl::base_service::getOptions::unimplemented(),
                aliveSince: r#impl::base_service::aliveSince::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::BaseService for BaseService<'mock> {
        fn getStatus(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::fb303_status, crate::errors::base_service::GetStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getName(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetNameError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getName.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getVersion(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetVersionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getVersion.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getStatusDetails(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetStatusDetailsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatusDetails.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getCounters(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getRegexCounters(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetRegexCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>, crate::errors::base_service::GetSelectedCountersError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedCounters.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getCounter(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::GetCounterError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCounter.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getExportedValues(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetSelectedExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSelectedExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_keys.to_owned())))
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetRegexExportedValuesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getRegexExportedValues.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_regex.to_owned())))
        }
        fn getExportedValue(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetExportedValueError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getExportedValue.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn setOption(
            &self,
            arg_key: &::std::primitive::str,
            arg_value: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::base_service::SetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned(), arg_value.to_owned())))
        }
        fn getOption(
            &self,
            arg_key: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::string::String, crate::errors::base_service::GetOptionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOption.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_key.to_owned())))
        }
        fn getOptions(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::collections::BTreeMap<::std::string::String, ::std::string::String>, crate::errors::base_service::GetOptionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getOptions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn aliveSince(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::base_service::AliveSinceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.aliveSince.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
    }

    mod r#impl {
        pub mod base_service {

            pub struct getStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::fb303_status,
                        crate::errors::base_service::GetStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatus<'mock> {
                pub fn unimplemented() -> Self {
                    getStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::fb303_status) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::fb303_status + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getName<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetNameError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getName<'mock> {
                pub fn unimplemented() -> Self {
                    getName {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getName",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetNameError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getVersion<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetVersionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getVersion<'mock> {
                pub fn unimplemented() -> Self {
                    getVersion {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getVersion",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetVersionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatusDetails<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetStatusDetailsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatusDetails<'mock> {
                pub fn unimplemented() -> Self {
                    getStatusDetails {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getStatusDetails",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetStatusDetailsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetRegexCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedCounters<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
                        crate::errors::base_service::GetSelectedCountersError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedCounters<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedCounters {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedCounters",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedCountersError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCounter<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::GetCounterError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCounter<'mock> {
                pub fn unimplemented() -> Self {
                    getCounter {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getCounter",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetCounterError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSelectedExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetSelectedExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSelectedExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getSelectedExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getSelectedExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::vec::Vec<::std::string::String>) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |keys| ::std::result::Result::Ok(mock(keys)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetSelectedExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getRegexExportedValues<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetRegexExportedValuesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getRegexExportedValues<'mock> {
                pub fn unimplemented() -> Self {
                    getRegexExportedValues {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getRegexExportedValues",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |regex| ::std::result::Result::Ok(mock(regex)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetRegexExportedValuesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getExportedValue<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetExportedValueError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getExportedValue<'mock> {
                pub fn unimplemented() -> Self {
                    getExportedValue {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getExportedValue",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetExportedValueError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String, ::std::string::String) -> ::std::result::Result<
                        (),
                        crate::errors::base_service::SetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setOption<'mock> {
                pub fn unimplemented() -> Self {
                    setOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String, _: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "setOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: ::std::string::String, _: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String, ::std::string::String) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key, value| ::std::result::Result::Ok(mock(key, value)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::SetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String, _: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOption<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        ::std::string::String,
                        crate::errors::base_service::GetOptionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOption<'mock> {
                pub fn unimplemented() -> Self {
                    getOption {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOption",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::string::String) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::string::String + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |key| ::std::result::Result::Ok(mock(key)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getOptions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::collections::BTreeMap<::std::string::String, ::std::string::String>,
                        crate::errors::base_service::GetOptionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getOptions<'mock> {
                pub fn unimplemented() -> Self {
                    getOptions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "getOptions",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::collections::BTreeMap<::std::string::String, ::std::string::String>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::collections::BTreeMap<::std::string::String, ::std::string::String> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::GetOptionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct aliveSince<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::base_service::AliveSinceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> aliveSince<'mock> {
                pub fn unimplemented() -> Self {
                    aliveSince {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "BaseService",
                            "aliveSince",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::base_service::AliveSinceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod base_service {

        pub type GetStatusError = ::fbthrift::NonthrowingFunctionError;

        pub type GetNameError = ::fbthrift::NonthrowingFunctionError;

        pub type GetVersionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetStatusDetailsError = ::fbthrift::NonthrowingFunctionError;

        pub type GetCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetRegexCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSelectedCountersError = ::fbthrift::NonthrowingFunctionError;

        pub type GetCounterError = ::fbthrift::NonthrowingFunctionError;

        pub type GetExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetSelectedExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetRegexExportedValuesError = ::fbthrift::NonthrowingFunctionError;

        pub type GetExportedValueError = ::fbthrift::NonthrowingFunctionError;

        pub type SetOptionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetOptionError = ::fbthrift::NonthrowingFunctionError;

        pub type GetOptionsError = ::fbthrift::NonthrowingFunctionError;

        pub type AliveSinceError = ::fbthrift::NonthrowingFunctionError;

    }

}
