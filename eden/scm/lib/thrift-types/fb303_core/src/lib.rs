// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    use fbthrift::{
        Deserialize, GetTType, ProtocolReader, ProtocolWriter, Serialize, TType,
    };

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct fb303_status(pub i32);

    impl fb303_status {
        pub const DEAD: Self = fb303_status(0i32);
        pub const STARTING: Self = fb303_status(1i32);
        pub const ALIVE: Self = fb303_status(2i32);
        pub const STOPPING: Self = fb303_status(3i32);
        pub const STOPPED: Self = fb303_status(4i32);
        pub const WARNING: Self = fb303_status(5i32);
    }

    impl Default for fb303_status {
        fn default() -> Self {
            fb303_status(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a fb303_status> for i32 {
        #[inline]
        fn from(x: &'a fb303_status) -> i32 {
            x.0
        }
    }

    impl From<fb303_status> for i32 {
        #[inline]
        fn from(x: fb303_status) -> i32 {
            x.0
        }
    }

    impl From<i32> for fb303_status {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for fb303_status {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                fb303_status::DEAD => "DEAD",
                fb303_status::STARTING => "STARTING",
                fb303_status::ALIVE => "ALIVE",
                fb303_status::STOPPING => "STOPPING",
                fb303_status::STOPPED => "STOPPED",
                fb303_status::WARNING => "WARNING",
                fb303_status(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for fb303_status {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "fb303_status", self)
        }
    }

    impl std::str::FromStr for fb303_status {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "DEAD" => Ok(fb303_status::DEAD),
                "STARTING" => Ok(fb303_status::STARTING),
                "ALIVE" => Ok(fb303_status::ALIVE),
                "STOPPING" => Ok(fb303_status::STOPPING),
                "STOPPED" => Ok(fb303_status::STOPPED),
                "WARNING" => Ok(fb303_status::WARNING),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "fb303_status"),
            }
        }
    }

    impl GetTType for fb303_status {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for fb303_status {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for fb303_status {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(fb303_status::from(p.read_i32()?))
        }
    }
}

pub mod services {
    pub mod base_service {
        use fbthrift::{
            ApplicationException, ApplicationExceptionErrorCode, Deserialize, ProtocolReader,
            ProtocolWriter, Serialize, TType,
        };

        #[derive(Clone, Debug)]
        pub enum GetStatusExn {
            Success(crate::types::fb303_status),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetStatusExn {
            fn default() -> Self {
                GetStatusExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetStatusExn {
            fn from(exn: ApplicationException) -> Self {
                GetStatusExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetStatusExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetStatusExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatus");
                match self {
                    GetStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I32,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetStatusExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetStatusExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I32, 0i32), false) => {
                            once = true;
                            alt = Some(GetStatusExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetNameExn {
            Success(String),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetNameExn {
            fn default() -> Self {
                GetNameExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetNameExn {
            fn from(exn: ApplicationException) -> Self {
                GetNameExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetNameExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetNameExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetName");
                match self {
                    GetNameExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetNameExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetNameExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetNameExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(GetNameExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetNameExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetNameExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetVersionExn {
            Success(String),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetVersionExn {
            fn default() -> Self {
                GetVersionExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetVersionExn {
            fn from(exn: ApplicationException) -> Self {
                GetVersionExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetVersionExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetVersionExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetVersion");
                match self {
                    GetVersionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetVersionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetVersionExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetVersionExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(GetVersionExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetVersionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetVersionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatusDetailsExn {
            Success(String),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetStatusDetailsExn {
            fn default() -> Self {
                GetStatusDetailsExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetStatusDetailsExn {
            fn from(exn: ApplicationException) -> Self {
                GetStatusDetailsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetStatusDetailsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetStatusDetailsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatusDetails");
                match self {
                    GetStatusDetailsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatusDetailsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetStatusDetailsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetStatusDetailsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(GetStatusDetailsExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatusDetailsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatusDetailsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCountersExn {
            Success(std::collections::BTreeMap<String, i64>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetCountersExn {
            fn default() -> Self {
                GetCountersExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetCountersExn {
            fn from(exn: ApplicationException) -> Self {
                GetCountersExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetCountersExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetCountersExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounters");
                match self {
                    GetCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetCountersExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetCountersExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetCountersExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexCountersExn {
            Success(std::collections::BTreeMap<String, i64>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetRegexCountersExn {
            fn default() -> Self {
                GetRegexCountersExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetRegexCountersExn {
            fn from(exn: ApplicationException) -> Self {
                GetRegexCountersExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetRegexCountersExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetRegexCountersExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexCounters");
                match self {
                    GetRegexCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetRegexCountersExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetRegexCountersExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetRegexCountersExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedCountersExn {
            Success(std::collections::BTreeMap<String, i64>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetSelectedCountersExn {
            fn default() -> Self {
                GetSelectedCountersExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetSelectedCountersExn {
            fn from(exn: ApplicationException) -> Self {
                GetSelectedCountersExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetSelectedCountersExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetSelectedCountersExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedCounters");
                match self {
                    GetSelectedCountersExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedCountersExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetSelectedCountersExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetSelectedCountersExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetSelectedCountersExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedCountersExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedCountersExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCounterExn {
            Success(i64),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetCounterExn {
            fn default() -> Self {
                GetCounterExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetCounterExn {
            fn from(exn: ApplicationException) -> Self {
                GetCounterExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetCounterExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetCounterExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCounter");
                match self {
                    GetCounterExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCounterExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetCounterExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetCounterExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(GetCounterExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCounterExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCounterExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValuesExn {
            Success(std::collections::BTreeMap<String, String>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetExportedValuesExn {
            fn default() -> Self {
                GetExportedValuesExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetExportedValuesExn {
            fn from(exn: ApplicationException) -> Self {
                GetExportedValuesExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetExportedValuesExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetExportedValuesExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValues");
                match self {
                    GetExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetExportedValuesExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetExportedValuesExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetExportedValuesExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSelectedExportedValuesExn {
            Success(std::collections::BTreeMap<String, String>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetSelectedExportedValuesExn {
            fn default() -> Self {
                GetSelectedExportedValuesExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetSelectedExportedValuesExn {
            fn from(exn: ApplicationException) -> Self {
                GetSelectedExportedValuesExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetSelectedExportedValuesExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetSelectedExportedValuesExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSelectedExportedValues");
                match self {
                    GetSelectedExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSelectedExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetSelectedExportedValuesExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetSelectedExportedValuesExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetSelectedExportedValuesExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSelectedExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSelectedExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetRegexExportedValuesExn {
            Success(std::collections::BTreeMap<String, String>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetRegexExportedValuesExn {
            fn default() -> Self {
                GetRegexExportedValuesExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetRegexExportedValuesExn {
            fn from(exn: ApplicationException) -> Self {
                GetRegexExportedValuesExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetRegexExportedValuesExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetRegexExportedValuesExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetRegexExportedValues");
                match self {
                    GetRegexExportedValuesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetRegexExportedValuesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetRegexExportedValuesExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetRegexExportedValuesExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetRegexExportedValuesExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetRegexExportedValuesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetRegexExportedValuesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetExportedValueExn {
            Success(String),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetExportedValueExn {
            fn default() -> Self {
                GetExportedValueExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetExportedValueExn {
            fn from(exn: ApplicationException) -> Self {
                GetExportedValueExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetExportedValueExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetExportedValueExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetExportedValue");
                match self {
                    GetExportedValueExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetExportedValueExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetExportedValueExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetExportedValueExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(GetExportedValueExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetExportedValueExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetExportedValueExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetOptionExn {
            Success(()),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for SetOptionExn {
            fn default() -> Self {
                SetOptionExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for SetOptionExn {
            fn from(exn: ApplicationException) -> Self {
                SetOptionExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for SetOptionExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for SetOptionExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetOption");
                match self {
                    SetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    SetOptionExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for SetOptionExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetOptionExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetOptionExn::Success(Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionExn {
            Success(String),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetOptionExn {
            fn default() -> Self {
                GetOptionExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetOptionExn {
            fn from(exn: ApplicationException) -> Self {
                GetOptionExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetOptionExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetOptionExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOption");
                match self {
                    GetOptionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetOptionExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetOptionExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::String, 0i32), false) => {
                            once = true;
                            alt = Some(GetOptionExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetOptionsExn {
            Success(std::collections::BTreeMap<String, String>),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for GetOptionsExn {
            fn default() -> Self {
                GetOptionsExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for GetOptionsExn {
            fn from(exn: ApplicationException) -> Self {
                GetOptionsExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for GetOptionsExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for GetOptionsExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetOptions");
                match self {
                    GetOptionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::Map,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetOptionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    GetOptionsExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for GetOptionsExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::Map, 0i32), false) => {
                            once = true;
                            alt = Some(GetOptionsExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetOptionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetOptionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AliveSinceExn {
            Success(i64),
            ApplicationException(::fbthrift::types::ApplicationException),
            UnknownField(i32),
        }

        impl Default for AliveSinceExn {
            fn default() -> Self {
                AliveSinceExn::UnknownField(-1)
            }
        }

        impl From<ApplicationException> for AliveSinceExn {
            fn from(exn: ApplicationException) -> Self {
                AliveSinceExn::ApplicationException(exn)
            }
        }

        impl fbthrift::GetTType for AliveSinceExn {
            const TTYPE: fbthrift::TType = fbthrift::TType::Struct;
        }

        impl<P: ProtocolWriter> Serialize<P> for AliveSinceExn {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AliveSince");
                match self {
                    AliveSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AliveSinceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                    AliveSinceExn::UnknownField(x) => {
                        p.write_field_begin("UnknownField", TType::I32, *x as i16);
                        x.write(p);
                        p.write_field_end();
                    }
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P: ProtocolReader> Deserialize<P> for AliveSinceExn {
            fn read(p: &mut P) -> anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as i32), once) {
                        ((TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((TType::I64, 0i32), false) => {
                            once = true;
                            alt = Some(AliveSinceExn::Success(Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return Err(From::from(
                            ApplicationException::new(
                                ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AliveSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or(
                    ApplicationException::new(
                        ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "AliveSinceExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {
    use fbthrift::*;
    use std::marker::PhantomData;
    use std::sync::Arc;

    pub struct BaseServiceImpl<P, T> {
        transport: T,
        _phantom: PhantomData<fn() -> P>,
    }

    impl<P, T> BaseServiceImpl<P, T> {
        pub fn new(transport: T) -> Self {
            Self {
                transport,
                _phantom: PhantomData,
            }
        }
    }

    pub trait BaseService: Send {
        fn getStatus(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::fb303_status>> + Send + 'static>>;
        fn getName(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>>;
        fn getVersion(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>>;
        fn getStatusDetails(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>>;
        fn getCounters(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>>;
        fn getRegexCounters(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>>;
        fn getSelectedCounters(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>>;
        fn getCounter(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
        fn getExportedValues(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>>;
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>>;
        fn getRegexExportedValues(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>>;
        fn getExportedValue(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>>;
        fn setOption(
            &self,
            arg_key: &str,
            arg_value: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>>;
        fn getOption(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>>;
        fn getOptions(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>>;
        fn aliveSince(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>>;
    }

    impl<P, T> BaseService for BaseServiceImpl<P, T>
    where
        P: Protocol,
        T: Transport,
        P::Frame: Framing<DecBuf = FramingDecoded<T>>,
        ProtocolEncoded<P>: BufMutExt<Final = FramingEncodedFinal<T>>,
    {        fn getStatus(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::fb303_status>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getStatus",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<crate::types::fb303_status> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetStatusExn::read(p)? {
                                    crate::services::base_service::GetStatusExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetStatusError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetStatusError(
                                    crate::services::base_service::GetStatusExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getName(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getName",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<String> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetNameExn::read(p)? {
                                    crate::services::base_service::GetNameExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetNameError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetNameError(
                                    crate::services::base_service::GetNameExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getVersion(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getVersion",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<String> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetVersionExn::read(p)? {
                                    crate::services::base_service::GetVersionExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetVersionError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetVersionError(
                                    crate::services::base_service::GetVersionExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getStatusDetails(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getStatusDetails",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<String> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetStatusDetailsExn::read(p)? {
                                    crate::services::base_service::GetStatusDetailsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetStatusDetailsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetStatusDetailsError(
                                    crate::services::base_service::GetStatusDetailsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCounters(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getCounters",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, i64>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetCountersExn::read(p)? {
                                    crate::services::base_service::GetCountersExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetCountersError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetCountersError(
                                    crate::services::base_service::GetCountersExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getRegexCounters(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getRegexCounters",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", TType::String, 1i16);
                    arg_regex.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, i64>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetRegexCountersExn::read(p)? {
                                    crate::services::base_service::GetRegexCountersExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetRegexCountersError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetRegexCountersError(
                                    crate::services::base_service::GetRegexCountersExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getSelectedCounters",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", TType::List, 1i16);
                    arg_keys.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, i64>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetSelectedCountersExn::read(p)? {
                                    crate::services::base_service::GetSelectedCountersExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetSelectedCountersError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetSelectedCountersError(
                                    crate::services::base_service::GetSelectedCountersExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCounter(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getCounter",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", TType::String, 1i16);
                    arg_key.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetCounterExn::read(p)? {
                                    crate::services::base_service::GetCounterExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetCounterError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetCounterError(
                                    crate::services::base_service::GetCounterExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getExportedValues(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getExportedValues",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, String>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetExportedValuesExn::read(p)? {
                                    crate::services::base_service::GetExportedValuesExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetExportedValuesError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetExportedValuesError(
                                    crate::services::base_service::GetExportedValuesExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getSelectedExportedValues",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_keys", TType::List, 1i16);
                    arg_keys.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, String>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetSelectedExportedValuesExn::read(p)? {
                                    crate::services::base_service::GetSelectedExportedValuesExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetSelectedExportedValuesError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetSelectedExportedValuesError(
                                    crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getRegexExportedValues",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_regex", TType::String, 1i16);
                    arg_regex.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, String>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetRegexExportedValuesExn::read(p)? {
                                    crate::services::base_service::GetRegexExportedValuesExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetRegexExportedValuesError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetRegexExportedValuesError(
                                    crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getExportedValue(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getExportedValue",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", TType::String, 1i16);
                    arg_key.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<String> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetExportedValueExn::read(p)? {
                                    crate::services::base_service::GetExportedValueExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetExportedValueError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetExportedValueError(
                                    crate::services::base_service::GetExportedValueExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setOption(
            &self,
            arg_key: &str,
            arg_value: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "setOption",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", TType::String, 1i16);
                    arg_key.write(p);
                    p.write_field_end();
                    p.write_field_begin("arg_value", TType::String, 2i16);
                    arg_value.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<()> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::SetOptionExn::read(p)? {
                                    crate::services::base_service::SetOptionExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceSetOptionError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceSetOptionError(
                                    crate::services::base_service::SetOptionExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getOption(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getOption",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_key", TType::String, 1i16);
                    arg_key.write(p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<String> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetOptionExn::read(p)? {
                                    crate::services::base_service::GetOptionExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetOptionError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetOptionError(
                                    crate::services::base_service::GetOptionExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getOptions(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "getOptions",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<std::collections::BTreeMap<String, String>> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::GetOptionsExn::read(p)? {
                                    crate::services::base_service::GetOptionsExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceGetOptionsError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceGetOptionsError(
                                    crate::services::base_service::GetOptionsExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn aliveSince(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            use futures_preview::future::{FutureExt, TryFutureExt};
            let request = serialize!(P, |p| protocol::write_message(
                p,
                "aliveSince",
                MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport
                .call(request)
                .and_then(|reply| futures_preview::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> anyhow::Result<i64> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            MessageType::Reply => {
                                match crate::services::base_service::AliveSinceExn::read(p)? {
                                    crate::services::base_service::AliveSinceExn::Success(res) => Ok(res),
                                    exn => Err(crate::errors::ErrorKind::BaseServiceAliveSinceError(exn).into()),
                                }
                            }
                            MessageType::Exception => {
                                let ae = ApplicationException::read(p)?;
                                Err(crate::errors::ErrorKind::BaseServiceAliveSinceError(
                                    crate::services::base_service::AliveSinceExn::ApplicationException(ae),
                                ).into())
                            }
                            MessageType::Call | MessageType::Oneway | MessageType::InvalidMessageType => {
                                anyhow::bail!("Unexpected message type {:?}", message_type)
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    pub struct make_BaseService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn BaseService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> Arc<impl BaseService + Send + 'static>
        where
            P: Protocol<Frame = T>,
            T: Transport,
        {
            let _ = protocol;
            Arc::new(BaseServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ClientFactory for make_BaseService {
        type Api = dyn BaseService + Send + Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> Arc<Self::Api>
        where
            P: Protocol<Frame = T>,
            T: Transport + Sync,
        {
            BaseService::new(protocol, transport)
        }
    }
}

pub mod server {
    use async_trait::async_trait;
    use fbthrift::*;
    use std::marker::PhantomData;

    #[async_trait]
    pub trait BaseService: Send + Sync + 'static {
        async fn getStatus(
            &self,
        ) -> Result<crate::types::fb303_status, crate::services::base_service::GetStatusExn> {
            Err(crate::services::base_service::GetStatusExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getStatus",
                ),
            ))
        }
        async fn getName(
            &self,
        ) -> Result<String, crate::services::base_service::GetNameExn> {
            Err(crate::services::base_service::GetNameExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getName",
                ),
            ))
        }
        async fn getVersion(
            &self,
        ) -> Result<String, crate::services::base_service::GetVersionExn> {
            Err(crate::services::base_service::GetVersionExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getVersion",
                ),
            ))
        }
        async fn getStatusDetails(
            &self,
        ) -> Result<String, crate::services::base_service::GetStatusDetailsExn> {
            Err(crate::services::base_service::GetStatusDetailsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getStatusDetails",
                ),
            ))
        }
        async fn getCounters(
            &self,
        ) -> Result<std::collections::BTreeMap<String, i64>, crate::services::base_service::GetCountersExn> {
            Err(crate::services::base_service::GetCountersExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getCounters",
                ),
            ))
        }
        async fn getRegexCounters(
            &self,
            _regex: String,
        ) -> Result<std::collections::BTreeMap<String, i64>, crate::services::base_service::GetRegexCountersExn> {
            Err(crate::services::base_service::GetRegexCountersExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getRegexCounters",
                ),
            ))
        }
        async fn getSelectedCounters(
            &self,
            _keys: Vec<String>,
        ) -> Result<std::collections::BTreeMap<String, i64>, crate::services::base_service::GetSelectedCountersExn> {
            Err(crate::services::base_service::GetSelectedCountersExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getSelectedCounters",
                ),
            ))
        }
        async fn getCounter(
            &self,
            _key: String,
        ) -> Result<i64, crate::services::base_service::GetCounterExn> {
            Err(crate::services::base_service::GetCounterExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getCounter",
                ),
            ))
        }
        async fn getExportedValues(
            &self,
        ) -> Result<std::collections::BTreeMap<String, String>, crate::services::base_service::GetExportedValuesExn> {
            Err(crate::services::base_service::GetExportedValuesExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getExportedValues",
                ),
            ))
        }
        async fn getSelectedExportedValues(
            &self,
            _keys: Vec<String>,
        ) -> Result<std::collections::BTreeMap<String, String>, crate::services::base_service::GetSelectedExportedValuesExn> {
            Err(crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getSelectedExportedValues",
                ),
            ))
        }
        async fn getRegexExportedValues(
            &self,
            _regex: String,
        ) -> Result<std::collections::BTreeMap<String, String>, crate::services::base_service::GetRegexExportedValuesExn> {
            Err(crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getRegexExportedValues",
                ),
            ))
        }
        async fn getExportedValue(
            &self,
            _key: String,
        ) -> Result<String, crate::services::base_service::GetExportedValueExn> {
            Err(crate::services::base_service::GetExportedValueExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getExportedValue",
                ),
            ))
        }
        async fn setOption(
            &self,
            _key: String,
            _value: String,
        ) -> Result<(), crate::services::base_service::SetOptionExn> {
            Err(crate::services::base_service::SetOptionExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "setOption",
                ),
            ))
        }
        async fn getOption(
            &self,
            _key: String,
        ) -> Result<String, crate::services::base_service::GetOptionExn> {
            Err(crate::services::base_service::GetOptionExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getOption",
                ),
            ))
        }
        async fn getOptions(
            &self,
        ) -> Result<std::collections::BTreeMap<String, String>, crate::services::base_service::GetOptionsExn> {
            Err(crate::services::base_service::GetOptionsExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "getOptions",
                ),
            ))
        }
        async fn aliveSince(
            &self,
        ) -> Result<i64, crate::services::base_service::AliveSinceExn> {
            Err(crate::services::base_service::AliveSinceExn::ApplicationException(
                ApplicationException::unimplemented_method(
                    "BaseService",
                    "aliveSince",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct BaseServiceProcessor<P, H, R> {
        service: H,
        supa: fbthrift::NullServiceProcessor<P, R>,
        _phantom: PhantomData<(P, H, R)>,
    }

    impl<P, H, R> BaseServiceProcessor<P, H, R>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        H: BaseService,
    {
        pub fn new(service: H) -> Self {
            Self {
                service,
                supa: fbthrift::NullServiceProcessor::new(),
                _phantom: PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_getStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatus(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetStatusExn::Success(res)
                }
                Err(crate::services::base_service::GetStatusExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatus",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getStatus",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getName<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getName(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetNameExn::Success(res)
                }
                Err(crate::services::base_service::GetNameExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetNameExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getName",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getName",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getVersion<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getVersion(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetVersionExn::Success(res)
                }
                Err(crate::services::base_service::GetVersionExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetVersionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getVersion",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getVersion",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getStatusDetails<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatusDetails(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetStatusDetailsExn::Success(res)
                }
                Err(crate::services::base_service::GetStatusDetailsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetStatusDetailsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatusDetails",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getStatusDetails",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCounters(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetCountersExn::Success(res)
                }
                Err(crate::services::base_service::GetCountersExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCounters",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getCounters",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getRegexCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_regex = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_regex = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getRegexCounters(
                field_regex.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getRegexCounters",
                        "regex",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetRegexCountersExn::Success(res)
                }
                Err(crate::services::base_service::GetRegexCountersExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetRegexCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getRegexCounters",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getRegexCounters",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getSelectedCounters<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_keys = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::List, 1) => field_keys = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSelectedCounters(
                field_keys.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getSelectedCounters",
                        "keys",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetSelectedCountersExn::Success(res)
                }
                Err(crate::services::base_service::GetSelectedCountersExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetSelectedCountersExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSelectedCounters",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getSelectedCounters",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getCounter<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_key = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_key = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCounter(
                field_key.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getCounter",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetCounterExn::Success(res)
                }
                Err(crate::services::base_service::GetCounterExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetCounterExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCounter",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getCounter",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getExportedValues(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetExportedValuesExn::Success(res)
                }
                Err(crate::services::base_service::GetExportedValuesExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getExportedValues",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getExportedValues",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getSelectedExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_keys = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::List, 1) => field_keys = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSelectedExportedValues(
                field_keys.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getSelectedExportedValues",
                        "keys",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetSelectedExportedValuesExn::Success(res)
                }
                Err(crate::services::base_service::GetSelectedExportedValuesExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetSelectedExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSelectedExportedValues",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getSelectedExportedValues",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getRegexExportedValues<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_regex = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_regex = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getRegexExportedValues(
                field_regex.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getRegexExportedValues",
                        "regex",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetRegexExportedValuesExn::Success(res)
                }
                Err(crate::services::base_service::GetRegexExportedValuesExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetRegexExportedValuesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getRegexExportedValues",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getRegexExportedValues",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getExportedValue<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_key = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_key = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getExportedValue(
                field_key.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getExportedValue",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetExportedValueExn::Success(res)
                }
                Err(crate::services::base_service::GetExportedValueExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetExportedValueExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getExportedValue",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getExportedValue",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_setOption<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_key = None;
            let mut field_value = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_key = Some(Deserialize::read(p)?),
                    (TType::String, 2) => field_value = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.setOption(
                field_key.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "setOption",
                        "key",
                    )
                })?,
                field_value.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "setOption",
                        "value",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::SetOptionExn::Success(res)
                }
                Err(crate::services::base_service::SetOptionExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::SetOptionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setOption",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "setOption",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getOption<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut field_key = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_key = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getOption(
                field_key.ok_or_else(|| {
                    ApplicationException::missing_arg(
                        "getOption",
                        "key",
                    )
                })?,
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetOptionExn::Success(res)
                }
                Err(crate::services::base_service::GetOptionExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetOptionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getOption",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getOption",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_getOptions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getOptions(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::GetOptionsExn::Success(res)
                }
                Err(crate::services::base_service::GetOptionsExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::GetOptionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getOptions",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "getOptions",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }

        async fn handle_aliveSince<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.aliveSince(
            ).await;
            let res = match res {
                Ok(res) => {
                    crate::services::base_service::AliveSinceExn::Success(res)
                }
                Err(crate::services::base_service::AliveSinceExn::ApplicationException(aexn)) => {
                    return Err(aexn.into())
                }
                Err(crate::services::base_service::AliveSinceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "aliveSince",
                    )
                }
                Err(exn) => exn,
            };
            let res = serialize!(P, |p| fbthrift::protocol::write_message(
                p,
                "aliveSince",
                MessageType::Reply,
                seqid,
                |p| res.write(p),
            ));
            Ok(res)
        }
    }

    #[async_trait]
    impl<P, H, R> fbthrift::ServiceProcessor<P> for BaseServiceProcessor<P, H, R>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        H: BaseService,
        R: Send + Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[u8]) -> Result<usize, ApplicationException> {
            match name {
                b"getStatus" => Ok(0usize),
                b"getName" => Ok(1usize),
                b"getVersion" => Ok(2usize),
                b"getStatusDetails" => Ok(3usize),
                b"getCounters" => Ok(4usize),
                b"getRegexCounters" => Ok(5usize),
                b"getSelectedCounters" => Ok(6usize),
                b"getCounter" => Ok(7usize),
                b"getExportedValues" => Ok(8usize),
                b"getSelectedExportedValues" => Ok(9usize),
                b"getRegexExportedValues" => Ok(10usize),
                b"getExportedValue" => Ok(11usize),
                b"setOption" => Ok(12usize),
                b"getOption" => Ok(13usize),
                b"getOptions" => Ok(14usize),
                b"aliveSince" => Ok(15usize),
                _ => Err(ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: usize,
            p: &mut P::Deserializer,
            r: &R,
            seqid: u32,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_getStatus(p, r, seqid).await,
                1usize => self.handle_getName(p, r, seqid).await,
                2usize => self.handle_getVersion(p, r, seqid).await,
                3usize => self.handle_getStatusDetails(p, r, seqid).await,
                4usize => self.handle_getCounters(p, r, seqid).await,
                5usize => self.handle_getRegexCounters(p, r, seqid).await,
                6usize => self.handle_getSelectedCounters(p, r, seqid).await,
                7usize => self.handle_getCounter(p, r, seqid).await,
                8usize => self.handle_getExportedValues(p, r, seqid).await,
                9usize => self.handle_getSelectedExportedValues(p, r, seqid).await,
                10usize => self.handle_getRegexExportedValues(p, r, seqid).await,
                11usize => self.handle_getExportedValue(p, r, seqid).await,
                12usize => self.handle_setOption(p, r, seqid).await,
                13usize => self.handle_getOption(p, r, seqid).await,
                14usize => self.handle_getOptions(p, r, seqid).await,
                15usize => self.handle_aliveSince(p, r, seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "BaseServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[async_trait]
    impl<P, H, R> ThriftService<P::Frame> for BaseServiceProcessor<P, H, R>
    where
        P: Protocol + Send + Sync + 'static,
        P::Deserializer: Send,
        P::Frame: Send + 'static,
        H: BaseService,
        R: Send + Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> anyhow::Result<ProtocolEncodedFinal<P>> {
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != MessageType::Call {
                return Err(From::from(ApplicationException::new(
                    ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                Ok(idx) => idx,
                Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                Ok(bytes) => Ok(bytes),
                Err(err) => match err.downcast_ref::<fbthrift::ProtocolError>() {
                    Some(fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = serialize!(P, |p| {
                            fbthrift::protocol::write_message(
                                p,
                                "BaseServiceProcessor",
                                MessageType::Exception,
                                seqid,
                                |p| ae.write(p),
                            )
                        });
                        Ok(res)
                    }
                    _ => Err(err),
                },
            }
        }
    }

    pub fn make_BaseService_server<F, H, R>(
        proto: ProtocolID,
        handler: H,
    ) -> Result<Box<dyn ThriftService<F, Handler = H, RequestContext = R> + Send + 'static>, ApplicationException>
    where
        F: Framing + Send + Sync + 'static,
        H: BaseService,
        R: Send + Sync + 'static,
    {
        match proto {
            ProtocolID::BinaryProtocol => {
                Ok(Box::new(BaseServiceProcessor::<BinaryProtocol<F>, H, R>::new(handler)))
            }
            ProtocolID::CompactProtocol => {
                Ok(Box::new(BaseServiceProcessor::<CompactProtocol<F>, H, R>::new(handler)))
            }
            bad => Err(ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    use async_trait::async_trait;
    use std::marker::PhantomData;

    pub struct BaseService<'mock> {
        pub getStatus: base_service::getStatus<'mock>,
        pub getName: base_service::getName<'mock>,
        pub getVersion: base_service::getVersion<'mock>,
        pub getStatusDetails: base_service::getStatusDetails<'mock>,
        pub getCounters: base_service::getCounters<'mock>,
        pub getRegexCounters: base_service::getRegexCounters<'mock>,
        pub getSelectedCounters: base_service::getSelectedCounters<'mock>,
        pub getCounter: base_service::getCounter<'mock>,
        pub getExportedValues: base_service::getExportedValues<'mock>,
        pub getSelectedExportedValues: base_service::getSelectedExportedValues<'mock>,
        pub getRegexExportedValues: base_service::getRegexExportedValues<'mock>,
        pub getExportedValue: base_service::getExportedValue<'mock>,
        pub setOption: base_service::setOption<'mock>,
        pub getOption: base_service::getOption<'mock>,
        pub getOptions: base_service::getOptions<'mock>,
        pub aliveSince: base_service::aliveSince<'mock>,
        _marker: PhantomData<&'mock ()>,
    }

    impl dyn super::client::BaseService {
        pub fn mock<'mock>() -> BaseService<'mock> {
            BaseService {
                getStatus: base_service::getStatus::unimplemented(),
                getName: base_service::getName::unimplemented(),
                getVersion: base_service::getVersion::unimplemented(),
                getStatusDetails: base_service::getStatusDetails::unimplemented(),
                getCounters: base_service::getCounters::unimplemented(),
                getRegexCounters: base_service::getRegexCounters::unimplemented(),
                getSelectedCounters: base_service::getSelectedCounters::unimplemented(),
                getCounter: base_service::getCounter::unimplemented(),
                getExportedValues: base_service::getExportedValues::unimplemented(),
                getSelectedExportedValues: base_service::getSelectedExportedValues::unimplemented(),
                getRegexExportedValues: base_service::getRegexExportedValues::unimplemented(),
                getExportedValue: base_service::getExportedValue::unimplemented(),
                setOption: base_service::setOption::unimplemented(),
                getOption: base_service::getOption::unimplemented(),
                getOptions: base_service::getOptions::unimplemented(),
                aliveSince: base_service::aliveSince::unimplemented(),
                _marker: PhantomData,
            }
        }
    }

    #[async_trait]
    impl<'mock> super::client::BaseService for BaseService<'mock> {
        fn getStatus(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<crate::types::fb303_status>> + Send + 'static>> {
            let mut closure = self.getStatus.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetStatusError(error),
                ))))
        }
        fn getName(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            let mut closure = self.getName.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetNameError(error),
                ))))
        }
        fn getVersion(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            let mut closure = self.getVersion.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetVersionError(error),
                ))))
        }
        fn getStatusDetails(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            let mut closure = self.getStatusDetails.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetStatusDetailsError(error),
                ))))
        }
        fn getCounters(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            let mut closure = self.getCounters.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetCountersError(error),
                ))))
        }
        fn getRegexCounters(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            let mut closure = self.getRegexCounters.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_regex.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetRegexCountersError(error),
                ))))
        }
        fn getSelectedCounters(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, i64>>> + Send + 'static>> {
            let mut closure = self.getSelectedCounters.closure.lock().unwrap();
            let closure: &mut dyn FnMut(Vec<String>) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_keys.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetSelectedCountersError(error),
                ))))
        }
        fn getCounter(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.getCounter.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_key.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetCounterError(error),
                ))))
        }
        fn getExportedValues(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            let mut closure = self.getExportedValues.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetExportedValuesError(error),
                ))))
        }
        fn getSelectedExportedValues(
            &self,
            arg_keys: &[String],
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            let mut closure = self.getSelectedExportedValues.closure.lock().unwrap();
            let closure: &mut dyn FnMut(Vec<String>) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_keys.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetSelectedExportedValuesError(error),
                ))))
        }
        fn getRegexExportedValues(
            &self,
            arg_regex: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            let mut closure = self.getRegexExportedValues.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_regex.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetRegexExportedValuesError(error),
                ))))
        }
        fn getExportedValue(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            let mut closure = self.getExportedValue.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_key.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetExportedValueError(error),
                ))))
        }
        fn setOption(
            &self,
            arg_key: &str,
            arg_value: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<()>> + Send + 'static>> {
            let mut closure = self.setOption.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String, String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_key.to_owned(), arg_value.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceSetOptionError(error),
                ))))
        }
        fn getOption(
            &self,
            arg_key: &str,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<String>> + Send + 'static>> {
            let mut closure = self.getOption.closure.lock().unwrap();
            let closure: &mut dyn FnMut(String) -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure(arg_key.to_owned())
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetOptionError(error),
                ))))
        }
        fn getOptions(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<std::collections::BTreeMap<String, String>>> + Send + 'static>> {
            let mut closure = self.getOptions.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceGetOptionsError(error),
                ))))
        }
        fn aliveSince(
            &self,
        ) -> std::pin::Pin<Box<dyn std::future::Future<Output = anyhow::Result<i64>> + Send + 'static>> {
            let mut closure = self.aliveSince.closure.lock().unwrap();
            let closure: &mut dyn FnMut() -> _ = &mut **closure;
            Box::pin(futures_preview::future::ready(closure()
                .map_err(|error| anyhow::Error::from(
                    crate::errors::ErrorKind::BaseServiceAliveSinceError(error),
                ))))
        }
    }

    mod base_service {
        use std::sync::Mutex;

        pub struct getStatus<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    crate::types::fb303_status,
                    crate::services::base_service::GetStatusExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getStatus<'mock> {
            pub fn unimplemented() -> Self {
                getStatus {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getStatus",
                    ))),
                }
            }

            pub fn ret(&self, value: crate::types::fb303_status) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> crate::types::fb303_status + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetStatusExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getName<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    String,
                    crate::services::base_service::GetNameExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getName<'mock> {
            pub fn unimplemented() -> Self {
                getName {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getName",
                    ))),
                }
            }

            pub fn ret(&self, value: String) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> String + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetNameExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getVersion<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    String,
                    crate::services::base_service::GetVersionExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getVersion<'mock> {
            pub fn unimplemented() -> Self {
                getVersion {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getVersion",
                    ))),
                }
            }

            pub fn ret(&self, value: String) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> String + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetVersionExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getStatusDetails<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    String,
                    crate::services::base_service::GetStatusDetailsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getStatusDetails<'mock> {
            pub fn unimplemented() -> Self {
                getStatusDetails {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getStatusDetails",
                    ))),
                }
            }

            pub fn ret(&self, value: String) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> String + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetStatusDetailsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getCounters<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    std::collections::BTreeMap<String, i64>,
                    crate::services::base_service::GetCountersExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getCounters<'mock> {
            pub fn unimplemented() -> Self {
                getCounters {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getCounters",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, i64>) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> std::collections::BTreeMap<String, i64> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetCountersExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getRegexCounters<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    std::collections::BTreeMap<String, i64>,
                    crate::services::base_service::GetRegexCountersExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getRegexCounters<'mock> {
            pub fn unimplemented() -> Self {
                getRegexCounters {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getRegexCounters",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, i64>) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> std::collections::BTreeMap<String, i64> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |regex| Ok(mock(regex)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetRegexCountersExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct getSelectedCounters<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(Vec<String>) -> Result<
                    std::collections::BTreeMap<String, i64>,
                    crate::services::base_service::GetSelectedCountersExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getSelectedCounters<'mock> {
            pub fn unimplemented() -> Self {
                getSelectedCounters {
                    closure: Mutex::new(Box::new(|_: Vec<String>| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getSelectedCounters",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, i64>) {
                self.mock(move |_: Vec<String>| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(Vec<String>) -> std::collections::BTreeMap<String, i64> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |keys| Ok(mock(keys)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetSelectedCountersExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: Vec<String>| Err(exception.clone().into()));
            }
        }

        pub struct getCounter<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    i64,
                    crate::services::base_service::GetCounterExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getCounter<'mock> {
            pub fn unimplemented() -> Self {
                getCounter {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getCounter",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |key| Ok(mock(key)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetCounterExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct getExportedValues<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    std::collections::BTreeMap<String, String>,
                    crate::services::base_service::GetExportedValuesExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getExportedValues<'mock> {
            pub fn unimplemented() -> Self {
                getExportedValues {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getExportedValues",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, String>) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> std::collections::BTreeMap<String, String> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetExportedValuesExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct getSelectedExportedValues<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(Vec<String>) -> Result<
                    std::collections::BTreeMap<String, String>,
                    crate::services::base_service::GetSelectedExportedValuesExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getSelectedExportedValues<'mock> {
            pub fn unimplemented() -> Self {
                getSelectedExportedValues {
                    closure: Mutex::new(Box::new(|_: Vec<String>| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getSelectedExportedValues",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, String>) {
                self.mock(move |_: Vec<String>| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(Vec<String>) -> std::collections::BTreeMap<String, String> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |keys| Ok(mock(keys)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetSelectedExportedValuesExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: Vec<String>| Err(exception.clone().into()));
            }
        }

        pub struct getRegexExportedValues<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    std::collections::BTreeMap<String, String>,
                    crate::services::base_service::GetRegexExportedValuesExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getRegexExportedValues<'mock> {
            pub fn unimplemented() -> Self {
                getRegexExportedValues {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getRegexExportedValues",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, String>) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> std::collections::BTreeMap<String, String> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |regex| Ok(mock(regex)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetRegexExportedValuesExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct getExportedValue<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    String,
                    crate::services::base_service::GetExportedValueExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getExportedValue<'mock> {
            pub fn unimplemented() -> Self {
                getExportedValue {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getExportedValue",
                    ))),
                }
            }

            pub fn ret(&self, value: String) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> String + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |key| Ok(mock(key)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetExportedValueExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct setOption<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String, String) -> Result<
                    (),
                    crate::services::base_service::SetOptionExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> setOption<'mock> {
            pub fn unimplemented() -> Self {
                setOption {
                    closure: Mutex::new(Box::new(|_: String, _: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "setOption",
                    ))),
                }
            }

            pub fn ret(&self, value: ()) {
                self.mock(move |_: String, _: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String, String) -> () + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |key, value| Ok(mock(key, value)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::SetOptionExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String, _: String| Err(exception.clone().into()));
            }
        }

        pub struct getOption<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut(String) -> Result<
                    String,
                    crate::services::base_service::GetOptionExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getOption<'mock> {
            pub fn unimplemented() -> Self {
                getOption {
                    closure: Mutex::new(Box::new(|_: String| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getOption",
                    ))),
                }
            }

            pub fn ret(&self, value: String) {
                self.mock(move |_: String| value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut(String) -> String + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |key| Ok(mock(key)));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetOptionExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move |_: String| Err(exception.clone().into()));
            }
        }

        pub struct getOptions<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    std::collections::BTreeMap<String, String>,
                    crate::services::base_service::GetOptionsExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> getOptions<'mock> {
            pub fn unimplemented() -> Self {
                getOptions {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "getOptions",
                    ))),
                }
            }

            pub fn ret(&self, value: std::collections::BTreeMap<String, String>) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> std::collections::BTreeMap<String, String> + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::GetOptionsExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }

        pub struct aliveSince<'mock> {
            pub(super) closure: Mutex<Box<
                dyn FnMut() -> Result<
                    i64,
                    crate::services::base_service::AliveSinceExn,
                > + Send + Sync + 'mock,
            >>,
        }

        impl<'mock> aliveSince<'mock> {
            pub fn unimplemented() -> Self {
                aliveSince {
                    closure: Mutex::new(Box::new(|| panic!(
                        "{}::{} is not mocked",
                        "BaseService",
                        "aliveSince",
                    ))),
                }
            }

            pub fn ret(&self, value: i64) {
                self.mock(move || value.clone());
            }

            pub fn mock(&self, mut mock: impl FnMut() -> i64 + Send + Sync + 'mock) {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Ok(mock()));
            }

            pub fn throw<E>(&self, exception: E)
            where
                E: Into<crate::services::base_service::AliveSinceExn>,
                E: Clone + Send + Sync + 'mock,
            {
                let mut closure = self.closure.lock().unwrap();
                *closure = Box::new(move || Err(exception.clone().into()));
            }
        }
    }
}

pub mod errors {
    use fbthrift::ApplicationException;
    use thiserror::Error;

    #[derive(Debug, Error)]
    pub enum ErrorKind {
        #[error("BaseService::getStatus failed with {0:?}")]
        BaseServiceGetStatusError(crate::services::base_service::GetStatusExn),
        #[error("BaseService::getName failed with {0:?}")]
        BaseServiceGetNameError(crate::services::base_service::GetNameExn),
        #[error("BaseService::getVersion failed with {0:?}")]
        BaseServiceGetVersionError(crate::services::base_service::GetVersionExn),
        #[error("BaseService::getStatusDetails failed with {0:?}")]
        BaseServiceGetStatusDetailsError(crate::services::base_service::GetStatusDetailsExn),
        #[error("BaseService::getCounters failed with {0:?}")]
        BaseServiceGetCountersError(crate::services::base_service::GetCountersExn),
        #[error("BaseService::getRegexCounters failed with {0:?}")]
        BaseServiceGetRegexCountersError(crate::services::base_service::GetRegexCountersExn),
        #[error("BaseService::getSelectedCounters failed with {0:?}")]
        BaseServiceGetSelectedCountersError(crate::services::base_service::GetSelectedCountersExn),
        #[error("BaseService::getCounter failed with {0:?}")]
        BaseServiceGetCounterError(crate::services::base_service::GetCounterExn),
        #[error("BaseService::getExportedValues failed with {0:?}")]
        BaseServiceGetExportedValuesError(crate::services::base_service::GetExportedValuesExn),
        #[error("BaseService::getSelectedExportedValues failed with {0:?}")]
        BaseServiceGetSelectedExportedValuesError(crate::services::base_service::GetSelectedExportedValuesExn),
        #[error("BaseService::getRegexExportedValues failed with {0:?}")]
        BaseServiceGetRegexExportedValuesError(crate::services::base_service::GetRegexExportedValuesExn),
        #[error("BaseService::getExportedValue failed with {0:?}")]
        BaseServiceGetExportedValueError(crate::services::base_service::GetExportedValueExn),
        #[error("BaseService::setOption failed with {0:?}")]
        BaseServiceSetOptionError(crate::services::base_service::SetOptionExn),
        #[error("BaseService::getOption failed with {0:?}")]
        BaseServiceGetOptionError(crate::services::base_service::GetOptionExn),
        #[error("BaseService::getOptions failed with {0:?}")]
        BaseServiceGetOptionsError(crate::services::base_service::GetOptionsExn),
        #[error("BaseService::aliveSince failed with {0:?}")]
        BaseServiceAliveSinceError(crate::services::base_service::AliveSinceExn),
        #[error("Application exception: {0:?}")]
        ApplicationException(ApplicationException),
    }

    impl From<ApplicationException> for ErrorKind {
        fn from(exn: ApplicationException) -> Self {
            ErrorKind::ApplicationException(exn)
        }
    }
}
