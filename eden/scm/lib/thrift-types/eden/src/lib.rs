// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    #![allow(clippy::redundant_closure)]


    pub type unsigned64 = ::std::primitive::i64;

    pub type pid_t = ::std::primitive::i32;

    pub type BinaryHash = ::std::vec::Vec<::std::primitive::u8>;

    pub type PathString = ::std::vec::Vec<::std::primitive::u8>;

    pub type OsDtype = ::std::primitive::i16;

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenError {
        #[serde(default)]
        pub message: ::std::string::String,
        pub errorCode: ::std::option::Option<::std::primitive::i32>,
        #[serde(default)]
        pub errorType: crate::types::EdenErrorType,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct NoValueForKeyError {
        #[serde(default)]
        pub key: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DaemonInfo {
        #[serde(default)]
        pub pid: ::std::primitive::i32,
        #[serde(default)]
        pub commandLine: ::std::vec::Vec<::std::string::String>,
        pub status: ::std::option::Option<fb303_core::types::fb303_status>,
        pub uptime: ::std::option::Option<::std::primitive::f32>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountInfo {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub edenClientPath: crate::types::PathString,
        #[serde(default)]
        pub state: crate::types::MountState,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountArgument {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub edenClientPath: crate::types::PathString,
        #[serde(default)]
        pub readOnly: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub enum SHA1Result {
        sha1(crate::types::BinaryHash),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TimeSpec {
        #[serde(default)]
        pub seconds: ::std::primitive::i64,
        #[serde(default)]
        pub nanoSeconds: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EntryInformation {
        #[serde(default)]
        pub dtype: crate::types::Dtype,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub enum EntryInformationOrError {
        info(crate::types::EntryInformation),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FileInformation {
        #[serde(default)]
        pub size: crate::types::unsigned64,
        #[serde(default)]
        pub mtime: crate::types::TimeSpec,
        #[serde(default)]
        pub mode: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub enum FileInformationOrError {
        info(crate::types::FileInformation),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct JournalPosition {
        #[serde(default)]
        pub mountGeneration: ::std::primitive::i64,
        #[serde(default)]
        pub sequenceNumber: crate::types::unsigned64,
        #[serde(default)]
        pub snapshotHash: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FileDelta {
        #[serde(default)]
        pub fromPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub toPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub changedPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub createdPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub removedPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub uncleanPaths: ::std::vec::Vec<crate::types::PathString>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugGetRawJournalParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        pub limit: ::std::option::Option<::std::primitive::i32>,
        #[serde(default)]
        pub fromSequenceNumber: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugPathChangeInfo {
        #[serde(default)]
        pub existedBefore: ::std::primitive::bool,
        #[serde(default)]
        pub existedAfter: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugJournalDelta {
        #[serde(default)]
        pub fromPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub toPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub changedPaths: ::std::collections::BTreeMap<crate::types::PathString, crate::types::DebugPathChangeInfo>,
        #[serde(default)]
        pub uncleanPaths: ::std::collections::BTreeSet<crate::types::PathString>,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugGetRawJournalResponse {
        #[serde(default)]
        pub allDeltas: ::std::vec::Vec<crate::types::DebugJournalDelta>,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmStatus {
        #[serde(default)]
        pub entries: ::std::collections::BTreeMap<crate::types::PathString, crate::types::ScmFileStatus>,
        #[serde(default)]
        pub errors: ::std::collections::BTreeMap<crate::types::PathString, ::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CheckoutConflict {
        #[serde(default)]
        pub path: crate::types::PathString,
        #[serde(rename = "type")]
        #[serde(default)]
        pub type_: crate::types::ConflictType,
        #[serde(default)]
        pub message: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmBlobMetadata {
        #[serde(default)]
        pub size: ::std::primitive::i64,
        #[serde(default)]
        pub contentsSha1: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmTreeEntry {
        #[serde(default)]
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub mode: ::std::primitive::i32,
        #[serde(default)]
        pub id: crate::types::BinaryHash,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TreeInodeEntryDebugInfo {
        #[serde(default)]
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub inodeNumber: ::std::primitive::i64,
        #[serde(default)]
        pub mode: ::std::primitive::i32,
        #[serde(default)]
        pub loaded: ::std::primitive::bool,
        #[serde(default)]
        pub materialized: ::std::primitive::bool,
        #[serde(default)]
        pub hash: crate::types::BinaryHash,
        pub fileSize: ::std::option::Option<::std::primitive::i64>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct WorkingDirectoryParents {
        #[serde(default)]
        pub parent1: crate::types::BinaryHash,
        pub parent2: ::std::option::Option<crate::types::BinaryHash>,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TreeInodeDebugInfo {
        #[serde(default)]
        pub inodeNumber: ::std::primitive::i64,
        #[serde(default)]
        pub path: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub materialized: ::std::primitive::bool,
        #[serde(default)]
        pub treeHash: crate::types::BinaryHash,
        #[serde(default)]
        pub entries: ::std::vec::Vec<crate::types::TreeInodeEntryDebugInfo>,
        #[serde(default)]
        pub refcount: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct InodePathDebugInfo {
        #[serde(default)]
        pub path: crate::types::PathString,
        #[serde(default)]
        pub loaded: ::std::primitive::bool,
        #[serde(default)]
        pub linked: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct SetLogLevelResult {
        #[serde(default)]
        pub categoryCreated: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct JournalInfo {
        #[serde(default)]
        pub entryCount: ::std::primitive::i64,
        #[serde(default)]
        pub memoryUsage: ::std::primitive::i64,
        #[serde(default)]
        pub durationSeconds: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountInodeInfo {
        #[serde(default)]
        pub unloadedInodeCount: ::std::primitive::i64,
        #[serde(default)]
        pub loadedFileCount: ::std::primitive::i64,
        #[serde(default)]
        pub loadedTreeCount: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CacheStats {
        #[serde(default)]
        pub entryCount: ::std::primitive::i64,
        #[serde(default)]
        pub totalSizeInBytes: ::std::primitive::i64,
        #[serde(default)]
        pub hitCount: ::std::primitive::i64,
        #[serde(default)]
        pub missCount: ::std::primitive::i64,
        #[serde(default)]
        pub evictionCount: ::std::primitive::i64,
        #[serde(default)]
        pub dropCount: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct InternalStats {
        #[serde(default)]
        pub periodicUnloadCount: ::std::primitive::i64,
        #[serde(default)]
        pub counters: ::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>,
        #[serde(default)]
        pub mountPointInfo: ::std::collections::BTreeMap<crate::types::PathString, crate::types::MountInodeInfo>,
        #[serde(default)]
        pub smaps: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub privateBytes: ::std::primitive::i64,
        #[serde(default)]
        pub vmRSSBytes: ::std::primitive::i64,
        #[serde(default)]
        pub blobCacheStats: crate::types::CacheStats,
        #[serde(default)]
        pub mountPointJournalInfo: ::std::collections::BTreeMap<crate::types::PathString, crate::types::JournalInfo>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ManifestEntry {
        #[serde(default)]
        pub mode: ::std::primitive::i32,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FuseCall {
        #[serde(default)]
        pub len: ::std::primitive::i32,
        #[serde(default)]
        pub opcode: ::std::primitive::i32,
        #[serde(default)]
        pub unique: ::std::primitive::i64,
        #[serde(default)]
        pub nodeid: ::std::primitive::i64,
        #[serde(default)]
        pub uid: ::std::primitive::i32,
        #[serde(default)]
        pub gid: ::std::primitive::i32,
        #[serde(default)]
        pub pid: crate::types::pid_t,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetConfigParams {
        #[serde(default)]
        pub reload: eden_config::types::ConfigReloadBehavior,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GlobParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub globs: ::std::vec::Vec<::std::string::String>,
        #[serde(default)]
        pub includeDotfiles: ::std::primitive::bool,
        #[serde(default)]
        pub prefetchFiles: ::std::primitive::bool,
        #[serde(default)]
        pub suppressFileList: ::std::primitive::bool,
        #[serde(default)]
        pub wantDtype: ::std::primitive::bool,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct Glob {
        #[serde(default)]
        pub matchingFiles: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub dtypes: ::std::vec::Vec<crate::types::OsDtype>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct AccessCounts {
        #[serde(default)]
        pub fuseTotal: ::std::primitive::i64,
        #[serde(default)]
        pub fuseReads: ::std::primitive::i64,
        #[serde(default)]
        pub fuseWrites: ::std::primitive::i64,
        #[serde(default)]
        pub fuseBackingStoreImports: ::std::primitive::i64,
        #[serde(default)]
        pub fuseDurationNs: ::std::primitive::i64,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountAccesses {
        #[serde(default)]
        pub accessCountsByPid: ::std::collections::BTreeMap<crate::types::pid_t, crate::types::AccessCounts>,
        #[serde(default)]
        pub fetchCountsByPid: ::std::collections::BTreeMap<crate::types::pid_t, ::std::primitive::i64>,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetAccessCountsResult {
        #[serde(default)]
        pub cmdsByPid: ::std::collections::BTreeMap<crate::types::pid_t, ::std::vec::Vec<::std::primitive::u8>>,
        #[serde(default)]
        pub accessesByMount: ::std::collections::BTreeMap<crate::types::PathString, crate::types::MountAccesses>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TracePoint {
        #[serde(default)]
        pub timestamp: ::std::primitive::i64,
        #[serde(default)]
        pub traceId: ::std::primitive::i64,
        #[serde(default)]
        pub blockId: ::std::primitive::i64,
        #[serde(default)]
        pub parentBlockId: ::std::primitive::i64,
        #[serde(default)]
        pub name: ::std::string::String,
        #[serde(default)]
        pub event: crate::types::TracePointEvent,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FaultDefinition {
        #[serde(default)]
        pub keyClass: ::std::string::String,
        #[serde(default)]
        pub keyValueRegex: ::std::string::String,
        #[serde(default)]
        pub count: ::std::primitive::i64,
        #[serde(default)]
        pub block: ::std::primitive::bool,
        #[serde(default)]
        pub delayMilliseconds: ::std::primitive::i64,
        pub errorType: ::std::option::Option<::std::string::String>,
        pub errorMessage: ::std::option::Option<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct RemoveFaultArg {
        #[serde(default)]
        pub keyClass: ::std::string::String,
        #[serde(default)]
        pub keyValueRegex: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct UnblockFaultArg {
        pub keyClass: ::std::option::Option<::std::string::String>,
        pub keyValueRegex: ::std::option::Option<::std::string::String>,
        pub errorType: ::std::option::Option<::std::string::String>,
        pub errorMessage: ::std::option::Option<::std::string::String>,
    }

    #[derive(Clone, Debug, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetScmStatusResult {
        #[serde(default)]
        pub status: crate::types::ScmStatus,
        #[serde(default)]
        pub version: ::std::string::String,
    }

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetScmStatusParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub commit: crate::types::BinaryHash,
        #[serde(default)]
        pub listIgnored: ::std::primitive::bool,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenErrorType(pub ::std::primitive::i32);

    impl EdenErrorType {
        pub const POSIX_ERROR: Self = EdenErrorType(0i32);
        pub const WIN32_ERROR: Self = EdenErrorType(1i32);
        pub const HRESULT_ERROR: Self = EdenErrorType(2i32);
        pub const ARGUMENT_ERROR: Self = EdenErrorType(3i32);
        pub const GENERIC_ERROR: Self = EdenErrorType(4i32);
        pub const MOUNT_GENERATION_CHANGED: Self = EdenErrorType(5i32);
        pub const JOURNAL_TRUNCATED: Self = EdenErrorType(6i32);
        pub const CHECKOUT_IN_PROGRESS: Self = EdenErrorType(7i32);
        pub const OUT_OF_DATE_PARENT: Self = EdenErrorType(8i32);
    }

    impl ::std::default::Default for EdenErrorType {
        fn default() -> Self {
            EdenErrorType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EdenErrorType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EdenErrorType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EdenErrorType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EdenErrorType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EdenErrorType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EdenErrorType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                EdenErrorType::POSIX_ERROR => "POSIX_ERROR",
                EdenErrorType::WIN32_ERROR => "WIN32_ERROR",
                EdenErrorType::HRESULT_ERROR => "HRESULT_ERROR",
                EdenErrorType::ARGUMENT_ERROR => "ARGUMENT_ERROR",
                EdenErrorType::GENERIC_ERROR => "GENERIC_ERROR",
                EdenErrorType::MOUNT_GENERATION_CHANGED => "MOUNT_GENERATION_CHANGED",
                EdenErrorType::JOURNAL_TRUNCATED => "JOURNAL_TRUNCATED",
                EdenErrorType::CHECKOUT_IN_PROGRESS => "CHECKOUT_IN_PROGRESS",
                EdenErrorType::OUT_OF_DATE_PARENT => "OUT_OF_DATE_PARENT",
                EdenErrorType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for EdenErrorType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EdenErrorType::{}", self)
        }
    }

    impl ::std::str::FromStr for EdenErrorType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "POSIX_ERROR" => ::std::result::Result::Ok(EdenErrorType::POSIX_ERROR),
                "WIN32_ERROR" => ::std::result::Result::Ok(EdenErrorType::WIN32_ERROR),
                "HRESULT_ERROR" => ::std::result::Result::Ok(EdenErrorType::HRESULT_ERROR),
                "ARGUMENT_ERROR" => ::std::result::Result::Ok(EdenErrorType::ARGUMENT_ERROR),
                "GENERIC_ERROR" => ::std::result::Result::Ok(EdenErrorType::GENERIC_ERROR),
                "MOUNT_GENERATION_CHANGED" => ::std::result::Result::Ok(EdenErrorType::MOUNT_GENERATION_CHANGED),
                "JOURNAL_TRUNCATED" => ::std::result::Result::Ok(EdenErrorType::JOURNAL_TRUNCATED),
                "CHECKOUT_IN_PROGRESS" => ::std::result::Result::Ok(EdenErrorType::CHECKOUT_IN_PROGRESS),
                "OUT_OF_DATE_PARENT" => ::std::result::Result::Ok(EdenErrorType::OUT_OF_DATE_PARENT),
                _ => ::anyhow::bail!("Unable to parse {} as EdenErrorType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for EdenErrorType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EdenErrorType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EdenErrorType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EdenErrorType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountState(pub ::std::primitive::i32);

    impl MountState {
        pub const UNINITIALIZED: Self = MountState(0i32);
        pub const INITIALIZING: Self = MountState(1i32);
        pub const INITIALIZED: Self = MountState(2i32);
        pub const STARTING: Self = MountState(3i32);
        pub const RUNNING: Self = MountState(4i32);
        pub const FUSE_ERROR: Self = MountState(5i32);
        pub const SHUTTING_DOWN: Self = MountState(6i32);
        pub const SHUT_DOWN: Self = MountState(7i32);
        pub const DESTROYING: Self = MountState(8i32);
        pub const INIT_ERROR: Self = MountState(9i32);
    }

    impl ::std::default::Default for MountState {
        fn default() -> Self {
            MountState(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a MountState> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a MountState) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<MountState> for ::std::primitive::i32 {
        #[inline]
        fn from(x: MountState) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for MountState {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for MountState {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                MountState::UNINITIALIZED => "UNINITIALIZED",
                MountState::INITIALIZING => "INITIALIZING",
                MountState::INITIALIZED => "INITIALIZED",
                MountState::STARTING => "STARTING",
                MountState::RUNNING => "RUNNING",
                MountState::FUSE_ERROR => "FUSE_ERROR",
                MountState::SHUTTING_DOWN => "SHUTTING_DOWN",
                MountState::SHUT_DOWN => "SHUT_DOWN",
                MountState::DESTROYING => "DESTROYING",
                MountState::INIT_ERROR => "INIT_ERROR",
                MountState(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for MountState {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "MountState::{}", self)
        }
    }

    impl ::std::str::FromStr for MountState {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "UNINITIALIZED" => ::std::result::Result::Ok(MountState::UNINITIALIZED),
                "INITIALIZING" => ::std::result::Result::Ok(MountState::INITIALIZING),
                "INITIALIZED" => ::std::result::Result::Ok(MountState::INITIALIZED),
                "STARTING" => ::std::result::Result::Ok(MountState::STARTING),
                "RUNNING" => ::std::result::Result::Ok(MountState::RUNNING),
                "FUSE_ERROR" => ::std::result::Result::Ok(MountState::FUSE_ERROR),
                "SHUTTING_DOWN" => ::std::result::Result::Ok(MountState::SHUTTING_DOWN),
                "SHUT_DOWN" => ::std::result::Result::Ok(MountState::SHUT_DOWN),
                "DESTROYING" => ::std::result::Result::Ok(MountState::DESTROYING),
                "INIT_ERROR" => ::std::result::Result::Ok(MountState::INIT_ERROR),
                _ => ::anyhow::bail!("Unable to parse {} as MountState", string),
            }
        }
    }

    impl ::fbthrift::GetTType for MountState {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for MountState
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for MountState
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(MountState::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmFileStatus(pub ::std::primitive::i32);

    impl ScmFileStatus {
        pub const ADDED: Self = ScmFileStatus(0i32);
        pub const MODIFIED: Self = ScmFileStatus(1i32);
        pub const REMOVED: Self = ScmFileStatus(2i32);
        pub const IGNORED: Self = ScmFileStatus(3i32);
    }

    impl ::std::default::Default for ScmFileStatus {
        fn default() -> Self {
            ScmFileStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ScmFileStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ScmFileStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ScmFileStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ScmFileStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ScmFileStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ScmFileStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ScmFileStatus::ADDED => "ADDED",
                ScmFileStatus::MODIFIED => "MODIFIED",
                ScmFileStatus::REMOVED => "REMOVED",
                ScmFileStatus::IGNORED => "IGNORED",
                ScmFileStatus(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ScmFileStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ScmFileStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for ScmFileStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "ADDED" => ::std::result::Result::Ok(ScmFileStatus::ADDED),
                "MODIFIED" => ::std::result::Result::Ok(ScmFileStatus::MODIFIED),
                "REMOVED" => ::std::result::Result::Ok(ScmFileStatus::REMOVED),
                "IGNORED" => ::std::result::Result::Ok(ScmFileStatus::IGNORED),
                _ => ::anyhow::bail!("Unable to parse {} as ScmFileStatus", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ScmFileStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ScmFileStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ScmFileStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ScmFileStatus::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CheckoutMode(pub ::std::primitive::i32);

    impl CheckoutMode {
        pub const NORMAL: Self = CheckoutMode(0i32);
        pub const DRY_RUN: Self = CheckoutMode(1i32);
        pub const FORCE: Self = CheckoutMode(2i32);
    }

    impl ::std::default::Default for CheckoutMode {
        fn default() -> Self {
            CheckoutMode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a CheckoutMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a CheckoutMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<CheckoutMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: CheckoutMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for CheckoutMode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for CheckoutMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                CheckoutMode::NORMAL => "NORMAL",
                CheckoutMode::DRY_RUN => "DRY_RUN",
                CheckoutMode::FORCE => "FORCE",
                CheckoutMode(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for CheckoutMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "CheckoutMode::{}", self)
        }
    }

    impl ::std::str::FromStr for CheckoutMode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "NORMAL" => ::std::result::Result::Ok(CheckoutMode::NORMAL),
                "DRY_RUN" => ::std::result::Result::Ok(CheckoutMode::DRY_RUN),
                "FORCE" => ::std::result::Result::Ok(CheckoutMode::FORCE),
                _ => ::anyhow::bail!("Unable to parse {} as CheckoutMode", string),
            }
        }
    }

    impl ::fbthrift::GetTType for CheckoutMode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for CheckoutMode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for CheckoutMode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(CheckoutMode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConflictType(pub ::std::primitive::i32);

    impl ConflictType {
        pub const ERROR: Self = ConflictType(0i32);
        pub const MODIFIED_REMOVED: Self = ConflictType(1i32);
        pub const UNTRACKED_ADDED: Self = ConflictType(2i32);
        pub const REMOVED_MODIFIED: Self = ConflictType(3i32);
        pub const MISSING_REMOVED: Self = ConflictType(4i32);
        pub const MODIFIED_MODIFIED: Self = ConflictType(5i32);
        pub const DIRECTORY_NOT_EMPTY: Self = ConflictType(6i32);
    }

    impl ::std::default::Default for ConflictType {
        fn default() -> Self {
            ConflictType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConflictType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConflictType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConflictType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConflictType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConflictType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConflictType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                ConflictType::ERROR => "ERROR",
                ConflictType::MODIFIED_REMOVED => "MODIFIED_REMOVED",
                ConflictType::UNTRACKED_ADDED => "UNTRACKED_ADDED",
                ConflictType::REMOVED_MODIFIED => "REMOVED_MODIFIED",
                ConflictType::MISSING_REMOVED => "MISSING_REMOVED",
                ConflictType::MODIFIED_MODIFIED => "MODIFIED_MODIFIED",
                ConflictType::DIRECTORY_NOT_EMPTY => "DIRECTORY_NOT_EMPTY",
                ConflictType(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for ConflictType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConflictType::{}", self)
        }
    }

    impl ::std::str::FromStr for ConflictType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "ERROR" => ::std::result::Result::Ok(ConflictType::ERROR),
                "MODIFIED_REMOVED" => ::std::result::Result::Ok(ConflictType::MODIFIED_REMOVED),
                "UNTRACKED_ADDED" => ::std::result::Result::Ok(ConflictType::UNTRACKED_ADDED),
                "REMOVED_MODIFIED" => ::std::result::Result::Ok(ConflictType::REMOVED_MODIFIED),
                "MISSING_REMOVED" => ::std::result::Result::Ok(ConflictType::MISSING_REMOVED),
                "MODIFIED_MODIFIED" => ::std::result::Result::Ok(ConflictType::MODIFIED_MODIFIED),
                "DIRECTORY_NOT_EMPTY" => ::std::result::Result::Ok(ConflictType::DIRECTORY_NOT_EMPTY),
                _ => ::anyhow::bail!("Unable to parse {} as ConflictType", string),
            }
        }
    }

    impl ::fbthrift::GetTType for ConflictType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConflictType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConflictType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConflictType::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct Dtype(pub ::std::primitive::i32);

    impl Dtype {
        pub const UNKNOWN: Self = Dtype(0i32);
        pub const FIFO: Self = Dtype(1i32);
        pub const CHAR: Self = Dtype(2i32);
        pub const DIR: Self = Dtype(4i32);
        pub const BLOCK: Self = Dtype(6i32);
        pub const REGULAR: Self = Dtype(8i32);
        pub const LINK: Self = Dtype(10i32);
        pub const SOCKET: Self = Dtype(12i32);
        pub const WHITEOUT: Self = Dtype(14i32);
    }

    impl ::std::default::Default for Dtype {
        fn default() -> Self {
            Dtype(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Dtype> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Dtype) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Dtype> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Dtype) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Dtype {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Dtype {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                Dtype::UNKNOWN => "UNKNOWN",
                Dtype::FIFO => "FIFO",
                Dtype::CHAR => "CHAR",
                Dtype::DIR => "DIR",
                Dtype::BLOCK => "BLOCK",
                Dtype::REGULAR => "REGULAR",
                Dtype::LINK => "LINK",
                Dtype::SOCKET => "SOCKET",
                Dtype::WHITEOUT => "WHITEOUT",
                Dtype(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for Dtype {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Dtype::{}", self)
        }
    }

    impl ::std::str::FromStr for Dtype {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "UNKNOWN" => ::std::result::Result::Ok(Dtype::UNKNOWN),
                "FIFO" => ::std::result::Result::Ok(Dtype::FIFO),
                "CHAR" => ::std::result::Result::Ok(Dtype::CHAR),
                "DIR" => ::std::result::Result::Ok(Dtype::DIR),
                "BLOCK" => ::std::result::Result::Ok(Dtype::BLOCK),
                "REGULAR" => ::std::result::Result::Ok(Dtype::REGULAR),
                "LINK" => ::std::result::Result::Ok(Dtype::LINK),
                "SOCKET" => ::std::result::Result::Ok(Dtype::SOCKET),
                "WHITEOUT" => ::std::result::Result::Ok(Dtype::WHITEOUT),
                _ => ::anyhow::bail!("Unable to parse {} as Dtype", string),
            }
        }
    }

    impl ::fbthrift::GetTType for Dtype {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Dtype
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Dtype
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Dtype::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TracePointEvent(pub ::std::primitive::i32);

    impl TracePointEvent {
        pub const START: Self = TracePointEvent(0i32);
        pub const STOP: Self = TracePointEvent(1i32);
    }

    impl ::std::default::Default for TracePointEvent {
        fn default() -> Self {
            TracePointEvent(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a TracePointEvent> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a TracePointEvent) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<TracePointEvent> for ::std::primitive::i32 {
        #[inline]
        fn from(x: TracePointEvent) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for TracePointEvent {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for TracePointEvent {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            let s: &::std::primitive::str = match *self {
                TracePointEvent::START => "START",
                TracePointEvent::STOP => "STOP",
                TracePointEvent(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl ::std::fmt::Debug for TracePointEvent {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "TracePointEvent::{}", self)
        }
    }

    impl ::std::str::FromStr for TracePointEvent {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            match string {
                "START" => ::std::result::Result::Ok(TracePointEvent::START),
                "STOP" => ::std::result::Result::Ok(TracePointEvent::STOP),
                _ => ::anyhow::bail!("Unable to parse {} as TracePointEvent", string),
            }
        }
    }

    impl ::fbthrift::GetTType for TracePointEvent {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for TracePointEvent
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for TracePointEvent
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(TracePointEvent::from(p.read_i32()?))
        }
    }






    impl ::std::default::Default for self::EdenError {
        fn default() -> Self {
            Self {
                message: ::std::default::Default::default(),
                errorCode: ::std::option::Option::None,
                errorType: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EdenError {}
    unsafe impl ::std::marker::Sync for self::EdenError {}

    impl ::fbthrift::GetTType for self::EdenError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdenError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenError");
            p.write_field_begin("message", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.message, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.errorCode {
                p.write_field_begin("errorCode", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("errorType", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.errorType, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdenError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_message = ::std::option::Option::None;
            let mut field_errorCode = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_message = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_errorCode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                message: field_message.unwrap_or_default(),
                errorCode: field_errorCode,
                errorType: field_errorType.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::NoValueForKeyError {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::NoValueForKeyError {}
    unsafe impl ::std::marker::Sync for self::NoValueForKeyError {}

    impl ::fbthrift::GetTType for self::NoValueForKeyError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NoValueForKeyError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NoValueForKeyError");
            p.write_field_begin("key", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NoValueForKeyError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DaemonInfo {
        fn default() -> Self {
            Self {
                pid: ::std::default::Default::default(),
                commandLine: ::std::default::Default::default(),
                status: ::std::option::Option::None,
                uptime: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DaemonInfo {}
    unsafe impl ::std::marker::Sync for self::DaemonInfo {}

    impl ::fbthrift::GetTType for self::DaemonInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DaemonInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DaemonInfo");
            p.write_field_begin("pid", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_begin("commandLine", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.commandLine, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.status {
                p.write_field_begin("status", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.uptime {
                p.write_field_begin("uptime", ::fbthrift::TType::Float, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DaemonInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_pid = ::std::option::Option::None;
            let mut field_commandLine = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_uptime = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_pid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_commandLine = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Float, 4) => field_uptime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                pid: field_pid.unwrap_or_default(),
                commandLine: field_commandLine.unwrap_or_default(),
                status: field_status,
                uptime: field_uptime,
            })
        }
    }


    impl ::std::default::Default for self::MountInfo {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                edenClientPath: ::std::default::Default::default(),
                state: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MountInfo {}
    unsafe impl ::std::marker::Sync for self::MountInfo {}

    impl ::fbthrift::GetTType for self::MountInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInfo");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_begin("state", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.state, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_edenClientPath = ::std::option::Option::None;
            let mut field_state = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edenClientPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_state = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
                state: field_state.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MountArgument {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                edenClientPath: ::std::default::Default::default(),
                readOnly: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MountArgument {}
    unsafe impl ::std::marker::Sync for self::MountArgument {}

    impl ::fbthrift::GetTType for self::MountArgument {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountArgument
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountArgument");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_begin("readOnly", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.readOnly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountArgument
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_edenClientPath = ::std::option::Option::None;
            let mut field_readOnly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edenClientPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_readOnly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
                readOnly: field_readOnly.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for SHA1Result {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for SHA1Result {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for SHA1Result
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SHA1Result");
            match self {
                SHA1Result::sha1(inner) => {
                    p.write_field_begin("sha1", ::fbthrift::TType::String, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for SHA1Result
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::String, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SHA1Result::sha1(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SHA1Result::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "SHA1Result",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::TimeSpec {
        fn default() -> Self {
            Self {
                seconds: ::std::default::Default::default(),
                nanoSeconds: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TimeSpec {}
    unsafe impl ::std::marker::Sync for self::TimeSpec {}

    impl ::fbthrift::GetTType for self::TimeSpec {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TimeSpec
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TimeSpec");
            p.write_field_begin("seconds", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.seconds, p);
            p.write_field_end();
            p.write_field_begin("nanoSeconds", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.nanoSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TimeSpec
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_seconds = ::std::option::Option::None;
            let mut field_nanoSeconds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_seconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_nanoSeconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                seconds: field_seconds.unwrap_or_default(),
                nanoSeconds: field_nanoSeconds.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::EntryInformation {
        fn default() -> Self {
            Self {
                dtype: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::EntryInformation {}
    unsafe impl ::std::marker::Sync for self::EntryInformation {}

    impl ::fbthrift::GetTType for self::EntryInformation {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EntryInformation
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EntryInformation");
            p.write_field_begin("dtype", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.dtype, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EntryInformation
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_dtype = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_dtype = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dtype: field_dtype.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for EntryInformationOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for EntryInformationOrError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for EntryInformationOrError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EntryInformationOrError");
            match self {
                EntryInformationOrError::info(inner) => {
                    p.write_field_begin("info", ::fbthrift::TType::Struct, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryInformationOrError::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryInformationOrError::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EntryInformationOrError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::Struct, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryInformationOrError::info(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryInformationOrError::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "EntryInformationOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::FileInformation {
        fn default() -> Self {
            Self {
                size: ::std::default::Default::default(),
                mtime: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::FileInformation {}
    unsafe impl ::std::marker::Sync for self::FileInformation {}

    impl ::fbthrift::GetTType for self::FileInformation {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FileInformation
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformation");
            p.write_field_begin("size", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("mtime", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.mtime, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FileInformation
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_size = ::std::option::Option::None;
            let mut field_mtime = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_mtime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                size: field_size.unwrap_or_default(),
                mtime: field_mtime.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
            })
        }
    }



    impl ::std::default::Default for FileInformationOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for FileInformationOrError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for FileInformationOrError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformationOrError");
            match self {
                FileInformationOrError::info(inner) => {
                    p.write_field_begin("info", ::fbthrift::TType::Struct, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::UnknownField(x) => {
                    p.write_field_begin("UnknownField", ::fbthrift::TType::I32, *x as ::std::primitive::i16);
                    x.write(p);
                    p.write_field_end();
                }
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for FileInformationOrError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::Struct, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileInformationOrError::info(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileInformationOrError::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "FileInformationOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::JournalPosition {
        fn default() -> Self {
            Self {
                mountGeneration: ::std::default::Default::default(),
                sequenceNumber: ::std::default::Default::default(),
                snapshotHash: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::JournalPosition {}
    unsafe impl ::std::marker::Sync for self::JournalPosition {}

    impl ::fbthrift::GetTType for self::JournalPosition {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JournalPosition
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalPosition");
            p.write_field_begin("mountGeneration", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.mountGeneration, p);
            p.write_field_end();
            p.write_field_begin("sequenceNumber", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.sequenceNumber, p);
            p.write_field_end();
            p.write_field_begin("snapshotHash", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.snapshotHash, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JournalPosition
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountGeneration = ::std::option::Option::None;
            let mut field_sequenceNumber = ::std::option::Option::None;
            let mut field_snapshotHash = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_mountGeneration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_sequenceNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_snapshotHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountGeneration: field_mountGeneration.unwrap_or_default(),
                sequenceNumber: field_sequenceNumber.unwrap_or_default(),
                snapshotHash: field_snapshotHash.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::FileDelta {
        fn default() -> Self {
            Self {
                fromPosition: ::std::default::Default::default(),
                toPosition: ::std::default::Default::default(),
                changedPaths: ::std::default::Default::default(),
                createdPaths: ::std::default::Default::default(),
                removedPaths: ::std::default::Default::default(),
                uncleanPaths: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::FileDelta {}
    unsafe impl ::std::marker::Sync for self::FileDelta {}

    impl ::fbthrift::GetTType for self::FileDelta {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FileDelta
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileDelta");
            p.write_field_begin("fromPosition", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("createdPaths", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.createdPaths, p);
            p.write_field_end();
            p.write_field_begin("removedPaths", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.removedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FileDelta
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_fromPosition = ::std::option::Option::None;
            let mut field_toPosition = ::std::option::Option::None;
            let mut field_changedPaths = ::std::option::Option::None;
            let mut field_createdPaths = ::std::option::Option::None;
            let mut field_removedPaths = ::std::option::Option::None;
            let mut field_uncleanPaths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fromPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_toPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_changedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_createdPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_removedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_uncleanPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                createdPaths: field_createdPaths.unwrap_or_default(),
                removedPaths: field_removedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DebugGetRawJournalParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                limit: ::std::option::Option::None,
                fromSequenceNumber: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DebugGetRawJournalParams {}
    unsafe impl ::std::marker::Sync for self::DebugGetRawJournalParams {}

    impl ::fbthrift::GetTType for self::DebugGetRawJournalParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugGetRawJournalParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.limit {
                p.write_field_begin("limit", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("fromSequenceNumber", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.fromSequenceNumber, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugGetRawJournalParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_fromSequenceNumber = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_fromSequenceNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                limit: field_limit,
                fromSequenceNumber: field_fromSequenceNumber.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DebugPathChangeInfo {
        fn default() -> Self {
            Self {
                existedBefore: ::std::default::Default::default(),
                existedAfter: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DebugPathChangeInfo {}
    unsafe impl ::std::marker::Sync for self::DebugPathChangeInfo {}

    impl ::fbthrift::GetTType for self::DebugPathChangeInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugPathChangeInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugPathChangeInfo");
            p.write_field_begin("existedBefore", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.existedBefore, p);
            p.write_field_end();
            p.write_field_begin("existedAfter", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.existedAfter, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugPathChangeInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_existedBefore = ::std::option::Option::None;
            let mut field_existedAfter = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_existedBefore = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_existedAfter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                existedBefore: field_existedBefore.unwrap_or_default(),
                existedAfter: field_existedAfter.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DebugJournalDelta {
        fn default() -> Self {
            Self {
                fromPosition: ::std::default::Default::default(),
                toPosition: ::std::default::Default::default(),
                changedPaths: ::std::default::Default::default(),
                uncleanPaths: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DebugJournalDelta {}
    unsafe impl ::std::marker::Sync for self::DebugJournalDelta {}

    impl ::fbthrift::GetTType for self::DebugJournalDelta {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugJournalDelta
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugJournalDelta");
            p.write_field_begin("fromPosition", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", ::fbthrift::TType::Set, 4);
            ::fbthrift::Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugJournalDelta
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_fromPosition = ::std::option::Option::None;
            let mut field_toPosition = ::std::option::Option::None;
            let mut field_changedPaths = ::std::option::Option::None;
            let mut field_uncleanPaths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fromPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_toPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_changedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Set, 4) => field_uncleanPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::DebugGetRawJournalResponse {
        fn default() -> Self {
            Self {
                allDeltas: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::DebugGetRawJournalResponse {}
    unsafe impl ::std::marker::Sync for self::DebugGetRawJournalResponse {}

    impl ::fbthrift::GetTType for self::DebugGetRawJournalResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugGetRawJournalResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalResponse");
            p.write_field_begin("allDeltas", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.allDeltas, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugGetRawJournalResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_allDeltas = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 2) => field_allDeltas = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                allDeltas: field_allDeltas.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScmStatus {
        fn default() -> Self {
            Self {
                entries: ::std::default::Default::default(),
                errors: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScmStatus {}
    unsafe impl ::std::marker::Sync for self::ScmStatus {}

    impl ::fbthrift::GetTType for self::ScmStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmStatus");
            p.write_field_begin("entries", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("errors", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.errors, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_entries = ::std::option::Option::None;
            let mut field_errors = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_entries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_errors = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entries: field_entries.unwrap_or_default(),
                errors: field_errors.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CheckoutConflict {
        fn default() -> Self {
            Self {
                path: ::std::default::Default::default(),
                type_: ::std::default::Default::default(),
                message: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CheckoutConflict {}
    unsafe impl ::std::marker::Sync for self::CheckoutConflict {}

    impl ::fbthrift::GetTType for self::CheckoutConflict {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckoutConflict
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckoutConflict");
            p.write_field_begin("path", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.type_, p);
            p.write_field_end();
            p.write_field_begin("message", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.message, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckoutConflict
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_path = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_message = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_message = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                path: field_path.unwrap_or_default(),
                type_: field_type.unwrap_or_default(),
                message: field_message.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScmBlobMetadata {
        fn default() -> Self {
            Self {
                size: ::std::default::Default::default(),
                contentsSha1: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScmBlobMetadata {}
    unsafe impl ::std::marker::Sync for self::ScmBlobMetadata {}

    impl ::fbthrift::GetTType for self::ScmBlobMetadata {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmBlobMetadata
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmBlobMetadata");
            p.write_field_begin("size", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("contentsSha1", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.contentsSha1, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmBlobMetadata
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_size = ::std::option::Option::None;
            let mut field_contentsSha1 = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_contentsSha1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                size: field_size.unwrap_or_default(),
                contentsSha1: field_contentsSha1.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ScmTreeEntry {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ScmTreeEntry {}
    unsafe impl ::std::marker::Sync for self::ScmTreeEntry {}

    impl ::fbthrift::GetTType for self::ScmTreeEntry {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmTreeEntry
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmTreeEntry");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmTreeEntry
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_name = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TreeInodeEntryDebugInfo {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                inodeNumber: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                loaded: ::std::default::Default::default(),
                materialized: ::std::default::Default::default(),
                hash: ::std::default::Default::default(),
                fileSize: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TreeInodeEntryDebugInfo {}
    unsafe impl ::std::marker::Sync for self::TreeInodeEntryDebugInfo {}

    impl ::fbthrift::GetTType for self::TreeInodeEntryDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TreeInodeEntryDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeEntryDebugInfo");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("inodeNumber", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("loaded", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("materialized", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("hash", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(&self.hash, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.fileSize {
                p.write_field_begin("fileSize", ::fbthrift::TType::I64, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TreeInodeEntryDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_name = ::std::option::Option::None;
            let mut field_inodeNumber = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_loaded = ::std::option::Option::None;
            let mut field_materialized = ::std::option::Option::None;
            let mut field_hash = ::std::option::Option::None;
            let mut field_fileSize = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_inodeNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_loaded = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_materialized = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_hash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_fileSize = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                hash: field_hash.unwrap_or_default(),
                fileSize: field_fileSize,
            })
        }
    }


    impl ::std::default::Default for self::WorkingDirectoryParents {
        fn default() -> Self {
            Self {
                parent1: ::std::default::Default::default(),
                parent2: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::WorkingDirectoryParents {}
    unsafe impl ::std::marker::Sync for self::WorkingDirectoryParents {}

    impl ::fbthrift::GetTType for self::WorkingDirectoryParents {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::WorkingDirectoryParents
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("WorkingDirectoryParents");
            p.write_field_begin("parent1", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.parent1, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.parent2 {
                p.write_field_begin("parent2", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::WorkingDirectoryParents
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_parent1 = ::std::option::Option::None;
            let mut field_parent2 = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_parent1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_parent2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                parent1: field_parent1.unwrap_or_default(),
                parent2: field_parent2,
            })
        }
    }


    impl ::std::default::Default for self::TreeInodeDebugInfo {
        fn default() -> Self {
            Self {
                inodeNumber: ::std::default::Default::default(),
                path: ::std::default::Default::default(),
                materialized: ::std::default::Default::default(),
                treeHash: ::std::default::Default::default(),
                entries: ::std::default::Default::default(),
                refcount: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TreeInodeDebugInfo {}
    unsafe impl ::std::marker::Sync for self::TreeInodeDebugInfo {}

    impl ::fbthrift::GetTType for self::TreeInodeDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TreeInodeDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeDebugInfo");
            p.write_field_begin("inodeNumber", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("materialized", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("treeHash", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.treeHash, p);
            p.write_field_end();
            p.write_field_begin("entries", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("refcount", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.refcount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TreeInodeDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_inodeNumber = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let mut field_materialized = ::std::option::Option::None;
            let mut field_treeHash = ::std::option::Option::None;
            let mut field_entries = ::std::option::Option::None;
            let mut field_refcount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_inodeNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_materialized = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_treeHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_entries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_refcount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                path: field_path.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                treeHash: field_treeHash.unwrap_or_default(),
                entries: field_entries.unwrap_or_default(),
                refcount: field_refcount.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::InodePathDebugInfo {
        fn default() -> Self {
            Self {
                path: ::std::default::Default::default(),
                loaded: ::std::default::Default::default(),
                linked: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::InodePathDebugInfo {}
    unsafe impl ::std::marker::Sync for self::InodePathDebugInfo {}

    impl ::fbthrift::GetTType for self::InodePathDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::InodePathDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InodePathDebugInfo");
            p.write_field_begin("path", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("loaded", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("linked", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.linked, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::InodePathDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_path = ::std::option::Option::None;
            let mut field_loaded = ::std::option::Option::None;
            let mut field_linked = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_loaded = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_linked = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                path: field_path.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                linked: field_linked.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::SetLogLevelResult {
        fn default() -> Self {
            Self {
                categoryCreated: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::SetLogLevelResult {}
    unsafe impl ::std::marker::Sync for self::SetLogLevelResult {}

    impl ::fbthrift::GetTType for self::SetLogLevelResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetLogLevelResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetLogLevelResult");
            p.write_field_begin("categoryCreated", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.categoryCreated, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetLogLevelResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_categoryCreated = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_categoryCreated = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                categoryCreated: field_categoryCreated.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::JournalInfo {
        fn default() -> Self {
            Self {
                entryCount: ::std::default::Default::default(),
                memoryUsage: ::std::default::Default::default(),
                durationSeconds: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::JournalInfo {}
    unsafe impl ::std::marker::Sync for self::JournalInfo {}

    impl ::fbthrift::GetTType for self::JournalInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JournalInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalInfo");
            p.write_field_begin("entryCount", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("memoryUsage", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.memoryUsage, p);
            p.write_field_end();
            p.write_field_begin("durationSeconds", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.durationSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JournalInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_entryCount = ::std::option::Option::None;
            let mut field_memoryUsage = ::std::option::Option::None;
            let mut field_durationSeconds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_entryCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_memoryUsage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_durationSeconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                memoryUsage: field_memoryUsage.unwrap_or_default(),
                durationSeconds: field_durationSeconds.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MountInodeInfo {
        fn default() -> Self {
            Self {
                unloadedInodeCount: ::std::default::Default::default(),
                loadedFileCount: ::std::default::Default::default(),
                loadedTreeCount: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MountInodeInfo {}
    unsafe impl ::std::marker::Sync for self::MountInodeInfo {}

    impl ::fbthrift::GetTType for self::MountInodeInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountInodeInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInodeInfo");
            p.write_field_begin("unloadedInodeCount", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.unloadedInodeCount, p);
            p.write_field_end();
            p.write_field_begin("loadedFileCount", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.loadedFileCount, p);
            p.write_field_end();
            p.write_field_begin("loadedTreeCount", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.loadedTreeCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountInodeInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_unloadedInodeCount = ::std::option::Option::None;
            let mut field_loadedFileCount = ::std::option::Option::None;
            let mut field_loadedTreeCount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 2) => field_unloadedInodeCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_loadedFileCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_loadedTreeCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                unloadedInodeCount: field_unloadedInodeCount.unwrap_or_default(),
                loadedFileCount: field_loadedFileCount.unwrap_or_default(),
                loadedTreeCount: field_loadedTreeCount.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::CacheStats {
        fn default() -> Self {
            Self {
                entryCount: ::std::default::Default::default(),
                totalSizeInBytes: ::std::default::Default::default(),
                hitCount: ::std::default::Default::default(),
                missCount: ::std::default::Default::default(),
                evictionCount: ::std::default::Default::default(),
                dropCount: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::CacheStats {}
    unsafe impl ::std::marker::Sync for self::CacheStats {}

    impl ::fbthrift::GetTType for self::CacheStats {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CacheStats
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CacheStats");
            p.write_field_begin("entryCount", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("totalSizeInBytes", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.totalSizeInBytes, p);
            p.write_field_end();
            p.write_field_begin("hitCount", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.hitCount, p);
            p.write_field_end();
            p.write_field_begin("missCount", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.missCount, p);
            p.write_field_end();
            p.write_field_begin("evictionCount", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.evictionCount, p);
            p.write_field_end();
            p.write_field_begin("dropCount", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.dropCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CacheStats
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_entryCount = ::std::option::Option::None;
            let mut field_totalSizeInBytes = ::std::option::Option::None;
            let mut field_hitCount = ::std::option::Option::None;
            let mut field_missCount = ::std::option::Option::None;
            let mut field_evictionCount = ::std::option::Option::None;
            let mut field_dropCount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_entryCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_totalSizeInBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_hitCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_missCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_evictionCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_dropCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                totalSizeInBytes: field_totalSizeInBytes.unwrap_or_default(),
                hitCount: field_hitCount.unwrap_or_default(),
                missCount: field_missCount.unwrap_or_default(),
                evictionCount: field_evictionCount.unwrap_or_default(),
                dropCount: field_dropCount.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::InternalStats {
        fn default() -> Self {
            Self {
                periodicUnloadCount: ::std::default::Default::default(),
                counters: ::std::default::Default::default(),
                mountPointInfo: ::std::default::Default::default(),
                smaps: ::std::default::Default::default(),
                privateBytes: ::std::default::Default::default(),
                vmRSSBytes: ::std::default::Default::default(),
                blobCacheStats: ::std::default::Default::default(),
                mountPointJournalInfo: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::InternalStats {}
    unsafe impl ::std::marker::Sync for self::InternalStats {}

    impl ::fbthrift::GetTType for self::InternalStats {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::InternalStats
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InternalStats");
            p.write_field_begin("periodicUnloadCount", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.periodicUnloadCount, p);
            p.write_field_end();
            p.write_field_begin("counters", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.counters, p);
            p.write_field_end();
            p.write_field_begin("mountPointInfo", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.mountPointInfo, p);
            p.write_field_end();
            p.write_field_begin("smaps", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.smaps, p);
            p.write_field_end();
            p.write_field_begin("privateBytes", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.privateBytes, p);
            p.write_field_end();
            p.write_field_begin("vmRSSBytes", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.vmRSSBytes, p);
            p.write_field_end();
            p.write_field_begin("blobCacheStats", ::fbthrift::TType::Struct, 7);
            ::fbthrift::Serialize::write(&self.blobCacheStats, p);
            p.write_field_end();
            p.write_field_begin("mountPointJournalInfo", ::fbthrift::TType::Map, 8);
            ::fbthrift::Serialize::write(&self.mountPointJournalInfo, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::InternalStats
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_periodicUnloadCount = ::std::option::Option::None;
            let mut field_counters = ::std::option::Option::None;
            let mut field_mountPointInfo = ::std::option::Option::None;
            let mut field_smaps = ::std::option::Option::None;
            let mut field_privateBytes = ::std::option::Option::None;
            let mut field_vmRSSBytes = ::std::option::Option::None;
            let mut field_blobCacheStats = ::std::option::Option::None;
            let mut field_mountPointJournalInfo = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_periodicUnloadCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_counters = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_mountPointInfo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_smaps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_privateBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_vmRSSBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 7) => field_blobCacheStats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 8) => field_mountPointJournalInfo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                periodicUnloadCount: field_periodicUnloadCount.unwrap_or_default(),
                counters: field_counters.unwrap_or_default(),
                mountPointInfo: field_mountPointInfo.unwrap_or_default(),
                smaps: field_smaps.unwrap_or_default(),
                privateBytes: field_privateBytes.unwrap_or_default(),
                vmRSSBytes: field_vmRSSBytes.unwrap_or_default(),
                blobCacheStats: field_blobCacheStats.unwrap_or_default(),
                mountPointJournalInfo: field_mountPointJournalInfo.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::ManifestEntry {
        fn default() -> Self {
            Self {
                mode: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::ManifestEntry {}
    unsafe impl ::std::marker::Sync for self::ManifestEntry {}

    impl ::fbthrift::GetTType for self::ManifestEntry {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ManifestEntry
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ManifestEntry");
            p.write_field_begin("mode", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ManifestEntry
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mode = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mode: field_mode.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::FuseCall {
        fn default() -> Self {
            Self {
                len: ::std::default::Default::default(),
                opcode: ::std::default::Default::default(),
                unique: ::std::default::Default::default(),
                nodeid: ::std::default::Default::default(),
                uid: ::std::default::Default::default(),
                gid: ::std::default::Default::default(),
                pid: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::FuseCall {}
    unsafe impl ::std::marker::Sync for self::FuseCall {}

    impl ::fbthrift::GetTType for self::FuseCall {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FuseCall
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FuseCall");
            p.write_field_begin("len", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.len, p);
            p.write_field_end();
            p.write_field_begin("opcode", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.opcode, p);
            p.write_field_end();
            p.write_field_begin("unique", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.unique, p);
            p.write_field_end();
            p.write_field_begin("nodeid", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.nodeid, p);
            p.write_field_end();
            p.write_field_begin("uid", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(&self.uid, p);
            p.write_field_end();
            p.write_field_begin("gid", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.gid, p);
            p.write_field_end();
            p.write_field_begin("pid", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FuseCall
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_len = ::std::option::Option::None;
            let mut field_opcode = ::std::option::Option::None;
            let mut field_unique = ::std::option::Option::None;
            let mut field_nodeid = ::std::option::Option::None;
            let mut field_uid = ::std::option::Option::None;
            let mut field_gid = ::std::option::Option::None;
            let mut field_pid = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_len = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_opcode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_nodeid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_uid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_gid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_pid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                len: field_len.unwrap_or_default(),
                opcode: field_opcode.unwrap_or_default(),
                unique: field_unique.unwrap_or_default(),
                nodeid: field_nodeid.unwrap_or_default(),
                uid: field_uid.unwrap_or_default(),
                gid: field_gid.unwrap_or_default(),
                pid: field_pid.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigParams {
        fn default() -> Self {
            Self {
                reload: eden_config::types::ConfigReloadBehavior::AutoReload,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigParams {}
    unsafe impl ::std::marker::Sync for self::GetConfigParams {}

    impl ::fbthrift::GetTType for self::GetConfigParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigParams");
            p.write_field_begin("reload", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.reload, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_reload = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_reload = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                reload: field_reload.unwrap_or_else(|| eden_config::types::ConfigReloadBehavior::AutoReload),
            })
        }
    }


    impl ::std::default::Default for self::GlobParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                globs: ::std::default::Default::default(),
                includeDotfiles: ::std::default::Default::default(),
                prefetchFiles: ::std::default::Default::default(),
                suppressFileList: ::std::default::Default::default(),
                wantDtype: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GlobParams {}
    unsafe impl ::std::marker::Sync for self::GlobParams {}

    impl ::fbthrift::GetTType for self::GlobParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GlobParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GlobParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("globs", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.globs, p);
            p.write_field_end();
            p.write_field_begin("includeDotfiles", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.includeDotfiles, p);
            p.write_field_end();
            p.write_field_begin("prefetchFiles", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.prefetchFiles, p);
            p.write_field_end();
            p.write_field_begin("suppressFileList", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.suppressFileList, p);
            p.write_field_end();
            p.write_field_begin("wantDtype", ::fbthrift::TType::Bool, 6);
            ::fbthrift::Serialize::write(&self.wantDtype, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GlobParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_globs = ::std::option::Option::None;
            let mut field_includeDotfiles = ::std::option::Option::None;
            let mut field_prefetchFiles = ::std::option::Option::None;
            let mut field_suppressFileList = ::std::option::Option::None;
            let mut field_wantDtype = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_globs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_includeDotfiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_prefetchFiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_suppressFileList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 6) => field_wantDtype = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                globs: field_globs.unwrap_or_default(),
                includeDotfiles: field_includeDotfiles.unwrap_or_default(),
                prefetchFiles: field_prefetchFiles.unwrap_or_default(),
                suppressFileList: field_suppressFileList.unwrap_or_default(),
                wantDtype: field_wantDtype.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::Glob {
        fn default() -> Self {
            Self {
                matchingFiles: ::std::default::Default::default(),
                dtypes: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::Glob {}
    unsafe impl ::std::marker::Sync for self::Glob {}

    impl ::fbthrift::GetTType for self::Glob {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Glob
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Glob");
            p.write_field_begin("matchingFiles", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.matchingFiles, p);
            p.write_field_end();
            p.write_field_begin("dtypes", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.dtypes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Glob
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_matchingFiles = ::std::option::Option::None;
            let mut field_dtypes = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_matchingFiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_dtypes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                matchingFiles: field_matchingFiles.unwrap_or_default(),
                dtypes: field_dtypes.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::AccessCounts {
        fn default() -> Self {
            Self {
                fuseTotal: ::std::default::Default::default(),
                fuseReads: ::std::default::Default::default(),
                fuseWrites: ::std::default::Default::default(),
                fuseBackingStoreImports: ::std::default::Default::default(),
                fuseDurationNs: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::AccessCounts {}
    unsafe impl ::std::marker::Sync for self::AccessCounts {}

    impl ::fbthrift::GetTType for self::AccessCounts {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AccessCounts
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AccessCounts");
            p.write_field_begin("fuseTotal", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.fuseTotal, p);
            p.write_field_end();
            p.write_field_begin("fuseReads", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.fuseReads, p);
            p.write_field_end();
            p.write_field_begin("fuseWrites", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.fuseWrites, p);
            p.write_field_end();
            p.write_field_begin("fuseBackingStoreImports", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.fuseBackingStoreImports, p);
            p.write_field_end();
            p.write_field_begin("fuseDurationNs", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.fuseDurationNs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AccessCounts
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_fuseTotal = ::std::option::Option::None;
            let mut field_fuseReads = ::std::option::Option::None;
            let mut field_fuseWrites = ::std::option::Option::None;
            let mut field_fuseBackingStoreImports = ::std::option::Option::None;
            let mut field_fuseDurationNs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_fuseTotal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_fuseReads = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_fuseWrites = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_fuseBackingStoreImports = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_fuseDurationNs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fuseTotal: field_fuseTotal.unwrap_or_default(),
                fuseReads: field_fuseReads.unwrap_or_default(),
                fuseWrites: field_fuseWrites.unwrap_or_default(),
                fuseBackingStoreImports: field_fuseBackingStoreImports.unwrap_or_default(),
                fuseDurationNs: field_fuseDurationNs.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::MountAccesses {
        fn default() -> Self {
            Self {
                accessCountsByPid: ::std::default::Default::default(),
                fetchCountsByPid: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::MountAccesses {}
    unsafe impl ::std::marker::Sync for self::MountAccesses {}

    impl ::fbthrift::GetTType for self::MountAccesses {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountAccesses
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountAccesses");
            p.write_field_begin("accessCountsByPid", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.accessCountsByPid, p);
            p.write_field_end();
            p.write_field_begin("fetchCountsByPid", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.fetchCountsByPid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountAccesses
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_accessCountsByPid = ::std::option::Option::None;
            let mut field_fetchCountsByPid = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_accessCountsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_fetchCountsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                accessCountsByPid: field_accessCountsByPid.unwrap_or_default(),
                fetchCountsByPid: field_fetchCountsByPid.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetAccessCountsResult {
        fn default() -> Self {
            Self {
                cmdsByPid: ::std::default::Default::default(),
                accessesByMount: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetAccessCountsResult {}
    unsafe impl ::std::marker::Sync for self::GetAccessCountsResult {}

    impl ::fbthrift::GetTType for self::GetAccessCountsResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetAccessCountsResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetAccessCountsResult");
            p.write_field_begin("cmdsByPid", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.cmdsByPid, p);
            p.write_field_end();
            p.write_field_begin("accessesByMount", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.accessesByMount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetAccessCountsResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_cmdsByPid = ::std::option::Option::None;
            let mut field_accessesByMount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_cmdsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_accessesByMount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                cmdsByPid: field_cmdsByPid.unwrap_or_default(),
                accessesByMount: field_accessesByMount.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::TracePoint {
        fn default() -> Self {
            Self {
                timestamp: ::std::default::Default::default(),
                traceId: ::std::default::Default::default(),
                blockId: ::std::default::Default::default(),
                parentBlockId: ::std::default::Default::default(),
                name: ::std::string::String::new(),
                event: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::TracePoint {}
    unsafe impl ::std::marker::Sync for self::TracePoint {}

    impl ::fbthrift::GetTType for self::TracePoint {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TracePoint
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TracePoint");
            p.write_field_begin("timestamp", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.timestamp, p);
            p.write_field_end();
            p.write_field_begin("traceId", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.traceId, p);
            p.write_field_end();
            p.write_field_begin("blockId", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.blockId, p);
            p.write_field_end();
            p.write_field_begin("parentBlockId", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.parentBlockId, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("event", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.event, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TracePoint
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_timestamp = ::std::option::Option::None;
            let mut field_traceId = ::std::option::Option::None;
            let mut field_blockId = ::std::option::Option::None;
            let mut field_parentBlockId = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_event = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_timestamp = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_traceId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_blockId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_parentBlockId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_event = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                timestamp: field_timestamp.unwrap_or_default(),
                traceId: field_traceId.unwrap_or_default(),
                blockId: field_blockId.unwrap_or_default(),
                parentBlockId: field_parentBlockId.unwrap_or_default(),
                name: field_name.unwrap_or_else(|| ::std::string::String::new()),
                event: field_event.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::FaultDefinition {
        fn default() -> Self {
            Self {
                keyClass: ::std::default::Default::default(),
                keyValueRegex: ::std::default::Default::default(),
                count: ::std::default::Default::default(),
                block: ::std::default::Default::default(),
                delayMilliseconds: ::std::default::Default::default(),
                errorType: ::std::option::Option::None,
                errorMessage: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::FaultDefinition {}
    unsafe impl ::std::marker::Sync for self::FaultDefinition {}

    impl ::fbthrift::GetTType for self::FaultDefinition {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FaultDefinition
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FaultDefinition");
            p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_begin("count", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.count, p);
            p.write_field_end();
            p.write_field_begin("block", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.block, p);
            p.write_field_end();
            p.write_field_begin("delayMilliseconds", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.delayMilliseconds, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.errorType {
                p.write_field_begin("errorType", ::fbthrift::TType::String, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", ::fbthrift::TType::String, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FaultDefinition
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let mut field_count = ::std::option::Option::None;
            let mut field_block = ::std::option::Option::None;
            let mut field_delayMilliseconds = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let mut field_errorMessage = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_count = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_block = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_delayMilliseconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_errorMessage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
                count: field_count.unwrap_or_default(),
                block: field_block.unwrap_or_default(),
                delayMilliseconds: field_delayMilliseconds.unwrap_or_default(),
                errorType: field_errorType,
                errorMessage: field_errorMessage,
            })
        }
    }


    impl ::std::default::Default for self::RemoveFaultArg {
        fn default() -> Self {
            Self {
                keyClass: ::std::default::Default::default(),
                keyValueRegex: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveFaultArg {}
    unsafe impl ::std::marker::Sync for self::RemoveFaultArg {}

    impl ::fbthrift::GetTType for self::RemoveFaultArg {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveFaultArg
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveFaultArg");
            p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveFaultArg
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::UnblockFaultArg {
        fn default() -> Self {
            Self {
                keyClass: ::std::option::Option::None,
                keyValueRegex: ::std::option::Option::None,
                errorType: ::std::option::Option::None,
                errorMessage: ::std::option::Option::None,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::UnblockFaultArg {}
    unsafe impl ::std::marker::Sync for self::UnblockFaultArg {}

    impl ::fbthrift::GetTType for self::UnblockFaultArg {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UnblockFaultArg
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UnblockFaultArg");
            if let ::std::option::Option::Some(some) = &self.keyClass {
                p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.keyValueRegex {
                p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorType {
                p.write_field_begin("errorType", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UnblockFaultArg
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let mut field_errorMessage = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_errorMessage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass,
                keyValueRegex: field_keyValueRegex,
                errorType: field_errorType,
                errorMessage: field_errorMessage,
            })
        }
    }


    impl ::std::default::Default for self::GetScmStatusResult {
        fn default() -> Self {
            Self {
                status: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetScmStatusResult {}
    unsafe impl ::std::marker::Sync for self::GetScmStatusResult {}

    impl ::fbthrift::GetTType for self::GetScmStatusResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetScmStatusResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusResult");
            p.write_field_begin("status", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetScmStatusResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_status = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                status: field_status.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
            })
        }
    }


    impl ::std::default::Default for self::GetScmStatusParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                commit: ::std::default::Default::default(),
                listIgnored: false,
            }
        }
    }

    unsafe impl ::std::marker::Send for self::GetScmStatusParams {}
    unsafe impl ::std::marker::Sync for self::GetScmStatusParams {}

    impl ::fbthrift::GetTType for self::GetScmStatusParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetScmStatusParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("commit", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.commit, p);
            p.write_field_end();
            p.write_field_begin("listIgnored", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.listIgnored, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetScmStatusParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_commit = ::std::option::Option::None;
            let mut field_listIgnored = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_commit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_listIgnored = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                commit: field_commit.unwrap_or_default(),
                listIgnored: field_listIgnored.unwrap_or_else(|| false),
            })
        }
    }

}

pub mod dependencies {
    pub use eden_config as eden_config;
    pub use fb303_core as fb303_core;
}

pub mod services {
    pub mod eden_service {

        #[derive(Clone, Debug)]
        pub enum ListMountsExn {
            Success(::std::vec::Vec<crate::types::MountInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ListMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ListMountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListMountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListMountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ListMountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListMountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ListMounts");
                match self {
                    ListMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListMountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListMountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListMountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for MountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                MountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for MountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Mount");
                match self {
                    MountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = MountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = MountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = MountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnmountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnmountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnmountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnmountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnmountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UnmountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnmountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Unmount");
                match self {
                    UnmountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnmountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = UnmountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = UnmountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = UnmountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnmountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckOutRevisionExn {
            Success(::std::vec::Vec<crate::types::CheckoutConflict>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckOutRevisionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                CheckOutRevisionExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckOutRevisionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CheckOutRevisionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for CheckOutRevisionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckOutRevisionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("CheckOutRevision");
                match self {
                    CheckOutRevisionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckOutRevisionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckOutRevisionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckOutRevisionExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckOutRevisionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckOutRevisionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ResetParentCommitsExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ResetParentCommitsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ResetParentCommitsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ResetParentCommitsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ResetParentCommitsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ResetParentCommitsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ResetParentCommitsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ResetParentCommits");
                match self {
                    ResetParentCommitsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ResetParentCommitsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ResetParentCommitsExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ResetParentCommitsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSHA1Exn {
            Success(::std::vec::Vec<crate::types::SHA1Result>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetSHA1Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetSHA1Exn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSHA1Exn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSHA1Exn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetSHA1Exn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSHA1Exn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetSHA1");
                match self {
                    GetSHA1Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSHA1Exn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSHA1Exn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSHA1Exn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSHA1Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSHA1Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetBindMountsExn {
            Success(::std::vec::Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetBindMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetBindMountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBindMountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetBindMountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetBindMountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetBindMountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetBindMounts");
                match self {
                    GetBindMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetBindMountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetBindMountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetBindMountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetBindMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetBindMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for AddBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                AddBindMountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddBindMountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddBindMountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for AddBindMountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddBindMountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("AddBindMount");
                match self {
                    AddBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddBindMountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = AddBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = AddBindMountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = AddBindMountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveBindMountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveBindMountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveBindMountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveBindMountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveBindMountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveBindMount");
                match self {
                    RemoveBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveBindMountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = RemoveBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = RemoveBindMountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = RemoveBindMountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCurrentJournalPositionExn {
            Success(crate::types::JournalPosition),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetCurrentJournalPositionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetCurrentJournalPositionExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCurrentJournalPositionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCurrentJournalPositionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetCurrentJournalPositionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCurrentJournalPositionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetCurrentJournalPosition");
                match self {
                    GetCurrentJournalPositionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCurrentJournalPositionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCurrentJournalPositionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCurrentJournalPositionExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCurrentJournalPositionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCurrentJournalPositionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFilesChangedSinceExn {
            Success(crate::types::FileDelta),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFilesChangedSinceExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFilesChangedSinceExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFilesChangedSinceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetFilesChangedSinceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetFilesChangedSinceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetFilesChangedSinceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetFilesChangedSince");
                match self {
                    GetFilesChangedSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetFilesChangedSinceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFilesChangedSinceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFilesChangedSinceExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFilesChangedSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFilesChangedSinceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetJournalMemoryLimitExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                SetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetJournalMemoryLimitExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for SetJournalMemoryLimitExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("SetJournalMemoryLimit");
                match self {
                    SetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetJournalMemoryLimitExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetJournalMemoryLimitExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetJournalMemoryLimitExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetJournalMemoryLimitExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetJournalMemoryLimit");
                match self {
                    GetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetJournalMemoryLimitExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetJournalMemoryLimitExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetJournalMemoryLimitExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushJournalExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushJournalExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushJournalExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                FlushJournalExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for FlushJournalExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for FlushJournalExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("FlushJournal");
                match self {
                    FlushJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for FlushJournalExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushJournalExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushJournalExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushJournalExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetRawJournalExn {
            Success(crate::types::DebugGetRawJournalResponse),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetRawJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetRawJournalExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetRawJournalExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetRawJournalExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugGetRawJournalExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetRawJournalExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetRawJournal");
                match self {
                    DebugGetRawJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetRawJournalExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetRawJournalExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetRawJournalExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetRawJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetRawJournalExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEntryInformationExn {
            Success(::std::vec::Vec<crate::types::EntryInformationOrError>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetEntryInformationExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetEntryInformationExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEntryInformationExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEntryInformationExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetEntryInformationExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEntryInformationExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetEntryInformation");
                match self {
                    GetEntryInformationExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEntryInformationExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEntryInformationExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEntryInformationExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEntryInformationExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEntryInformationExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEntryInformationExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEntryInformationExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFileInformationExn {
            Success(::std::vec::Vec<crate::types::FileInformationOrError>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFileInformationExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFileInformationExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFileInformationExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetFileInformationExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetFileInformationExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetFileInformationExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetFileInformation");
                match self {
                    GetFileInformationExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetFileInformationExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFileInformationExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFileInformationExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFileInformationExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFileInformationExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobExn {
            Success(::std::vec::Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GlobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GlobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GlobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Glob");
                match self {
                    GlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GlobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobFilesExn {
            Success(crate::types::Glob),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobFilesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobFilesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobFilesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GlobFilesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GlobFilesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GlobFilesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GlobFiles");
                match self {
                    GlobFilesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GlobFilesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobFilesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobFilesExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobFilesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobFilesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChownExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChownExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ChownExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ChownExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChownExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("Chown");
                match self {
                    ChownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ChownExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChownExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ChownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ChownExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusV2Exn {
            Success(crate::types::GetScmStatusResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusV2Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusV2Exn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusV2Exn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusV2Exn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusV2Exn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusV2Exn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatusV2");
                match self {
                    GetScmStatusV2Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusV2Exn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusV2Exn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusV2Exn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusV2Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusV2Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatus");
                match self {
                    GetScmStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusBetweenRevisionsExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusBetweenRevisionsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusBetweenRevisionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusBetweenRevisionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusBetweenRevisionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetScmStatusBetweenRevisions");
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusBetweenRevisionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusBetweenRevisionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusBetweenRevisionsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusBetweenRevisionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusBetweenRevisionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetManifestEntryExn {
            Success(crate::types::ManifestEntry),
            ex(crate::types::EdenError),
            noValueForKeyError(crate::types::NoValueForKeyError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetManifestEntryExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetManifestEntryExn::ex(exn)
            }
        }

        impl ::std::convert::From<crate::types::NoValueForKeyError> for GetManifestEntryExn {
            fn from(exn: crate::types::NoValueForKeyError) -> Self {
                GetManifestEntryExn::noValueForKeyError(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetManifestEntryExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetManifestEntryExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetManifestEntryExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetManifestEntryExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetManifestEntry");
                match self {
                    GetManifestEntryExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::noValueForKeyError(inner) => {
                        p.write_field_begin(
                            "noValueForKeyError",
                            ::fbthrift::TType::Struct,
                            2,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetManifestEntryExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetManifestEntryExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetManifestEntryExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetManifestEntryExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 2), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetManifestEntryExn::noValueForKeyError(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetManifestEntryExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetManifestEntryExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetDaemonInfoExn {
            Success(crate::types::DaemonInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetDaemonInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetDaemonInfoExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetDaemonInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetDaemonInfoExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetDaemonInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetDaemonInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetDaemonInfo");
                match self {
                    GetDaemonInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetDaemonInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetDaemonInfoExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetDaemonInfoExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetDaemonInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetDaemonInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPidExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetPidExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetPidExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPidExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPidExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetPidExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPidExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetPid");
                match self {
                    GetPidExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPidExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPidExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPidExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPidExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPidExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InitiateShutdownExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InitiateShutdownExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InitiateShutdownExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InitiateShutdownExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InitiateShutdownExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for InitiateShutdownExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InitiateShutdownExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InitiateShutdown");
                match self {
                    InitiateShutdownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InitiateShutdownExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InitiateShutdownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InitiateShutdownExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InitiateShutdownExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InitiateShutdownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            Success(eden_config::types::EdenConfigData),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetConfigExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetConfig");
                match self {
                    GetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReloadConfigExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ReloadConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ReloadConfigExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReloadConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ReloadConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ReloadConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ReloadConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ReloadConfig");
                match self {
                    ReloadConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ReloadConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ReloadConfigExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ReloadConfigExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ReloadConfigExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReloadConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmTreeExn {
            Success(::std::vec::Vec<crate::types::ScmTreeEntry>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmTreeExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmTreeExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmTreeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmTreeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmTreeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmTreeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmTree");
                match self {
                    DebugGetScmTreeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmTreeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmTreeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmTreeExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmTreeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmTreeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobExn {
            Success(::std::vec::Vec<::std::primitive::u8>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmBlobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmBlobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmBlob");
                match self {
                    DebugGetScmBlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmBlobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobMetadataExn {
            Success(crate::types::ScmBlobMetadata),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobMetadataExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobMetadataExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobMetadataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobMetadataExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmBlobMetadataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmBlobMetadataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetScmBlobMetadata");
                match self {
                    DebugGetScmBlobMetadataExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmBlobMetadataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobMetadataExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobMetadataExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobMetadataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobMetadataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugInodeStatusExn {
            Success(::std::vec::Vec<crate::types::TreeInodeDebugInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugInodeStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugInodeStatusExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugInodeStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugInodeStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugInodeStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugInodeStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugInodeStatus");
                match self {
                    DebugInodeStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugInodeStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugInodeStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugInodeStatusExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugInodeStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugInodeStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugOutstandingFuseCallsExn {
            Success(::std::vec::Vec<crate::types::FuseCall>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugOutstandingFuseCallsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugOutstandingFuseCallsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugOutstandingFuseCallsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugOutstandingFuseCallsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugOutstandingFuseCalls");
                match self {
                    DebugOutstandingFuseCallsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugOutstandingFuseCallsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugOutstandingFuseCallsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugOutstandingFuseCallsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugOutstandingFuseCallsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugOutstandingFuseCallsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetInodePathExn {
            Success(crate::types::InodePathDebugInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetInodePathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetInodePathExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetInodePathExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetInodePathExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugGetInodePathExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetInodePathExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugGetInodePath");
                match self {
                    DebugGetInodePathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetInodePathExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetInodePathExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetInodePathExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetInodePathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetInodePathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetAccessCountsExn {
            Success(crate::types::GetAccessCountsResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAccessCountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetAccessCountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAccessCountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetAccessCountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetAccessCountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetAccessCountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetAccessCounts");
                match self {
                    GetAccessCountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetAccessCountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAccessCountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAccessCountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetAccessCountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetAccessCountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearAndCompactLocalStoreExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearAndCompactLocalStoreExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ClearAndCompactLocalStoreExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearAndCompactLocalStoreExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ClearAndCompactLocalStoreExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for ClearAndCompactLocalStoreExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ClearAndCompactLocalStoreExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("ClearAndCompactLocalStore");
                match self {
                    ClearAndCompactLocalStoreExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ClearAndCompactLocalStoreExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ClearAndCompactLocalStoreExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearAndCompactLocalStoreExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugClearLocalStoreCachesExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugClearLocalStoreCachesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugClearLocalStoreCachesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugClearLocalStoreCachesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugClearLocalStoreCachesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugClearLocalStoreCachesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugClearLocalStoreCachesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugClearLocalStoreCaches");
                match self {
                    DebugClearLocalStoreCachesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugClearLocalStoreCachesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugClearLocalStoreCachesExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugClearLocalStoreCachesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugCompactLocalStorageExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugCompactLocalStorageExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugCompactLocalStorageExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugCompactLocalStorageExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugCompactLocalStorageExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DebugCompactLocalStorageExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugCompactLocalStorageExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DebugCompactLocalStorage");
                match self {
                    DebugCompactLocalStorageExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugCompactLocalStorageExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugCompactLocalStorageExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugCompactLocalStorageExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnloadInodeForPathExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnloadInodeForPathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnloadInodeForPathExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnloadInodeForPathExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnloadInodeForPathExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UnloadInodeForPathExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnloadInodeForPathExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UnloadInodeForPath");
                match self {
                    UnloadInodeForPathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnloadInodeForPathExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnloadInodeForPathExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnloadInodeForPathExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnloadInodeForPathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnloadInodeForPathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushStatsNowExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushStatsNowExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushStatsNowExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushStatsNowExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                FlushStatsNowExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for FlushStatsNowExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for FlushStatsNowExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("FlushStatsNow");
                match self {
                    FlushStatsNowExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for FlushStatsNowExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushStatsNowExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushStatsNowExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushStatsNowExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushStatsNowExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum InvalidateKernelInodeCacheExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InvalidateKernelInodeCacheExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InvalidateKernelInodeCacheExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InvalidateKernelInodeCacheExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InvalidateKernelInodeCacheExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for InvalidateKernelInodeCacheExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InvalidateKernelInodeCacheExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InvalidateKernelInodeCache");
                match self {
                    InvalidateKernelInodeCacheExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InvalidateKernelInodeCacheExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InvalidateKernelInodeCacheExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InvalidateKernelInodeCacheExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatInfoExn {
            Success(crate::types::InternalStats),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetStatInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetStatInfoExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatInfoExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetStatInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetStatInfo");
                match self {
                    GetStatInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatInfoExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatInfoExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum EnableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for EnableTracingExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                EnableTracingExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for EnableTracingExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for EnableTracingExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("EnableTracing");
                match self {
                    EnableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    EnableTracingExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for EnableTracingExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = EnableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = EnableTracingExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "EnableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DisableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DisableTracingExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DisableTracingExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for DisableTracingExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DisableTracingExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("DisableTracing");
                match self {
                    DisableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DisableTracingExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DisableTracingExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DisableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DisableTracingExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DisableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTracePointsExn {
            Success(::std::vec::Vec<crate::types::TracePoint>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTracePointsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTracePointsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for GetTracePointsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTracePointsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("GetTracePoints");
                match self {
                    GetTracePointsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTracePointsExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTracePointsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTracePointsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTracePointsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTracePointsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InjectFaultExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InjectFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InjectFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InjectFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InjectFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for InjectFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InjectFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("InjectFault");
                match self {
                    InjectFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InjectFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InjectFaultExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InjectFaultExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InjectFaultExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InjectFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveFaultExn {
            Success(::std::primitive::bool),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for RemoveFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("RemoveFault");
                match self {
                    RemoveFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Bool,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Bool, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveFaultExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveFaultExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveFaultExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnblockFaultExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnblockFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnblockFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnblockFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnblockFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::GetTType for UnblockFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnblockFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                p.write_struct_begin("UnblockFault");
                match self {
                    UnblockFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ApplicationException(_) => panic!(
                        "Bad union Alt field {} id {}",
                        "ApplicationException",
                        -2147483648i32,
                    ),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnblockFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| ())?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnblockFaultExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnblockFaultExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnblockFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnblockFaultExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

pub mod client {

    pub struct EdenServiceImpl<P, T> {
        parent: fb303_core::client::BaseServiceImpl<P, T>,
    }

    impl<P, T> EdenServiceImpl<P, T> {
        pub fn new(
            transport: T,
        ) -> Self {
            let parent = fb303_core::client::BaseServiceImpl::<P, T>::new(transport);
            Self { parent }
        }

        pub fn transport(&self) -> &T {
            self.parent.transport()
        }
    }

    impl<P, T> ::std::convert::AsRef<dyn crate::dependencies::fb303_core::client::BaseService + 'static> for EdenServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {
        fn as_ref(&self) -> &(dyn crate::dependencies::fb303_core::client::BaseService + 'static)
        {
            &self.parent
        }
    }

    pub trait EdenService: fb303_core::client::BaseService + ::std::marker::Send {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>>;
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>>;
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>>;
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>>;
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>>;
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>>;
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>>;
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>>;
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>>;
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>>;
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>>;
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>>;
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>>;
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>>;
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>>;
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>>;
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>>;
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>>;
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>>;
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>>;
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>>;
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>>;
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>>;
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ManifestEntry, crate::errors::eden_service::GetManifestEntryError>> + ::std::marker::Send + 'static>>;
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>>;
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>>;
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>>;
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>>;
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>>;
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>>;
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>>;
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>>;
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>>;
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>>;
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>>;
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>>;
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>>;
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>>;
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>>;
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>>;
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>>;
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>>;
        fn getStatInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>>;
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>>;
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>>;
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>>;
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>>;
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>>;
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>>;
    }

    impl<P, T> EdenService for EdenServiceImpl<P, T>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
    {        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listMounts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::ListMountsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::ListMountsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::ListMountsExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ListMountsError::ex(err))
                                    }
                                    crate::services::eden_service::ListMountsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ListMountsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::ListMountsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::ListMountsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "mount",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_info", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_info, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::MountError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::MountExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::MountExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::MountExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::MountError::ex(err))
                                    }
                                    crate::services::eden_service::MountExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::MountError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::MountError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::MountError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unmount",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::UnmountError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::UnmountExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::UnmountExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::UnmountExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnmountError::ex(err))
                                    }
                                    crate::services::eden_service::UnmountExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnmountError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::UnmountError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::UnmountError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkOutRevision",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_snapshotHash", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_snapshotHash, p);
                    p.write_field_end();
                    p.write_field_begin("arg_checkoutMode", ::fbthrift::TType::I32, 3i16);
                    ::fbthrift::Serialize::write(&arg_checkoutMode, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::CheckOutRevisionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::CheckOutRevisionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::CheckOutRevisionExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::CheckOutRevisionError::ex(err))
                                    }
                                    crate::services::eden_service::CheckOutRevisionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::CheckOutRevisionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::CheckOutRevisionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::CheckOutRevisionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "resetParentCommits",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_parents", ::fbthrift::TType::Struct, 2i16);
                    ::fbthrift::Serialize::write(&arg_parents, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::ResetParentCommitsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::ResetParentCommitsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::ResetParentCommitsExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ResetParentCommitsError::ex(err))
                                    }
                                    crate::services::eden_service::ResetParentCommitsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ResetParentCommitsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::ResetParentCommitsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::ResetParentCommitsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSHA1",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_paths", ::fbthrift::TType::List, 2i16);
                    ::fbthrift::Serialize::write(&arg_paths, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetSHA1Exn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetSHA1Exn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetSHA1Exn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetSHA1Error::ex(err))
                                    }
                                    crate::services::eden_service::GetSHA1Exn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetSHA1Error::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetSHA1Error::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetSHA1Error::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getBindMounts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetBindMountsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetBindMountsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetBindMountsExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetBindMountsError::ex(err))
                                    }
                                    crate::services::eden_service::GetBindMountsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetBindMountsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetBindMountsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetBindMountsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addBindMount",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_repoPath", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_repoPath, p);
                    p.write_field_end();
                    p.write_field_begin("arg_targetPath", ::fbthrift::TType::String, 3i16);
                    ::fbthrift::Serialize::write(&arg_targetPath, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::AddBindMountError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::AddBindMountExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::AddBindMountExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::AddBindMountExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::AddBindMountError::ex(err))
                                    }
                                    crate::services::eden_service::AddBindMountExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::AddBindMountError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::AddBindMountError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::AddBindMountError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeBindMount",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_repoPath", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_repoPath, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::RemoveBindMountExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::RemoveBindMountExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::RemoveBindMountExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::RemoveBindMountError::ex(err))
                                    }
                                    crate::services::eden_service::RemoveBindMountExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::RemoveBindMountError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::RemoveBindMountError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::RemoveBindMountError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCurrentJournalPosition",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetCurrentJournalPositionExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetCurrentJournalPositionExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetCurrentJournalPositionExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetCurrentJournalPositionError::ex(err))
                                    }
                                    crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetCurrentJournalPositionError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetCurrentJournalPositionError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetCurrentJournalPositionError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getFilesChangedSince",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_fromPosition", ::fbthrift::TType::Struct, 2i16);
                    ::fbthrift::Serialize::write(&arg_fromPosition, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetFilesChangedSinceExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetFilesChangedSinceExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetFilesChangedSinceExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetFilesChangedSinceError::ex(err))
                                    }
                                    crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetFilesChangedSinceError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetFilesChangedSinceError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetFilesChangedSinceError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setJournalMemoryLimit",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_limit", ::fbthrift::TType::I64, 2i16);
                    ::fbthrift::Serialize::write(&arg_limit, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::SetJournalMemoryLimitExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::SetJournalMemoryLimitExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::SetJournalMemoryLimitExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::SetJournalMemoryLimitError::ex(err))
                                    }
                                    crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::SetJournalMemoryLimitError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::SetJournalMemoryLimitError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::SetJournalMemoryLimitError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getJournalMemoryLimit",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetJournalMemoryLimitExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetJournalMemoryLimitExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetJournalMemoryLimitExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetJournalMemoryLimitError::ex(err))
                                    }
                                    crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetJournalMemoryLimitError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetJournalMemoryLimitError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetJournalMemoryLimitError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "flushJournal",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::FlushJournalError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::FlushJournalExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::FlushJournalExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::FlushJournalExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::FlushJournalError::ex(err))
                                    }
                                    crate::services::eden_service::FlushJournalExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::FlushJournalError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::FlushJournalError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::FlushJournalError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetRawJournal",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_params, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugGetRawJournalExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugGetRawJournalExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugGetRawJournalExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetRawJournalError::ex(err))
                                    }
                                    crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetRawJournalError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetRawJournalError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetRawJournalError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEntryInformation",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_paths", ::fbthrift::TType::List, 2i16);
                    ::fbthrift::Serialize::write(&arg_paths, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetEntryInformationExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetEntryInformationExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetEntryInformationExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetEntryInformationError::ex(err))
                                    }
                                    crate::services::eden_service::GetEntryInformationExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetEntryInformationError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetEntryInformationError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetEntryInformationError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getFileInformation",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_paths", ::fbthrift::TType::List, 2i16);
                    ::fbthrift::Serialize::write(&arg_paths, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetFileInformationExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetFileInformationExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetFileInformationExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetFileInformationError::ex(err))
                                    }
                                    crate::services::eden_service::GetFileInformationExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetFileInformationError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetFileInformationError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetFileInformationError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "glob",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_globs", ::fbthrift::TType::List, 2i16);
                    ::fbthrift::Serialize::write(&arg_globs, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GlobExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GlobExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GlobExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GlobError::ex(err))
                                    }
                                    crate::services::eden_service::GlobExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GlobError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GlobError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GlobError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "globFiles",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_params, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GlobFilesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GlobFilesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GlobFilesExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GlobFilesError::ex(err))
                                    }
                                    crate::services::eden_service::GlobFilesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GlobFilesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GlobFilesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GlobFilesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "chown",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_uid", ::fbthrift::TType::I32, 2i16);
                    ::fbthrift::Serialize::write(&arg_uid, p);
                    p.write_field_end();
                    p.write_field_begin("arg_gid", ::fbthrift::TType::I32, 3i16);
                    ::fbthrift::Serialize::write(&arg_gid, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::ChownError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::ChownExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::ChownExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::ChownExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ChownError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::ChownError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::ChownError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatusV2",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_params, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetScmStatusV2Exn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetScmStatusV2Exn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetScmStatusV2Exn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusV2Error::ex(err))
                                    }
                                    crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusV2Error::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusV2Error::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusV2Error::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_listIgnored", ::fbthrift::TType::Bool, 2i16);
                    ::fbthrift::Serialize::write(&arg_listIgnored, p);
                    p.write_field_end();
                    p.write_field_begin("arg_commit", ::fbthrift::TType::String, 3i16);
                    ::fbthrift::Serialize::write(&arg_commit, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetScmStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetScmStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetScmStatusExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusError::ex(err))
                                    }
                                    crate::services::eden_service::GetScmStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatusBetweenRevisions",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_oldHash", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_oldHash, p);
                    p.write_field_end();
                    p.write_field_begin("arg_newHash", ::fbthrift::TType::String, 3i16);
                    ::fbthrift::Serialize::write(&arg_newHash, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetScmStatusBetweenRevisionsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusBetweenRevisionsError::ex(err))
                                    }
                                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusBetweenRevisionsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusBetweenRevisionsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusBetweenRevisionsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ManifestEntry, crate::errors::eden_service::GetManifestEntryError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getManifestEntry",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_relativePath", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_relativePath, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ManifestEntry, crate::errors::eden_service::GetManifestEntryError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetManifestEntryExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetManifestEntryExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetManifestEntryExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetManifestEntryError::ex(err))
                                    }
                                    crate::services::eden_service::GetManifestEntryExn::noValueForKeyError(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetManifestEntryError::noValueForKeyError(err))
                                    }
                                    crate::services::eden_service::GetManifestEntryExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetManifestEntryError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetManifestEntryError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetManifestEntryError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getDaemonInfo",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetDaemonInfoExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetDaemonInfoExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetDaemonInfoExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetDaemonInfoError::ex(err))
                                    }
                                    crate::services::eden_service::GetDaemonInfoExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetDaemonInfoError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetDaemonInfoError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetDaemonInfoError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPid",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetPidExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetPidExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetPidExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetPidError::ex(err))
                                    }
                                    crate::services::eden_service::GetPidExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetPidError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetPidError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetPidError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "initiateShutdown",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_reason", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_reason, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::InitiateShutdownExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::InitiateShutdownExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::InitiateShutdownExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InitiateShutdownError::ex(err))
                                    }
                                    crate::services::eden_service::InitiateShutdownExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InitiateShutdownError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::InitiateShutdownError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::InitiateShutdownError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_params", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_params, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetConfigExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetConfigError::ex(err))
                                    }
                                    crate::services::eden_service::GetConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "reloadConfig",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::ReloadConfigExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::ReloadConfigExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::ReloadConfigExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ReloadConfigError::ex(err))
                                    }
                                    crate::services::eden_service::ReloadConfigExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ReloadConfigError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::ReloadConfigError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::ReloadConfigError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmTree",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_id, p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", ::fbthrift::TType::Bool, 3i16);
                    ::fbthrift::Serialize::write(&arg_localStoreOnly, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugGetScmTreeExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugGetScmTreeExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugGetScmTreeExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmTreeError::ex(err))
                                    }
                                    crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmTreeError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmTreeError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmTreeError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmBlob",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_id, p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", ::fbthrift::TType::Bool, 3i16);
                    ::fbthrift::Serialize::write(&arg_localStoreOnly, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugGetScmBlobExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugGetScmBlobExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugGetScmBlobExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobError::ex(err))
                                    }
                                    crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmBlobMetadata",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_id", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_id, p);
                    p.write_field_end();
                    p.write_field_begin("arg_localStoreOnly", ::fbthrift::TType::Bool, 3i16);
                    ::fbthrift::Serialize::write(&arg_localStoreOnly, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugGetScmBlobMetadataExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugGetScmBlobMetadataExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobMetadataError::ex(err))
                                    }
                                    crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobMetadataError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobMetadataError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobMetadataError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugInodeStatus",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_path, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugInodeStatusExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugInodeStatusExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugInodeStatusExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugInodeStatusError::ex(err))
                                    }
                                    crate::services::eden_service::DebugInodeStatusExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugInodeStatusError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugInodeStatusError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugInodeStatusError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugOutstandingFuseCalls",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugOutstandingFuseCallsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugOutstandingFuseCallsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugOutstandingFuseCallsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugOutstandingFuseCallsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetInodePath",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_inodeNumber", ::fbthrift::TType::I64, 2i16);
                    ::fbthrift::Serialize::write(&arg_inodeNumber, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugGetInodePathExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugGetInodePathExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugGetInodePathExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetInodePathError::ex(err))
                                    }
                                    crate::services::eden_service::DebugGetInodePathExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetInodePathError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetInodePathError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugGetInodePathError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getAccessCounts",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_duration", ::fbthrift::TType::I64, 1i16);
                    ::fbthrift::Serialize::write(&arg_duration, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetAccessCountsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetAccessCountsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetAccessCountsExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetAccessCountsError::ex(err))
                                    }
                                    crate::services::eden_service::GetAccessCountsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetAccessCountsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetAccessCountsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetAccessCountsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "clearAndCompactLocalStore",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::ClearAndCompactLocalStoreExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::ClearAndCompactLocalStoreExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ClearAndCompactLocalStoreError::ex(err))
                                    }
                                    crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::ClearAndCompactLocalStoreError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::ClearAndCompactLocalStoreError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::ClearAndCompactLocalStoreError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugClearLocalStoreCaches",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugClearLocalStoreCachesExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugClearLocalStoreCachesExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugClearLocalStoreCachesError::ex(err))
                                    }
                                    crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugClearLocalStoreCachesError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugClearLocalStoreCachesError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugClearLocalStoreCachesError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugCompactLocalStorage",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DebugCompactLocalStorageExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DebugCompactLocalStorageExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DebugCompactLocalStorageExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugCompactLocalStorageError::ex(err))
                                    }
                                    crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DebugCompactLocalStorageError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DebugCompactLocalStorageError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DebugCompactLocalStorageError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unloadInodeForPath",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_path, p);
                    p.write_field_end();
                    p.write_field_begin("arg_age", ::fbthrift::TType::Struct, 3i16);
                    ::fbthrift::Serialize::write(&arg_age, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::UnloadInodeForPathExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::UnloadInodeForPathExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::UnloadInodeForPathExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnloadInodeForPathError::ex(err))
                                    }
                                    crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnloadInodeForPathError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::UnloadInodeForPathError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::UnloadInodeForPathError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "flushStatsNow",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::FlushStatsNowExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::FlushStatsNowExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::FlushStatsNowExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::FlushStatsNowError::ex(err))
                                    }
                                    crate::services::eden_service::FlushStatsNowExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::FlushStatsNowError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::FlushStatsNowError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::FlushStatsNowError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "invalidateKernelInodeCache",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_mountPoint", ::fbthrift::TType::String, 1i16);
                    ::fbthrift::Serialize::write(&arg_mountPoint, p);
                    p.write_field_end();
                    p.write_field_begin("arg_path", ::fbthrift::TType::String, 2i16);
                    ::fbthrift::Serialize::write(&arg_path, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::InvalidateKernelInodeCacheExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::InvalidateKernelInodeCacheExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InvalidateKernelInodeCacheError::ex(err))
                                    }
                                    crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InvalidateKernelInodeCacheError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::InvalidateKernelInodeCacheError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::InvalidateKernelInodeCacheError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getStatInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatInfo",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetStatInfoExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetStatInfoExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetStatInfoExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetStatInfoError::ex(err))
                                    }
                                    crate::services::eden_service::GetStatInfoExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetStatInfoError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetStatInfoError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetStatInfoError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "enableTracing",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::EnableTracingError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::EnableTracingExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::EnableTracingExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::EnableTracingExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::EnableTracingError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::EnableTracingError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::EnableTracingError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "disableTracing",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::DisableTracingError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::DisableTracingExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::DisableTracingExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::DisableTracingExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::DisableTracingError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::DisableTracingError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::DisableTracingError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTracePoints",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::GetTracePointsExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::GetTracePointsExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::GetTracePointsExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::GetTracePointsError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::GetTracePointsError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::GetTracePointsError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "injectFault",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_fault", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_fault, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<(), crate::errors::eden_service::InjectFaultError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::InjectFaultExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::InjectFaultExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::InjectFaultExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InjectFaultError::ex(err))
                                    }
                                    crate::services::eden_service::InjectFaultExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::InjectFaultError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::InjectFaultError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::InjectFaultError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeFault",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_fault", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_fault, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::RemoveFaultExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::RemoveFaultExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::RemoveFaultExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::RemoveFaultError::ex(err))
                                    }
                                    crate::services::eden_service::RemoveFaultExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::RemoveFaultError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::RemoveFaultError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::RemoveFaultError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            use ::fbthrift::{ProtocolReader as _, ProtocolWriter as _};
            use ::futures::future::{FutureExt as _, TryFutureExt as _};
            let request = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unblockFault",
                ::fbthrift::MessageType::Call,
                // Note: we send a 0 message sequence ID from clients because
                // this field should not be used by the server (except for some
                // language implementations).
                0,
                |p| {
                    p.write_struct_begin("args");
                    p.write_field_begin("arg_info", ::fbthrift::TType::Struct, 1i16);
                    ::fbthrift::Serialize::write(&arg_info, p);
                    p.write_field_end();
                    p.write_field_stop();
                    p.write_struct_end();
                },
            ));
            self.transport()
                .call(request)
                .map_err(::std::convert::From::from)
                .and_then(|reply| ::futures::future::ready({
                    let de = P::deserializer(reply);
                    move |mut p: P::Deserializer| -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError> {
                        let p = &mut p;
                        let (_, message_type, _) = p.read_message_begin(|_| ())?;
                        let result = match message_type {
                            ::fbthrift::MessageType::Reply => {
                                let exn: crate::services::eden_service::UnblockFaultExn = ::fbthrift::Deserialize::read(p)?;
                                match exn {
                                    crate::services::eden_service::UnblockFaultExn::Success(x) => ::std::result::Result::Ok(x),
                                    crate::services::eden_service::UnblockFaultExn::ex(err) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnblockFaultError::ex(err))
                                    }
                                    crate::services::eden_service::UnblockFaultExn::ApplicationException(ae) => {
                                        ::std::result::Result::Err(crate::errors::eden_service::UnblockFaultError::ApplicationException(ae))
                                    }
                                }
                            }
                            ::fbthrift::MessageType::Exception => {
                                let ae: ::fbthrift::ApplicationException = ::fbthrift::Deserialize::read(p)?;
                                ::std::result::Result::Err(crate::errors::eden_service::UnblockFaultError::ApplicationException(ae))
                            }
                            ::fbthrift::MessageType::Call | ::fbthrift::MessageType::Oneway | ::fbthrift::MessageType::InvalidMessageType => {
                                let err = ::anyhow::anyhow!("Unexpected message type {:?}", message_type);
                                ::std::result::Result::Err(crate::errors::eden_service::UnblockFaultError::ThriftError(err))
                            }
                        };
                        p.read_message_end()?;
                        result
                    }(de)
                }))
                .boxed()
        }
    }

    impl<'a, T> EdenService for T
    where
        T: ::std::convert::AsRef<dyn EdenService + 'a>,
        T: crate::dependencies::fb303_core::client::BaseService,
        T: ::std::marker::Send,
    {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listMounts(
            )
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().mount(
                arg_info,
            )
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unmount(
                arg_mountPoint,
            )
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().checkOutRevision(
                arg_mountPoint,
                arg_snapshotHash,
                arg_checkoutMode,
            )
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().resetParentCommits(
                arg_mountPoint,
                arg_parents,
            )
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSHA1(
                arg_mountPoint,
                arg_paths,
            )
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getBindMounts(
                arg_mountPoint,
            )
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addBindMount(
                arg_mountPoint,
                arg_repoPath,
                arg_targetPath,
            )
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeBindMount(
                arg_mountPoint,
                arg_repoPath,
            )
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCurrentJournalPosition(
                arg_mountPoint,
            )
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getFilesChangedSince(
                arg_mountPoint,
                arg_fromPosition,
            )
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setJournalMemoryLimit(
                arg_mountPoint,
                arg_limit,
            )
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getJournalMemoryLimit(
                arg_mountPoint,
            )
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            self.as_ref().flushJournal(
                arg_mountPoint,
            )
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetRawJournal(
                arg_params,
            )
        }
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEntryInformation(
                arg_mountPoint,
                arg_paths,
            )
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getFileInformation(
                arg_mountPoint,
                arg_paths,
            )
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().glob(
                arg_mountPoint,
                arg_globs,
            )
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().globFiles(
                arg_params,
            )
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            self.as_ref().chown(
                arg_mountPoint,
                arg_uid,
                arg_gid,
            )
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatusV2(
                arg_params,
            )
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatus(
                arg_mountPoint,
                arg_listIgnored,
                arg_commit,
            )
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatusBetweenRevisions(
                arg_mountPoint,
                arg_oldHash,
                arg_newHash,
            )
        }
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ManifestEntry, crate::errors::eden_service::GetManifestEntryError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getManifestEntry(
                arg_mountPoint,
                arg_relativePath,
            )
        }
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getDaemonInfo(
            )
        }
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getPid(
            )
        }
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            self.as_ref().initiateShutdown(
                arg_reason,
            )
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getConfig(
                arg_params,
            )
        }
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().reloadConfig(
            )
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmTree(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmBlob(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmBlobMetadata(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugInodeStatus(
                arg_mountPoint,
                arg_path,
            )
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugOutstandingFuseCalls(
                arg_mountPoint,
            )
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetInodePath(
                arg_mountPoint,
                arg_inodeNumber,
            )
        }
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getAccessCounts(
                arg_duration,
            )
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            self.as_ref().clearAndCompactLocalStore(
            )
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugClearLocalStoreCaches(
            )
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugCompactLocalStorage(
            )
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unloadInodeForPath(
                arg_mountPoint,
                arg_path,
                arg_age,
            )
        }
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            self.as_ref().flushStatsNow(
            )
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            self.as_ref().invalidateKernelInodeCache(
                arg_mountPoint,
                arg_path,
            )
        }
        fn getStatInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatInfo(
            )
        }
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            self.as_ref().enableTracing(
            )
        }
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            self.as_ref().disableTracing(
            )
        }
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTracePoints(
            )
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().injectFault(
                arg_fault,
            )
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeFault(
                arg_fault,
            )
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unblockFault(
                arg_info,
            )
        }
    }

    pub struct make_EdenService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = BuckGraphService::new(protocol, transport);
    /// ```
    impl dyn EdenService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl EdenService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
        {
            let _ = protocol;
            ::std::sync::Arc::new(EdenServiceImpl::<P, T>::new(transport))
        }
    }

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_EdenService {
        type Api = dyn EdenService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn new<P, T>(protocol: P, transport: T) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
        {
            EdenService::new(protocol, transport)
        }
    }
}

pub mod server {
    #[::async_trait::async_trait]
    pub trait EdenService: ::std::marker::Send + ::std::marker::Sync + 'static {
        async fn listMounts(
            &self,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::services::eden_service::ListMountsExn> {
            ::std::result::Result::Err(crate::services::eden_service::ListMountsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "listMounts",
                ),
            ))
        }
        async fn mount(
            &self,
            _info: crate::types::MountArgument,
        ) -> ::std::result::Result<(), crate::services::eden_service::MountExn> {
            ::std::result::Result::Err(crate::services::eden_service::MountExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "mount",
                ),
            ))
        }
        async fn unmount(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<(), crate::services::eden_service::UnmountExn> {
            ::std::result::Result::Err(crate::services::eden_service::UnmountExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "unmount",
                ),
            ))
        }
        async fn checkOutRevision(
            &self,
            _mountPoint: crate::types::PathString,
            _snapshotHash: crate::types::BinaryHash,
            _checkoutMode: crate::types::CheckoutMode,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::services::eden_service::CheckOutRevisionExn> {
            ::std::result::Result::Err(crate::services::eden_service::CheckOutRevisionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "checkOutRevision",
                ),
            ))
        }
        async fn resetParentCommits(
            &self,
            _mountPoint: crate::types::PathString,
            _parents: crate::types::WorkingDirectoryParents,
        ) -> ::std::result::Result<(), crate::services::eden_service::ResetParentCommitsExn> {
            ::std::result::Result::Err(crate::services::eden_service::ResetParentCommitsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "resetParentCommits",
                ),
            ))
        }
        async fn getSHA1(
            &self,
            _mountPoint: crate::types::PathString,
            _paths: ::std::vec::Vec<crate::types::PathString>,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::services::eden_service::GetSHA1Exn> {
            ::std::result::Result::Err(crate::services::eden_service::GetSHA1Exn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getSHA1",
                ),
            ))
        }
        async fn getBindMounts(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::services::eden_service::GetBindMountsExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetBindMountsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getBindMounts",
                ),
            ))
        }
        async fn addBindMount(
            &self,
            _mountPoint: crate::types::PathString,
            _repoPath: crate::types::PathString,
            _targetPath: crate::types::PathString,
        ) -> ::std::result::Result<(), crate::services::eden_service::AddBindMountExn> {
            ::std::result::Result::Err(crate::services::eden_service::AddBindMountExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "addBindMount",
                ),
            ))
        }
        async fn removeBindMount(
            &self,
            _mountPoint: crate::types::PathString,
            _repoPath: crate::types::PathString,
        ) -> ::std::result::Result<(), crate::services::eden_service::RemoveBindMountExn> {
            ::std::result::Result::Err(crate::services::eden_service::RemoveBindMountExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "removeBindMount",
                ),
            ))
        }
        async fn getCurrentJournalPosition(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<crate::types::JournalPosition, crate::services::eden_service::GetCurrentJournalPositionExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getCurrentJournalPosition",
                ),
            ))
        }
        async fn getFilesChangedSince(
            &self,
            _mountPoint: crate::types::PathString,
            _fromPosition: crate::types::JournalPosition,
        ) -> ::std::result::Result<crate::types::FileDelta, crate::services::eden_service::GetFilesChangedSinceExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getFilesChangedSince",
                ),
            ))
        }
        async fn setJournalMemoryLimit(
            &self,
            _mountPoint: crate::types::PathString,
            _limit: ::std::primitive::i64,
        ) -> ::std::result::Result<(), crate::services::eden_service::SetJournalMemoryLimitExn> {
            ::std::result::Result::Err(crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "setJournalMemoryLimit",
                ),
            ))
        }
        async fn getJournalMemoryLimit(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::eden_service::GetJournalMemoryLimitExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getJournalMemoryLimit",
                ),
            ))
        }
        async fn flushJournal(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<(), crate::services::eden_service::FlushJournalExn> {
            ::std::result::Result::Err(crate::services::eden_service::FlushJournalExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "flushJournal",
                ),
            ))
        }
        async fn debugGetRawJournal(
            &self,
            _params: crate::types::DebugGetRawJournalParams,
        ) -> ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::services::eden_service::DebugGetRawJournalExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetRawJournal",
                ),
            ))
        }
        async fn getEntryInformation(
            &self,
            _mountPoint: crate::types::PathString,
            _paths: ::std::vec::Vec<crate::types::PathString>,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::services::eden_service::GetEntryInformationExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetEntryInformationExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getEntryInformation",
                ),
            ))
        }
        async fn getFileInformation(
            &self,
            _mountPoint: crate::types::PathString,
            _paths: ::std::vec::Vec<crate::types::PathString>,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::services::eden_service::GetFileInformationExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetFileInformationExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getFileInformation",
                ),
            ))
        }
        async fn glob(
            &self,
            _mountPoint: crate::types::PathString,
            _globs: ::std::vec::Vec<::std::string::String>,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::services::eden_service::GlobExn> {
            ::std::result::Result::Err(crate::services::eden_service::GlobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "glob",
                ),
            ))
        }
        async fn globFiles(
            &self,
            _params: crate::types::GlobParams,
        ) -> ::std::result::Result<crate::types::Glob, crate::services::eden_service::GlobFilesExn> {
            ::std::result::Result::Err(crate::services::eden_service::GlobFilesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "globFiles",
                ),
            ))
        }
        async fn chown(
            &self,
            _mountPoint: crate::types::PathString,
            _uid: ::std::primitive::i32,
            _gid: ::std::primitive::i32,
        ) -> ::std::result::Result<(), crate::services::eden_service::ChownExn> {
            ::std::result::Result::Err(crate::services::eden_service::ChownExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "chown",
                ),
            ))
        }
        async fn getScmStatusV2(
            &self,
            _params: crate::types::GetScmStatusParams,
        ) -> ::std::result::Result<crate::types::GetScmStatusResult, crate::services::eden_service::GetScmStatusV2Exn> {
            ::std::result::Result::Err(crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatusV2",
                ),
            ))
        }
        async fn getScmStatus(
            &self,
            _mountPoint: crate::types::PathString,
            _listIgnored: ::std::primitive::bool,
            _commit: crate::types::BinaryHash,
        ) -> ::std::result::Result<crate::types::ScmStatus, crate::services::eden_service::GetScmStatusExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetScmStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatus",
                ),
            ))
        }
        async fn getScmStatusBetweenRevisions(
            &self,
            _mountPoint: crate::types::PathString,
            _oldHash: crate::types::BinaryHash,
            _newHash: crate::types::BinaryHash,
        ) -> ::std::result::Result<crate::types::ScmStatus, crate::services::eden_service::GetScmStatusBetweenRevisionsExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getScmStatusBetweenRevisions",
                ),
            ))
        }
        async fn getManifestEntry(
            &self,
            _mountPoint: crate::types::PathString,
            _relativePath: crate::types::PathString,
        ) -> ::std::result::Result<crate::types::ManifestEntry, crate::services::eden_service::GetManifestEntryExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetManifestEntryExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getManifestEntry",
                ),
            ))
        }
        async fn getDaemonInfo(
            &self,
        ) -> ::std::result::Result<crate::types::DaemonInfo, crate::services::eden_service::GetDaemonInfoExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetDaemonInfoExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getDaemonInfo",
                ),
            ))
        }
        async fn getPid(
            &self,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::eden_service::GetPidExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetPidExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getPid",
                ),
            ))
        }
        async fn initiateShutdown(
            &self,
            _reason: ::std::string::String,
        ) -> ::std::result::Result<(), crate::services::eden_service::InitiateShutdownExn> {
            ::std::result::Result::Err(crate::services::eden_service::InitiateShutdownExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "initiateShutdown",
                ),
            ))
        }
        async fn getConfig(
            &self,
            _params: crate::types::GetConfigParams,
        ) -> ::std::result::Result<eden_config::types::EdenConfigData, crate::services::eden_service::GetConfigExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getConfig",
                ),
            ))
        }
        async fn reloadConfig(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::ReloadConfigExn> {
            ::std::result::Result::Err(crate::services::eden_service::ReloadConfigExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "reloadConfig",
                ),
            ))
        }
        async fn debugGetScmTree(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: ::std::primitive::bool,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::services::eden_service::DebugGetScmTreeExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmTree",
                ),
            ))
        }
        async fn debugGetScmBlob(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: ::std::primitive::bool,
        ) -> ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::services::eden_service::DebugGetScmBlobExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmBlob",
                ),
            ))
        }
        async fn debugGetScmBlobMetadata(
            &self,
            _mountPoint: crate::types::PathString,
            _id: crate::types::BinaryHash,
            _localStoreOnly: ::std::primitive::bool,
        ) -> ::std::result::Result<crate::types::ScmBlobMetadata, crate::services::eden_service::DebugGetScmBlobMetadataExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetScmBlobMetadata",
                ),
            ))
        }
        async fn debugInodeStatus(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::services::eden_service::DebugInodeStatusExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugInodeStatusExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugInodeStatus",
                ),
            ))
        }
        async fn debugOutstandingFuseCalls(
            &self,
            _mountPoint: crate::types::PathString,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::services::eden_service::DebugOutstandingFuseCallsExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugOutstandingFuseCalls",
                ),
            ))
        }
        async fn debugGetInodePath(
            &self,
            _mountPoint: crate::types::PathString,
            _inodeNumber: ::std::primitive::i64,
        ) -> ::std::result::Result<crate::types::InodePathDebugInfo, crate::services::eden_service::DebugGetInodePathExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugGetInodePathExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugGetInodePath",
                ),
            ))
        }
        async fn getAccessCounts(
            &self,
            _duration: ::std::primitive::i64,
        ) -> ::std::result::Result<crate::types::GetAccessCountsResult, crate::services::eden_service::GetAccessCountsExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetAccessCountsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getAccessCounts",
                ),
            ))
        }
        async fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::ClearAndCompactLocalStoreExn> {
            ::std::result::Result::Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "clearAndCompactLocalStore",
                ),
            ))
        }
        async fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::DebugClearLocalStoreCachesExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugClearLocalStoreCaches",
                ),
            ))
        }
        async fn debugCompactLocalStorage(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::DebugCompactLocalStorageExn> {
            ::std::result::Result::Err(crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "debugCompactLocalStorage",
                ),
            ))
        }
        async fn unloadInodeForPath(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
            _age: crate::types::TimeSpec,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::eden_service::UnloadInodeForPathExn> {
            ::std::result::Result::Err(crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "unloadInodeForPath",
                ),
            ))
        }
        async fn flushStatsNow(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::FlushStatsNowExn> {
            ::std::result::Result::Err(crate::services::eden_service::FlushStatsNowExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "flushStatsNow",
                ),
            ))
        }
        async fn invalidateKernelInodeCache(
            &self,
            _mountPoint: crate::types::PathString,
            _path: crate::types::PathString,
        ) -> ::std::result::Result<(), crate::services::eden_service::InvalidateKernelInodeCacheExn> {
            ::std::result::Result::Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "invalidateKernelInodeCache",
                ),
            ))
        }
        async fn getStatInfo(
            &self,
        ) -> ::std::result::Result<crate::types::InternalStats, crate::services::eden_service::GetStatInfoExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetStatInfoExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getStatInfo",
                ),
            ))
        }
        async fn enableTracing(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::EnableTracingExn> {
            ::std::result::Result::Err(crate::services::eden_service::EnableTracingExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "enableTracing",
                ),
            ))
        }
        async fn disableTracing(
            &self,
        ) -> ::std::result::Result<(), crate::services::eden_service::DisableTracingExn> {
            ::std::result::Result::Err(crate::services::eden_service::DisableTracingExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "disableTracing",
                ),
            ))
        }
        async fn getTracePoints(
            &self,
        ) -> ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::services::eden_service::GetTracePointsExn> {
            ::std::result::Result::Err(crate::services::eden_service::GetTracePointsExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "getTracePoints",
                ),
            ))
        }
        async fn injectFault(
            &self,
            _fault: crate::types::FaultDefinition,
        ) -> ::std::result::Result<(), crate::services::eden_service::InjectFaultExn> {
            ::std::result::Result::Err(crate::services::eden_service::InjectFaultExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "injectFault",
                ),
            ))
        }
        async fn removeFault(
            &self,
            _fault: crate::types::RemoveFaultArg,
        ) -> ::std::result::Result<::std::primitive::bool, crate::services::eden_service::RemoveFaultExn> {
            ::std::result::Result::Err(crate::services::eden_service::RemoveFaultExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "removeFault",
                ),
            ))
        }
        async fn unblockFault(
            &self,
            _info: crate::types::UnblockFaultArg,
        ) -> ::std::result::Result<::std::primitive::i64, crate::services::eden_service::UnblockFaultExn> {
            ::std::result::Result::Err(crate::services::eden_service::UnblockFaultExn::ApplicationException(
                ::fbthrift::ApplicationException::unimplemented_method(
                    "EdenService",
                    "unblockFault",
                ),
            ))
        }
    }

    #[derive(Clone, Debug)]
    pub struct EdenServiceProcessor<P, H, R, SS> {
        service: H,
        supa: SS,
        _phantom: ::std::marker::PhantomData<(P, H, R)>,
    }

    impl<P, H, R, SS> EdenServiceProcessor<P, H, R, SS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: EdenService,
        SS: ::fbthrift::ThriftService<P::Frame>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::std::marker::Sync,
    {
        pub fn new(service: H, supa: SS) -> Self {
            Self {
                service,
                supa,
                _phantom: ::std::marker::PhantomData,
            }
        }

        pub fn into_inner(self) -> H {
            self.service
        }

        async fn handle_listMounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.listMounts(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::ListMountsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::ListMountsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::ListMountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "listMounts",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "listMounts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_mount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_info = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.mount(
                field_info.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "mount",
                        "info",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::MountExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::MountExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::MountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "mount",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "mount",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_unmount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unmount(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "unmount",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::UnmountExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::UnmountExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::UnmountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unmount",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unmount",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_checkOutRevision<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_snapshotHash = ::std::option::Option::None;
            let mut field_checkoutMode = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_snapshotHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_checkoutMode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.checkOutRevision(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "checkOutRevision",
                        "mountPoint",
                    )
                })?,
                field_snapshotHash.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "checkOutRevision",
                        "snapshotHash",
                    )
                })?,
                field_checkoutMode.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "checkOutRevision",
                        "checkoutMode",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::CheckOutRevisionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::CheckOutRevisionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::CheckOutRevisionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "checkOutRevision",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "checkOutRevision",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_resetParentCommits<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_parents = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_parents = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.resetParentCommits(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "resetParentCommits",
                        "mountPoint",
                    )
                })?,
                field_parents.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "resetParentCommits",
                        "parents",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::ResetParentCommitsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::ResetParentCommitsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::ResetParentCommitsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "resetParentCommits",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "resetParentCommits",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getSHA1<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_paths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_paths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getSHA1(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSHA1",
                        "mountPoint",
                    )
                })?,
                field_paths.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getSHA1",
                        "paths",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetSHA1Exn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetSHA1Exn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetSHA1Exn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getSHA1",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getSHA1",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getBindMounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getBindMounts(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getBindMounts",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetBindMountsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetBindMountsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetBindMountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getBindMounts",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getBindMounts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_addBindMount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_repoPath = ::std::option::Option::None;
            let mut field_targetPath = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_repoPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_targetPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.addBindMount(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addBindMount",
                        "mountPoint",
                    )
                })?,
                field_repoPath.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addBindMount",
                        "repoPath",
                    )
                })?,
                field_targetPath.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "addBindMount",
                        "targetPath",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::AddBindMountExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::AddBindMountExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::AddBindMountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "addBindMount",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "addBindMount",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeBindMount<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_repoPath = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_repoPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removeBindMount(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeBindMount",
                        "mountPoint",
                    )
                })?,
                field_repoPath.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeBindMount",
                        "repoPath",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::RemoveBindMountExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::RemoveBindMountExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::RemoveBindMountExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeBindMount",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeBindMount",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getCurrentJournalPosition<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getCurrentJournalPosition(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getCurrentJournalPosition",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetCurrentJournalPositionExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetCurrentJournalPositionExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getCurrentJournalPosition",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getCurrentJournalPosition",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getFilesChangedSince<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_fromPosition = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_fromPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getFilesChangedSince(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getFilesChangedSince",
                        "mountPoint",
                    )
                })?,
                field_fromPosition.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getFilesChangedSince",
                        "fromPosition",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetFilesChangedSinceExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetFilesChangedSinceExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getFilesChangedSince",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getFilesChangedSince",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_setJournalMemoryLimit<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.setJournalMemoryLimit(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setJournalMemoryLimit",
                        "mountPoint",
                    )
                })?,
                field_limit.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "setJournalMemoryLimit",
                        "limit",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::SetJournalMemoryLimitExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::SetJournalMemoryLimitExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "setJournalMemoryLimit",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "setJournalMemoryLimit",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getJournalMemoryLimit<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getJournalMemoryLimit(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getJournalMemoryLimit",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetJournalMemoryLimitExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetJournalMemoryLimitExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getJournalMemoryLimit",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getJournalMemoryLimit",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_flushJournal<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.flushJournal(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "flushJournal",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::FlushJournalExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::FlushJournalExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::FlushJournalExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "flushJournal",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "flushJournal",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugGetRawJournal<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_params = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetRawJournal(
                field_params.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetRawJournal",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugGetRawJournalExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetRawJournalExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetRawJournal",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetRawJournal",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getEntryInformation<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_paths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_paths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getEntryInformation(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEntryInformation",
                        "mountPoint",
                    )
                })?,
                field_paths.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getEntryInformation",
                        "paths",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetEntryInformationExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetEntryInformationExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetEntryInformationExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getEntryInformation",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getEntryInformation",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getFileInformation<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_paths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_paths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getFileInformation(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getFileInformation",
                        "mountPoint",
                    )
                })?,
                field_paths.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getFileInformation",
                        "paths",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetFileInformationExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetFileInformationExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetFileInformationExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getFileInformation",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getFileInformation",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_glob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_globs = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_globs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.glob(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "glob",
                        "mountPoint",
                    )
                })?,
                field_globs.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "glob",
                        "globs",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GlobExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GlobExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GlobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "glob",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "glob",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_globFiles<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_params = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.globFiles(
                field_params.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "globFiles",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GlobFilesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GlobFilesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GlobFilesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "globFiles",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "globFiles",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_chown<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_uid = ::std::option::Option::None;
            let mut field_gid = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_uid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_gid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.chown(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "chown",
                        "mountPoint",
                    )
                })?,
                field_uid.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "chown",
                        "uid",
                    )
                })?,
                field_gid.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "chown",
                        "gid",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::ChownExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::ChownExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::ChownExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "chown",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "chown",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getScmStatusV2<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_params = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatusV2(
                field_params.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatusV2",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetScmStatusV2Exn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusV2Exn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatusV2",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatusV2",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getScmStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_listIgnored = ::std::option::Option::None;
            let mut field_commit = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_listIgnored = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_commit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatus(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatus",
                        "mountPoint",
                    )
                })?,
                field_listIgnored.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatus",
                        "listIgnored",
                    )
                })?,
                field_commit.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatus",
                        "commit",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetScmStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatus",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getScmStatusBetweenRevisions<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_oldHash = ::std::option::Option::None;
            let mut field_newHash = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_oldHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_newHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getScmStatusBetweenRevisions(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "mountPoint",
                    )
                })?,
                field_oldHash.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "oldHash",
                    )
                })?,
                field_newHash.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getScmStatusBetweenRevisions",
                        "newHash",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getScmStatusBetweenRevisions",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getScmStatusBetweenRevisions",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getManifestEntry<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_relativePath = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_relativePath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getManifestEntry(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getManifestEntry",
                        "mountPoint",
                    )
                })?,
                field_relativePath.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getManifestEntry",
                        "relativePath",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetManifestEntryExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetManifestEntryExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetManifestEntryExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getManifestEntry",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getManifestEntry",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getDaemonInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getDaemonInfo(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetDaemonInfoExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetDaemonInfoExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetDaemonInfoExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getDaemonInfo",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getDaemonInfo",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getPid<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getPid(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetPidExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetPidExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetPidExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getPid",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getPid",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_initiateShutdown<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_reason = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_reason = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.initiateShutdown(
                field_reason.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "initiateShutdown",
                        "reason",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::InitiateShutdownExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::InitiateShutdownExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::InitiateShutdownExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "initiateShutdown",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "initiateShutdown",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_params = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_params = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getConfig(
                field_params.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getConfig",
                        "params",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getConfig",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_reloadConfig<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.reloadConfig(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::ReloadConfigExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::ReloadConfigExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::ReloadConfigExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "reloadConfig",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "reloadConfig",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugGetScmTree<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_localStoreOnly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_localStoreOnly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmTree(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmTree",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugGetScmTreeExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmTreeExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmTree",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmTree",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugGetScmBlob<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_localStoreOnly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_localStoreOnly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmBlob(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlob",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugGetScmBlobExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmBlob",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmBlob",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugGetScmBlobMetadata<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let mut field_localStoreOnly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_localStoreOnly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetScmBlobMetadata(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "mountPoint",
                    )
                })?,
                field_id.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "id",
                    )
                })?,
                field_localStoreOnly.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetScmBlobMetadata",
                        "localStoreOnly",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetScmBlobMetadata",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetScmBlobMetadata",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugInodeStatus<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugInodeStatus(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugInodeStatus",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugInodeStatus",
                        "path",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugInodeStatusExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugInodeStatusExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugInodeStatusExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugInodeStatus",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugInodeStatus",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugOutstandingFuseCalls<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugOutstandingFuseCalls(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugOutstandingFuseCalls",
                        "mountPoint",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugOutstandingFuseCalls",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugOutstandingFuseCalls",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugGetInodePath<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_inodeNumber = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_inodeNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugGetInodePath(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetInodePath",
                        "mountPoint",
                    )
                })?,
                field_inodeNumber.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "debugGetInodePath",
                        "inodeNumber",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugGetInodePathExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetInodePathExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugGetInodePathExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugGetInodePath",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugGetInodePath",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getAccessCounts<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_duration = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_duration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getAccessCounts(
                field_duration.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "getAccessCounts",
                        "duration",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetAccessCountsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetAccessCountsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetAccessCountsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getAccessCounts",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getAccessCounts",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_clearAndCompactLocalStore<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.clearAndCompactLocalStore(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "clearAndCompactLocalStore",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "clearAndCompactLocalStore",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugClearLocalStoreCaches<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugClearLocalStoreCaches(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugClearLocalStoreCaches",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugClearLocalStoreCaches",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_debugCompactLocalStorage<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.debugCompactLocalStorage(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DebugCompactLocalStorageExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DebugCompactLocalStorageExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "debugCompactLocalStorage",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "debugCompactLocalStorage",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_unloadInodeForPath<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let mut field_age = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 3) => field_age = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unloadInodeForPath(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "path",
                    )
                })?,
                field_age.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "unloadInodeForPath",
                        "age",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::UnloadInodeForPathExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::UnloadInodeForPathExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unloadInodeForPath",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unloadInodeForPath",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_flushStatsNow<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.flushStatsNow(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::FlushStatsNowExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::FlushStatsNowExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::FlushStatsNowExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "flushStatsNow",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "flushStatsNow",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_invalidateKernelInodeCache<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.invalidateKernelInodeCache(
                field_mountPoint.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "invalidateKernelInodeCache",
                        "mountPoint",
                    )
                })?,
                field_path.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "invalidateKernelInodeCache",
                        "path",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "invalidateKernelInodeCache",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "invalidateKernelInodeCache",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getStatInfo<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getStatInfo(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetStatInfoExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetStatInfoExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetStatInfoExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getStatInfo",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getStatInfo",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_enableTracing<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.enableTracing(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::EnableTracingExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::EnableTracingExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::EnableTracingExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "enableTracing",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "enableTracing",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_disableTracing<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.disableTracing(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::DisableTracingExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::DisableTracingExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::DisableTracingExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "disableTracing",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "disableTracing",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_getTracePoints<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.getTracePoints(
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::GetTracePointsExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::GetTracePointsExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::GetTracePointsExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "getTracePoints",
                    )
                }
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "getTracePoints",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_injectFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_fault = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.injectFault(
                field_fault.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "injectFault",
                        "fault",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::InjectFaultExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::InjectFaultExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::InjectFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "injectFault",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "injectFault",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_removeFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_fault = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fault = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.removeFault(
                field_fault.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "removeFault",
                        "fault",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::RemoveFaultExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::RemoveFaultExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::RemoveFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "removeFault",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "removeFault",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }

        async fn handle_unblockFault<'a>(
            &'a self,
            p: &'a mut P::Deserializer,
            _req_ctxt: &R,
            seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::ProtocolReader as _;
            let mut field_info = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_info = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            let res = self.service.unblockFault(
                field_info.ok_or_else(|| {
                    ::fbthrift::ApplicationException::missing_arg(
                        "unblockFault",
                        "info",
                    )
                })?,
            ).await;
            let res = match res {
                ::std::result::Result::Ok(res) => {
                    crate::services::eden_service::UnblockFaultExn::Success(res)
                }
                ::std::result::Result::Err(crate::services::eden_service::UnblockFaultExn::ApplicationException(aexn)) => {
                    return ::std::result::Result::Err(aexn.into())
                }
                ::std::result::Result::Err(crate::services::eden_service::UnblockFaultExn::Success(_)) => {
                    panic!(
                        "{} attempted to return success via error",
                        "unblockFault",
                    )
                }
                ::std::result::Result::Err(exn) => exn,
            };
            let res = ::fbthrift::serialize!(P, |p| ::fbthrift::protocol::write_message(
                p,
                "unblockFault",
                ::fbthrift::MessageType::Reply,
                seqid,
                |p| ::fbthrift::Serialize::write(&res, p),
            ));
            ::std::result::Result::Ok(res)
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, SS> ::fbthrift::ServiceProcessor<P> for EdenServiceProcessor<P, H, R, SS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        H: EdenService,
        SS: ::fbthrift::ThriftService<P::Frame>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type RequestContext = R;

        #[inline]
        fn method_idx(&self, name: &[::std::primitive::u8]) -> ::std::result::Result<::std::primitive::usize, ::fbthrift::ApplicationException> {
            match name {
                b"listMounts" => ::std::result::Result::Ok(0usize),
                b"mount" => ::std::result::Result::Ok(1usize),
                b"unmount" => ::std::result::Result::Ok(2usize),
                b"checkOutRevision" => ::std::result::Result::Ok(3usize),
                b"resetParentCommits" => ::std::result::Result::Ok(4usize),
                b"getSHA1" => ::std::result::Result::Ok(5usize),
                b"getBindMounts" => ::std::result::Result::Ok(6usize),
                b"addBindMount" => ::std::result::Result::Ok(7usize),
                b"removeBindMount" => ::std::result::Result::Ok(8usize),
                b"getCurrentJournalPosition" => ::std::result::Result::Ok(9usize),
                b"getFilesChangedSince" => ::std::result::Result::Ok(10usize),
                b"setJournalMemoryLimit" => ::std::result::Result::Ok(11usize),
                b"getJournalMemoryLimit" => ::std::result::Result::Ok(12usize),
                b"flushJournal" => ::std::result::Result::Ok(13usize),
                b"debugGetRawJournal" => ::std::result::Result::Ok(14usize),
                b"getEntryInformation" => ::std::result::Result::Ok(15usize),
                b"getFileInformation" => ::std::result::Result::Ok(16usize),
                b"glob" => ::std::result::Result::Ok(17usize),
                b"globFiles" => ::std::result::Result::Ok(18usize),
                b"chown" => ::std::result::Result::Ok(19usize),
                b"getScmStatusV2" => ::std::result::Result::Ok(20usize),
                b"getScmStatus" => ::std::result::Result::Ok(21usize),
                b"getScmStatusBetweenRevisions" => ::std::result::Result::Ok(22usize),
                b"getManifestEntry" => ::std::result::Result::Ok(23usize),
                b"getDaemonInfo" => ::std::result::Result::Ok(24usize),
                b"getPid" => ::std::result::Result::Ok(25usize),
                b"initiateShutdown" => ::std::result::Result::Ok(26usize),
                b"getConfig" => ::std::result::Result::Ok(27usize),
                b"reloadConfig" => ::std::result::Result::Ok(28usize),
                b"debugGetScmTree" => ::std::result::Result::Ok(29usize),
                b"debugGetScmBlob" => ::std::result::Result::Ok(30usize),
                b"debugGetScmBlobMetadata" => ::std::result::Result::Ok(31usize),
                b"debugInodeStatus" => ::std::result::Result::Ok(32usize),
                b"debugOutstandingFuseCalls" => ::std::result::Result::Ok(33usize),
                b"debugGetInodePath" => ::std::result::Result::Ok(34usize),
                b"getAccessCounts" => ::std::result::Result::Ok(35usize),
                b"clearAndCompactLocalStore" => ::std::result::Result::Ok(36usize),
                b"debugClearLocalStoreCaches" => ::std::result::Result::Ok(37usize),
                b"debugCompactLocalStorage" => ::std::result::Result::Ok(38usize),
                b"unloadInodeForPath" => ::std::result::Result::Ok(39usize),
                b"flushStatsNow" => ::std::result::Result::Ok(40usize),
                b"invalidateKernelInodeCache" => ::std::result::Result::Ok(41usize),
                b"getStatInfo" => ::std::result::Result::Ok(42usize),
                b"enableTracing" => ::std::result::Result::Ok(43usize),
                b"disableTracing" => ::std::result::Result::Ok(44usize),
                b"getTracePoints" => ::std::result::Result::Ok(45usize),
                b"injectFault" => ::std::result::Result::Ok(46usize),
                b"removeFault" => ::std::result::Result::Ok(47usize),
                b"unblockFault" => ::std::result::Result::Ok(48usize),
                _ => ::std::result::Result::Err(::fbthrift::ApplicationException::unknown_method()),
            }
        }

        async fn handle_method(
            &self,
            idx: ::std::primitive::usize,
            _p: &mut P::Deserializer,
            _r: &R,
            _seqid: ::std::primitive::u32,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            match idx {
                0usize => self.handle_listMounts(_p, _r, _seqid).await,
                1usize => self.handle_mount(_p, _r, _seqid).await,
                2usize => self.handle_unmount(_p, _r, _seqid).await,
                3usize => self.handle_checkOutRevision(_p, _r, _seqid).await,
                4usize => self.handle_resetParentCommits(_p, _r, _seqid).await,
                5usize => self.handle_getSHA1(_p, _r, _seqid).await,
                6usize => self.handle_getBindMounts(_p, _r, _seqid).await,
                7usize => self.handle_addBindMount(_p, _r, _seqid).await,
                8usize => self.handle_removeBindMount(_p, _r, _seqid).await,
                9usize => self.handle_getCurrentJournalPosition(_p, _r, _seqid).await,
                10usize => self.handle_getFilesChangedSince(_p, _r, _seqid).await,
                11usize => self.handle_setJournalMemoryLimit(_p, _r, _seqid).await,
                12usize => self.handle_getJournalMemoryLimit(_p, _r, _seqid).await,
                13usize => self.handle_flushJournal(_p, _r, _seqid).await,
                14usize => self.handle_debugGetRawJournal(_p, _r, _seqid).await,
                15usize => self.handle_getEntryInformation(_p, _r, _seqid).await,
                16usize => self.handle_getFileInformation(_p, _r, _seqid).await,
                17usize => self.handle_glob(_p, _r, _seqid).await,
                18usize => self.handle_globFiles(_p, _r, _seqid).await,
                19usize => self.handle_chown(_p, _r, _seqid).await,
                20usize => self.handle_getScmStatusV2(_p, _r, _seqid).await,
                21usize => self.handle_getScmStatus(_p, _r, _seqid).await,
                22usize => self.handle_getScmStatusBetweenRevisions(_p, _r, _seqid).await,
                23usize => self.handle_getManifestEntry(_p, _r, _seqid).await,
                24usize => self.handle_getDaemonInfo(_p, _r, _seqid).await,
                25usize => self.handle_getPid(_p, _r, _seqid).await,
                26usize => self.handle_initiateShutdown(_p, _r, _seqid).await,
                27usize => self.handle_getConfig(_p, _r, _seqid).await,
                28usize => self.handle_reloadConfig(_p, _r, _seqid).await,
                29usize => self.handle_debugGetScmTree(_p, _r, _seqid).await,
                30usize => self.handle_debugGetScmBlob(_p, _r, _seqid).await,
                31usize => self.handle_debugGetScmBlobMetadata(_p, _r, _seqid).await,
                32usize => self.handle_debugInodeStatus(_p, _r, _seqid).await,
                33usize => self.handle_debugOutstandingFuseCalls(_p, _r, _seqid).await,
                34usize => self.handle_debugGetInodePath(_p, _r, _seqid).await,
                35usize => self.handle_getAccessCounts(_p, _r, _seqid).await,
                36usize => self.handle_clearAndCompactLocalStore(_p, _r, _seqid).await,
                37usize => self.handle_debugClearLocalStoreCaches(_p, _r, _seqid).await,
                38usize => self.handle_debugCompactLocalStorage(_p, _r, _seqid).await,
                39usize => self.handle_unloadInodeForPath(_p, _r, _seqid).await,
                40usize => self.handle_flushStatsNow(_p, _r, _seqid).await,
                41usize => self.handle_invalidateKernelInodeCache(_p, _r, _seqid).await,
                42usize => self.handle_getStatInfo(_p, _r, _seqid).await,
                43usize => self.handle_enableTracing(_p, _r, _seqid).await,
                44usize => self.handle_disableTracing(_p, _r, _seqid).await,
                45usize => self.handle_getTracePoints(_p, _r, _seqid).await,
                46usize => self.handle_injectFault(_p, _r, _seqid).await,
                47usize => self.handle_removeFault(_p, _r, _seqid).await,
                48usize => self.handle_unblockFault(_p, _r, _seqid).await,
                bad => panic!(
                    "{}: unexpected method idx {}",
                    "EdenServiceProcessor",
                    bad
                ),
            }
        }
    }

    #[::async_trait::async_trait]
    impl<P, H, R, SS> ::fbthrift::ThriftService<P::Frame> for EdenServiceProcessor<P, H, R, SS>
    where
        P: ::fbthrift::Protocol + ::std::marker::Send + ::std::marker::Sync + 'static,
        P::Deserializer: ::std::marker::Send,
        P::Frame: ::std::marker::Send + 'static,
        H: EdenService,
        SS: ::fbthrift::ThriftService<P::Frame, RequestContext = R>,
        SS::Handler: fb303_core::server::BaseService,
        P::Frame: ::std::marker::Send + 'static,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        type Handler = H;
        type RequestContext = R;

        async fn call(
            &self,
            req: ::fbthrift::ProtocolDecoded<P>,
            req_ctxt: &R,
        ) -> ::anyhow::Result<::fbthrift::ProtocolEncodedFinal<P>> {
            use ::fbthrift::{BufExt as _, ProtocolReader as _, ServiceProcessor as _};
            let mut p = P::deserializer(req);
            let (idx, mty, seqid) = p.read_message_begin(|name| self.method_idx(name))?;
            if mty != ::fbthrift::MessageType::Call {
                return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                    ::fbthrift::ApplicationExceptionErrorCode::InvalidMessageType,
                    format!("message type {:?} not handled", mty)
                )));
            }
            let idx = match idx {
                ::std::result::Result::Ok(idx) => idx,
                ::std::result::Result::Err(_) => {
                    let cur = P::into_buffer(p).reset();
                    return self.supa.call(cur, req_ctxt).await;
                }
            };
            let res = self.handle_method(idx, &mut p, req_ctxt, seqid).await;
            p.read_message_end()?;
            match res {
                ::std::result::Result::Ok(bytes) => ::std::result::Result::Ok(bytes),
                ::std::result::Result::Err(err) => match err.downcast_ref::<::fbthrift::ProtocolError>() {
                    ::std::option::Option::Some(::fbthrift::ProtocolError::ApplicationException(ae)) => {
                        let res = ::fbthrift::serialize!(P, |p| {
                            ::fbthrift::protocol::write_message(
                                p,
                                "EdenServiceProcessor",
                                ::fbthrift::MessageType::Exception,
                                seqid,
                                |p| ::fbthrift::Serialize::write(&ae, p),
                            )
                        });
                        ::std::result::Result::Ok(res)
                    }
                    _ => ::std::result::Result::Err(err),
                },
            }
        }
    }

    pub fn make_EdenService_server<F, H, R, SMAKE, SS>(
        proto: ::fbthrift::ProtocolID,
        handler: H,
        supa: SMAKE,
    ) -> ::std::result::Result<::std::boxed::Box<dyn ::fbthrift::ThriftService<F, Handler = H, RequestContext = R> + ::std::marker::Send + 'static>, ::fbthrift::ApplicationException>
    where
        F: ::fbthrift::Framing + ::std::marker::Send + ::std::marker::Sync + 'static,
        H: EdenService,
        SMAKE: ::std::ops::Fn(::fbthrift::ProtocolID) -> ::std::result::Result<SS, ::fbthrift::ApplicationException>,
        SS: ::fbthrift::ThriftService<F, RequestContext = R>,
        SS::Handler: fb303_core::server::BaseService,
        R: ::std::marker::Send + ::std::marker::Sync + 'static,
    {
        match proto {
            ::fbthrift::ProtocolID::BinaryProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(EdenServiceProcessor::<::fbthrift::BinaryProtocol<F>, H, R, SS>::new(handler, supa(proto)?)))
            }
            ::fbthrift::ProtocolID::CompactProtocol => {
                ::std::result::Result::Ok(::std::boxed::Box::new(EdenServiceProcessor::<::fbthrift::CompactProtocol<F>, H, R, SS>::new(handler, supa(proto)?)))
            }
            bad => ::std::result::Result::Err(::fbthrift::ApplicationException::invalid_protocol(bad)),
        }
    }
}

/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
///     service MyService {
///         FunctionResponse myFunction(
///             1: FunctionRequest request,
///         ) throws {
///             1: StorageException s,
///             2: NotFoundException n,
///         ),
///
///         // other functions
///     }
///
///
/// we would end up with this mock object under crate::mock::MyService:
///
///     impl crate::client::MyService for MyService<'mock> {...}
///
///     pub struct MyService<'mock> {
///         pub myFunction: myFunction<'mock>,
///         // ...
///     }
///
///     impl dyn crate::client::MyService {
///         pub fn mock<'mock>() -> MyService<'mock>;
///     }
///
///     impl myFunction<'mock> {
///         // directly return the given success response
///         pub fn ret(&self, value: FunctionResponse);
///
///         // invoke closure to compute success response
///         pub fn mock(
///             &self,
///             mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///         );
///
///         // return one of the function's declared exceptions
///         pub fn throw<E>(&self, exception: E)
///         where
///             E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
///     }
///
///     impl From<StorageException> for MyFunctionExn {...}
///     impl From<NotFoundException> for MyFunctionExn {...}
///
///
/// The intended usage from a test would be:
///
///     use std::sync::Arc;
///     use thrift_if::client::MyService;
///
///     #[test]
///     fn test_my_client() {
///         let mock = Arc::new(MyService::mock());
///
///         // directly return a success response
///         let resp = FunctionResponse {...};
///         mock.myFunction.ret(resp);
///
///         // or give a closure to compute the success response
///         mock.myFunction.mock(|request| FunctionResponse {...});
///
///         // or throw one of the function's exceptions
///         mock.myFunction.throw(StorageException::ItFailed);
///
///         let out = do_the_thing(mock).wait().unwrap();
///         assert!(out.what_i_expected());
///     }
///
///     fn do_the_thing(
///         client: Arc<dyn MyService + Send + Sync + 'static>,
///     ) -> impl Future<Item = Out> {...}
pub mod mock {
    pub struct EdenService<'mock> {
        pub parent: fb303_core::mock::BaseService<'mock>,
        pub listMounts: r#impl::eden_service::listMounts<'mock>,
        pub mount: r#impl::eden_service::mount<'mock>,
        pub unmount: r#impl::eden_service::unmount<'mock>,
        pub checkOutRevision: r#impl::eden_service::checkOutRevision<'mock>,
        pub resetParentCommits: r#impl::eden_service::resetParentCommits<'mock>,
        pub getSHA1: r#impl::eden_service::getSHA1<'mock>,
        pub getBindMounts: r#impl::eden_service::getBindMounts<'mock>,
        pub addBindMount: r#impl::eden_service::addBindMount<'mock>,
        pub removeBindMount: r#impl::eden_service::removeBindMount<'mock>,
        pub getCurrentJournalPosition: r#impl::eden_service::getCurrentJournalPosition<'mock>,
        pub getFilesChangedSince: r#impl::eden_service::getFilesChangedSince<'mock>,
        pub setJournalMemoryLimit: r#impl::eden_service::setJournalMemoryLimit<'mock>,
        pub getJournalMemoryLimit: r#impl::eden_service::getJournalMemoryLimit<'mock>,
        pub flushJournal: r#impl::eden_service::flushJournal<'mock>,
        pub debugGetRawJournal: r#impl::eden_service::debugGetRawJournal<'mock>,
        pub getEntryInformation: r#impl::eden_service::getEntryInformation<'mock>,
        pub getFileInformation: r#impl::eden_service::getFileInformation<'mock>,
        pub glob: r#impl::eden_service::glob<'mock>,
        pub globFiles: r#impl::eden_service::globFiles<'mock>,
        pub chown: r#impl::eden_service::chown<'mock>,
        pub getScmStatusV2: r#impl::eden_service::getScmStatusV2<'mock>,
        pub getScmStatus: r#impl::eden_service::getScmStatus<'mock>,
        pub getScmStatusBetweenRevisions: r#impl::eden_service::getScmStatusBetweenRevisions<'mock>,
        pub getManifestEntry: r#impl::eden_service::getManifestEntry<'mock>,
        pub getDaemonInfo: r#impl::eden_service::getDaemonInfo<'mock>,
        pub getPid: r#impl::eden_service::getPid<'mock>,
        pub initiateShutdown: r#impl::eden_service::initiateShutdown<'mock>,
        pub getConfig: r#impl::eden_service::getConfig<'mock>,
        pub reloadConfig: r#impl::eden_service::reloadConfig<'mock>,
        pub debugGetScmTree: r#impl::eden_service::debugGetScmTree<'mock>,
        pub debugGetScmBlob: r#impl::eden_service::debugGetScmBlob<'mock>,
        pub debugGetScmBlobMetadata: r#impl::eden_service::debugGetScmBlobMetadata<'mock>,
        pub debugInodeStatus: r#impl::eden_service::debugInodeStatus<'mock>,
        pub debugOutstandingFuseCalls: r#impl::eden_service::debugOutstandingFuseCalls<'mock>,
        pub debugGetInodePath: r#impl::eden_service::debugGetInodePath<'mock>,
        pub getAccessCounts: r#impl::eden_service::getAccessCounts<'mock>,
        pub clearAndCompactLocalStore: r#impl::eden_service::clearAndCompactLocalStore<'mock>,
        pub debugClearLocalStoreCaches: r#impl::eden_service::debugClearLocalStoreCaches<'mock>,
        pub debugCompactLocalStorage: r#impl::eden_service::debugCompactLocalStorage<'mock>,
        pub unloadInodeForPath: r#impl::eden_service::unloadInodeForPath<'mock>,
        pub flushStatsNow: r#impl::eden_service::flushStatsNow<'mock>,
        pub invalidateKernelInodeCache: r#impl::eden_service::invalidateKernelInodeCache<'mock>,
        pub getStatInfo: r#impl::eden_service::getStatInfo<'mock>,
        pub enableTracing: r#impl::eden_service::enableTracing<'mock>,
        pub disableTracing: r#impl::eden_service::disableTracing<'mock>,
        pub getTracePoints: r#impl::eden_service::getTracePoints<'mock>,
        pub injectFault: r#impl::eden_service::injectFault<'mock>,
        pub removeFault: r#impl::eden_service::removeFault<'mock>,
        pub unblockFault: r#impl::eden_service::unblockFault<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::EdenService {
        pub fn mock<'mock>() -> EdenService<'mock> {
            EdenService {
                parent: fb303_core::client::BaseService::mock(),
                listMounts: r#impl::eden_service::listMounts::unimplemented(),
                mount: r#impl::eden_service::mount::unimplemented(),
                unmount: r#impl::eden_service::unmount::unimplemented(),
                checkOutRevision: r#impl::eden_service::checkOutRevision::unimplemented(),
                resetParentCommits: r#impl::eden_service::resetParentCommits::unimplemented(),
                getSHA1: r#impl::eden_service::getSHA1::unimplemented(),
                getBindMounts: r#impl::eden_service::getBindMounts::unimplemented(),
                addBindMount: r#impl::eden_service::addBindMount::unimplemented(),
                removeBindMount: r#impl::eden_service::removeBindMount::unimplemented(),
                getCurrentJournalPosition: r#impl::eden_service::getCurrentJournalPosition::unimplemented(),
                getFilesChangedSince: r#impl::eden_service::getFilesChangedSince::unimplemented(),
                setJournalMemoryLimit: r#impl::eden_service::setJournalMemoryLimit::unimplemented(),
                getJournalMemoryLimit: r#impl::eden_service::getJournalMemoryLimit::unimplemented(),
                flushJournal: r#impl::eden_service::flushJournal::unimplemented(),
                debugGetRawJournal: r#impl::eden_service::debugGetRawJournal::unimplemented(),
                getEntryInformation: r#impl::eden_service::getEntryInformation::unimplemented(),
                getFileInformation: r#impl::eden_service::getFileInformation::unimplemented(),
                glob: r#impl::eden_service::glob::unimplemented(),
                globFiles: r#impl::eden_service::globFiles::unimplemented(),
                chown: r#impl::eden_service::chown::unimplemented(),
                getScmStatusV2: r#impl::eden_service::getScmStatusV2::unimplemented(),
                getScmStatus: r#impl::eden_service::getScmStatus::unimplemented(),
                getScmStatusBetweenRevisions: r#impl::eden_service::getScmStatusBetweenRevisions::unimplemented(),
                getManifestEntry: r#impl::eden_service::getManifestEntry::unimplemented(),
                getDaemonInfo: r#impl::eden_service::getDaemonInfo::unimplemented(),
                getPid: r#impl::eden_service::getPid::unimplemented(),
                initiateShutdown: r#impl::eden_service::initiateShutdown::unimplemented(),
                getConfig: r#impl::eden_service::getConfig::unimplemented(),
                reloadConfig: r#impl::eden_service::reloadConfig::unimplemented(),
                debugGetScmTree: r#impl::eden_service::debugGetScmTree::unimplemented(),
                debugGetScmBlob: r#impl::eden_service::debugGetScmBlob::unimplemented(),
                debugGetScmBlobMetadata: r#impl::eden_service::debugGetScmBlobMetadata::unimplemented(),
                debugInodeStatus: r#impl::eden_service::debugInodeStatus::unimplemented(),
                debugOutstandingFuseCalls: r#impl::eden_service::debugOutstandingFuseCalls::unimplemented(),
                debugGetInodePath: r#impl::eden_service::debugGetInodePath::unimplemented(),
                getAccessCounts: r#impl::eden_service::getAccessCounts::unimplemented(),
                clearAndCompactLocalStore: r#impl::eden_service::clearAndCompactLocalStore::unimplemented(),
                debugClearLocalStoreCaches: r#impl::eden_service::debugClearLocalStoreCaches::unimplemented(),
                debugCompactLocalStorage: r#impl::eden_service::debugCompactLocalStorage::unimplemented(),
                unloadInodeForPath: r#impl::eden_service::unloadInodeForPath::unimplemented(),
                flushStatsNow: r#impl::eden_service::flushStatsNow::unimplemented(),
                invalidateKernelInodeCache: r#impl::eden_service::invalidateKernelInodeCache::unimplemented(),
                getStatInfo: r#impl::eden_service::getStatInfo::unimplemented(),
                enableTracing: r#impl::eden_service::enableTracing::unimplemented(),
                disableTracing: r#impl::eden_service::disableTracing::unimplemented(),
                getTracePoints: r#impl::eden_service::getTracePoints::unimplemented(),
                injectFault: r#impl::eden_service::injectFault::unimplemented(),
                removeFault: r#impl::eden_service::removeFault::unimplemented(),
                unblockFault: r#impl::eden_service::unblockFault::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> super::client::EdenService for EdenService<'mock> {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listMounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.mount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MountArgument) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_info.clone())))
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unmount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::BinaryHash,
            arg_checkoutMode: &crate::types::CheckoutMode,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.checkOutRevision.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_snapshotHash.clone(), arg_checkoutMode.clone())))
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.resetParentCommits.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_parents.clone())))
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSHA1.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned())))
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getBindMounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addBindMount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone(), arg_targetPath.clone())))
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeBindMount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone())))
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCurrentJournalPosition.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getFilesChangedSince.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_fromPosition.clone())))
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_limit.clone())))
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.flushJournal.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetRawJournal.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEntryInformation.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned())))
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getFileInformation.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned())))
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.glob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_globs.to_owned())))
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.globFiles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GlobParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.chown.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_uid.clone(), arg_gid.clone())))
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatusV2.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetScmStatusParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::BinaryHash) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_listIgnored.clone(), arg_commit.clone())))
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::BinaryHash,
            arg_newHash: &crate::types::BinaryHash,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatusBetweenRevisions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_oldHash.clone(), arg_newHash.clone())))
        }
        fn getManifestEntry(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_relativePath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ManifestEntry, crate::errors::eden_service::GetManifestEntryError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getManifestEntry.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_relativePath.clone())))
        }
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getDaemonInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getPid.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.initiateShutdown.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_reason.to_owned())))
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.reloadConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmTree.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmBlob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmBlobMetadata.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugInodeStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone())))
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugOutstandingFuseCalls.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetInodePath.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_inodeNumber.clone())))
        }
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getAccessCounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_duration.clone())))
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.clearAndCompactLocalStore.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugClearLocalStoreCaches.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugCompactLocalStorage.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unloadInodeForPath.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone(), arg_age.clone())))
        }
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.flushStatsNow.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.invalidateKernelInodeCache.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone())))
        }
        fn getStatInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.enableTracing.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.disableTracing.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTracePoints.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.injectFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::FaultDefinition) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_fault.clone())))
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveFaultArg) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_fault.clone())))
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unblockFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UnblockFaultArg) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_info.clone())))
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> ::std::convert::AsRef<dyn crate::dependencies::fb303_core::client::BaseService + 'mock> for EdenService<'mock>
    {
        fn as_ref(&self) -> &(dyn crate::dependencies::fb303_core::client::BaseService + 'mock) {
            self
        }
    }

    mod r#impl {
        pub mod eden_service {

            pub struct listMounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::MountInfo>,
                        crate::errors::eden_service::ListMountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listMounts<'mock> {
                pub fn unimplemented() -> Self {
                    listMounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "listMounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::MountInfo>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::vec::Vec<crate::types::MountInfo> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ListMountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct mount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MountArgument) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::MountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> mount<'mock> {
                pub fn unimplemented() -> Self {
                    mount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MountArgument| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "mount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::MountArgument| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MountArgument) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| ::std::result::Result::Ok(mock(info)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::MountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MountArgument| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unmount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::UnmountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unmount<'mock> {
                pub fn unimplemented() -> Self {
                    unmount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unmount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnmountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkOutRevision<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::CheckoutConflict>,
                        crate::errors::eden_service::CheckOutRevisionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> checkOutRevision<'mock> {
                pub fn unimplemented() -> Self {
                    checkOutRevision {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "checkOutRevision",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::CheckoutConflict>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::CheckoutMode) -> ::std::vec::Vec<crate::types::CheckoutConflict> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, snapshotHash, checkoutMode| ::std::result::Result::Ok(mock(mountPoint, snapshotHash, checkoutMode)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::CheckOutRevisionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::CheckoutMode| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct resetParentCommits<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ResetParentCommitsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> resetParentCommits<'mock> {
                pub fn unimplemented() -> Self {
                    resetParentCommits {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "resetParentCommits",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, parents| ::std::result::Result::Ok(mock(mountPoint, parents)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ResetParentCommitsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSHA1<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::SHA1Result>,
                        crate::errors::eden_service::GetSHA1Error,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSHA1<'mock> {
                pub fn unimplemented() -> Self {
                    getSHA1 {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getSHA1",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::SHA1Result>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::vec::Vec<crate::types::SHA1Result> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths| ::std::result::Result::Ok(mock(mountPoint, paths)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetSHA1Error>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getBindMounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::PathString>,
                        crate::errors::eden_service::GetBindMountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getBindMounts<'mock> {
                pub fn unimplemented() -> Self {
                    getBindMounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getBindMounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::PathString>) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::vec::Vec<crate::types::PathString> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetBindMountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addBindMount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::AddBindMountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addBindMount<'mock> {
                pub fn unimplemented() -> Self {
                    addBindMount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "addBindMount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath, targetPath| ::std::result::Result::Ok(mock(mountPoint, repoPath, targetPath)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::AddBindMountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeBindMount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::RemoveBindMountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeBindMount<'mock> {
                pub fn unimplemented() -> Self {
                    removeBindMount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "removeBindMount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath| ::std::result::Result::Ok(mock(mountPoint, repoPath)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::RemoveBindMountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCurrentJournalPosition<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        crate::types::JournalPosition,
                        crate::errors::eden_service::GetCurrentJournalPositionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCurrentJournalPosition<'mock> {
                pub fn unimplemented() -> Self {
                    getCurrentJournalPosition {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getCurrentJournalPosition",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::JournalPosition) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> crate::types::JournalPosition + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetCurrentJournalPositionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getFilesChangedSince<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> ::std::result::Result<
                        crate::types::FileDelta,
                        crate::errors::eden_service::GetFilesChangedSinceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getFilesChangedSince<'mock> {
                pub fn unimplemented() -> Self {
                    getFilesChangedSince {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::JournalPosition| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getFilesChangedSince",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::FileDelta) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::JournalPosition| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> crate::types::FileDelta + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, fromPosition| ::std::result::Result::Ok(mock(mountPoint, fromPosition)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetFilesChangedSinceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::JournalPosition| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setJournalMemoryLimit<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::SetJournalMemoryLimitError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setJournalMemoryLimit<'mock> {
                pub fn unimplemented() -> Self {
                    setJournalMemoryLimit {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "setJournalMemoryLimit",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, limit| ::std::result::Result::Ok(mock(mountPoint, limit)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::SetJournalMemoryLimitError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getJournalMemoryLimit<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::GetJournalMemoryLimitError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getJournalMemoryLimit<'mock> {
                pub fn unimplemented() -> Self {
                    getJournalMemoryLimit {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getJournalMemoryLimit",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetJournalMemoryLimitError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct flushJournal<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::FlushJournalError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> flushJournal<'mock> {
                pub fn unimplemented() -> Self {
                    flushJournal {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "flushJournal",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::FlushJournalError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetRawJournal<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> ::std::result::Result<
                        crate::types::DebugGetRawJournalResponse,
                        crate::errors::eden_service::DebugGetRawJournalError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetRawJournal<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetRawJournal {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DebugGetRawJournalParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetRawJournal",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::DebugGetRawJournalResponse) {
                    self.mock(move |_: crate::types::DebugGetRawJournalParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> crate::types::DebugGetRawJournalResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetRawJournalError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DebugGetRawJournalParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEntryInformation<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::EntryInformationOrError>,
                        crate::errors::eden_service::GetEntryInformationError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEntryInformation<'mock> {
                pub fn unimplemented() -> Self {
                    getEntryInformation {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getEntryInformation",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::EntryInformationOrError>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::vec::Vec<crate::types::EntryInformationOrError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths| ::std::result::Result::Ok(mock(mountPoint, paths)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetEntryInformationError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getFileInformation<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::FileInformationOrError>,
                        crate::errors::eden_service::GetFileInformationError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getFileInformation<'mock> {
                pub fn unimplemented() -> Self {
                    getFileInformation {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getFileInformation",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::FileInformationOrError>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>) -> ::std::vec::Vec<crate::types::FileInformationOrError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths| ::std::result::Result::Ok(mock(mountPoint, paths)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetFileInformationError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct glob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::PathString>,
                        crate::errors::eden_service::GlobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> glob<'mock> {
                pub fn unimplemented() -> Self {
                    glob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "glob",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::PathString>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> ::std::vec::Vec<crate::types::PathString> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, globs| ::std::result::Result::Ok(mock(mountPoint, globs)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GlobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct globFiles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GlobParams) -> ::std::result::Result<
                        crate::types::Glob,
                        crate::errors::eden_service::GlobFilesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> globFiles<'mock> {
                pub fn unimplemented() -> Self {
                    globFiles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GlobParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "globFiles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::Glob) {
                    self.mock(move |_: crate::types::GlobParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GlobParams) -> crate::types::Glob + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GlobFilesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GlobParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct chown<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ChownError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> chown<'mock> {
                pub fn unimplemented() -> Self {
                    chown {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "chown",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, uid, gid| ::std::result::Result::Ok(mock(mountPoint, uid, gid)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ChownError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatusV2<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetScmStatusParams) -> ::std::result::Result<
                        crate::types::GetScmStatusResult,
                        crate::errors::eden_service::GetScmStatusV2Error,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatusV2<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatusV2 {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetScmStatusParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatusV2",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetScmStatusResult) {
                    self.mock(move |_: crate::types::GetScmStatusParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetScmStatusParams) -> crate::types::GetScmStatusResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusV2Error>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetScmStatusParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::BinaryHash) -> ::std::result::Result<
                        crate::types::ScmStatus,
                        crate::errors::eden_service::GetScmStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatus<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::BinaryHash| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmStatus) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::BinaryHash| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::BinaryHash) -> crate::types::ScmStatus + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, listIgnored, commit| ::std::result::Result::Ok(mock(mountPoint, listIgnored, commit)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::BinaryHash| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatusBetweenRevisions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> ::std::result::Result<
                        crate::types::ScmStatus,
                        crate::errors::eden_service::GetScmStatusBetweenRevisionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatusBetweenRevisions<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatusBetweenRevisions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatusBetweenRevisions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmStatus) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, crate::types::BinaryHash) -> crate::types::ScmStatus + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, oldHash, newHash| ::std::result::Result::Ok(mock(mountPoint, oldHash, newHash)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusBetweenRevisionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: crate::types::BinaryHash| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getManifestEntry<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        crate::types::ManifestEntry,
                        crate::errors::eden_service::GetManifestEntryError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getManifestEntry<'mock> {
                pub fn unimplemented() -> Self {
                    getManifestEntry {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getManifestEntry",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ManifestEntry) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> crate::types::ManifestEntry + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, relativePath| ::std::result::Result::Ok(mock(mountPoint, relativePath)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetManifestEntryError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getDaemonInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::DaemonInfo,
                        crate::errors::eden_service::GetDaemonInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getDaemonInfo<'mock> {
                pub fn unimplemented() -> Self {
                    getDaemonInfo {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getDaemonInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::DaemonInfo) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::DaemonInfo + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetDaemonInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPid<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::GetPidError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getPid<'mock> {
                pub fn unimplemented() -> Self {
                    getPid {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getPid",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetPidError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct initiateShutdown<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InitiateShutdownError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> initiateShutdown<'mock> {
                pub fn unimplemented() -> Self {
                    initiateShutdown {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "initiateShutdown",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |reason| ::std::result::Result::Ok(mock(reason)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InitiateShutdownError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigParams) -> ::std::result::Result<
                        eden_config::types::EdenConfigData,
                        crate::errors::eden_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    getConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: eden_config::types::EdenConfigData) {
                    self.mock(move |_: crate::types::GetConfigParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigParams) -> eden_config::types::EdenConfigData + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct reloadConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ReloadConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> reloadConfig<'mock> {
                pub fn unimplemented() -> Self {
                    reloadConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "reloadConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ReloadConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmTree<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::ScmTreeEntry>,
                        crate::errors::eden_service::DebugGetScmTreeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmTree<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmTree {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmTree",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::ScmTreeEntry>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::vec::Vec<crate::types::ScmTreeEntry> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmTreeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmBlob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        ::std::vec::Vec<::std::primitive::u8>,
                        crate::errors::eden_service::DebugGetScmBlobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmBlob<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmBlob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmBlob",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<::std::primitive::u8>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::vec::Vec<::std::primitive::u8> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmBlobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmBlobMetadata<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        crate::types::ScmBlobMetadata,
                        crate::errors::eden_service::DebugGetScmBlobMetadataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmBlobMetadata<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmBlobMetadata {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmBlobMetadata",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmBlobMetadata) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> crate::types::ScmBlobMetadata + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmBlobMetadataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugInodeStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::TreeInodeDebugInfo>,
                        crate::errors::eden_service::DebugInodeStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugInodeStatus<'mock> {
                pub fn unimplemented() -> Self {
                    debugInodeStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugInodeStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::TreeInodeDebugInfo>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::vec::Vec<crate::types::TreeInodeDebugInfo> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path| ::std::result::Result::Ok(mock(mountPoint, path)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugInodeStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugOutstandingFuseCalls<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::FuseCall>,
                        crate::errors::eden_service::DebugOutstandingFuseCallsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugOutstandingFuseCalls<'mock> {
                pub fn unimplemented() -> Self {
                    debugOutstandingFuseCalls {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugOutstandingFuseCalls",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::FuseCall>) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::vec::Vec<crate::types::FuseCall> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugOutstandingFuseCallsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetInodePath<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<
                        crate::types::InodePathDebugInfo,
                        crate::errors::eden_service::DebugGetInodePathError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetInodePath<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetInodePath {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetInodePath",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::InodePathDebugInfo) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> crate::types::InodePathDebugInfo + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, inodeNumber| ::std::result::Result::Ok(mock(mountPoint, inodeNumber)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetInodePathError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getAccessCounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::primitive::i64) -> ::std::result::Result<
                        crate::types::GetAccessCountsResult,
                        crate::errors::eden_service::GetAccessCountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getAccessCounts<'mock> {
                pub fn unimplemented() -> Self {
                    getAccessCounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getAccessCounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetAccessCountsResult) {
                    self.mock(move |_: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i64) -> crate::types::GetAccessCountsResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |duration| ::std::result::Result::Ok(mock(duration)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetAccessCountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct clearAndCompactLocalStore<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ClearAndCompactLocalStoreError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> clearAndCompactLocalStore<'mock> {
                pub fn unimplemented() -> Self {
                    clearAndCompactLocalStore {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "clearAndCompactLocalStore",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ClearAndCompactLocalStoreError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugClearLocalStoreCaches<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DebugClearLocalStoreCachesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugClearLocalStoreCaches<'mock> {
                pub fn unimplemented() -> Self {
                    debugClearLocalStoreCaches {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugClearLocalStoreCaches",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugClearLocalStoreCachesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugCompactLocalStorage<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DebugCompactLocalStorageError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugCompactLocalStorage<'mock> {
                pub fn unimplemented() -> Self {
                    debugCompactLocalStorage {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugCompactLocalStorage",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugCompactLocalStorageError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unloadInodeForPath<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::UnloadInodeForPathError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unloadInodeForPath<'mock> {
                pub fn unimplemented() -> Self {
                    unloadInodeForPath {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unloadInodeForPath",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path, age| ::std::result::Result::Ok(mock(mountPoint, path, age)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnloadInodeForPathError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct flushStatsNow<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::FlushStatsNowError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> flushStatsNow<'mock> {
                pub fn unimplemented() -> Self {
                    flushStatsNow {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "flushStatsNow",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::FlushStatsNowError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct invalidateKernelInodeCache<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InvalidateKernelInodeCacheError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> invalidateKernelInodeCache<'mock> {
                pub fn unimplemented() -> Self {
                    invalidateKernelInodeCache {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "invalidateKernelInodeCache",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path| ::std::result::Result::Ok(mock(mountPoint, path)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InvalidateKernelInodeCacheError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::InternalStats,
                        crate::errors::eden_service::GetStatInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatInfo<'mock> {
                pub fn unimplemented() -> Self {
                    getStatInfo {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getStatInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::InternalStats) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::InternalStats + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetStatInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct enableTracing<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::EnableTracingError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> enableTracing<'mock> {
                pub fn unimplemented() -> Self {
                    enableTracing {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "enableTracing",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::EnableTracingError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct disableTracing<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DisableTracingError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> disableTracing<'mock> {
                pub fn unimplemented() -> Self {
                    disableTracing {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "disableTracing",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DisableTracingError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTracePoints<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::TracePoint>,
                        crate::errors::eden_service::GetTracePointsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTracePoints<'mock> {
                pub fn unimplemented() -> Self {
                    getTracePoints {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getTracePoints",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::TracePoint>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::vec::Vec<crate::types::TracePoint> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetTracePointsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct injectFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::FaultDefinition) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InjectFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> injectFault<'mock> {
                pub fn unimplemented() -> Self {
                    injectFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::FaultDefinition| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "injectFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::FaultDefinition| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::FaultDefinition) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| ::std::result::Result::Ok(mock(fault)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InjectFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::FaultDefinition| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveFaultArg) -> ::std::result::Result<
                        ::std::primitive::bool,
                        crate::errors::eden_service::RemoveFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeFault<'mock> {
                pub fn unimplemented() -> Self {
                    removeFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveFaultArg| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "removeFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::bool) {
                    self.mock(move |_: crate::types::RemoveFaultArg| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveFaultArg) -> ::std::primitive::bool + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| ::std::result::Result::Ok(mock(fault)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::RemoveFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveFaultArg| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unblockFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UnblockFaultArg) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::UnblockFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unblockFault<'mock> {
                pub fn unimplemented() -> Self {
                    unblockFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UnblockFaultArg| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unblockFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::UnblockFaultArg| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UnblockFaultArg) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| ::std::result::Result::Ok(mock(info)));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnblockFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UnblockFaultArg| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

pub mod errors {
    pub mod eden_service {

        #[derive(Debug, ::thiserror::Error)]
        pub enum ListMountsError {
            #[error("EdenService::listMounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ListMountsError {
            fn from(e: crate::types::EdenError) -> Self {
                ListMountsError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ListMountsError {
            fn from(err: ::anyhow::Error) -> Self {
                ListMountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListMountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ListMountsError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum MountError {
            #[error("EdenService::mount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for MountError {
            fn from(e: crate::types::EdenError) -> Self {
                MountError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for MountError {
            fn from(err: ::anyhow::Error) -> Self {
                MountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                MountError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum UnmountError {
            #[error("EdenService::unmount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnmountError {
            fn from(e: crate::types::EdenError) -> Self {
                UnmountError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnmountError {
            fn from(err: ::anyhow::Error) -> Self {
                UnmountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnmountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnmountError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum CheckOutRevisionError {
            #[error("EdenService::checkOutRevision failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckOutRevisionError {
            fn from(e: crate::types::EdenError) -> Self {
                CheckOutRevisionError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for CheckOutRevisionError {
            fn from(err: ::anyhow::Error) -> Self {
                CheckOutRevisionError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckOutRevisionError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                CheckOutRevisionError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum ResetParentCommitsError {
            #[error("EdenService::resetParentCommits failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ResetParentCommitsError {
            fn from(e: crate::types::EdenError) -> Self {
                ResetParentCommitsError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ResetParentCommitsError {
            fn from(err: ::anyhow::Error) -> Self {
                ResetParentCommitsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ResetParentCommitsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ResetParentCommitsError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetSHA1Error {
            #[error("EdenService::getSHA1 failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetSHA1Error {
            fn from(e: crate::types::EdenError) -> Self {
                GetSHA1Error::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetSHA1Error {
            fn from(err: ::anyhow::Error) -> Self {
                GetSHA1Error::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSHA1Error {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetSHA1Error::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetBindMountsError {
            #[error("EdenService::getBindMounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetBindMountsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetBindMountsError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetBindMountsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetBindMountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBindMountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetBindMountsError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum AddBindMountError {
            #[error("EdenService::addBindMount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for AddBindMountError {
            fn from(e: crate::types::EdenError) -> Self {
                AddBindMountError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for AddBindMountError {
            fn from(err: ::anyhow::Error) -> Self {
                AddBindMountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddBindMountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                AddBindMountError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum RemoveBindMountError {
            #[error("EdenService::removeBindMount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveBindMountError {
            fn from(e: crate::types::EdenError) -> Self {
                RemoveBindMountError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for RemoveBindMountError {
            fn from(err: ::anyhow::Error) -> Self {
                RemoveBindMountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveBindMountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                RemoveBindMountError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetCurrentJournalPositionError {
            #[error("EdenService::getCurrentJournalPosition failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetCurrentJournalPositionError {
            fn from(e: crate::types::EdenError) -> Self {
                GetCurrentJournalPositionError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetCurrentJournalPositionError {
            fn from(err: ::anyhow::Error) -> Self {
                GetCurrentJournalPositionError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCurrentJournalPositionError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetCurrentJournalPositionError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetFilesChangedSinceError {
            #[error("EdenService::getFilesChangedSince failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFilesChangedSinceError {
            fn from(e: crate::types::EdenError) -> Self {
                GetFilesChangedSinceError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetFilesChangedSinceError {
            fn from(err: ::anyhow::Error) -> Self {
                GetFilesChangedSinceError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFilesChangedSinceError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetFilesChangedSinceError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum SetJournalMemoryLimitError {
            #[error("EdenService::setJournalMemoryLimit failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetJournalMemoryLimitError {
            fn from(e: crate::types::EdenError) -> Self {
                SetJournalMemoryLimitError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for SetJournalMemoryLimitError {
            fn from(err: ::anyhow::Error) -> Self {
                SetJournalMemoryLimitError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetJournalMemoryLimitError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                SetJournalMemoryLimitError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetJournalMemoryLimitError {
            #[error("EdenService::getJournalMemoryLimit failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetJournalMemoryLimitError {
            fn from(e: crate::types::EdenError) -> Self {
                GetJournalMemoryLimitError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetJournalMemoryLimitError {
            fn from(err: ::anyhow::Error) -> Self {
                GetJournalMemoryLimitError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetJournalMemoryLimitError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetJournalMemoryLimitError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum FlushJournalError {
            #[error("EdenService::flushJournal failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushJournalError {
            fn from(e: crate::types::EdenError) -> Self {
                FlushJournalError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for FlushJournalError {
            fn from(err: ::anyhow::Error) -> Self {
                FlushJournalError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushJournalError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                FlushJournalError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetRawJournalError {
            #[error("EdenService::debugGetRawJournal failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetRawJournalError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetRawJournalError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetRawJournalError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetRawJournalError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetRawJournalError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetRawJournalError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetEntryInformationError {
            #[error("EdenService::getEntryInformation failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetEntryInformationError {
            fn from(e: crate::types::EdenError) -> Self {
                GetEntryInformationError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetEntryInformationError {
            fn from(err: ::anyhow::Error) -> Self {
                GetEntryInformationError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEntryInformationError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetEntryInformationError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetFileInformationError {
            #[error("EdenService::getFileInformation failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFileInformationError {
            fn from(e: crate::types::EdenError) -> Self {
                GetFileInformationError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetFileInformationError {
            fn from(err: ::anyhow::Error) -> Self {
                GetFileInformationError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFileInformationError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetFileInformationError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GlobError {
            #[error("EdenService::glob failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobError {
            fn from(e: crate::types::EdenError) -> Self {
                GlobError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GlobError {
            fn from(err: ::anyhow::Error) -> Self {
                GlobError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GlobError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GlobFilesError {
            #[error("EdenService::globFiles failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobFilesError {
            fn from(e: crate::types::EdenError) -> Self {
                GlobFilesError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GlobFilesError {
            fn from(err: ::anyhow::Error) -> Self {
                GlobFilesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobFilesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GlobFilesError::ApplicationException(ae)
            }
        }

        pub type ChownError = ::fbthrift::NonthrowingFunctionError;

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusV2Error {
            #[error("EdenService::getScmStatusV2 failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusV2Error {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusV2Error::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusV2Error {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusV2Error::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusV2Error {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusV2Error::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusError {
            #[error("EdenService::getScmStatus failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusError {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusError {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusBetweenRevisionsError {
            #[error("EdenService::getScmStatusBetweenRevisions failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusBetweenRevisionsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusBetweenRevisionsError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusBetweenRevisionsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusBetweenRevisionsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusBetweenRevisionsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusBetweenRevisionsError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetManifestEntryError {
            #[error("EdenService::getManifestEntry failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("EdenService::getManifestEntry failed with {0:?}")]
            noValueForKeyError(crate::types::NoValueForKeyError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetManifestEntryError {
            fn from(e: crate::types::EdenError) -> Self {
                GetManifestEntryError::ex(e)
            }
        }

        impl ::std::convert::From<crate::types::NoValueForKeyError> for GetManifestEntryError {
            fn from(e: crate::types::NoValueForKeyError) -> Self {
                GetManifestEntryError::noValueForKeyError(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetManifestEntryError {
            fn from(err: ::anyhow::Error) -> Self {
                GetManifestEntryError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetManifestEntryError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetManifestEntryError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetDaemonInfoError {
            #[error("EdenService::getDaemonInfo failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetDaemonInfoError {
            fn from(e: crate::types::EdenError) -> Self {
                GetDaemonInfoError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetDaemonInfoError {
            fn from(err: ::anyhow::Error) -> Self {
                GetDaemonInfoError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetDaemonInfoError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetDaemonInfoError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetPidError {
            #[error("EdenService::getPid failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetPidError {
            fn from(e: crate::types::EdenError) -> Self {
                GetPidError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetPidError {
            fn from(err: ::anyhow::Error) -> Self {
                GetPidError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPidError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetPidError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum InitiateShutdownError {
            #[error("EdenService::initiateShutdown failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InitiateShutdownError {
            fn from(e: crate::types::EdenError) -> Self {
                InitiateShutdownError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InitiateShutdownError {
            fn from(err: ::anyhow::Error) -> Self {
                InitiateShutdownError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InitiateShutdownError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InitiateShutdownError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetConfigError {
            #[error("EdenService::getConfig failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetConfigError {
            fn from(e: crate::types::EdenError) -> Self {
                GetConfigError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetConfigError {
            fn from(err: ::anyhow::Error) -> Self {
                GetConfigError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetConfigError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum ReloadConfigError {
            #[error("EdenService::reloadConfig failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ReloadConfigError {
            fn from(e: crate::types::EdenError) -> Self {
                ReloadConfigError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ReloadConfigError {
            fn from(err: ::anyhow::Error) -> Self {
                ReloadConfigError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReloadConfigError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ReloadConfigError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmTreeError {
            #[error("EdenService::debugGetScmTree failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmTreeError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmTreeError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmTreeError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmTreeError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmTreeError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmTreeError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmBlobError {
            #[error("EdenService::debugGetScmBlob failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmBlobError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmBlobError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmBlobError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmBlobMetadataError {
            #[error("EdenService::debugGetScmBlobMetadata failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobMetadataError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmBlobMetadataError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmBlobMetadataError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmBlobMetadataError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobMetadataError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobMetadataError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugInodeStatusError {
            #[error("EdenService::debugInodeStatus failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugInodeStatusError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugInodeStatusError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugInodeStatusError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugInodeStatusError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugInodeStatusError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugInodeStatusError::ApplicationException(ae)
            }
        }

        pub type DebugOutstandingFuseCallsError = ::fbthrift::NonthrowingFunctionError;

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetInodePathError {
            #[error("EdenService::debugGetInodePath failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetInodePathError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetInodePathError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetInodePathError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetInodePathError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetInodePathError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetInodePathError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetAccessCountsError {
            #[error("EdenService::getAccessCounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAccessCountsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetAccessCountsError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetAccessCountsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetAccessCountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAccessCountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetAccessCountsError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum ClearAndCompactLocalStoreError {
            #[error("EdenService::clearAndCompactLocalStore failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearAndCompactLocalStoreError {
            fn from(e: crate::types::EdenError) -> Self {
                ClearAndCompactLocalStoreError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ClearAndCompactLocalStoreError {
            fn from(err: ::anyhow::Error) -> Self {
                ClearAndCompactLocalStoreError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearAndCompactLocalStoreError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ClearAndCompactLocalStoreError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugClearLocalStoreCachesError {
            #[error("EdenService::debugClearLocalStoreCaches failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugClearLocalStoreCachesError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugClearLocalStoreCachesError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugClearLocalStoreCachesError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugClearLocalStoreCachesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugClearLocalStoreCachesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugClearLocalStoreCachesError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugCompactLocalStorageError {
            #[error("EdenService::debugCompactLocalStorage failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugCompactLocalStorageError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugCompactLocalStorageError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugCompactLocalStorageError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugCompactLocalStorageError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugCompactLocalStorageError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugCompactLocalStorageError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum UnloadInodeForPathError {
            #[error("EdenService::unloadInodeForPath failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnloadInodeForPathError {
            fn from(e: crate::types::EdenError) -> Self {
                UnloadInodeForPathError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnloadInodeForPathError {
            fn from(err: ::anyhow::Error) -> Self {
                UnloadInodeForPathError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnloadInodeForPathError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnloadInodeForPathError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum FlushStatsNowError {
            #[error("EdenService::flushStatsNow failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushStatsNowError {
            fn from(e: crate::types::EdenError) -> Self {
                FlushStatsNowError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for FlushStatsNowError {
            fn from(err: ::anyhow::Error) -> Self {
                FlushStatsNowError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushStatsNowError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                FlushStatsNowError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum InvalidateKernelInodeCacheError {
            #[error("EdenService::invalidateKernelInodeCache failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InvalidateKernelInodeCacheError {
            fn from(e: crate::types::EdenError) -> Self {
                InvalidateKernelInodeCacheError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InvalidateKernelInodeCacheError {
            fn from(err: ::anyhow::Error) -> Self {
                InvalidateKernelInodeCacheError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InvalidateKernelInodeCacheError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InvalidateKernelInodeCacheError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum GetStatInfoError {
            #[error("EdenService::getStatInfo failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetStatInfoError {
            fn from(e: crate::types::EdenError) -> Self {
                GetStatInfoError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetStatInfoError {
            fn from(err: ::anyhow::Error) -> Self {
                GetStatInfoError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatInfoError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetStatInfoError::ApplicationException(ae)
            }
        }

        pub type EnableTracingError = ::fbthrift::NonthrowingFunctionError;

        pub type DisableTracingError = ::fbthrift::NonthrowingFunctionError;

        pub type GetTracePointsError = ::fbthrift::NonthrowingFunctionError;

        #[derive(Debug, ::thiserror::Error)]
        pub enum InjectFaultError {
            #[error("EdenService::injectFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InjectFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                InjectFaultError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InjectFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                InjectFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InjectFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InjectFaultError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum RemoveFaultError {
            #[error("EdenService::removeFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                RemoveFaultError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for RemoveFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                RemoveFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                RemoveFaultError::ApplicationException(ae)
            }
        }

        #[derive(Debug, ::thiserror::Error)]
        pub enum UnblockFaultError {
            #[error("EdenService::unblockFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnblockFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                UnblockFaultError::ex(e)
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnblockFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                UnblockFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnblockFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnblockFaultError::ApplicationException(ae)
            }
        }

    }

}
