// @generated by Thrift for eden/fs/service/eden.thrift
// This file is probably not the place you want to edit!

#![recursion_limit = "100000000"]
#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals, unused_crate_dependencies)]

extern crate serde;
pub use self::consts::*;
pub use self::errors::*;
pub use self::types::*;

/// Constant definitions for `eden`.
pub mod consts {
    #[doc = "No effect other than avoiding the legacy behavior."]
    pub const DIS_ENABLE_FLAGS: ::std::primitive::i64 = 1;

    #[doc = "Only return inodes currently loaded in memory."]
    pub const DIS_REQUIRE_LOADED: ::std::primitive::i64 = 2;

    #[doc = "Only return materialized inodes."]
    pub const DIS_REQUIRE_MATERIALIZED: ::std::primitive::i64 = 4;

    #[doc = "Return accurate blob sizes, which may require fetching blob metadata from\nthe backing store."]
    pub const DIS_COMPUTE_BLOB_SIZES: ::std::primitive::i64 = 8;

    #[doc = "Returns accurate mode_t bits, including ownership. When unset, only\nthe dtype bits are set."]
    pub const DIS_COMPUTE_ACCURATE_MODE: ::std::primitive::i64 = 16;

    pub const STATS_MOUNTS_STATS: ::std::primitive::i64 = 1;

    pub const STATS_COUNTERS: ::std::primitive::i64 = 2;

    pub const STATS_SMAPS: ::std::primitive::i64 = 4;

    pub const STATS_PRIVATE_BYTES: ::std::primitive::i64 = 8;

    pub const STATS_RSS_BYTES: ::std::primitive::i64 = 16;

    pub const STATS_CACHE_STATS: ::std::primitive::i64 = 32;

    pub const STATS_ALL: ::std::primitive::i64 = 65535;
}

/// Thrift type definitions for `eden`.
pub mod types {
    #![allow(clippy::redundant_closure)]


    #[doc = "Thrift doesn't really do unsigned numbers, but we can sort of fake it.\nThis type is serialized as an integer value that is 64-bits wide and\nshould round-trip with full fidelity for C++ client/server, but for\nother runtimes will have crazy results if the sign bit is ever set.\nIn practice it is impossible for us to have files that large in eden,\nand sequence numbers will take an incredibly long time to ever roll\nover and cause problems.\nOnce t13345978 is done, we can uncomment the cpp.type below."]
    pub type unsigned64 = ::std::primitive::i64;

    pub type pid_t = ::std::primitive::i32;

    #[doc = "A backing-store-specific identifier for the root tree. For Mercurial or\nGit, this is a 20-byte binary hash or a 40-byte hexadecimal hash.\n\nFor other backing stores, this string may have variable length and its\nmeaning is defined by the backing-store. If possible, prefer human-readable\nstrings so they can be read in log files and error messages.\n\nThis is named ThriftRootId to not conflict with the RootId class, but\nperhaps this Thrift module should be placed in its own namespace."]
    pub type ThriftRootId = ::std::vec::Vec<::std::primitive::u8>;

    #[doc = "A source control hash.\n\nThis should normally be a 20-byte binary value, however the edenfs server\nwill accept BinaryHash arguments as 40-byte hexadecimal strings as well.\nData returned by the edenfs server in a BinaryHash field will always be a\n20-byte binary value."]
    pub type BinaryHash = ::std::vec::Vec<::std::primitive::u8>;

    #[doc = "So, you thought that a path was a string?\nPaths in posix are arbitrary byte strings with some pre-defined special\ncharacters.  On modern systems they tend to be represented as UTF-8 but\nthere is no guarantee.  We use the `PathString` type as symbolic way\nto indicate that you may need to perform special processing to safely\ninterpret the path data on your system."]
    pub type PathString = ::std::vec::Vec<::std::primitive::u8>;

    #[doc = "A representation of the system-dependent dirent::d_type field.\nThe bits and their interpretation is system dependent.\nThis value is u8 on all systems that implement it.  We\nuse i16 to pass this through thrift, which doesn't have unsigned\nnumbers"]
    pub type OsDtype = ::std::primitive::i16;

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenError {
        #[serde(default)]
        pub message: ::std::string::String,
        pub errorCode: ::std::option::Option<::std::primitive::i32>,
        #[serde(default)]
        pub errorType: crate::types::EdenErrorType,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    impl ::fbthrift::ExceptionInfo for EdenError {
        fn exn_value(&self) -> String {
            format!("{:?}", self)
        }

        #[inline]
        fn exn_is_declared(&self) -> bool { true }
    }

    impl ::std::error::Error for EdenError {}

    impl ::std::fmt::Display for EdenError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(f, "EdenError: {}: {:?}", self.message, self)
        }
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct NoValueForKeyError {
        #[serde(default)]
        pub key: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    impl ::fbthrift::ExceptionInfo for NoValueForKeyError {
        fn exn_value(&self) -> String {
            format!("{:?}", self)
        }

        #[inline]
        fn exn_is_declared(&self) -> bool { true }
    }

    impl ::std::error::Error for NoValueForKeyError {}

    impl ::std::fmt::Display for NoValueForKeyError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(f, "{:?}", self)
        }
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Information about the running edenfs daemon."]
    pub struct DaemonInfo {
        #[serde(default)]
        pub pid: ::std::primitive::i32,
        #[serde(default)]
        #[doc = "List of command line arguments, including the executable name,\ngiven to the edenfs process."]
        pub commandLine: ::std::vec::Vec<::std::string::String>,
        #[doc = "The service status.\n\nThis is almost the same value reported by\nfb303_core.BaseService.getStatus(). fb303_core.BaseService.getStatus()\nonly returns the Thrift server status and does not understand mounts or\ngraceful restarts."]
        pub status: ::std::option::Option<fb303_core::types::fb303_status>,
        #[doc = "The uptime of the edenfs daemon\nSame data from /proc/pid/stat"]
        pub uptime: ::std::option::Option<::std::primitive::f32>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Information about the privhelper process"]
    pub struct PrivHelperInfo {
        #[serde(default)]
        pub connected: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountInfo {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub edenClientPath: crate::types::PathString,
        #[serde(default)]
        pub state: crate::types::MountState,
        pub backingRepoPath: ::std::option::Option<crate::types::PathString>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountArgument {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub edenClientPath: crate::types::PathString,
        #[serde(default)]
        pub readOnly: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Debug, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub enum SHA1Result {
        sha1(crate::types::BinaryHash),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Effectively a `struct timespec`"]
    pub struct TimeSpec {
        #[serde(default)]
        pub seconds: ::std::primitive::i64,
        #[serde(default)]
        pub nanoSeconds: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Information about filesystem entries that can be retrieved solely\nfrom the tree structure, without having to fetch the actual child\nobjects from source control."]
    pub struct EntryInformation {
        #[serde(default)]
        pub dtype: crate::types::Dtype,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Debug, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub enum EntryInformationOrError {
        info(crate::types::EntryInformation),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Subset of stat() data returned from getFileInformation())"]
    pub struct FileInformation {
        #[serde(default)]
        pub size: crate::types::unsigned64,
        #[serde(default)]
        pub mtime: crate::types::TimeSpec,
        #[serde(default)]
        pub mode: ::std::primitive::i32,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Debug, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Holds information about a file, or an error in retrieving that info.\nThe most likely error will be ENOENT, implying that the file doesn't exist."]
    pub enum FileInformationOrError {
        info(crate::types::FileInformation),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Subset of attributes for a single file returned by getAttributesFromFiles()"]
    pub struct FileAttributeData {
        pub sha1: ::std::option::Option<crate::types::BinaryHash>,
        pub fileSize: ::std::option::Option<::std::primitive::i64>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Debug, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Attributes for a file or information about error encountered when accessing file attributes.\nThe most likely error will be ENOENT, implying that the file doesn't exist."]
    pub enum FileAttributeDataOrError {
        data(crate::types::FileAttributeData),
        error(crate::types::EdenError),
        UnknownField(::std::primitive::i32),
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Ensure that all inflight working copy modification have completed.\n\nOn some platforms, EdenFS is processing working copy modifications\ncallbacks from the platform in an asynchronous manner, which means that by\nthe time a write/creat/mkdir/unlink/etc syscall returns from the kernel,\nEdenFS may not have updated its internal state.\n\nThus, an application making changes to the working copy and quickly\nrequesting EdenFS to perform an operation on it will race with EdenFS\nupdating its internal state and may thus get stale data.\n\nTo avoid this, EdenFS queries need to internally synchronize the working\ncopy before performing the query itself. This structure defines how EdenFS\nwill do this.\n\nApplications that care about synchronizing EdenFS up to a certain point in\ntime are expected to set a non-zero syncTimeout once to synchronize EdenFS\nand then issue all their thrift requests with a syncTimeout of 0."]
    pub struct SyncBehavior {
        pub syncTimeoutSeconds: ::std::option::Option<::std::primitive::i64>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Parameters for the getAttributesFromFiles() function"]
    pub struct GetAttributesFromFilesParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub paths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub requestedAttributes: crate::types::unsigned64,
        #[serde(default)]
        pub sync: crate::types::SyncBehavior,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Return value for the getAttributesFromFiles() function.\nThe returned list of attributes corresponds to the input list of\npaths; eg; res[0] holds the information for paths[0]."]
    pub struct GetAttributesFromFilesResult {
        #[serde(default)]
        pub res: ::std::vec::Vec<crate::types::FileAttributeDataOrError>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "reference a point in time in the journal.\nThis can be used to reason about a point in time in a given mount point.\nThe mountGeneration value is opaque to the client."]
    pub struct JournalPosition {
        #[serde(default)]
        #[doc = "An opaque but unique number within the scope of a given mount point.\nThis is used to determine when sequenceNumber has been invalidated."]
        pub mountGeneration: ::std::primitive::i64,
        #[serde(default)]
        #[doc = "Monotonically incrementing number\nEach journalled change causes this number to increment."]
        pub sequenceNumber: crate::types::unsigned64,
        #[serde(default)]
        #[doc = "Records the snapshot hash at the appropriate point in the journal"]
        pub snapshotHash: crate::types::ThriftRootId,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Holds information about a set of paths that changed between two points.\nfromPosition, toPosition define the time window.\npaths holds the list of paths that changed in that window.\n\nThis type is quasi-deprecated. It has multiple API problems and should be\nrethought when we have a chance to make a breaking change."]
    pub struct FileDelta {
        #[serde(default)]
        #[doc = "The fromPosition passed to getFilesChangedSince"]
        pub fromPosition: crate::types::JournalPosition,
        #[serde(default)]
        #[doc = "The current position at the time that getFilesChangedSince was called"]
        pub toPosition: crate::types::JournalPosition,
        #[serde(default)]
        #[doc = "The union of changedPaths and createdPaths contains the total set of paths\nchanged in the overlay between fromPosition and toPosition.\nDisjoint with createdPaths."]
        pub changedPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        #[doc = "The set of paths created between fromPosition and toPosition.\nUsed by Watchman to search for cookies and to populate its 'new' field.\nDisjoint with changedPaths."]
        pub createdPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        #[doc = "Deprecated - always empty."]
        pub removedPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        #[doc = "When fromPosition.snapshotHash != toPosition.snapshotHash this holds\nthe union of the set of files whose ScmFileStatus differed from the\ncommitted fromPosition hash before the hash changed, and the set of\nfiles whose ScmFileStatus differed from the committed toPosition hash\nafter the hash was changed.  This list of files represents files\nwhose state may have changed as part of an update operation, but\nin ways that may not be able to be extracted solely by performing\nsource control diff operations on the from/to hashes."]
        pub uncleanPaths: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        #[doc = "Contains the list of commit transitions in this range. If only files\nhave been changed, the list has one entry. Otherwise, it has size N + 1,\nwhere N is the number of checkout operations.\n\nThis list's items may not be unique: [A, B, A] is a common sequence,\nand [A, B, C] has a different meaning than [A, C, B].\n\nSubsumes fromPosition.snapshotHash and toPosition.snapshotHash."]
        pub snapshotTransitions: ::std::vec::Vec<crate::types::ThriftRootId>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugGetRawJournalParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        pub limit: ::std::option::Option<::std::primitive::i32>,
        #[serde(default)]
        pub fromSequenceNumber: ::std::primitive::i32,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugPathChangeInfo {
        #[serde(default)]
        pub existedBefore: ::std::primitive::bool,
        #[serde(default)]
        pub existedAfter: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "A fairly direct modeling of the underlying JournalDelta data structure."]
    pub struct DebugJournalDelta {
        #[serde(default)]
        pub fromPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub toPosition: crate::types::JournalPosition,
        #[serde(default)]
        pub changedPaths: ::std::collections::BTreeMap<crate::types::PathString, crate::types::DebugPathChangeInfo>,
        #[serde(default)]
        pub uncleanPaths: ::std::collections::BTreeSet<crate::types::PathString>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct DebugGetRawJournalResponse {
        #[serde(default)]
        pub allDeltas: ::std::vec::Vec<crate::types::DebugJournalDelta>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmStatus {
        #[serde(default)]
        pub entries: ::std::collections::BTreeMap<crate::types::PathString, crate::types::ScmFileStatus>,
        #[serde(default)]
        #[doc = "A map of { path -> error message }\n\nIf any errors occured while computing the diff they will be reported here.\nThe results listed in the entries field may not be accurate for any paths\nlisted in this error field.\n\nThis map will be empty if no errors occurred."]
        pub errors: ::std::collections::BTreeMap<crate::types::PathString, ::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Details about conflicts or errors that occurred during a checkout operation"]
    pub struct CheckoutConflict {
        #[serde(default)]
        pub path: crate::types::PathString,
        #[serde(rename = "type")]
        #[serde(default)]
        pub r#type: crate::types::ConflictType,
        #[serde(default)]
        pub message: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmBlobMetadata {
        #[serde(default)]
        pub size: ::std::primitive::i64,
        #[serde(default)]
        pub contentsSha1: crate::types::BinaryHash,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmTreeEntry {
        #[serde(default)]
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub mode: ::std::primitive::i32,
        #[serde(default)]
        pub id: crate::types::BinaryHash,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TreeInodeEntryDebugInfo {
        #[serde(default)]
        #[doc = "The entry name.  This is just a PathComponent, not the full path"]
        pub name: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        #[doc = "The inode number, or 0 if no inode number has been assigned to\nthis entry"]
        pub inodeNumber: ::std::primitive::i64,
        #[serde(default)]
        #[doc = "The entry mode_t value"]
        pub mode: ::std::primitive::i32,
        #[serde(default)]
        #[doc = "True if an InodeBase object exists for this inode or not."]
        pub loaded: ::std::primitive::bool,
        #[serde(default)]
        #[doc = "True if an the inode is materialized in the overlay"]
        pub materialized: ::std::primitive::bool,
        #[serde(default)]
        #[doc = "If materialized is false, hash contains the ID of the underlying source\ncontrol Blob or Tree."]
        pub hash: crate::types::BinaryHash,
        #[doc = "Size of the file in bytes. It won't be set for directories."]
        pub fileSize: ::std::option::Option<::std::primitive::i64>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetFetchedFilesResult {
        #[serde(default)]
        pub fetchedFilePaths: ::std::collections::BTreeMap<::std::string::String, ::std::collections::BTreeSet<crate::types::PathString>>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct WorkingDirectoryParents {
        #[serde(default)]
        pub parent1: crate::types::ThriftRootId,
        pub parent2: ::std::option::Option<crate::types::ThriftRootId>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TreeInodeDebugInfo {
        #[serde(default)]
        pub inodeNumber: ::std::primitive::i64,
        #[serde(default)]
        pub path: ::std::vec::Vec<::std::primitive::u8>,
        #[serde(default)]
        pub materialized: ::std::primitive::bool,
        #[serde(default)]
        pub treeHash: crate::types::BinaryHash,
        #[serde(default)]
        pub entries: ::std::vec::Vec<crate::types::TreeInodeEntryDebugInfo>,
        #[serde(default)]
        pub refcount: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct InodePathDebugInfo {
        #[serde(default)]
        pub path: crate::types::PathString,
        #[serde(default)]
        pub loaded: ::std::primitive::bool,
        #[serde(default)]
        pub linked: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ActivityRecorderResult {
        #[serde(default)]
        pub unique: ::std::primitive::i64,
        pub path: ::std::option::Option<crate::types::PathString>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ListActivityRecordingsResult {
        #[serde(default)]
        pub recordings: ::std::vec::Vec<crate::types::ActivityRecorderResult>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct SetLogLevelResult {
        #[serde(default)]
        pub categoryCreated: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct JournalInfo {
        #[serde(default)]
        pub entryCount: ::std::primitive::i64,
        #[serde(default)]
        pub memoryUsage: ::std::primitive::i64,
        #[serde(default)]
        pub durationSeconds: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Struct to store Information about inodes in a mount point."]
    pub struct MountInodeInfo {
        #[serde(default)]
        pub unloadedInodeCount: ::std::primitive::i64,
        #[serde(default)]
        pub loadedFileCount: ::std::primitive::i64,
        #[serde(default)]
        pub loadedTreeCount: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CacheStats {
        #[serde(default)]
        pub entryCount: ::std::primitive::i64,
        #[serde(default)]
        pub totalSizeInBytes: ::std::primitive::i64,
        #[serde(default)]
        pub hitCount: ::std::primitive::i64,
        #[serde(default)]
        pub missCount: ::std::primitive::i64,
        #[serde(default)]
        pub evictionCount: ::std::primitive::i64,
        #[serde(default)]
        pub dropCount: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Struct to store fb303 counters from ServiceData.getCounters() and inode\ninformation of all the mount points."]
    pub struct InternalStats {
        #[doc = "fbf303 counter of inodes unloaded by periodic job.\nPopulated if STATS_COUNTERS is set."]
        pub periodicUnloadCount: ::std::option::Option<::std::primitive::i64>,
        #[doc = "counters is the list of fb303 counters, key is the counter name, value is the\ncounter value.\nPopulated if STATS_COUNTERS is set."]
        pub counters: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::primitive::i64>>,
        #[doc = "mountPointInfo is a map whose key is the path of the mount point and value\nis the details like number of loaded inodes,unloaded inodes in that mount\nand number of materialized inodes in that mountpoint.\nPopulated if STATS_MOUNTS_STATS is set."]
        pub mountPointInfo: ::std::option::Option<::std::collections::BTreeMap<crate::types::PathString, crate::types::MountInodeInfo>>,
        #[doc = "Linux-only: the contents of /proc/self/smaps, to be parsed by the caller.\nPopulated if STATS_SMAPS is set."]
        pub smaps: ::std::option::Option<::std::vec::Vec<::std::primitive::u8>>,
        #[doc = "Linux-only: privateBytes populated from contents of /proc/self/smaps.\nPopulated with current value (the fb303 counters value is an average).\nPopulated if STATS_PRIVATE_BYTES is set."]
        pub privateBytes: ::std::option::Option<::std::primitive::i64>,
        #[doc = "Linux-only: vmRSS bytes is populated from contents of /proc/self/stats.\nPopulated with current value (the fb303 counters value is an average).\nPopulated if STATS_RSS_BYTES is set."]
        pub vmRSSBytes: ::std::option::Option<::std::primitive::i64>,
        #[doc = "Statistics about the in-memory blob cache.\nPopulated if STATS_CACHE_STATS is set."]
        pub blobCacheStats: ::std::option::Option<crate::types::CacheStats>,
        #[doc = "mountPointJournalInfo is a map whose key is the path of the mount point\nand whose value is information about the journal on that mount\nPopulated if STATS_MOUNTS_STATS is set."]
        pub mountPointJournalInfo: ::std::option::Option<::std::collections::BTreeMap<crate::types::PathString, crate::types::JournalInfo>>,
        #[doc = "Statistics about the in-memory tree cache.\nPopulated if STATS_CACHE_STATS is set."]
        pub treeCacheStats: ::std::option::Option<crate::types::CacheStats>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FuseCall {
        #[serde(default)]
        pub opcode: ::std::primitive::i32,
        #[serde(default)]
        pub unique: ::std::primitive::i64,
        #[serde(default)]
        pub nodeid: ::std::primitive::i64,
        #[serde(default)]
        pub uid: ::std::primitive::i32,
        #[serde(default)]
        pub gid: ::std::primitive::i32,
        #[serde(default)]
        pub pid: crate::types::pid_t,
        #[serde(default)]
        pub opcodeName: ::std::string::String,
        pub processName: ::std::option::Option<::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct NfsCall {
        #[serde(default)]
        pub xid: ::std::primitive::i32,
        #[serde(default)]
        pub procNumber: ::std::primitive::i32,
        #[serde(default)]
        pub procName: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetConfigParams {
        #[serde(default)]
        pub reload: eden_config::types::ConfigReloadBehavior,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetStatInfoParams {
        #[serde(default)]
        pub statsMask: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct PredictiveFetch {
        pub numTopDirectories: ::std::option::Option<::std::primitive::i32>,
        pub user: ::std::option::Option<::std::string::String>,
        pub repo: ::std::option::Option<::std::string::String>,
        pub os: ::std::option::Option<::std::string::String>,
        pub startTime: ::std::option::Option<crate::types::unsigned64>,
        pub endTime: ::std::option::Option<crate::types::unsigned64>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    #[doc = "Params for globFiles()."]
    pub struct GlobParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub globs: ::std::vec::Vec<::std::string::String>,
        #[serde(default)]
        pub includeDotfiles: ::std::primitive::bool,
        #[serde(default)]
        pub prefetchFiles: ::std::primitive::bool,
        #[serde(default)]
        pub suppressFileList: ::std::primitive::bool,
        #[serde(default)]
        pub wantDtype: ::std::primitive::bool,
        #[serde(default)]
        pub revisions: ::std::vec::Vec<crate::types::ThriftRootId>,
        #[serde(default)]
        pub prefetchMetadata: ::std::primitive::bool,
        #[serde(default)]
        pub searchRoot: crate::types::PathString,
        #[serde(default)]
        pub background: ::std::primitive::bool,
        pub predictiveGlob: ::std::option::Option<crate::types::PredictiveFetch>,
        #[serde(default)]
        pub listOnlyFiles: ::std::primitive::bool,
        #[serde(default)]
        pub sync: crate::types::SyncBehavior,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct Glob {
        #[serde(default)]
        #[doc = "matchingFiles can contain duplicate values and is not guaranteed to be\nsorted. However, no duplicates may have the same originCommits (note this\nis not true should the input GlobParams contain duplicate revisions) ."]
        pub matchingFiles: ::std::vec::Vec<crate::types::PathString>,
        #[serde(default)]
        pub dtypes: ::std::vec::Vec<crate::types::OsDtype>,
        #[serde(default)]
        #[doc = "Currently these are the commit hash for the commit to which this file\nbelongs. But should eden move away from commit hashes this may become\nthe tree hash of the root tree to which this file belongs."]
        pub originHashes: ::std::vec::Vec<::std::vec::Vec<::std::primitive::u8>>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct AccessCounts {
        #[serde(default)]
        pub fsChannelTotal: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelReads: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelWrites: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelBackingStoreImports: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelDurationNs: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelMemoryCacheImports: ::std::primitive::i64,
        #[serde(default)]
        pub fsChannelDiskCacheImports: ::std::primitive::i64,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountAccesses {
        #[serde(default)]
        pub accessCountsByPid: ::std::collections::BTreeMap<crate::types::pid_t, crate::types::AccessCounts>,
        #[serde(default)]
        pub fetchCountsByPid: ::std::collections::BTreeMap<crate::types::pid_t, ::std::primitive::i64>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetAccessCountsResult {
        #[serde(default)]
        pub cmdsByPid: ::std::collections::BTreeMap<crate::types::pid_t, ::std::vec::Vec<::std::primitive::u8>>,
        #[serde(default)]
        pub accessesByMount: ::std::collections::BTreeMap<crate::types::PathString, crate::types::MountAccesses>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TracePoint {
        #[serde(default)]
        pub timestamp: ::std::primitive::i64,
        #[serde(default)]
        pub traceId: ::std::primitive::i64,
        #[serde(default)]
        pub blockId: ::std::primitive::i64,
        #[serde(default)]
        pub parentBlockId: ::std::primitive::i64,
        #[serde(default)]
        pub name: ::std::string::String,
        #[serde(default)]
        pub event: crate::types::TracePointEvent,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FaultDefinition {
        #[serde(default)]
        pub keyClass: ::std::string::String,
        #[serde(default)]
        pub keyValueRegex: ::std::string::String,
        #[serde(default)]
        pub count: ::std::primitive::i64,
        #[serde(default)]
        pub block: ::std::primitive::bool,
        #[serde(default)]
        pub delayMilliseconds: ::std::primitive::i64,
        pub errorType: ::std::option::Option<::std::string::String>,
        pub errorMessage: ::std::option::Option<::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct RemoveFaultArg {
        #[serde(default)]
        pub keyClass: ::std::string::String,
        #[serde(default)]
        pub keyValueRegex: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct UnblockFaultArg {
        pub keyClass: ::std::option::Option<::std::string::String>,
        pub keyValueRegex: ::std::option::Option<::std::string::String>,
        pub errorType: ::std::option::Option<::std::string::String>,
        pub errorMessage: ::std::option::Option<::std::string::String>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetScmStatusResult {
        #[serde(default)]
        pub status: crate::types::ScmStatus,
        #[serde(default)]
        pub version: ::std::string::String,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct GetScmStatusParams {
        #[serde(default)]
        #[doc = "The Eden checkout to query"]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        #[doc = "The commit ID of the current working directory parent commit.\n\nAn error will be returned if this is not actually the current parent\ncommit.  This behavior exists to support callers that do not perform their\nown external synchronization around access to the current parent commit,\nlike Mercurial."]
        pub commit: crate::types::ThriftRootId,
        #[serde(default)]
        #[doc = "Whether ignored files should be reported in the results.\n\nSome special source-control related files (e.g., inside the .hg or .git\ndirectory) will never be reported even when listIgnored is true."]
        pub listIgnored: ::std::primitive::bool,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct SetPathObjectIdParams {
        #[serde(default)]
        pub mountPoint: crate::types::PathString,
        #[serde(default)]
        pub path: crate::types::PathString,
        #[serde(default)]
        pub objectId: crate::types::BinaryHash,
        #[serde(rename = "type")]
        #[serde(default)]
        pub r#type: crate::types::ObjectType,
        #[serde(default)]
        pub mode: crate::types::CheckoutMode,
        pub requestInfo: ::std::option::Option<::std::collections::BTreeMap<::std::string::String, ::std::string::String>>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct SetPathObjectIdResult {
        #[serde(default)]
        pub conflicts: ::std::vec::Vec<crate::types::CheckoutConflict>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CheckOutRevisionParams {
        #[doc = "The hg root manifest that corresponds to the commit (if known).\n\nWhen a commit is newly created, EdenFS won't know the commit\nto root-manifest mapping for the commit, and won't be able to find\nout from the import helper until the import helper re-opens the\nrepo.  To speed this up, Mercurial clients may optionally provide\nthe hash of the root manifest directly, so that EdenFS doesn't\nneed to look it up."]
        pub hgRootManifest: ::std::option::Option<crate::types::BinaryHash>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ResetParentCommitsParams {
        #[doc = "The hg root manifest that corresponds to the commit (if known).\n\nWhen a commit is newly created, EdenFS won't know the commit\nto root-manifest mapping for the commit, and won't be able to find\nout from the import helper until the import helper re-opens the\nrepo.  To speed this up, Mercurial clients may optionally provide\nthe hash of the root manifest directly, so that EdenFS doesn't\nneed to look it up."]
        pub hgRootManifest: ::std::option::Option<crate::types::BinaryHash>,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[derive(Clone, PartialEq, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct SynchronizeWorkingCopyParams {
        #[serde(default)]
        pub sync: crate::types::SyncBehavior,
        // This field forces `..Default::default()` when instantiating this
        // struct, to make code future-proof against new fields added later to
        // the definition in Thrift. If you don't want this, add the annotation
        // `(rust.exhaustive)` to the Thrift struct to eliminate this field.
        #[doc(hidden)]
        #[serde(skip, default = "self::dot_dot::default_for_serde_deserialize")]
        pub _dot_dot_Default_default: self::dot_dot::OtherFields,
    }

    #[doc = "A customizable type to be returned with an EdenError, helpful for catching\nand having custom client logic to handle specfic error cases"]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct EdenErrorType(pub ::std::primitive::i32);

    impl EdenErrorType {
        #[doc = "The errorCode property is a posix errno value"]
        pub const POSIX_ERROR: Self = EdenErrorType(0i32);
        #[doc = "The errorCode property is a win32 error value"]
        pub const WIN32_ERROR: Self = EdenErrorType(1i32);
        #[doc = "The errorCode property is a windows NT HResult error value"]
        pub const HRESULT_ERROR: Self = EdenErrorType(2i32);
        #[doc = "An argument passed to thrift was invalid. errorCode will be set to EINVAL"]
        pub const ARGUMENT_ERROR: Self = EdenErrorType(3i32);
        #[doc = "An error occurred. errorCode will be not set"]
        pub const GENERIC_ERROR: Self = EdenErrorType(4i32);
        #[doc = "The mount generation changed. errorCode will be set to ERANGE"]
        pub const MOUNT_GENERATION_CHANGED: Self = EdenErrorType(5i32);
        #[doc = "The journal has been truncated. errorCode will be set to EDOM"]
        pub const JOURNAL_TRUNCATED: Self = EdenErrorType(6i32);
        #[doc = "The thrift funtion that receives this in an error is being called while\na checkout is in progress. errorCode will not be set."]
        pub const CHECKOUT_IN_PROGRESS: Self = EdenErrorType(7i32);
        #[doc = "The thrift function that receives this is an error is being called with a\nparent that is not the current parent. errorCode will not be set."]
        pub const OUT_OF_DATE_PARENT: Self = EdenErrorType(8i32);
    }

    impl ::fbthrift::ThriftEnum for EdenErrorType {
        fn enumerate() -> &'static [(EdenErrorType, &'static str)] {
            &[
                (EdenErrorType::POSIX_ERROR, "POSIX_ERROR"),
                (EdenErrorType::WIN32_ERROR, "WIN32_ERROR"),
                (EdenErrorType::HRESULT_ERROR, "HRESULT_ERROR"),
                (EdenErrorType::ARGUMENT_ERROR, "ARGUMENT_ERROR"),
                (EdenErrorType::GENERIC_ERROR, "GENERIC_ERROR"),
                (EdenErrorType::MOUNT_GENERATION_CHANGED, "MOUNT_GENERATION_CHANGED"),
                (EdenErrorType::JOURNAL_TRUNCATED, "JOURNAL_TRUNCATED"),
                (EdenErrorType::CHECKOUT_IN_PROGRESS, "CHECKOUT_IN_PROGRESS"),
                (EdenErrorType::OUT_OF_DATE_PARENT, "OUT_OF_DATE_PARENT"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "POSIX_ERROR",
                "WIN32_ERROR",
                "HRESULT_ERROR",
                "ARGUMENT_ERROR",
                "GENERIC_ERROR",
                "MOUNT_GENERATION_CHANGED",
                "JOURNAL_TRUNCATED",
                "CHECKOUT_IN_PROGRESS",
                "OUT_OF_DATE_PARENT",
            ]
        }

        fn variant_values() -> &'static [EdenErrorType] {
            &[
                EdenErrorType::POSIX_ERROR,
                EdenErrorType::WIN32_ERROR,
                EdenErrorType::HRESULT_ERROR,
                EdenErrorType::ARGUMENT_ERROR,
                EdenErrorType::GENERIC_ERROR,
                EdenErrorType::MOUNT_GENERATION_CHANGED,
                EdenErrorType::JOURNAL_TRUNCATED,
                EdenErrorType::CHECKOUT_IN_PROGRESS,
                EdenErrorType::OUT_OF_DATE_PARENT,
            ]
        }
    }

    impl ::std::default::Default for EdenErrorType {
        fn default() -> Self {
            EdenErrorType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a EdenErrorType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a EdenErrorType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<EdenErrorType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: EdenErrorType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for EdenErrorType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for EdenErrorType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("POSIX_ERROR", 0),
                ("WIN32_ERROR", 1),
                ("HRESULT_ERROR", 2),
                ("ARGUMENT_ERROR", 3),
                ("GENERIC_ERROR", 4),
                ("MOUNT_GENERATION_CHANGED", 5),
                ("JOURNAL_TRUNCATED", 6),
                ("CHECKOUT_IN_PROGRESS", 7),
                ("OUT_OF_DATE_PARENT", 8),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for EdenErrorType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "EdenErrorType::{}", self)
        }
    }

    impl ::std::str::FromStr for EdenErrorType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ARGUMENT_ERROR", 3),
                ("CHECKOUT_IN_PROGRESS", 7),
                ("GENERIC_ERROR", 4),
                ("HRESULT_ERROR", 2),
                ("JOURNAL_TRUNCATED", 6),
                ("MOUNT_GENERATION_CHANGED", 5),
                ("OUT_OF_DATE_PARENT", 8),
                ("POSIX_ERROR", 0),
                ("WIN32_ERROR", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "EdenErrorType").map(EdenErrorType)
        }
    }

    impl ::fbthrift::GetTType for EdenErrorType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for EdenErrorType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EdenErrorType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(EdenErrorType::from(p.read_i32()?))
        }
    }

    #[doc = "The current running state of an EdenMount."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct MountState(pub ::std::primitive::i32);

    impl MountState {
        #[doc = "The EdenMount object has been constructed but has not started\ninitializing."]
        pub const UNINITIALIZED: Self = MountState(0i32);
        #[doc = "The mount point is currently initializing and loading necessary state\n(such as the root directory contents) before it can ask the kernel to\nmount it."]
        pub const INITIALIZING: Self = MountState(1i32);
        #[doc = "The mount point has loaded its local state needed to start mounting\nbut has not actually started mounting yet."]
        pub const INITIALIZED: Self = MountState(2i32);
        #[doc = "Starting to mount fuse."]
        pub const STARTING: Self = MountState(3i32);
        #[doc = "The EdenMount is running normally."]
        pub const RUNNING: Self = MountState(4i32);
        #[doc = "Encountered an error while starting fuse mount."]
        pub const FUSE_ERROR: Self = MountState(5i32);
        #[doc = "EdenMount::shutdown() has been called, but it is not complete yet."]
        pub const SHUTTING_DOWN: Self = MountState(6i32);
        #[doc = "EdenMount::shutdown() has completed, but there are still outstanding\nreferences so EdenMount::destroy() has not been called yet.\n\nWhen EdenMount::destroy() is called the object can be destroyed\nimmediately."]
        pub const SHUT_DOWN: Self = MountState(7i32);
        #[doc = "EdenMount::destroy() has been called, but the shutdown is not complete\nyet.  There are no remaining references to the EdenMount at this point,\nso when the shutdown completes it will be automatically destroyed."]
        pub const DESTROYING: Self = MountState(8i32);
        #[doc = "An error occurred during mount initialization.\n\nThis state is used for errors that occur during the INITIALIZING phase,\nbefore we have attempted to start the FUSE mount."]
        pub const INIT_ERROR: Self = MountState(9i32);
    }

    impl ::fbthrift::ThriftEnum for MountState {
        fn enumerate() -> &'static [(MountState, &'static str)] {
            &[
                (MountState::UNINITIALIZED, "UNINITIALIZED"),
                (MountState::INITIALIZING, "INITIALIZING"),
                (MountState::INITIALIZED, "INITIALIZED"),
                (MountState::STARTING, "STARTING"),
                (MountState::RUNNING, "RUNNING"),
                (MountState::FUSE_ERROR, "FUSE_ERROR"),
                (MountState::SHUTTING_DOWN, "SHUTTING_DOWN"),
                (MountState::SHUT_DOWN, "SHUT_DOWN"),
                (MountState::DESTROYING, "DESTROYING"),
                (MountState::INIT_ERROR, "INIT_ERROR"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNINITIALIZED",
                "INITIALIZING",
                "INITIALIZED",
                "STARTING",
                "RUNNING",
                "FUSE_ERROR",
                "SHUTTING_DOWN",
                "SHUT_DOWN",
                "DESTROYING",
                "INIT_ERROR",
            ]
        }

        fn variant_values() -> &'static [MountState] {
            &[
                MountState::UNINITIALIZED,
                MountState::INITIALIZING,
                MountState::INITIALIZED,
                MountState::STARTING,
                MountState::RUNNING,
                MountState::FUSE_ERROR,
                MountState::SHUTTING_DOWN,
                MountState::SHUT_DOWN,
                MountState::DESTROYING,
                MountState::INIT_ERROR,
            ]
        }
    }

    impl ::std::default::Default for MountState {
        fn default() -> Self {
            MountState(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a MountState> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a MountState) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<MountState> for ::std::primitive::i32 {
        #[inline]
        fn from(x: MountState) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for MountState {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for MountState {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNINITIALIZED", 0),
                ("INITIALIZING", 1),
                ("INITIALIZED", 2),
                ("STARTING", 3),
                ("RUNNING", 4),
                ("FUSE_ERROR", 5),
                ("SHUTTING_DOWN", 6),
                ("SHUT_DOWN", 7),
                ("DESTROYING", 8),
                ("INIT_ERROR", 9),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for MountState {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "MountState::{}", self)
        }
    }

    impl ::std::str::FromStr for MountState {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DESTROYING", 8),
                ("FUSE_ERROR", 5),
                ("INITIALIZED", 2),
                ("INITIALIZING", 1),
                ("INIT_ERROR", 9),
                ("RUNNING", 4),
                ("SHUTTING_DOWN", 6),
                ("SHUT_DOWN", 7),
                ("STARTING", 3),
                ("UNINITIALIZED", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "MountState").map(MountState)
        }
    }

    impl ::fbthrift::GetTType for MountState {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for MountState
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for MountState
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(MountState::from(p.read_i32()?))
        }
    }

    #[doc = "File Attributes that can be requested with getAttributesFromFiles(). All attributes\nshould be a power of 2. OR the requested attributes together to get a bitmask."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct FileAttributes(pub ::std::primitive::i32);

    impl FileAttributes {
        pub const NONE: Self = FileAttributes(0i32);
        pub const SHA1_HASH: Self = FileAttributes(1i32);
        pub const FILE_SIZE: Self = FileAttributes(2i32);
    }

    impl ::fbthrift::ThriftEnum for FileAttributes {
        fn enumerate() -> &'static [(FileAttributes, &'static str)] {
            &[
                (FileAttributes::NONE, "NONE"),
                (FileAttributes::SHA1_HASH, "SHA1_HASH"),
                (FileAttributes::FILE_SIZE, "FILE_SIZE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "NONE",
                "SHA1_HASH",
                "FILE_SIZE",
            ]
        }

        fn variant_values() -> &'static [FileAttributes] {
            &[
                FileAttributes::NONE,
                FileAttributes::SHA1_HASH,
                FileAttributes::FILE_SIZE,
            ]
        }
    }

    impl ::std::default::Default for FileAttributes {
        fn default() -> Self {
            FileAttributes(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a FileAttributes> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a FileAttributes) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<FileAttributes> for ::std::primitive::i32 {
        #[inline]
        fn from(x: FileAttributes) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for FileAttributes {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for FileAttributes {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("NONE", 0),
                ("SHA1_HASH", 1),
                ("FILE_SIZE", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for FileAttributes {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "FileAttributes::{}", self)
        }
    }

    impl ::std::str::FromStr for FileAttributes {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("FILE_SIZE", 2),
                ("NONE", 0),
                ("SHA1_HASH", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "FileAttributes").map(FileAttributes)
        }
    }

    impl ::fbthrift::GetTType for FileAttributes {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for FileAttributes
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for FileAttributes
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(FileAttributes::from(p.read_i32()?))
        }
    }

    #[doc = "Classifies the change of the state of a file between and old and new state\nof the repository. Most commonly, the \"old state\" is the parent commit while\nthe \"new state\" is the working copy."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ScmFileStatus(pub ::std::primitive::i32);

    impl ScmFileStatus {
        #[doc = "File is present in the new state, but was not present in old state."]
        pub const ADDED: Self = ScmFileStatus(0i32);
        #[doc = "File is present in both the new and old states, but its contents or\nfile permissions have changed."]
        pub const MODIFIED: Self = ScmFileStatus(1i32);
        #[doc = "File was present in the old state, but is not present in the new state."]
        pub const REMOVED: Self = ScmFileStatus(2i32);
        #[doc = "File is present in the new state, but it is ignored according to the rules\nof the new state."]
        pub const IGNORED: Self = ScmFileStatus(3i32);
    }

    impl ::fbthrift::ThriftEnum for ScmFileStatus {
        fn enumerate() -> &'static [(ScmFileStatus, &'static str)] {
            &[
                (ScmFileStatus::ADDED, "ADDED"),
                (ScmFileStatus::MODIFIED, "MODIFIED"),
                (ScmFileStatus::REMOVED, "REMOVED"),
                (ScmFileStatus::IGNORED, "IGNORED"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ADDED",
                "MODIFIED",
                "REMOVED",
                "IGNORED",
            ]
        }

        fn variant_values() -> &'static [ScmFileStatus] {
            &[
                ScmFileStatus::ADDED,
                ScmFileStatus::MODIFIED,
                ScmFileStatus::REMOVED,
                ScmFileStatus::IGNORED,
            ]
        }
    }

    impl ::std::default::Default for ScmFileStatus {
        fn default() -> Self {
            ScmFileStatus(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ScmFileStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ScmFileStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ScmFileStatus> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ScmFileStatus) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ScmFileStatus {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ScmFileStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADDED", 0),
                ("MODIFIED", 1),
                ("REMOVED", 2),
                ("IGNORED", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ScmFileStatus {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ScmFileStatus::{}", self)
        }
    }

    impl ::std::str::FromStr for ScmFileStatus {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ADDED", 0),
                ("IGNORED", 3),
                ("MODIFIED", 1),
                ("REMOVED", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ScmFileStatus").map(ScmFileStatus)
        }
    }

    impl ::fbthrift::GetTType for ScmFileStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ScmFileStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ScmFileStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ScmFileStatus::from(p.read_i32()?))
        }
    }

    #[doc = "Option for use with checkOutRevision()."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct CheckoutMode(pub ::std::primitive::i32);

    impl CheckoutMode {
        #[doc = "Perform a \"normal\" checkout, analogous to `hg checkout` in Mercurial. Files\nin the working copy will be changed to reflect the destination snapshot,\nthough files with conflicts will not be modified."]
        pub const NORMAL: Self = CheckoutMode(0i32);
        #[doc = "Do not checkout: exercise the checkout logic to discover potential\nconflicts."]
        pub const DRY_RUN: Self = CheckoutMode(1i32);
        #[doc = "Perform a \"forced\" checkout, analogous to `hg checkout --clean` in\nMercurial. Conflicts between the working copy and destination snapshot will\nbe forcibly ignored in favor of the state of the new snapshot."]
        pub const FORCE: Self = CheckoutMode(2i32);
    }

    impl ::fbthrift::ThriftEnum for CheckoutMode {
        fn enumerate() -> &'static [(CheckoutMode, &'static str)] {
            &[
                (CheckoutMode::NORMAL, "NORMAL"),
                (CheckoutMode::DRY_RUN, "DRY_RUN"),
                (CheckoutMode::FORCE, "FORCE"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "NORMAL",
                "DRY_RUN",
                "FORCE",
            ]
        }

        fn variant_values() -> &'static [CheckoutMode] {
            &[
                CheckoutMode::NORMAL,
                CheckoutMode::DRY_RUN,
                CheckoutMode::FORCE,
            ]
        }
    }

    impl ::std::default::Default for CheckoutMode {
        fn default() -> Self {
            CheckoutMode(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a CheckoutMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a CheckoutMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<CheckoutMode> for ::std::primitive::i32 {
        #[inline]
        fn from(x: CheckoutMode) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for CheckoutMode {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for CheckoutMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("NORMAL", 0),
                ("DRY_RUN", 1),
                ("FORCE", 2),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for CheckoutMode {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "CheckoutMode::{}", self)
        }
    }

    impl ::std::str::FromStr for CheckoutMode {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DRY_RUN", 1),
                ("FORCE", 2),
                ("NORMAL", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "CheckoutMode").map(CheckoutMode)
        }
    }

    impl ::fbthrift::GetTType for CheckoutMode {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for CheckoutMode
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for CheckoutMode
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(CheckoutMode::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ConflictType(pub ::std::primitive::i32);

    impl ConflictType {
        #[doc = "We failed to update this particular path due to an error"]
        pub const ERROR: Self = ConflictType(0i32);
        #[doc = "A locally modified file was deleted in the new Tree"]
        pub const MODIFIED_REMOVED: Self = ConflictType(1i32);
        #[doc = "An untracked local file exists in the new Tree"]
        pub const UNTRACKED_ADDED: Self = ConflictType(2i32);
        #[doc = "The file was removed locally, but modified in the new Tree"]
        pub const REMOVED_MODIFIED: Self = ConflictType(3i32);
        #[doc = "The file was removed locally, and also removed in the new Tree."]
        pub const MISSING_REMOVED: Self = ConflictType(4i32);
        #[doc = "A locally modified file was modified in the new Tree\nThis may be contents modifications, or a file type change (directory to\nfile or vice-versa), or permissions changes."]
        pub const MODIFIED_MODIFIED: Self = ConflictType(5i32);
        #[doc = "A directory was supposed to be removed or replaced with a file,\nbut it contains untracked files preventing us from updating it."]
        pub const DIRECTORY_NOT_EMPTY: Self = ConflictType(6i32);
    }

    impl ::fbthrift::ThriftEnum for ConflictType {
        fn enumerate() -> &'static [(ConflictType, &'static str)] {
            &[
                (ConflictType::ERROR, "ERROR"),
                (ConflictType::MODIFIED_REMOVED, "MODIFIED_REMOVED"),
                (ConflictType::UNTRACKED_ADDED, "UNTRACKED_ADDED"),
                (ConflictType::REMOVED_MODIFIED, "REMOVED_MODIFIED"),
                (ConflictType::MISSING_REMOVED, "MISSING_REMOVED"),
                (ConflictType::MODIFIED_MODIFIED, "MODIFIED_MODIFIED"),
                (ConflictType::DIRECTORY_NOT_EMPTY, "DIRECTORY_NOT_EMPTY"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "ERROR",
                "MODIFIED_REMOVED",
                "UNTRACKED_ADDED",
                "REMOVED_MODIFIED",
                "MISSING_REMOVED",
                "MODIFIED_MODIFIED",
                "DIRECTORY_NOT_EMPTY",
            ]
        }

        fn variant_values() -> &'static [ConflictType] {
            &[
                ConflictType::ERROR,
                ConflictType::MODIFIED_REMOVED,
                ConflictType::UNTRACKED_ADDED,
                ConflictType::REMOVED_MODIFIED,
                ConflictType::MISSING_REMOVED,
                ConflictType::MODIFIED_MODIFIED,
                ConflictType::DIRECTORY_NOT_EMPTY,
            ]
        }
    }

    impl ::std::default::Default for ConflictType {
        fn default() -> Self {
            ConflictType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ConflictType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ConflictType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ConflictType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ConflictType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ConflictType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ConflictType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("ERROR", 0),
                ("MODIFIED_REMOVED", 1),
                ("UNTRACKED_ADDED", 2),
                ("REMOVED_MODIFIED", 3),
                ("MISSING_REMOVED", 4),
                ("MODIFIED_MODIFIED", 5),
                ("DIRECTORY_NOT_EMPTY", 6),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ConflictType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ConflictType::{}", self)
        }
    }

    impl ::std::str::FromStr for ConflictType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("DIRECTORY_NOT_EMPTY", 6),
                ("ERROR", 0),
                ("MISSING_REMOVED", 4),
                ("MODIFIED_MODIFIED", 5),
                ("MODIFIED_REMOVED", 1),
                ("REMOVED_MODIFIED", 3),
                ("UNTRACKED_ADDED", 2),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ConflictType").map(ConflictType)
        }
    }

    impl ::fbthrift::GetTType for ConflictType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ConflictType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ConflictType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ConflictType::from(p.read_i32()?))
        }
    }

    #[doc = "These numbers match up with Linux and macOS.\nWindows doesn't have dtype_t, but a subset of these map to and from\nthe GetFileType and dwFileAttributes equivalents.\n\nDtype and OsDtype can be cast between each other on all platforms."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct Dtype(pub ::std::primitive::i32);

    impl Dtype {
        pub const UNKNOWN: Self = Dtype(0i32);
        pub const FIFO: Self = Dtype(1i32);
        pub const CHAR: Self = Dtype(2i32);
        pub const DIR: Self = Dtype(4i32);
        pub const BLOCK: Self = Dtype(6i32);
        pub const REGULAR: Self = Dtype(8i32);
        pub const LINK: Self = Dtype(10i32);
        pub const SOCKET: Self = Dtype(12i32);
        pub const WHITEOUT: Self = Dtype(14i32);
    }

    impl ::fbthrift::ThriftEnum for Dtype {
        fn enumerate() -> &'static [(Dtype, &'static str)] {
            &[
                (Dtype::UNKNOWN, "UNKNOWN"),
                (Dtype::FIFO, "FIFO"),
                (Dtype::CHAR, "CHAR"),
                (Dtype::DIR, "DIR"),
                (Dtype::BLOCK, "BLOCK"),
                (Dtype::REGULAR, "REGULAR"),
                (Dtype::LINK, "LINK"),
                (Dtype::SOCKET, "SOCKET"),
                (Dtype::WHITEOUT, "WHITEOUT"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "UNKNOWN",
                "FIFO",
                "CHAR",
                "DIR",
                "BLOCK",
                "REGULAR",
                "LINK",
                "SOCKET",
                "WHITEOUT",
            ]
        }

        fn variant_values() -> &'static [Dtype] {
            &[
                Dtype::UNKNOWN,
                Dtype::FIFO,
                Dtype::CHAR,
                Dtype::DIR,
                Dtype::BLOCK,
                Dtype::REGULAR,
                Dtype::LINK,
                Dtype::SOCKET,
                Dtype::WHITEOUT,
            ]
        }
    }

    impl ::std::default::Default for Dtype {
        fn default() -> Self {
            Dtype(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a Dtype> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a Dtype) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<Dtype> for ::std::primitive::i32 {
        #[inline]
        fn from(x: Dtype) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for Dtype {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for Dtype {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("UNKNOWN", 0),
                ("FIFO", 1),
                ("CHAR", 2),
                ("DIR", 4),
                ("BLOCK", 6),
                ("REGULAR", 8),
                ("LINK", 10),
                ("SOCKET", 12),
                ("WHITEOUT", 14),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for Dtype {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "Dtype::{}", self)
        }
    }

    impl ::std::str::FromStr for Dtype {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("BLOCK", 6),
                ("CHAR", 2),
                ("DIR", 4),
                ("FIFO", 1),
                ("LINK", 10),
                ("REGULAR", 8),
                ("SOCKET", 12),
                ("UNKNOWN", 0),
                ("WHITEOUT", 14),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "Dtype").map(Dtype)
        }
    }

    impl ::fbthrift::GetTType for Dtype {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for Dtype
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for Dtype
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(Dtype::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct TracePointEvent(pub ::std::primitive::i32);

    impl TracePointEvent {
        pub const START: Self = TracePointEvent(0i32);
        pub const STOP: Self = TracePointEvent(1i32);
    }

    impl ::fbthrift::ThriftEnum for TracePointEvent {
        fn enumerate() -> &'static [(TracePointEvent, &'static str)] {
            &[
                (TracePointEvent::START, "START"),
                (TracePointEvent::STOP, "STOP"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "START",
                "STOP",
            ]
        }

        fn variant_values() -> &'static [TracePointEvent] {
            &[
                TracePointEvent::START,
                TracePointEvent::STOP,
            ]
        }
    }

    impl ::std::default::Default for TracePointEvent {
        fn default() -> Self {
            TracePointEvent(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a TracePointEvent> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a TracePointEvent) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<TracePointEvent> for ::std::primitive::i32 {
        #[inline]
        fn from(x: TracePointEvent) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for TracePointEvent {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for TracePointEvent {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("START", 0),
                ("STOP", 1),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for TracePointEvent {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "TracePointEvent::{}", self)
        }
    }

    impl ::std::str::FromStr for TracePointEvent {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("START", 0),
                ("STOP", 1),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "TracePointEvent").map(TracePointEvent)
        }
    }

    impl ::fbthrift::GetTType for TracePointEvent {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for TracePointEvent
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for TracePointEvent
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(TracePointEvent::from(p.read_i32()?))
        }
    }

    #[doc = "BackingStore object type. Caller will response to verify the type of the content\nmatching the parameters passed. Exception will be thrown if type mismatch."]
    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash, ::serde_derive::Serialize, ::serde_derive::Deserialize)]
    pub struct ObjectType(pub ::std::primitive::i32);

    impl ObjectType {
        pub const TREE: Self = ObjectType(0i32);
        pub const REGULAR_FILE: Self = ObjectType(1i32);
        pub const EXECUTABLE_FILE: Self = ObjectType(2i32);
        pub const SYMLINK: Self = ObjectType(3i32);
    }

    impl ::fbthrift::ThriftEnum for ObjectType {
        fn enumerate() -> &'static [(ObjectType, &'static str)] {
            &[
                (ObjectType::TREE, "TREE"),
                (ObjectType::REGULAR_FILE, "REGULAR_FILE"),
                (ObjectType::EXECUTABLE_FILE, "EXECUTABLE_FILE"),
                (ObjectType::SYMLINK, "SYMLINK"),
            ]
        }

        fn variants() -> &'static [&'static str] {
            &[
                "TREE",
                "REGULAR_FILE",
                "EXECUTABLE_FILE",
                "SYMLINK",
            ]
        }

        fn variant_values() -> &'static [ObjectType] {
            &[
                ObjectType::TREE,
                ObjectType::REGULAR_FILE,
                ObjectType::EXECUTABLE_FILE,
                ObjectType::SYMLINK,
            ]
        }
    }

    impl ::std::default::Default for ObjectType {
        fn default() -> Self {
            ObjectType(::fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> ::std::convert::From<&'a ObjectType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: &'a ObjectType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<ObjectType> for ::std::primitive::i32 {
        #[inline]
        fn from(x: ObjectType) -> Self {
            x.0
        }
    }

    impl ::std::convert::From<::std::primitive::i32> for ObjectType {
        #[inline]
        fn from(x: ::std::primitive::i32) -> Self {
            Self(x)
        }
    }

    impl ::std::fmt::Display for ObjectType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            static VARIANTS_BY_NUMBER: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("TREE", 0),
                ("REGULAR_FILE", 1),
                ("EXECUTABLE_FILE", 2),
                ("SYMLINK", 3),
            ];
            ::fbthrift::help::enum_display(VARIANTS_BY_NUMBER, fmt, self.0)
        }
    }

    impl ::std::fmt::Debug for ObjectType {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            write!(fmt, "ObjectType::{}", self)
        }
    }

    impl ::std::str::FromStr for ObjectType {
        type Err = ::anyhow::Error;

        fn from_str(string: &::std::primitive::str) -> ::std::result::Result<Self, Self::Err> {
            static VARIANTS_BY_NAME: &[(&::std::primitive::str, ::std::primitive::i32)] = &[
                ("EXECUTABLE_FILE", 2),
                ("REGULAR_FILE", 1),
                ("SYMLINK", 3),
                ("TREE", 0),
            ];
            ::fbthrift::help::enum_from_str(VARIANTS_BY_NAME, string, "ObjectType").map(ObjectType)
        }
    }

    impl ::fbthrift::GetTType for ObjectType {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::I32;
    }

    impl<P> ::fbthrift::Serialize<P> for ObjectType
    where
        P: ::fbthrift::ProtocolWriter,
    {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for ObjectType
    where
        P: ::fbthrift::ProtocolReader,
    {
        #[inline]
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            ::std::result::Result::Ok(ObjectType::from(p.read_i32()?))
        }
    }







    impl ::std::default::Default for self::EdenError {
        fn default() -> Self {
            Self {
                message: ::std::default::Default::default(),
                errorCode: ::std::option::Option::None,
                errorType: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::EdenError {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("EdenError")
                .field("message", &self.message)
                .field("errorCode", &self.errorCode)
                .field("errorType", &self.errorType)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::EdenError {}
    unsafe impl ::std::marker::Sync for self::EdenError {}

    impl ::fbthrift::GetTType for self::EdenError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EdenError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenError");
            p.write_field_begin("message", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.message, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.errorCode {
                p.write_field_begin("errorCode", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("errorType", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.errorType, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EdenError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("errorCode", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("errorType", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("message", ::fbthrift::TType::String, 1),
            ];
            let mut field_message = ::std::option::Option::None;
            let mut field_errorCode = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_message = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_errorCode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                message: field_message.unwrap_or_default(),
                errorCode: field_errorCode,
                errorType: field_errorType.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::NoValueForKeyError {
        fn default() -> Self {
            Self {
                key: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::NoValueForKeyError {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("NoValueForKeyError")
                .field("key", &self.key)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::NoValueForKeyError {}
    unsafe impl ::std::marker::Sync for self::NoValueForKeyError {}

    impl ::fbthrift::GetTType for self::NoValueForKeyError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NoValueForKeyError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NoValueForKeyError");
            p.write_field_begin("key", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.key, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NoValueForKeyError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("key", ::fbthrift::TType::String, 1),
            ];
            let mut field_key = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_key = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                key: field_key.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::DaemonInfo {
        fn default() -> Self {
            Self {
                pid: ::std::default::Default::default(),
                commandLine: ::std::default::Default::default(),
                status: ::std::option::Option::None,
                uptime: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::DaemonInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("DaemonInfo")
                .field("pid", &self.pid)
                .field("commandLine", &self.commandLine)
                .field("status", &self.status)
                .field("uptime", &self.uptime)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::DaemonInfo {}
    unsafe impl ::std::marker::Sync for self::DaemonInfo {}

    impl ::fbthrift::GetTType for self::DaemonInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DaemonInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DaemonInfo");
            p.write_field_begin("pid", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_begin("commandLine", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.commandLine, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.status {
                p.write_field_begin("status", ::fbthrift::TType::I32, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.uptime {
                p.write_field_begin("uptime", ::fbthrift::TType::Float, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DaemonInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("commandLine", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("pid", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("status", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("uptime", ::fbthrift::TType::Float, 4),
            ];
            let mut field_pid = ::std::option::Option::None;
            let mut field_commandLine = ::std::option::Option::None;
            let mut field_status = ::std::option::Option::None;
            let mut field_uptime = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_pid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_commandLine = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Float, 4) => field_uptime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                pid: field_pid.unwrap_or_default(),
                commandLine: field_commandLine.unwrap_or_default(),
                status: field_status,
                uptime: field_uptime,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::PrivHelperInfo {
        fn default() -> Self {
            Self {
                connected: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::PrivHelperInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("PrivHelperInfo")
                .field("connected", &self.connected)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::PrivHelperInfo {}
    unsafe impl ::std::marker::Sync for self::PrivHelperInfo {}

    impl ::fbthrift::GetTType for self::PrivHelperInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PrivHelperInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PrivHelperInfo");
            p.write_field_begin("connected", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.connected, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PrivHelperInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("connected", ::fbthrift::TType::Bool, 1),
            ];
            let mut field_connected = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_connected = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                connected: field_connected.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::MountInfo {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                edenClientPath: ::std::default::Default::default(),
                state: ::std::default::Default::default(),
                backingRepoPath: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::MountInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("MountInfo")
                .field("mountPoint", &self.mountPoint)
                .field("edenClientPath", &self.edenClientPath)
                .field("state", &self.state)
                .field("backingRepoPath", &self.backingRepoPath)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::MountInfo {}
    unsafe impl ::std::marker::Sync for self::MountInfo {}

    impl ::fbthrift::GetTType for self::MountInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInfo");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_begin("state", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.state, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.backingRepoPath {
                p.write_field_begin("backingRepoPath", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("backingRepoPath", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("edenClientPath", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("state", ::fbthrift::TType::I32, 3),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_edenClientPath = ::std::option::Option::None;
            let mut field_state = ::std::option::Option::None;
            let mut field_backingRepoPath = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edenClientPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_state = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_backingRepoPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
                state: field_state.unwrap_or_default(),
                backingRepoPath: field_backingRepoPath,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::MountArgument {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                edenClientPath: ::std::default::Default::default(),
                readOnly: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::MountArgument {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("MountArgument")
                .field("mountPoint", &self.mountPoint)
                .field("edenClientPath", &self.edenClientPath)
                .field("readOnly", &self.readOnly)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::MountArgument {}
    unsafe impl ::std::marker::Sync for self::MountArgument {}

    impl ::fbthrift::GetTType for self::MountArgument {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountArgument
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountArgument");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("edenClientPath", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.edenClientPath, p);
            p.write_field_end();
            p.write_field_begin("readOnly", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.readOnly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountArgument
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("edenClientPath", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("readOnly", ::fbthrift::TType::Bool, 3),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_edenClientPath = ::std::option::Option::None;
            let mut field_readOnly = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_edenClientPath = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_readOnly = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                edenClientPath: field_edenClientPath.unwrap_or_default(),
                readOnly: field_readOnly.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }



    impl ::std::default::Default for SHA1Result {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for SHA1Result {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for SHA1Result
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SHA1Result");
            match self {
                SHA1Result::sha1(inner) => {
                    p.write_field_begin("sha1", ::fbthrift::TType::String, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                SHA1Result::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for SHA1Result
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("error", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("sha1", ::fbthrift::TType::String, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::String, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SHA1Result::sha1(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(SHA1Result::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "SHA1Result",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::TimeSpec {
        fn default() -> Self {
            Self {
                seconds: ::std::default::Default::default(),
                nanoSeconds: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::TimeSpec {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("TimeSpec")
                .field("seconds", &self.seconds)
                .field("nanoSeconds", &self.nanoSeconds)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::TimeSpec {}
    unsafe impl ::std::marker::Sync for self::TimeSpec {}

    impl ::fbthrift::GetTType for self::TimeSpec {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TimeSpec
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TimeSpec");
            p.write_field_begin("seconds", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.seconds, p);
            p.write_field_end();
            p.write_field_begin("nanoSeconds", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.nanoSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TimeSpec
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("nanoSeconds", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("seconds", ::fbthrift::TType::I64, 1),
            ];
            let mut field_seconds = ::std::option::Option::None;
            let mut field_nanoSeconds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_seconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_nanoSeconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                seconds: field_seconds.unwrap_or_default(),
                nanoSeconds: field_nanoSeconds.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::EntryInformation {
        fn default() -> Self {
            Self {
                dtype: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::EntryInformation {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("EntryInformation")
                .field("dtype", &self.dtype)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::EntryInformation {}
    unsafe impl ::std::marker::Sync for self::EntryInformation {}

    impl ::fbthrift::GetTType for self::EntryInformation {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::EntryInformation
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EntryInformation");
            p.write_field_begin("dtype", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.dtype, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::EntryInformation
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dtype", ::fbthrift::TType::I32, 1),
            ];
            let mut field_dtype = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_dtype = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                dtype: field_dtype.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }



    impl ::std::default::Default for EntryInformationOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for EntryInformationOrError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for EntryInformationOrError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EntryInformationOrError");
            match self {
                EntryInformationOrError::info(inner) => {
                    p.write_field_begin("info", ::fbthrift::TType::Struct, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryInformationOrError::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                EntryInformationOrError::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for EntryInformationOrError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("error", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("info", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::Struct, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryInformationOrError::info(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(EntryInformationOrError::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "EntryInformationOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::FileInformation {
        fn default() -> Self {
            Self {
                size: ::std::default::Default::default(),
                mtime: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::FileInformation {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("FileInformation")
                .field("size", &self.size)
                .field("mtime", &self.mtime)
                .field("mode", &self.mode)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::FileInformation {}
    unsafe impl ::std::marker::Sync for self::FileInformation {}

    impl ::fbthrift::GetTType for self::FileInformation {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FileInformation
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformation");
            p.write_field_begin("size", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("mtime", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.mtime, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FileInformation
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("mtime", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("size", ::fbthrift::TType::I64, 1),
            ];
            let mut field_size = ::std::option::Option::None;
            let mut field_mtime = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_mtime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                size: field_size.unwrap_or_default(),
                mtime: field_mtime.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }



    impl ::std::default::Default for FileInformationOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for FileInformationOrError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for FileInformationOrError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileInformationOrError");
            match self {
                FileInformationOrError::info(inner) => {
                    p.write_field_begin("info", ::fbthrift::TType::Struct, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileInformationOrError::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for FileInformationOrError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("error", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("info", ::fbthrift::TType::Struct, 1),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::Struct, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileInformationOrError::info(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileInformationOrError::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "FileInformationOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::FileAttributeData {
        fn default() -> Self {
            Self {
                sha1: ::std::option::Option::None,
                fileSize: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::FileAttributeData {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("FileAttributeData")
                .field("sha1", &self.sha1)
                .field("fileSize", &self.fileSize)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::FileAttributeData {}
    unsafe impl ::std::marker::Sync for self::FileAttributeData {}

    impl ::fbthrift::GetTType for self::FileAttributeData {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FileAttributeData
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileAttributeData");
            if let ::std::option::Option::Some(some) = &self.sha1 {
                p.write_field_begin("sha1", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.fileSize {
                p.write_field_begin("fileSize", ::fbthrift::TType::I64, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FileAttributeData
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fileSize", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("sha1", ::fbthrift::TType::String, 1),
            ];
            let mut field_sha1 = ::std::option::Option::None;
            let mut field_fileSize = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_sha1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_fileSize = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                sha1: field_sha1,
                fileSize: field_fileSize,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }



    impl ::std::default::Default for FileAttributeDataOrError {
        fn default() -> Self {
            Self::UnknownField(-1)
        }
    }

    impl ::fbthrift::GetTType for FileAttributeDataOrError {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for FileAttributeDataOrError
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileAttributeDataOrError");
            match self {
                FileAttributeDataOrError::data(inner) => {
                    p.write_field_begin("data", ::fbthrift::TType::Struct, 1);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileAttributeDataOrError::error(inner) => {
                    p.write_field_begin("error", ::fbthrift::TType::Struct, 2);
                    ::fbthrift::Serialize::write(inner, p);
                    p.write_field_end();
                }
                FileAttributeDataOrError::UnknownField(_) => {}
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for FileAttributeDataOrError
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("data", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("error", ::fbthrift::TType::Struct, 2),
            ];
            let _ = p.read_struct_begin(|_| ())?;
            let mut once = false;
            let mut alt = ::std::option::Option::None;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32, once) {
                    (::fbthrift::TType::Stop, _, _) => break,
                    (::fbthrift::TType::Struct, 1, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileAttributeDataOrError::data(::fbthrift::Deserialize::read(p)?));
                    }
                    (::fbthrift::TType::Struct, 2, false) => {
                        once = true;
                        alt = ::std::option::Option::Some(FileAttributeDataOrError::error(::fbthrift::Deserialize::read(p)?));
                    }
                    (fty, _, false) => p.skip(fty)?,
                    (badty, badid, true) => return ::std::result::Result::Err(::std::convert::From::from(::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                        format!(
                            "unwanted extra union {} field ty {:?} id {}",
                            "FileAttributeDataOrError",
                            badty,
                            badid,
                        ),
                    ))),
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(alt.unwrap_or_default())
        }
    }

    impl ::std::default::Default for self::SyncBehavior {
        fn default() -> Self {
            Self {
                syncTimeoutSeconds: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SyncBehavior {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SyncBehavior")
                .field("syncTimeoutSeconds", &self.syncTimeoutSeconds)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SyncBehavior {}
    unsafe impl ::std::marker::Sync for self::SyncBehavior {}

    impl ::fbthrift::GetTType for self::SyncBehavior {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SyncBehavior
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SyncBehavior");
            if let ::std::option::Option::Some(some) = &self.syncTimeoutSeconds {
                p.write_field_begin("syncTimeoutSeconds", ::fbthrift::TType::I64, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SyncBehavior
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("syncTimeoutSeconds", ::fbthrift::TType::I64, 1),
            ];
            let mut field_syncTimeoutSeconds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_syncTimeoutSeconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                syncTimeoutSeconds: field_syncTimeoutSeconds,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetAttributesFromFilesParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                paths: ::std::default::Default::default(),
                requestedAttributes: ::std::default::Default::default(),
                sync: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetAttributesFromFilesParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetAttributesFromFilesParams")
                .field("mountPoint", &self.mountPoint)
                .field("paths", &self.paths)
                .field("requestedAttributes", &self.requestedAttributes)
                .field("sync", &self.sync)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetAttributesFromFilesParams {}
    unsafe impl ::std::marker::Sync for self::GetAttributesFromFilesParams {}

    impl ::fbthrift::GetTType for self::GetAttributesFromFilesParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetAttributesFromFilesParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetAttributesFromFilesParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("paths", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.paths, p);
            p.write_field_end();
            p.write_field_begin("requestedAttributes", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.requestedAttributes, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 4);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetAttributesFromFilesParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("paths", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("requestedAttributes", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("sync", ::fbthrift::TType::Struct, 4),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_paths = ::std::option::Option::None;
            let mut field_requestedAttributes = ::std::option::Option::None;
            let mut field_sync = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_paths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_requestedAttributes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 4) => field_sync = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                paths: field_paths.unwrap_or_default(),
                requestedAttributes: field_requestedAttributes.unwrap_or_default(),
                sync: field_sync.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetAttributesFromFilesResult {
        fn default() -> Self {
            Self {
                res: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetAttributesFromFilesResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetAttributesFromFilesResult")
                .field("res", &self.res)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetAttributesFromFilesResult {}
    unsafe impl ::std::marker::Sync for self::GetAttributesFromFilesResult {}

    impl ::fbthrift::GetTType for self::GetAttributesFromFilesResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetAttributesFromFilesResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetAttributesFromFilesResult");
            p.write_field_begin("res", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.res, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetAttributesFromFilesResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("res", ::fbthrift::TType::List, 1),
            ];
            let mut field_res = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_res = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                res: field_res.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::JournalPosition {
        fn default() -> Self {
            Self {
                mountGeneration: ::std::default::Default::default(),
                sequenceNumber: ::std::default::Default::default(),
                snapshotHash: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::JournalPosition {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("JournalPosition")
                .field("mountGeneration", &self.mountGeneration)
                .field("sequenceNumber", &self.sequenceNumber)
                .field("snapshotHash", &self.snapshotHash)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::JournalPosition {}
    unsafe impl ::std::marker::Sync for self::JournalPosition {}

    impl ::fbthrift::GetTType for self::JournalPosition {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JournalPosition
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalPosition");
            p.write_field_begin("mountGeneration", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.mountGeneration, p);
            p.write_field_end();
            p.write_field_begin("sequenceNumber", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.sequenceNumber, p);
            p.write_field_end();
            p.write_field_begin("snapshotHash", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.snapshotHash, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JournalPosition
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mountGeneration", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("sequenceNumber", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("snapshotHash", ::fbthrift::TType::String, 3),
            ];
            let mut field_mountGeneration = ::std::option::Option::None;
            let mut field_sequenceNumber = ::std::option::Option::None;
            let mut field_snapshotHash = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_mountGeneration = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_sequenceNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_snapshotHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountGeneration: field_mountGeneration.unwrap_or_default(),
                sequenceNumber: field_sequenceNumber.unwrap_or_default(),
                snapshotHash: field_snapshotHash.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::FileDelta {
        fn default() -> Self {
            Self {
                fromPosition: ::std::default::Default::default(),
                toPosition: ::std::default::Default::default(),
                changedPaths: ::std::default::Default::default(),
                createdPaths: ::std::default::Default::default(),
                removedPaths: ::std::default::Default::default(),
                uncleanPaths: ::std::default::Default::default(),
                snapshotTransitions: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::FileDelta {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("FileDelta")
                .field("fromPosition", &self.fromPosition)
                .field("toPosition", &self.toPosition)
                .field("changedPaths", &self.changedPaths)
                .field("createdPaths", &self.createdPaths)
                .field("removedPaths", &self.removedPaths)
                .field("uncleanPaths", &self.uncleanPaths)
                .field("snapshotTransitions", &self.snapshotTransitions)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::FileDelta {}
    unsafe impl ::std::marker::Sync for self::FileDelta {}

    impl ::fbthrift::GetTType for self::FileDelta {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FileDelta
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FileDelta");
            p.write_field_begin("fromPosition", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("createdPaths", ::fbthrift::TType::List, 4);
            ::fbthrift::Serialize::write(&self.createdPaths, p);
            p.write_field_end();
            p.write_field_begin("removedPaths", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.removedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", ::fbthrift::TType::List, 6);
            ::fbthrift::Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_begin("snapshotTransitions", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(&self.snapshotTransitions, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FileDelta
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("changedPaths", ::fbthrift::TType::List, 3),
                ::fbthrift::Field::new("createdPaths", ::fbthrift::TType::List, 4),
                ::fbthrift::Field::new("fromPosition", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("removedPaths", ::fbthrift::TType::List, 5),
                ::fbthrift::Field::new("snapshotTransitions", ::fbthrift::TType::List, 7),
                ::fbthrift::Field::new("toPosition", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("uncleanPaths", ::fbthrift::TType::List, 6),
            ];
            let mut field_fromPosition = ::std::option::Option::None;
            let mut field_toPosition = ::std::option::Option::None;
            let mut field_changedPaths = ::std::option::Option::None;
            let mut field_createdPaths = ::std::option::Option::None;
            let mut field_removedPaths = ::std::option::Option::None;
            let mut field_uncleanPaths = ::std::option::Option::None;
            let mut field_snapshotTransitions = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fromPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_toPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_changedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 4) => field_createdPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_removedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 6) => field_uncleanPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 7) => field_snapshotTransitions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                createdPaths: field_createdPaths.unwrap_or_default(),
                removedPaths: field_removedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
                snapshotTransitions: field_snapshotTransitions.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::DebugGetRawJournalParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                limit: ::std::option::Option::None,
                fromSequenceNumber: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::DebugGetRawJournalParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("DebugGetRawJournalParams")
                .field("mountPoint", &self.mountPoint)
                .field("limit", &self.limit)
                .field("fromSequenceNumber", &self.fromSequenceNumber)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::DebugGetRawJournalParams {}
    unsafe impl ::std::marker::Sync for self::DebugGetRawJournalParams {}

    impl ::fbthrift::GetTType for self::DebugGetRawJournalParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugGetRawJournalParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.limit {
                p.write_field_begin("limit", ::fbthrift::TType::I32, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("fromSequenceNumber", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.fromSequenceNumber, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugGetRawJournalParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fromSequenceNumber", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("limit", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_limit = ::std::option::Option::None;
            let mut field_fromSequenceNumber = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_limit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_fromSequenceNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                limit: field_limit,
                fromSequenceNumber: field_fromSequenceNumber.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::DebugPathChangeInfo {
        fn default() -> Self {
            Self {
                existedBefore: ::std::default::Default::default(),
                existedAfter: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::DebugPathChangeInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("DebugPathChangeInfo")
                .field("existedBefore", &self.existedBefore)
                .field("existedAfter", &self.existedAfter)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::DebugPathChangeInfo {}
    unsafe impl ::std::marker::Sync for self::DebugPathChangeInfo {}

    impl ::fbthrift::GetTType for self::DebugPathChangeInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugPathChangeInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugPathChangeInfo");
            p.write_field_begin("existedBefore", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.existedBefore, p);
            p.write_field_end();
            p.write_field_begin("existedAfter", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.existedAfter, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugPathChangeInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("existedAfter", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("existedBefore", ::fbthrift::TType::Bool, 1),
            ];
            let mut field_existedBefore = ::std::option::Option::None;
            let mut field_existedAfter = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_existedBefore = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_existedAfter = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                existedBefore: field_existedBefore.unwrap_or_default(),
                existedAfter: field_existedAfter.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::DebugJournalDelta {
        fn default() -> Self {
            Self {
                fromPosition: ::std::default::Default::default(),
                toPosition: ::std::default::Default::default(),
                changedPaths: ::std::default::Default::default(),
                uncleanPaths: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::DebugJournalDelta {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("DebugJournalDelta")
                .field("fromPosition", &self.fromPosition)
                .field("toPosition", &self.toPosition)
                .field("changedPaths", &self.changedPaths)
                .field("uncleanPaths", &self.uncleanPaths)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::DebugJournalDelta {}
    unsafe impl ::std::marker::Sync for self::DebugJournalDelta {}

    impl ::fbthrift::GetTType for self::DebugJournalDelta {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugJournalDelta
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugJournalDelta");
            p.write_field_begin("fromPosition", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_begin("toPosition", ::fbthrift::TType::Struct, 2);
            ::fbthrift::Serialize::write(&self.toPosition, p);
            p.write_field_end();
            p.write_field_begin("changedPaths", ::fbthrift::TType::Map, 3);
            ::fbthrift::Serialize::write(&self.changedPaths, p);
            p.write_field_end();
            p.write_field_begin("uncleanPaths", ::fbthrift::TType::Set, 4);
            ::fbthrift::Serialize::write(&self.uncleanPaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugJournalDelta
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("changedPaths", ::fbthrift::TType::Map, 3),
                ::fbthrift::Field::new("fromPosition", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("toPosition", ::fbthrift::TType::Struct, 2),
                ::fbthrift::Field::new("uncleanPaths", ::fbthrift::TType::Set, 4),
            ];
            let mut field_fromPosition = ::std::option::Option::None;
            let mut field_toPosition = ::std::option::Option::None;
            let mut field_changedPaths = ::std::option::Option::None;
            let mut field_uncleanPaths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_fromPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 2) => field_toPosition = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_changedPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Set, 4) => field_uncleanPaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fromPosition: field_fromPosition.unwrap_or_default(),
                toPosition: field_toPosition.unwrap_or_default(),
                changedPaths: field_changedPaths.unwrap_or_default(),
                uncleanPaths: field_uncleanPaths.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::DebugGetRawJournalResponse {
        fn default() -> Self {
            Self {
                allDeltas: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::DebugGetRawJournalResponse {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("DebugGetRawJournalResponse")
                .field("allDeltas", &self.allDeltas)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::DebugGetRawJournalResponse {}
    unsafe impl ::std::marker::Sync for self::DebugGetRawJournalResponse {}

    impl ::fbthrift::GetTType for self::DebugGetRawJournalResponse {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::DebugGetRawJournalResponse
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("DebugGetRawJournalResponse");
            p.write_field_begin("allDeltas", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.allDeltas, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::DebugGetRawJournalResponse
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("allDeltas", ::fbthrift::TType::List, 2),
            ];
            let mut field_allDeltas = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 2) => field_allDeltas = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                allDeltas: field_allDeltas.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ScmStatus {
        fn default() -> Self {
            Self {
                entries: ::std::default::Default::default(),
                errors: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ScmStatus {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ScmStatus")
                .field("entries", &self.entries)
                .field("errors", &self.errors)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ScmStatus {}
    unsafe impl ::std::marker::Sync for self::ScmStatus {}

    impl ::fbthrift::GetTType for self::ScmStatus {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmStatus
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmStatus");
            p.write_field_begin("entries", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("errors", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.errors, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmStatus
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("entries", ::fbthrift::TType::Map, 1),
                ::fbthrift::Field::new("errors", ::fbthrift::TType::Map, 2),
            ];
            let mut field_entries = ::std::option::Option::None;
            let mut field_errors = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_entries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_errors = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entries: field_entries.unwrap_or_default(),
                errors: field_errors.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::CheckoutConflict {
        fn default() -> Self {
            Self {
                path: ::std::default::Default::default(),
                r#type: ::std::default::Default::default(),
                message: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::CheckoutConflict {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("CheckoutConflict")
                .field("path", &self.path)
                .field("r#type", &self.r#type)
                .field("message", &self.message)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::CheckoutConflict {}
    unsafe impl ::std::marker::Sync for self::CheckoutConflict {}

    impl ::fbthrift::GetTType for self::CheckoutConflict {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckoutConflict
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckoutConflict");
            p.write_field_begin("path", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.r#type, p);
            p.write_field_end();
            p.write_field_begin("message", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.message, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckoutConflict
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("message", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 2),
            ];
            let mut field_path = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_message = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_message = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                path: field_path.unwrap_or_default(),
                r#type: field_type.unwrap_or_default(),
                message: field_message.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ScmBlobMetadata {
        fn default() -> Self {
            Self {
                size: ::std::default::Default::default(),
                contentsSha1: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ScmBlobMetadata {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ScmBlobMetadata")
                .field("size", &self.size)
                .field("contentsSha1", &self.contentsSha1)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ScmBlobMetadata {}
    unsafe impl ::std::marker::Sync for self::ScmBlobMetadata {}

    impl ::fbthrift::GetTType for self::ScmBlobMetadata {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmBlobMetadata
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmBlobMetadata");
            p.write_field_begin("size", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.size, p);
            p.write_field_end();
            p.write_field_begin("contentsSha1", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.contentsSha1, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmBlobMetadata
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("contentsSha1", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("size", ::fbthrift::TType::I64, 1),
            ];
            let mut field_size = ::std::option::Option::None;
            let mut field_contentsSha1 = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_size = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_contentsSha1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                size: field_size.unwrap_or_default(),
                contentsSha1: field_contentsSha1.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ScmTreeEntry {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                id: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ScmTreeEntry {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ScmTreeEntry")
                .field("name", &self.name)
                .field("mode", &self.mode)
                .field("id", &self.id)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ScmTreeEntry {}
    unsafe impl ::std::marker::Sync for self::ScmTreeEntry {}

    impl ::fbthrift::GetTType for self::ScmTreeEntry {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ScmTreeEntry
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ScmTreeEntry");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ScmTreeEntry
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("id", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_id = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_id = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                id: field_id.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::TreeInodeEntryDebugInfo {
        fn default() -> Self {
            Self {
                name: ::std::default::Default::default(),
                inodeNumber: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                loaded: ::std::default::Default::default(),
                materialized: ::std::default::Default::default(),
                hash: ::std::default::Default::default(),
                fileSize: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::TreeInodeEntryDebugInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("TreeInodeEntryDebugInfo")
                .field("name", &self.name)
                .field("inodeNumber", &self.inodeNumber)
                .field("mode", &self.mode)
                .field("loaded", &self.loaded)
                .field("materialized", &self.materialized)
                .field("hash", &self.hash)
                .field("fileSize", &self.fileSize)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::TreeInodeEntryDebugInfo {}
    unsafe impl ::std::marker::Sync for self::TreeInodeEntryDebugInfo {}

    impl ::fbthrift::GetTType for self::TreeInodeEntryDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TreeInodeEntryDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeEntryDebugInfo");
            p.write_field_begin("name", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("inodeNumber", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 3);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            p.write_field_begin("loaded", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("materialized", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("hash", ::fbthrift::TType::String, 6);
            ::fbthrift::Serialize::write(&self.hash, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.fileSize {
                p.write_field_begin("fileSize", ::fbthrift::TType::I64, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TreeInodeEntryDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fileSize", ::fbthrift::TType::I64, 7),
                ::fbthrift::Field::new("hash", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("inodeNumber", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("loaded", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("materialized", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 3),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 1),
            ];
            let mut field_name = ::std::option::Option::None;
            let mut field_inodeNumber = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_loaded = ::std::option::Option::None;
            let mut field_materialized = ::std::option::Option::None;
            let mut field_hash = ::std::option::Option::None;
            let mut field_fileSize = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_inodeNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 3) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_loaded = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_materialized = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_hash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_fileSize = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                name: field_name.unwrap_or_default(),
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                hash: field_hash.unwrap_or_default(),
                fileSize: field_fileSize,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetFetchedFilesResult {
        fn default() -> Self {
            Self {
                fetchedFilePaths: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetFetchedFilesResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetFetchedFilesResult")
                .field("fetchedFilePaths", &self.fetchedFilePaths)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetFetchedFilesResult {}
    unsafe impl ::std::marker::Sync for self::GetFetchedFilesResult {}

    impl ::fbthrift::GetTType for self::GetFetchedFilesResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetFetchedFilesResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetFetchedFilesResult");
            p.write_field_begin("fetchedFilePaths", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.fetchedFilePaths, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetFetchedFilesResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fetchedFilePaths", ::fbthrift::TType::Map, 1),
            ];
            let mut field_fetchedFilePaths = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_fetchedFilePaths = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fetchedFilePaths: field_fetchedFilePaths.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::WorkingDirectoryParents {
        fn default() -> Self {
            Self {
                parent1: ::std::default::Default::default(),
                parent2: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::WorkingDirectoryParents {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("WorkingDirectoryParents")
                .field("parent1", &self.parent1)
                .field("parent2", &self.parent2)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::WorkingDirectoryParents {}
    unsafe impl ::std::marker::Sync for self::WorkingDirectoryParents {}

    impl ::fbthrift::GetTType for self::WorkingDirectoryParents {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::WorkingDirectoryParents
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("WorkingDirectoryParents");
            p.write_field_begin("parent1", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.parent1, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.parent2 {
                p.write_field_begin("parent2", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::WorkingDirectoryParents
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("parent1", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("parent2", ::fbthrift::TType::String, 2),
            ];
            let mut field_parent1 = ::std::option::Option::None;
            let mut field_parent2 = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_parent1 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_parent2 = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                parent1: field_parent1.unwrap_or_default(),
                parent2: field_parent2,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::TreeInodeDebugInfo {
        fn default() -> Self {
            Self {
                inodeNumber: ::std::default::Default::default(),
                path: ::std::default::Default::default(),
                materialized: ::std::default::Default::default(),
                treeHash: ::std::default::Default::default(),
                entries: ::std::default::Default::default(),
                refcount: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::TreeInodeDebugInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("TreeInodeDebugInfo")
                .field("inodeNumber", &self.inodeNumber)
                .field("path", &self.path)
                .field("materialized", &self.materialized)
                .field("treeHash", &self.treeHash)
                .field("entries", &self.entries)
                .field("refcount", &self.refcount)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::TreeInodeDebugInfo {}
    unsafe impl ::std::marker::Sync for self::TreeInodeDebugInfo {}

    impl ::fbthrift::GetTType for self::TreeInodeDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TreeInodeDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TreeInodeDebugInfo");
            p.write_field_begin("inodeNumber", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("materialized", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.materialized, p);
            p.write_field_end();
            p.write_field_begin("treeHash", ::fbthrift::TType::String, 4);
            ::fbthrift::Serialize::write(&self.treeHash, p);
            p.write_field_end();
            p.write_field_begin("entries", ::fbthrift::TType::List, 5);
            ::fbthrift::Serialize::write(&self.entries, p);
            p.write_field_end();
            p.write_field_begin("refcount", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.refcount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TreeInodeDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("entries", ::fbthrift::TType::List, 5),
                ::fbthrift::Field::new("inodeNumber", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("materialized", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("refcount", ::fbthrift::TType::I64, 6),
                ::fbthrift::Field::new("treeHash", ::fbthrift::TType::String, 4),
            ];
            let mut field_inodeNumber = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let mut field_materialized = ::std::option::Option::None;
            let mut field_treeHash = ::std::option::Option::None;
            let mut field_entries = ::std::option::Option::None;
            let mut field_refcount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_inodeNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_materialized = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_treeHash = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 5) => field_entries = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_refcount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                inodeNumber: field_inodeNumber.unwrap_or_default(),
                path: field_path.unwrap_or_default(),
                materialized: field_materialized.unwrap_or_default(),
                treeHash: field_treeHash.unwrap_or_default(),
                entries: field_entries.unwrap_or_default(),
                refcount: field_refcount.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::InodePathDebugInfo {
        fn default() -> Self {
            Self {
                path: ::std::default::Default::default(),
                loaded: ::std::default::Default::default(),
                linked: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::InodePathDebugInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("InodePathDebugInfo")
                .field("path", &self.path)
                .field("loaded", &self.loaded)
                .field("linked", &self.linked)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::InodePathDebugInfo {}
    unsafe impl ::std::marker::Sync for self::InodePathDebugInfo {}

    impl ::fbthrift::GetTType for self::InodePathDebugInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::InodePathDebugInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InodePathDebugInfo");
            p.write_field_begin("path", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("loaded", ::fbthrift::TType::Bool, 2);
            ::fbthrift::Serialize::write(&self.loaded, p);
            p.write_field_end();
            p.write_field_begin("linked", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.linked, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::InodePathDebugInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("linked", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("loaded", ::fbthrift::TType::Bool, 2),
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 1),
            ];
            let mut field_path = ::std::option::Option::None;
            let mut field_loaded = ::std::option::Option::None;
            let mut field_linked = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 2) => field_loaded = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_linked = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                path: field_path.unwrap_or_default(),
                loaded: field_loaded.unwrap_or_default(),
                linked: field_linked.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ActivityRecorderResult {
        fn default() -> Self {
            Self {
                unique: ::std::default::Default::default(),
                path: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ActivityRecorderResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ActivityRecorderResult")
                .field("unique", &self.unique)
                .field("path", &self.path)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ActivityRecorderResult {}
    unsafe impl ::std::marker::Sync for self::ActivityRecorderResult {}

    impl ::fbthrift::GetTType for self::ActivityRecorderResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ActivityRecorderResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ActivityRecorderResult");
            p.write_field_begin("unique", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.unique, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.path {
                p.write_field_begin("path", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ActivityRecorderResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("unique", ::fbthrift::TType::I64, 1),
            ];
            let mut field_unique = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                unique: field_unique.unwrap_or_default(),
                path: field_path,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ListActivityRecordingsResult {
        fn default() -> Self {
            Self {
                recordings: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ListActivityRecordingsResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ListActivityRecordingsResult")
                .field("recordings", &self.recordings)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ListActivityRecordingsResult {}
    unsafe impl ::std::marker::Sync for self::ListActivityRecordingsResult {}

    impl ::fbthrift::GetTType for self::ListActivityRecordingsResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ListActivityRecordingsResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ListActivityRecordingsResult");
            p.write_field_begin("recordings", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.recordings, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ListActivityRecordingsResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("recordings", ::fbthrift::TType::List, 1),
            ];
            let mut field_recordings = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_recordings = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                recordings: field_recordings.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SetLogLevelResult {
        fn default() -> Self {
            Self {
                categoryCreated: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SetLogLevelResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SetLogLevelResult")
                .field("categoryCreated", &self.categoryCreated)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SetLogLevelResult {}
    unsafe impl ::std::marker::Sync for self::SetLogLevelResult {}

    impl ::fbthrift::GetTType for self::SetLogLevelResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetLogLevelResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetLogLevelResult");
            p.write_field_begin("categoryCreated", ::fbthrift::TType::Bool, 1);
            ::fbthrift::Serialize::write(&self.categoryCreated, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetLogLevelResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("categoryCreated", ::fbthrift::TType::Bool, 1),
            ];
            let mut field_categoryCreated = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Bool, 1) => field_categoryCreated = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                categoryCreated: field_categoryCreated.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::JournalInfo {
        fn default() -> Self {
            Self {
                entryCount: ::std::default::Default::default(),
                memoryUsage: ::std::default::Default::default(),
                durationSeconds: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::JournalInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("JournalInfo")
                .field("entryCount", &self.entryCount)
                .field("memoryUsage", &self.memoryUsage)
                .field("durationSeconds", &self.durationSeconds)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::JournalInfo {}
    unsafe impl ::std::marker::Sync for self::JournalInfo {}

    impl ::fbthrift::GetTType for self::JournalInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::JournalInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("JournalInfo");
            p.write_field_begin("entryCount", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("memoryUsage", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.memoryUsage, p);
            p.write_field_end();
            p.write_field_begin("durationSeconds", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.durationSeconds, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::JournalInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("durationSeconds", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("entryCount", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("memoryUsage", ::fbthrift::TType::I64, 2),
            ];
            let mut field_entryCount = ::std::option::Option::None;
            let mut field_memoryUsage = ::std::option::Option::None;
            let mut field_durationSeconds = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_entryCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_memoryUsage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_durationSeconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                memoryUsage: field_memoryUsage.unwrap_or_default(),
                durationSeconds: field_durationSeconds.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::MountInodeInfo {
        fn default() -> Self {
            Self {
                unloadedInodeCount: ::std::default::Default::default(),
                loadedFileCount: ::std::default::Default::default(),
                loadedTreeCount: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::MountInodeInfo {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("MountInodeInfo")
                .field("unloadedInodeCount", &self.unloadedInodeCount)
                .field("loadedFileCount", &self.loadedFileCount)
                .field("loadedTreeCount", &self.loadedTreeCount)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::MountInodeInfo {}
    unsafe impl ::std::marker::Sync for self::MountInodeInfo {}

    impl ::fbthrift::GetTType for self::MountInodeInfo {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountInodeInfo
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountInodeInfo");
            p.write_field_begin("unloadedInodeCount", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.unloadedInodeCount, p);
            p.write_field_end();
            p.write_field_begin("loadedFileCount", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.loadedFileCount, p);
            p.write_field_end();
            p.write_field_begin("loadedTreeCount", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.loadedTreeCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountInodeInfo
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("loadedFileCount", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("loadedTreeCount", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("unloadedInodeCount", ::fbthrift::TType::I64, 2),
            ];
            let mut field_unloadedInodeCount = ::std::option::Option::None;
            let mut field_loadedFileCount = ::std::option::Option::None;
            let mut field_loadedTreeCount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 2) => field_unloadedInodeCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_loadedFileCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_loadedTreeCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                unloadedInodeCount: field_unloadedInodeCount.unwrap_or_default(),
                loadedFileCount: field_loadedFileCount.unwrap_or_default(),
                loadedTreeCount: field_loadedTreeCount.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::CacheStats {
        fn default() -> Self {
            Self {
                entryCount: ::std::default::Default::default(),
                totalSizeInBytes: ::std::default::Default::default(),
                hitCount: ::std::default::Default::default(),
                missCount: ::std::default::Default::default(),
                evictionCount: ::std::default::Default::default(),
                dropCount: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::CacheStats {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("CacheStats")
                .field("entryCount", &self.entryCount)
                .field("totalSizeInBytes", &self.totalSizeInBytes)
                .field("hitCount", &self.hitCount)
                .field("missCount", &self.missCount)
                .field("evictionCount", &self.evictionCount)
                .field("dropCount", &self.dropCount)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::CacheStats {}
    unsafe impl ::std::marker::Sync for self::CacheStats {}

    impl ::fbthrift::GetTType for self::CacheStats {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CacheStats
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CacheStats");
            p.write_field_begin("entryCount", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.entryCount, p);
            p.write_field_end();
            p.write_field_begin("totalSizeInBytes", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.totalSizeInBytes, p);
            p.write_field_end();
            p.write_field_begin("hitCount", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.hitCount, p);
            p.write_field_end();
            p.write_field_begin("missCount", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.missCount, p);
            p.write_field_end();
            p.write_field_begin("evictionCount", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.evictionCount, p);
            p.write_field_end();
            p.write_field_begin("dropCount", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.dropCount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CacheStats
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dropCount", ::fbthrift::TType::I64, 6),
                ::fbthrift::Field::new("entryCount", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("evictionCount", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("hitCount", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("missCount", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("totalSizeInBytes", ::fbthrift::TType::I64, 2),
            ];
            let mut field_entryCount = ::std::option::Option::None;
            let mut field_totalSizeInBytes = ::std::option::Option::None;
            let mut field_hitCount = ::std::option::Option::None;
            let mut field_missCount = ::std::option::Option::None;
            let mut field_evictionCount = ::std::option::Option::None;
            let mut field_dropCount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_entryCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_totalSizeInBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_hitCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_missCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_evictionCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_dropCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                entryCount: field_entryCount.unwrap_or_default(),
                totalSizeInBytes: field_totalSizeInBytes.unwrap_or_default(),
                hitCount: field_hitCount.unwrap_or_default(),
                missCount: field_missCount.unwrap_or_default(),
                evictionCount: field_evictionCount.unwrap_or_default(),
                dropCount: field_dropCount.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::InternalStats {
        fn default() -> Self {
            Self {
                periodicUnloadCount: ::std::option::Option::None,
                counters: ::std::option::Option::None,
                mountPointInfo: ::std::option::Option::None,
                smaps: ::std::option::Option::None,
                privateBytes: ::std::option::Option::None,
                vmRSSBytes: ::std::option::Option::None,
                blobCacheStats: ::std::option::Option::None,
                mountPointJournalInfo: ::std::option::Option::None,
                treeCacheStats: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::InternalStats {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("InternalStats")
                .field("periodicUnloadCount", &self.periodicUnloadCount)
                .field("counters", &self.counters)
                .field("mountPointInfo", &self.mountPointInfo)
                .field("smaps", &self.smaps)
                .field("privateBytes", &self.privateBytes)
                .field("vmRSSBytes", &self.vmRSSBytes)
                .field("blobCacheStats", &self.blobCacheStats)
                .field("mountPointJournalInfo", &self.mountPointJournalInfo)
                .field("treeCacheStats", &self.treeCacheStats)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::InternalStats {}
    unsafe impl ::std::marker::Sync for self::InternalStats {}

    impl ::fbthrift::GetTType for self::InternalStats {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::InternalStats
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("InternalStats");
            if let ::std::option::Option::Some(some) = &self.periodicUnloadCount {
                p.write_field_begin("periodicUnloadCount", ::fbthrift::TType::I64, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.counters {
                p.write_field_begin("counters", ::fbthrift::TType::Map, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.mountPointInfo {
                p.write_field_begin("mountPointInfo", ::fbthrift::TType::Map, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.smaps {
                p.write_field_begin("smaps", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.privateBytes {
                p.write_field_begin("privateBytes", ::fbthrift::TType::I64, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.vmRSSBytes {
                p.write_field_begin("vmRSSBytes", ::fbthrift::TType::I64, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.blobCacheStats {
                p.write_field_begin("blobCacheStats", ::fbthrift::TType::Struct, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.mountPointJournalInfo {
                p.write_field_begin("mountPointJournalInfo", ::fbthrift::TType::Map, 8);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.treeCacheStats {
                p.write_field_begin("treeCacheStats", ::fbthrift::TType::Struct, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::InternalStats
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("blobCacheStats", ::fbthrift::TType::Struct, 7),
                ::fbthrift::Field::new("counters", ::fbthrift::TType::Map, 2),
                ::fbthrift::Field::new("mountPointInfo", ::fbthrift::TType::Map, 3),
                ::fbthrift::Field::new("mountPointJournalInfo", ::fbthrift::TType::Map, 8),
                ::fbthrift::Field::new("periodicUnloadCount", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("privateBytes", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("smaps", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("treeCacheStats", ::fbthrift::TType::Struct, 9),
                ::fbthrift::Field::new("vmRSSBytes", ::fbthrift::TType::I64, 6),
            ];
            let mut field_periodicUnloadCount = ::std::option::Option::None;
            let mut field_counters = ::std::option::Option::None;
            let mut field_mountPointInfo = ::std::option::Option::None;
            let mut field_smaps = ::std::option::Option::None;
            let mut field_privateBytes = ::std::option::Option::None;
            let mut field_vmRSSBytes = ::std::option::Option::None;
            let mut field_blobCacheStats = ::std::option::Option::None;
            let mut field_mountPointJournalInfo = ::std::option::Option::None;
            let mut field_treeCacheStats = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_periodicUnloadCount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_counters = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 3) => field_mountPointInfo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_smaps = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_privateBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_vmRSSBytes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 7) => field_blobCacheStats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 8) => field_mountPointJournalInfo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 9) => field_treeCacheStats = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                periodicUnloadCount: field_periodicUnloadCount,
                counters: field_counters,
                mountPointInfo: field_mountPointInfo,
                smaps: field_smaps,
                privateBytes: field_privateBytes,
                vmRSSBytes: field_vmRSSBytes,
                blobCacheStats: field_blobCacheStats,
                mountPointJournalInfo: field_mountPointJournalInfo,
                treeCacheStats: field_treeCacheStats,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::FuseCall {
        fn default() -> Self {
            Self {
                opcode: ::std::default::Default::default(),
                unique: ::std::default::Default::default(),
                nodeid: ::std::default::Default::default(),
                uid: ::std::default::Default::default(),
                gid: ::std::default::Default::default(),
                pid: ::std::default::Default::default(),
                opcodeName: ::std::default::Default::default(),
                processName: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::FuseCall {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("FuseCall")
                .field("opcode", &self.opcode)
                .field("unique", &self.unique)
                .field("nodeid", &self.nodeid)
                .field("uid", &self.uid)
                .field("gid", &self.gid)
                .field("pid", &self.pid)
                .field("opcodeName", &self.opcodeName)
                .field("processName", &self.processName)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::FuseCall {}
    unsafe impl ::std::marker::Sync for self::FuseCall {}

    impl ::fbthrift::GetTType for self::FuseCall {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FuseCall
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FuseCall");
            p.write_field_begin("opcode", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.opcode, p);
            p.write_field_end();
            p.write_field_begin("unique", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.unique, p);
            p.write_field_end();
            p.write_field_begin("nodeid", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.nodeid, p);
            p.write_field_end();
            p.write_field_begin("uid", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(&self.uid, p);
            p.write_field_end();
            p.write_field_begin("gid", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.gid, p);
            p.write_field_end();
            p.write_field_begin("pid", ::fbthrift::TType::I32, 7);
            ::fbthrift::Serialize::write(&self.pid, p);
            p.write_field_end();
            p.write_field_begin("opcodeName", ::fbthrift::TType::String, 8);
            ::fbthrift::Serialize::write(&self.opcodeName, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.processName {
                p.write_field_begin("processName", ::fbthrift::TType::String, 9);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FuseCall
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("gid", ::fbthrift::TType::I32, 6),
                ::fbthrift::Field::new("nodeid", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("opcode", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("opcodeName", ::fbthrift::TType::String, 8),
                ::fbthrift::Field::new("pid", ::fbthrift::TType::I32, 7),
                ::fbthrift::Field::new("processName", ::fbthrift::TType::String, 9),
                ::fbthrift::Field::new("uid", ::fbthrift::TType::I32, 5),
                ::fbthrift::Field::new("unique", ::fbthrift::TType::I64, 3),
            ];
            let mut field_opcode = ::std::option::Option::None;
            let mut field_unique = ::std::option::Option::None;
            let mut field_nodeid = ::std::option::Option::None;
            let mut field_uid = ::std::option::Option::None;
            let mut field_gid = ::std::option::Option::None;
            let mut field_pid = ::std::option::Option::None;
            let mut field_opcodeName = ::std::option::Option::None;
            let mut field_processName = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 2) => field_opcode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_unique = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_nodeid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_uid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_gid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 7) => field_pid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 8) => field_opcodeName = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 9) => field_processName = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                opcode: field_opcode.unwrap_or_default(),
                unique: field_unique.unwrap_or_default(),
                nodeid: field_nodeid.unwrap_or_default(),
                uid: field_uid.unwrap_or_default(),
                gid: field_gid.unwrap_or_default(),
                pid: field_pid.unwrap_or_default(),
                opcodeName: field_opcodeName.unwrap_or_default(),
                processName: field_processName,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::NfsCall {
        fn default() -> Self {
            Self {
                xid: ::std::default::Default::default(),
                procNumber: ::std::default::Default::default(),
                procName: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::NfsCall {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("NfsCall")
                .field("xid", &self.xid)
                .field("procNumber", &self.procNumber)
                .field("procName", &self.procName)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::NfsCall {}
    unsafe impl ::std::marker::Sync for self::NfsCall {}

    impl ::fbthrift::GetTType for self::NfsCall {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::NfsCall
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("NfsCall");
            p.write_field_begin("xid", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.xid, p);
            p.write_field_end();
            p.write_field_begin("procNumber", ::fbthrift::TType::I32, 2);
            ::fbthrift::Serialize::write(&self.procNumber, p);
            p.write_field_end();
            p.write_field_begin("procName", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.procName, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::NfsCall
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("procName", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("procNumber", ::fbthrift::TType::I32, 2),
                ::fbthrift::Field::new("xid", ::fbthrift::TType::I32, 1),
            ];
            let mut field_xid = ::std::option::Option::None;
            let mut field_procNumber = ::std::option::Option::None;
            let mut field_procName = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_xid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 2) => field_procNumber = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_procName = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                xid: field_xid.unwrap_or_default(),
                procNumber: field_procNumber.unwrap_or_default(),
                procName: field_procName.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetConfigParams {
        fn default() -> Self {
            Self {
                reload: eden_config::types::ConfigReloadBehavior::AutoReload,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetConfigParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetConfigParams")
                .field("reload", &self.reload)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetConfigParams {}
    unsafe impl ::std::marker::Sync for self::GetConfigParams {}

    impl ::fbthrift::GetTType for self::GetConfigParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetConfigParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetConfigParams");
            p.write_field_begin("reload", ::fbthrift::TType::I32, 1);
            ::fbthrift::Serialize::write(&self.reload, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetConfigParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("reload", ::fbthrift::TType::I32, 1),
            ];
            let mut field_reload = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_reload = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                reload: field_reload.unwrap_or_else(|| eden_config::types::ConfigReloadBehavior::AutoReload),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetStatInfoParams {
        fn default() -> Self {
            Self {
                statsMask: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetStatInfoParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetStatInfoParams")
                .field("statsMask", &self.statsMask)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetStatInfoParams {}
    unsafe impl ::std::marker::Sync for self::GetStatInfoParams {}

    impl ::fbthrift::GetTType for self::GetStatInfoParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetStatInfoParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetStatInfoParams");
            p.write_field_begin("statsMask", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.statsMask, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetStatInfoParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("statsMask", ::fbthrift::TType::I64, 1),
            ];
            let mut field_statsMask = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_statsMask = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                statsMask: field_statsMask.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::PredictiveFetch {
        fn default() -> Self {
            Self {
                numTopDirectories: ::std::option::Option::None,
                user: ::std::option::Option::None,
                repo: ::std::option::Option::None,
                os: ::std::option::Option::None,
                startTime: ::std::option::Option::None,
                endTime: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::PredictiveFetch {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("PredictiveFetch")
                .field("numTopDirectories", &self.numTopDirectories)
                .field("user", &self.user)
                .field("repo", &self.repo)
                .field("os", &self.os)
                .field("startTime", &self.startTime)
                .field("endTime", &self.endTime)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::PredictiveFetch {}
    unsafe impl ::std::marker::Sync for self::PredictiveFetch {}

    impl ::fbthrift::GetTType for self::PredictiveFetch {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::PredictiveFetch
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("PredictiveFetch");
            if let ::std::option::Option::Some(some) = &self.numTopDirectories {
                p.write_field_begin("numTopDirectories", ::fbthrift::TType::I32, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.user {
                p.write_field_begin("user", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.repo {
                p.write_field_begin("repo", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.os {
                p.write_field_begin("os", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.startTime {
                p.write_field_begin("startTime", ::fbthrift::TType::I64, 5);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.endTime {
                p.write_field_begin("endTime", ::fbthrift::TType::I64, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::PredictiveFetch
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("endTime", ::fbthrift::TType::I64, 6),
                ::fbthrift::Field::new("numTopDirectories", ::fbthrift::TType::I32, 1),
                ::fbthrift::Field::new("os", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("repo", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("startTime", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("user", ::fbthrift::TType::String, 2),
            ];
            let mut field_numTopDirectories = ::std::option::Option::None;
            let mut field_user = ::std::option::Option::None;
            let mut field_repo = ::std::option::Option::None;
            let mut field_os = ::std::option::Option::None;
            let mut field_startTime = ::std::option::Option::None;
            let mut field_endTime = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I32, 1) => field_numTopDirectories = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_user = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_repo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_os = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_startTime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_endTime = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                numTopDirectories: field_numTopDirectories,
                user: field_user,
                repo: field_repo,
                os: field_os,
                startTime: field_startTime,
                endTime: field_endTime,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GlobParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                globs: ::std::default::Default::default(),
                includeDotfiles: ::std::default::Default::default(),
                prefetchFiles: ::std::default::Default::default(),
                suppressFileList: ::std::default::Default::default(),
                wantDtype: ::std::default::Default::default(),
                revisions: ::std::default::Default::default(),
                prefetchMetadata: true,
                searchRoot: ::std::default::Default::default(),
                background: false,
                predictiveGlob: ::std::option::Option::None,
                listOnlyFiles: false,
                sync: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GlobParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GlobParams")
                .field("mountPoint", &self.mountPoint)
                .field("globs", &self.globs)
                .field("includeDotfiles", &self.includeDotfiles)
                .field("prefetchFiles", &self.prefetchFiles)
                .field("suppressFileList", &self.suppressFileList)
                .field("wantDtype", &self.wantDtype)
                .field("revisions", &self.revisions)
                .field("prefetchMetadata", &self.prefetchMetadata)
                .field("searchRoot", &self.searchRoot)
                .field("background", &self.background)
                .field("predictiveGlob", &self.predictiveGlob)
                .field("listOnlyFiles", &self.listOnlyFiles)
                .field("sync", &self.sync)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GlobParams {}
    unsafe impl ::std::marker::Sync for self::GlobParams {}

    impl ::fbthrift::GetTType for self::GlobParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GlobParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GlobParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("globs", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.globs, p);
            p.write_field_end();
            p.write_field_begin("includeDotfiles", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.includeDotfiles, p);
            p.write_field_end();
            p.write_field_begin("prefetchFiles", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.prefetchFiles, p);
            p.write_field_end();
            p.write_field_begin("suppressFileList", ::fbthrift::TType::Bool, 5);
            ::fbthrift::Serialize::write(&self.suppressFileList, p);
            p.write_field_end();
            p.write_field_begin("wantDtype", ::fbthrift::TType::Bool, 6);
            ::fbthrift::Serialize::write(&self.wantDtype, p);
            p.write_field_end();
            p.write_field_begin("revisions", ::fbthrift::TType::List, 7);
            ::fbthrift::Serialize::write(&self.revisions, p);
            p.write_field_end();
            p.write_field_begin("prefetchMetadata", ::fbthrift::TType::Bool, 8);
            ::fbthrift::Serialize::write(&self.prefetchMetadata, p);
            p.write_field_end();
            p.write_field_begin("searchRoot", ::fbthrift::TType::String, 9);
            ::fbthrift::Serialize::write(&self.searchRoot, p);
            p.write_field_end();
            p.write_field_begin("background", ::fbthrift::TType::Bool, 10);
            ::fbthrift::Serialize::write(&self.background, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.predictiveGlob {
                p.write_field_begin("predictiveGlob", ::fbthrift::TType::Struct, 11);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_begin("listOnlyFiles", ::fbthrift::TType::Bool, 12);
            ::fbthrift::Serialize::write(&self.listOnlyFiles, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 13);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GlobParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("background", ::fbthrift::TType::Bool, 10),
                ::fbthrift::Field::new("globs", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("includeDotfiles", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("listOnlyFiles", ::fbthrift::TType::Bool, 12),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("predictiveGlob", ::fbthrift::TType::Struct, 11),
                ::fbthrift::Field::new("prefetchFiles", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("prefetchMetadata", ::fbthrift::TType::Bool, 8),
                ::fbthrift::Field::new("revisions", ::fbthrift::TType::List, 7),
                ::fbthrift::Field::new("searchRoot", ::fbthrift::TType::String, 9),
                ::fbthrift::Field::new("suppressFileList", ::fbthrift::TType::Bool, 5),
                ::fbthrift::Field::new("sync", ::fbthrift::TType::Struct, 13),
                ::fbthrift::Field::new("wantDtype", ::fbthrift::TType::Bool, 6),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_globs = ::std::option::Option::None;
            let mut field_includeDotfiles = ::std::option::Option::None;
            let mut field_prefetchFiles = ::std::option::Option::None;
            let mut field_suppressFileList = ::std::option::Option::None;
            let mut field_wantDtype = ::std::option::Option::None;
            let mut field_revisions = ::std::option::Option::None;
            let mut field_prefetchMetadata = ::std::option::Option::None;
            let mut field_searchRoot = ::std::option::Option::None;
            let mut field_background = ::std::option::Option::None;
            let mut field_predictiveGlob = ::std::option::Option::None;
            let mut field_listOnlyFiles = ::std::option::Option::None;
            let mut field_sync = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_globs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_includeDotfiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_prefetchFiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 5) => field_suppressFileList = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 6) => field_wantDtype = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 7) => field_revisions = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 8) => field_prefetchMetadata = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 9) => field_searchRoot = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 10) => field_background = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 11) => field_predictiveGlob = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 12) => field_listOnlyFiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Struct, 13) => field_sync = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                globs: field_globs.unwrap_or_default(),
                includeDotfiles: field_includeDotfiles.unwrap_or_default(),
                prefetchFiles: field_prefetchFiles.unwrap_or_default(),
                suppressFileList: field_suppressFileList.unwrap_or_default(),
                wantDtype: field_wantDtype.unwrap_or_default(),
                revisions: field_revisions.unwrap_or_default(),
                prefetchMetadata: field_prefetchMetadata.unwrap_or_else(|| true),
                searchRoot: field_searchRoot.unwrap_or_default(),
                background: field_background.unwrap_or_else(|| false),
                predictiveGlob: field_predictiveGlob,
                listOnlyFiles: field_listOnlyFiles.unwrap_or_else(|| false),
                sync: field_sync.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::Glob {
        fn default() -> Self {
            Self {
                matchingFiles: ::std::default::Default::default(),
                dtypes: ::std::default::Default::default(),
                originHashes: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::Glob {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("Glob")
                .field("matchingFiles", &self.matchingFiles)
                .field("dtypes", &self.dtypes)
                .field("originHashes", &self.originHashes)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::Glob {}
    unsafe impl ::std::marker::Sync for self::Glob {}

    impl ::fbthrift::GetTType for self::Glob {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::Glob
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("Glob");
            p.write_field_begin("matchingFiles", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.matchingFiles, p);
            p.write_field_end();
            p.write_field_begin("dtypes", ::fbthrift::TType::List, 2);
            ::fbthrift::Serialize::write(&self.dtypes, p);
            p.write_field_end();
            p.write_field_begin("originHashes", ::fbthrift::TType::List, 3);
            ::fbthrift::Serialize::write(&self.originHashes, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::Glob
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("dtypes", ::fbthrift::TType::List, 2),
                ::fbthrift::Field::new("matchingFiles", ::fbthrift::TType::List, 1),
                ::fbthrift::Field::new("originHashes", ::fbthrift::TType::List, 3),
            ];
            let mut field_matchingFiles = ::std::option::Option::None;
            let mut field_dtypes = ::std::option::Option::None;
            let mut field_originHashes = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_matchingFiles = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 2) => field_dtypes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::List, 3) => field_originHashes = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                matchingFiles: field_matchingFiles.unwrap_or_default(),
                dtypes: field_dtypes.unwrap_or_default(),
                originHashes: field_originHashes.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::AccessCounts {
        fn default() -> Self {
            Self {
                fsChannelTotal: ::std::default::Default::default(),
                fsChannelReads: ::std::default::Default::default(),
                fsChannelWrites: ::std::default::Default::default(),
                fsChannelBackingStoreImports: ::std::default::Default::default(),
                fsChannelDurationNs: ::std::default::Default::default(),
                fsChannelMemoryCacheImports: ::std::default::Default::default(),
                fsChannelDiskCacheImports: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::AccessCounts {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("AccessCounts")
                .field("fsChannelTotal", &self.fsChannelTotal)
                .field("fsChannelReads", &self.fsChannelReads)
                .field("fsChannelWrites", &self.fsChannelWrites)
                .field("fsChannelBackingStoreImports", &self.fsChannelBackingStoreImports)
                .field("fsChannelDurationNs", &self.fsChannelDurationNs)
                .field("fsChannelMemoryCacheImports", &self.fsChannelMemoryCacheImports)
                .field("fsChannelDiskCacheImports", &self.fsChannelDiskCacheImports)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::AccessCounts {}
    unsafe impl ::std::marker::Sync for self::AccessCounts {}

    impl ::fbthrift::GetTType for self::AccessCounts {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::AccessCounts
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("AccessCounts");
            p.write_field_begin("fsChannelTotal", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.fsChannelTotal, p);
            p.write_field_end();
            p.write_field_begin("fsChannelReads", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.fsChannelReads, p);
            p.write_field_end();
            p.write_field_begin("fsChannelWrites", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.fsChannelWrites, p);
            p.write_field_end();
            p.write_field_begin("fsChannelBackingStoreImports", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.fsChannelBackingStoreImports, p);
            p.write_field_end();
            p.write_field_begin("fsChannelDurationNs", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.fsChannelDurationNs, p);
            p.write_field_end();
            p.write_field_begin("fsChannelMemoryCacheImports", ::fbthrift::TType::I64, 6);
            ::fbthrift::Serialize::write(&self.fsChannelMemoryCacheImports, p);
            p.write_field_end();
            p.write_field_begin("fsChannelDiskCacheImports", ::fbthrift::TType::I64, 7);
            ::fbthrift::Serialize::write(&self.fsChannelDiskCacheImports, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::AccessCounts
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("fsChannelBackingStoreImports", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("fsChannelDiskCacheImports", ::fbthrift::TType::I64, 7),
                ::fbthrift::Field::new("fsChannelDurationNs", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("fsChannelMemoryCacheImports", ::fbthrift::TType::I64, 6),
                ::fbthrift::Field::new("fsChannelReads", ::fbthrift::TType::I64, 2),
                ::fbthrift::Field::new("fsChannelTotal", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("fsChannelWrites", ::fbthrift::TType::I64, 3),
            ];
            let mut field_fsChannelTotal = ::std::option::Option::None;
            let mut field_fsChannelReads = ::std::option::Option::None;
            let mut field_fsChannelWrites = ::std::option::Option::None;
            let mut field_fsChannelBackingStoreImports = ::std::option::Option::None;
            let mut field_fsChannelDurationNs = ::std::option::Option::None;
            let mut field_fsChannelMemoryCacheImports = ::std::option::Option::None;
            let mut field_fsChannelDiskCacheImports = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_fsChannelTotal = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_fsChannelReads = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_fsChannelWrites = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_fsChannelBackingStoreImports = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_fsChannelDurationNs = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 6) => field_fsChannelMemoryCacheImports = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 7) => field_fsChannelDiskCacheImports = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                fsChannelTotal: field_fsChannelTotal.unwrap_or_default(),
                fsChannelReads: field_fsChannelReads.unwrap_or_default(),
                fsChannelWrites: field_fsChannelWrites.unwrap_or_default(),
                fsChannelBackingStoreImports: field_fsChannelBackingStoreImports.unwrap_or_default(),
                fsChannelDurationNs: field_fsChannelDurationNs.unwrap_or_default(),
                fsChannelMemoryCacheImports: field_fsChannelMemoryCacheImports.unwrap_or_default(),
                fsChannelDiskCacheImports: field_fsChannelDiskCacheImports.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::MountAccesses {
        fn default() -> Self {
            Self {
                accessCountsByPid: ::std::default::Default::default(),
                fetchCountsByPid: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::MountAccesses {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("MountAccesses")
                .field("accessCountsByPid", &self.accessCountsByPid)
                .field("fetchCountsByPid", &self.fetchCountsByPid)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::MountAccesses {}
    unsafe impl ::std::marker::Sync for self::MountAccesses {}

    impl ::fbthrift::GetTType for self::MountAccesses {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::MountAccesses
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("MountAccesses");
            p.write_field_begin("accessCountsByPid", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.accessCountsByPid, p);
            p.write_field_end();
            p.write_field_begin("fetchCountsByPid", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.fetchCountsByPid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::MountAccesses
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("accessCountsByPid", ::fbthrift::TType::Map, 1),
                ::fbthrift::Field::new("fetchCountsByPid", ::fbthrift::TType::Map, 2),
            ];
            let mut field_accessCountsByPid = ::std::option::Option::None;
            let mut field_fetchCountsByPid = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_accessCountsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_fetchCountsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                accessCountsByPid: field_accessCountsByPid.unwrap_or_default(),
                fetchCountsByPid: field_fetchCountsByPid.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetAccessCountsResult {
        fn default() -> Self {
            Self {
                cmdsByPid: ::std::default::Default::default(),
                accessesByMount: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetAccessCountsResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetAccessCountsResult")
                .field("cmdsByPid", &self.cmdsByPid)
                .field("accessesByMount", &self.accessesByMount)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetAccessCountsResult {}
    unsafe impl ::std::marker::Sync for self::GetAccessCountsResult {}

    impl ::fbthrift::GetTType for self::GetAccessCountsResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetAccessCountsResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetAccessCountsResult");
            p.write_field_begin("cmdsByPid", ::fbthrift::TType::Map, 1);
            ::fbthrift::Serialize::write(&self.cmdsByPid, p);
            p.write_field_end();
            p.write_field_begin("accessesByMount", ::fbthrift::TType::Map, 2);
            ::fbthrift::Serialize::write(&self.accessesByMount, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetAccessCountsResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("accessesByMount", ::fbthrift::TType::Map, 2),
                ::fbthrift::Field::new("cmdsByPid", ::fbthrift::TType::Map, 1),
            ];
            let mut field_cmdsByPid = ::std::option::Option::None;
            let mut field_accessesByMount = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Map, 1) => field_cmdsByPid = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 2) => field_accessesByMount = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                cmdsByPid: field_cmdsByPid.unwrap_or_default(),
                accessesByMount: field_accessesByMount.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::TracePoint {
        fn default() -> Self {
            Self {
                timestamp: ::std::default::Default::default(),
                traceId: ::std::default::Default::default(),
                blockId: ::std::default::Default::default(),
                parentBlockId: ::std::default::Default::default(),
                name: ::std::string::String::new(),
                event: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::TracePoint {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("TracePoint")
                .field("timestamp", &self.timestamp)
                .field("traceId", &self.traceId)
                .field("blockId", &self.blockId)
                .field("parentBlockId", &self.parentBlockId)
                .field("name", &self.name)
                .field("event", &self.event)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::TracePoint {}
    unsafe impl ::std::marker::Sync for self::TracePoint {}

    impl ::fbthrift::GetTType for self::TracePoint {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::TracePoint
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("TracePoint");
            p.write_field_begin("timestamp", ::fbthrift::TType::I64, 1);
            ::fbthrift::Serialize::write(&self.timestamp, p);
            p.write_field_end();
            p.write_field_begin("traceId", ::fbthrift::TType::I64, 2);
            ::fbthrift::Serialize::write(&self.traceId, p);
            p.write_field_end();
            p.write_field_begin("blockId", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.blockId, p);
            p.write_field_end();
            p.write_field_begin("parentBlockId", ::fbthrift::TType::I64, 4);
            ::fbthrift::Serialize::write(&self.parentBlockId, p);
            p.write_field_end();
            p.write_field_begin("name", ::fbthrift::TType::String, 5);
            ::fbthrift::Serialize::write(&self.name, p);
            p.write_field_end();
            p.write_field_begin("event", ::fbthrift::TType::I32, 6);
            ::fbthrift::Serialize::write(&self.event, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::TracePoint
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("blockId", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("event", ::fbthrift::TType::I32, 6),
                ::fbthrift::Field::new("name", ::fbthrift::TType::String, 5),
                ::fbthrift::Field::new("parentBlockId", ::fbthrift::TType::I64, 4),
                ::fbthrift::Field::new("timestamp", ::fbthrift::TType::I64, 1),
                ::fbthrift::Field::new("traceId", ::fbthrift::TType::I64, 2),
            ];
            let mut field_timestamp = ::std::option::Option::None;
            let mut field_traceId = ::std::option::Option::None;
            let mut field_blockId = ::std::option::Option::None;
            let mut field_parentBlockId = ::std::option::Option::None;
            let mut field_name = ::std::option::Option::None;
            let mut field_event = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::I64, 1) => field_timestamp = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 2) => field_traceId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_blockId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 4) => field_parentBlockId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 5) => field_name = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 6) => field_event = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                timestamp: field_timestamp.unwrap_or_default(),
                traceId: field_traceId.unwrap_or_default(),
                blockId: field_blockId.unwrap_or_default(),
                parentBlockId: field_parentBlockId.unwrap_or_default(),
                name: field_name.unwrap_or_else(|| ::std::string::String::new()),
                event: field_event.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::FaultDefinition {
        fn default() -> Self {
            Self {
                keyClass: ::std::default::Default::default(),
                keyValueRegex: ::std::default::Default::default(),
                count: ::std::default::Default::default(),
                block: ::std::default::Default::default(),
                delayMilliseconds: ::std::default::Default::default(),
                errorType: ::std::option::Option::None,
                errorMessage: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::FaultDefinition {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("FaultDefinition")
                .field("keyClass", &self.keyClass)
                .field("keyValueRegex", &self.keyValueRegex)
                .field("count", &self.count)
                .field("block", &self.block)
                .field("delayMilliseconds", &self.delayMilliseconds)
                .field("errorType", &self.errorType)
                .field("errorMessage", &self.errorMessage)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::FaultDefinition {}
    unsafe impl ::std::marker::Sync for self::FaultDefinition {}

    impl ::fbthrift::GetTType for self::FaultDefinition {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::FaultDefinition
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("FaultDefinition");
            p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_begin("count", ::fbthrift::TType::I64, 3);
            ::fbthrift::Serialize::write(&self.count, p);
            p.write_field_end();
            p.write_field_begin("block", ::fbthrift::TType::Bool, 4);
            ::fbthrift::Serialize::write(&self.block, p);
            p.write_field_end();
            p.write_field_begin("delayMilliseconds", ::fbthrift::TType::I64, 5);
            ::fbthrift::Serialize::write(&self.delayMilliseconds, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.errorType {
                p.write_field_begin("errorType", ::fbthrift::TType::String, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", ::fbthrift::TType::String, 7);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::FaultDefinition
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("block", ::fbthrift::TType::Bool, 4),
                ::fbthrift::Field::new("count", ::fbthrift::TType::I64, 3),
                ::fbthrift::Field::new("delayMilliseconds", ::fbthrift::TType::I64, 5),
                ::fbthrift::Field::new("errorMessage", ::fbthrift::TType::String, 7),
                ::fbthrift::Field::new("errorType", ::fbthrift::TType::String, 6),
                ::fbthrift::Field::new("keyClass", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("keyValueRegex", ::fbthrift::TType::String, 2),
            ];
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let mut field_count = ::std::option::Option::None;
            let mut field_block = ::std::option::Option::None;
            let mut field_delayMilliseconds = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let mut field_errorMessage = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 3) => field_count = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 4) => field_block = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I64, 5) => field_delayMilliseconds = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 6) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 7) => field_errorMessage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
                count: field_count.unwrap_or_default(),
                block: field_block.unwrap_or_default(),
                delayMilliseconds: field_delayMilliseconds.unwrap_or_default(),
                errorType: field_errorType,
                errorMessage: field_errorMessage,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::RemoveFaultArg {
        fn default() -> Self {
            Self {
                keyClass: ::std::default::Default::default(),
                keyValueRegex: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::RemoveFaultArg {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("RemoveFaultArg")
                .field("keyClass", &self.keyClass)
                .field("keyValueRegex", &self.keyValueRegex)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::RemoveFaultArg {}
    unsafe impl ::std::marker::Sync for self::RemoveFaultArg {}

    impl ::fbthrift::GetTType for self::RemoveFaultArg {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::RemoveFaultArg
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("RemoveFaultArg");
            p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.keyClass, p);
            p.write_field_end();
            p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.keyValueRegex, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::RemoveFaultArg
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("keyClass", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("keyValueRegex", ::fbthrift::TType::String, 2),
            ];
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass.unwrap_or_default(),
                keyValueRegex: field_keyValueRegex.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::UnblockFaultArg {
        fn default() -> Self {
            Self {
                keyClass: ::std::option::Option::None,
                keyValueRegex: ::std::option::Option::None,
                errorType: ::std::option::Option::None,
                errorMessage: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::UnblockFaultArg {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("UnblockFaultArg")
                .field("keyClass", &self.keyClass)
                .field("keyValueRegex", &self.keyValueRegex)
                .field("errorType", &self.errorType)
                .field("errorMessage", &self.errorMessage)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::UnblockFaultArg {}
    unsafe impl ::std::marker::Sync for self::UnblockFaultArg {}

    impl ::fbthrift::GetTType for self::UnblockFaultArg {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::UnblockFaultArg
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("UnblockFaultArg");
            if let ::std::option::Option::Some(some) = &self.keyClass {
                p.write_field_begin("keyClass", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.keyValueRegex {
                p.write_field_begin("keyValueRegex", ::fbthrift::TType::String, 2);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorType {
                p.write_field_begin("errorType", ::fbthrift::TType::String, 3);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            if let ::std::option::Option::Some(some) = &self.errorMessage {
                p.write_field_begin("errorMessage", ::fbthrift::TType::String, 4);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::UnblockFaultArg
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("errorMessage", ::fbthrift::TType::String, 4),
                ::fbthrift::Field::new("errorType", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("keyClass", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("keyValueRegex", ::fbthrift::TType::String, 2),
            ];
            let mut field_keyClass = ::std::option::Option::None;
            let mut field_keyValueRegex = ::std::option::Option::None;
            let mut field_errorType = ::std::option::Option::None;
            let mut field_errorMessage = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_keyClass = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_keyValueRegex = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_errorType = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 4) => field_errorMessage = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                keyClass: field_keyClass,
                keyValueRegex: field_keyValueRegex,
                errorType: field_errorType,
                errorMessage: field_errorMessage,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetScmStatusResult {
        fn default() -> Self {
            Self {
                status: ::std::default::Default::default(),
                version: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetScmStatusResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetScmStatusResult")
                .field("status", &self.status)
                .field("version", &self.version)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetScmStatusResult {}
    unsafe impl ::std::marker::Sync for self::GetScmStatusResult {}

    impl ::fbthrift::GetTType for self::GetScmStatusResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetScmStatusResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusResult");
            p.write_field_begin("status", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.status, p);
            p.write_field_end();
            p.write_field_begin("version", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.version, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetScmStatusResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("status", ::fbthrift::TType::Struct, 1),
                ::fbthrift::Field::new("version", ::fbthrift::TType::String, 2),
            ];
            let mut field_status = ::std::option::Option::None;
            let mut field_version = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_status = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_version = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                status: field_status.unwrap_or_default(),
                version: field_version.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::GetScmStatusParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                commit: ::std::default::Default::default(),
                listIgnored: false,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::GetScmStatusParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("GetScmStatusParams")
                .field("mountPoint", &self.mountPoint)
                .field("commit", &self.commit)
                .field("listIgnored", &self.listIgnored)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::GetScmStatusParams {}
    unsafe impl ::std::marker::Sync for self::GetScmStatusParams {}

    impl ::fbthrift::GetTType for self::GetScmStatusParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::GetScmStatusParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("GetScmStatusParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("commit", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.commit, p);
            p.write_field_end();
            p.write_field_begin("listIgnored", ::fbthrift::TType::Bool, 3);
            ::fbthrift::Serialize::write(&self.listIgnored, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::GetScmStatusParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("commit", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("listIgnored", ::fbthrift::TType::Bool, 3),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_commit = ::std::option::Option::None;
            let mut field_listIgnored = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_commit = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Bool, 3) => field_listIgnored = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                commit: field_commit.unwrap_or_default(),
                listIgnored: field_listIgnored.unwrap_or_else(|| false),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SetPathObjectIdParams {
        fn default() -> Self {
            Self {
                mountPoint: ::std::default::Default::default(),
                path: ::std::default::Default::default(),
                objectId: ::std::default::Default::default(),
                r#type: ::std::default::Default::default(),
                mode: ::std::default::Default::default(),
                requestInfo: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SetPathObjectIdParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SetPathObjectIdParams")
                .field("mountPoint", &self.mountPoint)
                .field("path", &self.path)
                .field("objectId", &self.objectId)
                .field("r#type", &self.r#type)
                .field("mode", &self.mode)
                .field("requestInfo", &self.requestInfo)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SetPathObjectIdParams {}
    unsafe impl ::std::marker::Sync for self::SetPathObjectIdParams {}

    impl ::fbthrift::GetTType for self::SetPathObjectIdParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetPathObjectIdParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetPathObjectIdParams");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("objectId", ::fbthrift::TType::String, 3);
            ::fbthrift::Serialize::write(&self.objectId, p);
            p.write_field_end();
            p.write_field_begin("type", ::fbthrift::TType::I32, 4);
            ::fbthrift::Serialize::write(&self.r#type, p);
            p.write_field_end();
            p.write_field_begin("mode", ::fbthrift::TType::I32, 5);
            ::fbthrift::Serialize::write(&self.mode, p);
            p.write_field_end();
            if let ::std::option::Option::Some(some) = &self.requestInfo {
                p.write_field_begin("requestInfo", ::fbthrift::TType::Map, 6);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetPathObjectIdParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("mode", ::fbthrift::TType::I32, 5),
                ::fbthrift::Field::new("mountPoint", ::fbthrift::TType::String, 1),
                ::fbthrift::Field::new("objectId", ::fbthrift::TType::String, 3),
                ::fbthrift::Field::new("path", ::fbthrift::TType::String, 2),
                ::fbthrift::Field::new("requestInfo", ::fbthrift::TType::Map, 6),
                ::fbthrift::Field::new("type", ::fbthrift::TType::I32, 4),
            ];
            let mut field_mountPoint = ::std::option::Option::None;
            let mut field_path = ::std::option::Option::None;
            let mut field_objectId = ::std::option::Option::None;
            let mut field_type = ::std::option::Option::None;
            let mut field_mode = ::std::option::Option::None;
            let mut field_requestInfo = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_mountPoint = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 2) => field_path = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::String, 3) => field_objectId = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 4) => field_type = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::I32, 5) => field_mode = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (::fbthrift::TType::Map, 6) => field_requestInfo = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                mountPoint: field_mountPoint.unwrap_or_default(),
                path: field_path.unwrap_or_default(),
                objectId: field_objectId.unwrap_or_default(),
                r#type: field_type.unwrap_or_default(),
                mode: field_mode.unwrap_or_default(),
                requestInfo: field_requestInfo,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SetPathObjectIdResult {
        fn default() -> Self {
            Self {
                conflicts: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SetPathObjectIdResult {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SetPathObjectIdResult")
                .field("conflicts", &self.conflicts)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SetPathObjectIdResult {}
    unsafe impl ::std::marker::Sync for self::SetPathObjectIdResult {}

    impl ::fbthrift::GetTType for self::SetPathObjectIdResult {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SetPathObjectIdResult
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SetPathObjectIdResult");
            p.write_field_begin("conflicts", ::fbthrift::TType::List, 1);
            ::fbthrift::Serialize::write(&self.conflicts, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SetPathObjectIdResult
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("conflicts", ::fbthrift::TType::List, 1),
            ];
            let mut field_conflicts = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::List, 1) => field_conflicts = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                conflicts: field_conflicts.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::CheckOutRevisionParams {
        fn default() -> Self {
            Self {
                hgRootManifest: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::CheckOutRevisionParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("CheckOutRevisionParams")
                .field("hgRootManifest", &self.hgRootManifest)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::CheckOutRevisionParams {}
    unsafe impl ::std::marker::Sync for self::CheckOutRevisionParams {}

    impl ::fbthrift::GetTType for self::CheckOutRevisionParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::CheckOutRevisionParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("CheckOutRevisionParams");
            if let ::std::option::Option::Some(some) = &self.hgRootManifest {
                p.write_field_begin("hgRootManifest", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::CheckOutRevisionParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hgRootManifest", ::fbthrift::TType::String, 1),
            ];
            let mut field_hgRootManifest = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_hgRootManifest = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hgRootManifest: field_hgRootManifest,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::ResetParentCommitsParams {
        fn default() -> Self {
            Self {
                hgRootManifest: ::std::option::Option::None,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::ResetParentCommitsParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("ResetParentCommitsParams")
                .field("hgRootManifest", &self.hgRootManifest)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::ResetParentCommitsParams {}
    unsafe impl ::std::marker::Sync for self::ResetParentCommitsParams {}

    impl ::fbthrift::GetTType for self::ResetParentCommitsParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::ResetParentCommitsParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ResetParentCommitsParams");
            if let ::std::option::Option::Some(some) = &self.hgRootManifest {
                p.write_field_begin("hgRootManifest", ::fbthrift::TType::String, 1);
                ::fbthrift::Serialize::write(some, p);
                p.write_field_end();
            }
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::ResetParentCommitsParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("hgRootManifest", ::fbthrift::TType::String, 1),
            ];
            let mut field_hgRootManifest = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::String, 1) => field_hgRootManifest = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                hgRootManifest: field_hgRootManifest,
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    impl ::std::default::Default for self::SynchronizeWorkingCopyParams {
        fn default() -> Self {
            Self {
                sync: ::std::default::Default::default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            }
        }
    }

    impl ::std::fmt::Debug for self::SynchronizeWorkingCopyParams {
        fn fmt(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            formatter
                .debug_struct("SynchronizeWorkingCopyParams")
                .field("sync", &self.sync)
                .finish()
        }
    }

    unsafe impl ::std::marker::Send for self::SynchronizeWorkingCopyParams {}
    unsafe impl ::std::marker::Sync for self::SynchronizeWorkingCopyParams {}

    impl ::fbthrift::GetTType for self::SynchronizeWorkingCopyParams {
        const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
    }

    impl<P> ::fbthrift::Serialize<P> for self::SynchronizeWorkingCopyParams
    where
        P: ::fbthrift::ProtocolWriter,
    {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("SynchronizeWorkingCopyParams");
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 1);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P> ::fbthrift::Deserialize<P> for self::SynchronizeWorkingCopyParams
    where
        P: ::fbthrift::ProtocolReader,
    {
        fn read(p: &mut P) -> ::anyhow::Result<Self> {
            static FIELDS: &[::fbthrift::Field] = &[
                ::fbthrift::Field::new("sync", ::fbthrift::TType::Struct, 1),
            ];
            let mut field_sync = ::std::option::Option::None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| (), FIELDS)?;
                match (fty, fid as ::std::primitive::i32) {
                    (::fbthrift::TType::Stop, _) => break,
                    (::fbthrift::TType::Struct, 1) => field_sync = ::std::option::Option::Some(::fbthrift::Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            ::std::result::Result::Ok(Self {
                sync: field_sync.unwrap_or_default(),
                _dot_dot_Default_default: self::dot_dot::OtherFields(()),
            })
        }
    }


    mod dot_dot {
        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]
        pub struct OtherFields(pub(crate) ());

        pub(super) fn default_for_serde_deserialize() -> OtherFields {
            OtherFields(())
        }
    }
}

#[doc(hidden)]
pub mod dependencies {
    pub use eden_config as eden_config;
    pub use fb303_core as fb303_core;
}

pub mod services {
    pub mod eden_service {

        #[derive(Clone, Debug)]
        pub enum ListMountsExn {
            Success(::std::vec::Vec<crate::types::MountInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ListMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ListMountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListMountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ListMountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ListMountsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ListMountsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ListMountsExn::ApplicationException(aexn) => aexn.exn_name(),
                    ListMountsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ListMountsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ListMountsExn::ApplicationException(aexn) => aexn.exn_value(),
                    ListMountsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ListMountsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ListMountsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ListMountsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ListMountsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ListMountsExn::Success(_) => ::fbthrift::ResultType::Return,
                    ListMountsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ListMountsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ListMountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ListMountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ListMountsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ListMounts");
                match self {
                    ListMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ListMountsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ListMountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListMountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(ListMountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ListMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "ListMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum MountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for MountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                MountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                MountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for MountExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    MountExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    MountExn::ApplicationException(aexn) => aexn.exn_name(),
                    MountExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    MountExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    MountExn::ApplicationException(aexn) => aexn.exn_value(),
                    MountExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    MountExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    MountExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    MountExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for MountExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    MountExn::Success(_) => ::fbthrift::ResultType::Return,
                    MountExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    MountExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for MountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for MountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let MountExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Mount");
                match self {
                    MountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    MountExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for MountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = MountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = MountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = MountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "MountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnmountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnmountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnmountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnmountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnmountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UnmountExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    UnmountExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    UnmountExn::ApplicationException(aexn) => aexn.exn_name(),
                    UnmountExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    UnmountExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    UnmountExn::ApplicationException(aexn) => aexn.exn_value(),
                    UnmountExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    UnmountExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    UnmountExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    UnmountExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UnmountExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    UnmountExn::Success(_) => ::fbthrift::ResultType::Return,
                    UnmountExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    UnmountExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for UnmountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnmountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let UnmountExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Unmount");
                match self {
                    UnmountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnmountExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnmountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = UnmountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = UnmountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = UnmountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnmountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckOutRevisionExn {
            Success(::std::vec::Vec<crate::types::CheckoutConflict>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckOutRevisionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                CheckOutRevisionExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckOutRevisionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CheckOutRevisionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CheckOutRevisionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    CheckOutRevisionExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    CheckOutRevisionExn::ApplicationException(aexn) => aexn.exn_name(),
                    CheckOutRevisionExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    CheckOutRevisionExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    CheckOutRevisionExn::ApplicationException(aexn) => aexn.exn_value(),
                    CheckOutRevisionExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    CheckOutRevisionExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    CheckOutRevisionExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    CheckOutRevisionExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CheckOutRevisionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    CheckOutRevisionExn::Success(_) => ::fbthrift::ResultType::Return,
                    CheckOutRevisionExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    CheckOutRevisionExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for CheckOutRevisionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckOutRevisionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let CheckOutRevisionExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CheckOutRevision");
                match self {
                    CheckOutRevisionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckOutRevisionExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckOutRevisionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckOutRevisionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckOutRevisionExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckOutRevisionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckOutRevisionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ResetParentCommitsExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ResetParentCommitsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ResetParentCommitsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ResetParentCommitsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ResetParentCommitsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ResetParentCommitsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ResetParentCommitsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ResetParentCommitsExn::ApplicationException(aexn) => aexn.exn_name(),
                    ResetParentCommitsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ResetParentCommitsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ResetParentCommitsExn::ApplicationException(aexn) => aexn.exn_value(),
                    ResetParentCommitsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ResetParentCommitsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ResetParentCommitsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ResetParentCommitsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ResetParentCommitsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ResetParentCommitsExn::Success(_) => ::fbthrift::ResultType::Return,
                    ResetParentCommitsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ResetParentCommitsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ResetParentCommitsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ResetParentCommitsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ResetParentCommitsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ResetParentCommits");
                match self {
                    ResetParentCommitsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ResetParentCommitsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ResetParentCommitsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ResetParentCommitsExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ResetParentCommitsExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ResetParentCommitsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum SynchronizeWorkingCopyExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for SynchronizeWorkingCopyExn {
            fn from(exn: crate::types::EdenError) -> Self {
                SynchronizeWorkingCopyExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SynchronizeWorkingCopyExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SynchronizeWorkingCopyExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SynchronizeWorkingCopyExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    SynchronizeWorkingCopyExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    SynchronizeWorkingCopyExn::ApplicationException(aexn) => aexn.exn_name(),
                    SynchronizeWorkingCopyExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    SynchronizeWorkingCopyExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    SynchronizeWorkingCopyExn::ApplicationException(aexn) => aexn.exn_value(),
                    SynchronizeWorkingCopyExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    SynchronizeWorkingCopyExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    SynchronizeWorkingCopyExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    SynchronizeWorkingCopyExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SynchronizeWorkingCopyExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    SynchronizeWorkingCopyExn::Success(_) => ::fbthrift::ResultType::Return,
                    SynchronizeWorkingCopyExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    SynchronizeWorkingCopyExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for SynchronizeWorkingCopyExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SynchronizeWorkingCopyExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let SynchronizeWorkingCopyExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SynchronizeWorkingCopy");
                match self {
                    SynchronizeWorkingCopyExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SynchronizeWorkingCopyExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SynchronizeWorkingCopyExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SynchronizeWorkingCopyExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SynchronizeWorkingCopyExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SynchronizeWorkingCopyExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = SynchronizeWorkingCopyExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SynchronizeWorkingCopyExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetSHA1Exn {
            Success(::std::vec::Vec<crate::types::SHA1Result>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetSHA1Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetSHA1Exn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSHA1Exn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetSHA1Exn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetSHA1Exn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetSHA1Exn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetSHA1Exn::ApplicationException(aexn) => aexn.exn_name(),
                    GetSHA1Exn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetSHA1Exn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetSHA1Exn::ApplicationException(aexn) => aexn.exn_value(),
                    GetSHA1Exn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetSHA1Exn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetSHA1Exn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetSHA1Exn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetSHA1Exn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetSHA1Exn::Success(_) => ::fbthrift::ResultType::Return,
                    GetSHA1Exn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetSHA1Exn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetSHA1Exn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetSHA1Exn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetSHA1Exn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetSHA1");
                match self {
                    GetSHA1Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetSHA1Exn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetSHA1Exn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSHA1Exn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetSHA1Exn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetSHA1Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetSHA1Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetBindMountsExn {
            Success(::std::vec::Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetBindMountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetBindMountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBindMountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetBindMountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetBindMountsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetBindMountsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetBindMountsExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetBindMountsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetBindMountsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetBindMountsExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetBindMountsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetBindMountsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetBindMountsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetBindMountsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetBindMountsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetBindMountsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetBindMountsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetBindMountsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetBindMountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetBindMountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetBindMountsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetBindMounts");
                match self {
                    GetBindMountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetBindMountsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetBindMountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetBindMountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetBindMountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetBindMountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetBindMountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum AddBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for AddBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                AddBindMountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddBindMountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                AddBindMountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for AddBindMountExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    AddBindMountExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    AddBindMountExn::ApplicationException(aexn) => aexn.exn_name(),
                    AddBindMountExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    AddBindMountExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    AddBindMountExn::ApplicationException(aexn) => aexn.exn_value(),
                    AddBindMountExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    AddBindMountExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    AddBindMountExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    AddBindMountExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for AddBindMountExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    AddBindMountExn::Success(_) => ::fbthrift::ResultType::Return,
                    AddBindMountExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    AddBindMountExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for AddBindMountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for AddBindMountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let AddBindMountExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("AddBindMount");
                match self {
                    AddBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    AddBindMountExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for AddBindMountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = AddBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = AddBindMountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = AddBindMountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "AddBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveBindMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveBindMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveBindMountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveBindMountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveBindMountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveBindMountExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    RemoveBindMountExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    RemoveBindMountExn::ApplicationException(aexn) => aexn.exn_name(),
                    RemoveBindMountExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    RemoveBindMountExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    RemoveBindMountExn::ApplicationException(aexn) => aexn.exn_value(),
                    RemoveBindMountExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    RemoveBindMountExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    RemoveBindMountExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    RemoveBindMountExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveBindMountExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    RemoveBindMountExn::Success(_) => ::fbthrift::ResultType::Return,
                    RemoveBindMountExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    RemoveBindMountExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveBindMountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveBindMountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let RemoveBindMountExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveBindMount");
                match self {
                    RemoveBindMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveBindMountExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveBindMountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = RemoveBindMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = RemoveBindMountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = RemoveBindMountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveBindMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetCurrentJournalPositionExn {
            Success(crate::types::JournalPosition),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetCurrentJournalPositionExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetCurrentJournalPositionExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCurrentJournalPositionExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetCurrentJournalPositionExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetCurrentJournalPositionExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetCurrentJournalPositionExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetCurrentJournalPositionExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetCurrentJournalPositionExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetCurrentJournalPositionExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetCurrentJournalPositionExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetCurrentJournalPositionExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetCurrentJournalPositionExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetCurrentJournalPositionExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetCurrentJournalPositionExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetCurrentJournalPositionExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetCurrentJournalPositionExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetCurrentJournalPositionExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetCurrentJournalPositionExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetCurrentJournalPositionExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetCurrentJournalPositionExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetCurrentJournalPositionExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetCurrentJournalPosition");
                match self {
                    GetCurrentJournalPositionExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetCurrentJournalPositionExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetCurrentJournalPositionExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCurrentJournalPositionExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetCurrentJournalPositionExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetCurrentJournalPositionExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetCurrentJournalPositionExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFilesChangedSinceExn {
            Success(crate::types::FileDelta),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFilesChangedSinceExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFilesChangedSinceExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFilesChangedSinceExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetFilesChangedSinceExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetFilesChangedSinceExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetFilesChangedSinceExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetFilesChangedSinceExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetFilesChangedSinceExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetFilesChangedSinceExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetFilesChangedSinceExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetFilesChangedSinceExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetFilesChangedSinceExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetFilesChangedSinceExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetFilesChangedSinceExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetFilesChangedSinceExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetFilesChangedSinceExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetFilesChangedSinceExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetFilesChangedSinceExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetFilesChangedSinceExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetFilesChangedSinceExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetFilesChangedSinceExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetFilesChangedSince");
                match self {
                    GetFilesChangedSinceExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFilesChangedSinceExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetFilesChangedSinceExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFilesChangedSinceExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFilesChangedSinceExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFilesChangedSinceExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFilesChangedSinceExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetJournalMemoryLimitExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                SetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetJournalMemoryLimitExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SetJournalMemoryLimitExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    SetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    SetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_name(),
                    SetJournalMemoryLimitExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    SetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    SetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_value(),
                    SetJournalMemoryLimitExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    SetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    SetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    SetJournalMemoryLimitExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SetJournalMemoryLimitExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    SetJournalMemoryLimitExn::Success(_) => ::fbthrift::ResultType::Return,
                    SetJournalMemoryLimitExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    SetJournalMemoryLimitExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for SetJournalMemoryLimitExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let SetJournalMemoryLimitExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetJournalMemoryLimit");
                match self {
                    SetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetJournalMemoryLimitExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = SetJournalMemoryLimitExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = SetJournalMemoryLimitExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetJournalMemoryLimitExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetJournalMemoryLimitExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetJournalMemoryLimitExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetJournalMemoryLimitExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetJournalMemoryLimitExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetJournalMemoryLimitExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetJournalMemoryLimitExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetJournalMemoryLimitExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetJournalMemoryLimitExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetJournalMemoryLimitExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetJournalMemoryLimitExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetJournalMemoryLimitExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetJournalMemoryLimitExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetJournalMemoryLimitExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetJournalMemoryLimitExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetJournalMemoryLimitExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetJournalMemoryLimitExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetJournalMemoryLimit");
                match self {
                    GetJournalMemoryLimitExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetJournalMemoryLimitExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetJournalMemoryLimitExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetJournalMemoryLimitExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetJournalMemoryLimitExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetJournalMemoryLimitExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetJournalMemoryLimitExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushJournalExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushJournalExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushJournalExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                FlushJournalExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for FlushJournalExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    FlushJournalExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    FlushJournalExn::ApplicationException(aexn) => aexn.exn_name(),
                    FlushJournalExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    FlushJournalExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    FlushJournalExn::ApplicationException(aexn) => aexn.exn_value(),
                    FlushJournalExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    FlushJournalExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    FlushJournalExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    FlushJournalExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for FlushJournalExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    FlushJournalExn::Success(_) => ::fbthrift::ResultType::Return,
                    FlushJournalExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    FlushJournalExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for FlushJournalExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for FlushJournalExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let FlushJournalExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("FlushJournal");
                match self {
                    FlushJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushJournalExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for FlushJournalExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushJournalExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushJournalExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushJournalExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetRawJournalExn {
            Success(crate::types::DebugGetRawJournalResponse),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetRawJournalExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetRawJournalExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetRawJournalExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetRawJournalExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugGetRawJournalExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugGetRawJournalExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugGetRawJournalExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugGetRawJournalExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugGetRawJournalExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugGetRawJournalExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugGetRawJournalExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugGetRawJournalExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugGetRawJournalExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugGetRawJournalExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugGetRawJournalExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugGetRawJournalExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugGetRawJournalExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugGetRawJournalExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugGetRawJournalExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetRawJournalExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugGetRawJournalExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugGetRawJournal");
                match self {
                    DebugGetRawJournalExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetRawJournalExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetRawJournalExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetRawJournalExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetRawJournalExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetRawJournalExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetRawJournalExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetEntryInformationExn {
            Success(::std::vec::Vec<crate::types::EntryInformationOrError>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetEntryInformationExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetEntryInformationExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEntryInformationExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetEntryInformationExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetEntryInformationExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetEntryInformationExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetEntryInformationExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetEntryInformationExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetEntryInformationExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetEntryInformationExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetEntryInformationExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetEntryInformationExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetEntryInformationExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetEntryInformationExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetEntryInformationExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetEntryInformationExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetEntryInformationExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetEntryInformationExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetEntryInformationExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetEntryInformationExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetEntryInformationExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetEntryInformation");
                match self {
                    GetEntryInformationExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEntryInformationExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetEntryInformationExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetEntryInformationExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEntryInformationExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetEntryInformationExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetEntryInformationExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetEntryInformationExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetFileInformationExn {
            Success(::std::vec::Vec<crate::types::FileInformationOrError>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFileInformationExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetFileInformationExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFileInformationExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetFileInformationExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetFileInformationExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetFileInformationExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetFileInformationExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetFileInformationExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetFileInformationExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetFileInformationExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetFileInformationExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetFileInformationExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetFileInformationExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetFileInformationExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetFileInformationExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetFileInformationExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetFileInformationExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetFileInformationExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetFileInformationExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetFileInformationExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetFileInformationExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetFileInformation");
                match self {
                    GetFileInformationExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetFileInformationExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetFileInformationExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFileInformationExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetFileInformationExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetFileInformationExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetFileInformationExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetAttributesFromFilesExn {
            Success(crate::types::GetAttributesFromFilesResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAttributesFromFilesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetAttributesFromFilesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAttributesFromFilesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetAttributesFromFilesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetAttributesFromFilesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetAttributesFromFilesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetAttributesFromFilesExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetAttributesFromFilesExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetAttributesFromFilesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetAttributesFromFilesExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetAttributesFromFilesExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetAttributesFromFilesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetAttributesFromFilesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetAttributesFromFilesExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetAttributesFromFilesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetAttributesFromFilesExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetAttributesFromFilesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetAttributesFromFilesExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetAttributesFromFilesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetAttributesFromFilesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetAttributesFromFilesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetAttributesFromFiles");
                match self {
                    GetAttributesFromFilesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAttributesFromFilesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAttributesFromFilesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetAttributesFromFilesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAttributesFromFilesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAttributesFromFilesExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetAttributesFromFilesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetAttributesFromFilesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobExn {
            Success(::std::vec::Vec<crate::types::PathString>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GlobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GlobExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GlobExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GlobExn::ApplicationException(aexn) => aexn.exn_name(),
                    GlobExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GlobExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GlobExn::ApplicationException(aexn) => aexn.exn_value(),
                    GlobExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GlobExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GlobExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GlobExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GlobExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GlobExn::Success(_) => ::fbthrift::ResultType::Return,
                    GlobExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GlobExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GlobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GlobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GlobExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Glob");
                match self {
                    GlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GlobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GlobFilesExn {
            Success(crate::types::Glob),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobFilesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GlobFilesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobFilesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GlobFilesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GlobFilesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GlobFilesExn::ApplicationException(aexn) => aexn.exn_name(),
                    GlobFilesExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GlobFilesExn::ApplicationException(aexn) => aexn.exn_value(),
                    GlobFilesExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GlobFilesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GlobFilesExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GlobFilesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GlobFilesExn::Success(_) => ::fbthrift::ResultType::Return,
                    GlobFilesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GlobFilesExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GlobFilesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GlobFilesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GlobFilesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GlobFiles");
                match self {
                    GlobFilesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GlobFilesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GlobFilesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobFilesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GlobFilesExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GlobFilesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GlobFilesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum PredictiveGlobFilesExn {
            Success(crate::types::Glob),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for PredictiveGlobFilesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                PredictiveGlobFilesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PredictiveGlobFilesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                PredictiveGlobFilesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for PredictiveGlobFilesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    PredictiveGlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    PredictiveGlobFilesExn::ApplicationException(aexn) => aexn.exn_name(),
                    PredictiveGlobFilesExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    PredictiveGlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    PredictiveGlobFilesExn::ApplicationException(aexn) => aexn.exn_value(),
                    PredictiveGlobFilesExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    PredictiveGlobFilesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    PredictiveGlobFilesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    PredictiveGlobFilesExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for PredictiveGlobFilesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    PredictiveGlobFilesExn::Success(_) => ::fbthrift::ResultType::Return,
                    PredictiveGlobFilesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    PredictiveGlobFilesExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for PredictiveGlobFilesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for PredictiveGlobFilesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let PredictiveGlobFilesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("PredictiveGlobFiles");
                match self {
                    PredictiveGlobFilesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    PredictiveGlobFilesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    PredictiveGlobFilesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for PredictiveGlobFilesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(PredictiveGlobFilesExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(PredictiveGlobFilesExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "PredictiveGlobFilesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "PredictiveGlobFilesExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ChownExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ChownExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ChownExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ChownExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ChownExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ChownExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ChownExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ChownExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ChownExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ChownExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ChownExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ChownExn::Success(_) => ::fbthrift::ResultType::Return,
                    ChownExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for ChownExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ChownExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ChownExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("Chown");
                match self {
                    ChownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ChownExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ChownExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ChownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ChownExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ChownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusV2Exn {
            Success(crate::types::GetScmStatusResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusV2Exn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusV2Exn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusV2Exn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusV2Exn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetScmStatusV2Exn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetScmStatusV2Exn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetScmStatusV2Exn::ApplicationException(aexn) => aexn.exn_name(),
                    GetScmStatusV2Exn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetScmStatusV2Exn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetScmStatusV2Exn::ApplicationException(aexn) => aexn.exn_value(),
                    GetScmStatusV2Exn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetScmStatusV2Exn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetScmStatusV2Exn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetScmStatusV2Exn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetScmStatusV2Exn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetScmStatusV2Exn::Success(_) => ::fbthrift::ResultType::Return,
                    GetScmStatusV2Exn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetScmStatusV2Exn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusV2Exn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusV2Exn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetScmStatusV2Exn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetScmStatusV2");
                match self {
                    GetScmStatusV2Exn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusV2Exn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusV2Exn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusV2Exn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusV2Exn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusV2Exn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusV2Exn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetScmStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetScmStatusExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetScmStatusExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetScmStatusExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetScmStatusExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetScmStatusExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetScmStatusExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetScmStatusExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetScmStatusExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetScmStatusExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetScmStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetScmStatusExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetScmStatusExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetScmStatusExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetScmStatusExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetScmStatus");
                match self {
                    GetScmStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetScmStatusBetweenRevisionsExn {
            Success(crate::types::ScmStatus),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetScmStatusBetweenRevisionsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusBetweenRevisionsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusBetweenRevisionsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetScmStatusBetweenRevisionsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetScmStatusBetweenRevisionsExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetScmStatusBetweenRevisionsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetScmStatusBetweenRevisionsExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetScmStatusBetweenRevisionsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetScmStatusBetweenRevisionsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetScmStatusBetweenRevisionsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetScmStatusBetweenRevisionsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetScmStatusBetweenRevisionsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetScmStatusBetweenRevisionsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetScmStatusBetweenRevisionsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetScmStatusBetweenRevisionsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetScmStatusBetweenRevisionsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetScmStatusBetweenRevisions");
                match self {
                    GetScmStatusBetweenRevisionsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetScmStatusBetweenRevisionsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetScmStatusBetweenRevisionsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusBetweenRevisionsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetScmStatusBetweenRevisionsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetScmStatusBetweenRevisionsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetScmStatusBetweenRevisionsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetDaemonInfoExn {
            Success(crate::types::DaemonInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetDaemonInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetDaemonInfoExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetDaemonInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetDaemonInfoExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetDaemonInfoExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetDaemonInfoExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetDaemonInfoExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetDaemonInfoExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetDaemonInfoExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetDaemonInfoExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetDaemonInfoExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetDaemonInfoExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetDaemonInfoExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetDaemonInfoExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetDaemonInfoExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetDaemonInfoExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetDaemonInfoExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetDaemonInfoExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetDaemonInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetDaemonInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetDaemonInfoExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetDaemonInfo");
                match self {
                    GetDaemonInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetDaemonInfoExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetDaemonInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetDaemonInfoExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetDaemonInfoExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetDaemonInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetDaemonInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum CheckPrivHelperExn {
            Success(crate::types::PrivHelperInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckPrivHelperExn {
            fn from(exn: crate::types::EdenError) -> Self {
                CheckPrivHelperExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPrivHelperExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                CheckPrivHelperExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for CheckPrivHelperExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    CheckPrivHelperExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    CheckPrivHelperExn::ApplicationException(aexn) => aexn.exn_name(),
                    CheckPrivHelperExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    CheckPrivHelperExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    CheckPrivHelperExn::ApplicationException(aexn) => aexn.exn_value(),
                    CheckPrivHelperExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    CheckPrivHelperExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    CheckPrivHelperExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    CheckPrivHelperExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for CheckPrivHelperExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    CheckPrivHelperExn::Success(_) => ::fbthrift::ResultType::Return,
                    CheckPrivHelperExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    CheckPrivHelperExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for CheckPrivHelperExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for CheckPrivHelperExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let CheckPrivHelperExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("CheckPrivHelper");
                match self {
                    CheckPrivHelperExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckPrivHelperExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    CheckPrivHelperExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for CheckPrivHelperExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckPrivHelperExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(CheckPrivHelperExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "CheckPrivHelperExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "CheckPrivHelperExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetPidExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetPidExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetPidExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPidExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetPidExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetPidExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetPidExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetPidExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetPidExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetPidExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetPidExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetPidExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetPidExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetPidExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetPidExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetPidExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetPidExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetPidExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetPidExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetPidExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetPidExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetPidExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetPid");
                match self {
                    GetPidExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetPidExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetPidExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPidExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetPidExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetPidExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetPidExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InitiateShutdownExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InitiateShutdownExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InitiateShutdownExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InitiateShutdownExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InitiateShutdownExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for InitiateShutdownExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    InitiateShutdownExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    InitiateShutdownExn::ApplicationException(aexn) => aexn.exn_name(),
                    InitiateShutdownExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    InitiateShutdownExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    InitiateShutdownExn::ApplicationException(aexn) => aexn.exn_value(),
                    InitiateShutdownExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    InitiateShutdownExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    InitiateShutdownExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    InitiateShutdownExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for InitiateShutdownExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    InitiateShutdownExn::Success(_) => ::fbthrift::ResultType::Return,
                    InitiateShutdownExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    InitiateShutdownExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for InitiateShutdownExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InitiateShutdownExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let InitiateShutdownExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("InitiateShutdown");
                match self {
                    InitiateShutdownExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InitiateShutdownExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InitiateShutdownExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InitiateShutdownExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InitiateShutdownExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InitiateShutdownExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InitiateShutdownExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetConfigExn {
            Success(eden_config::types::EdenConfigData),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetConfigExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetConfigExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetConfigExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetConfigExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetConfigExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetConfigExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetConfigExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetConfigExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetConfigExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetConfigExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetConfigExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetConfigExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetConfigExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetConfigExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetConfig");
                match self {
                    GetConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetConfigExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetConfigExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetConfigExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ReloadConfigExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ReloadConfigExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ReloadConfigExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReloadConfigExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ReloadConfigExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ReloadConfigExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ReloadConfigExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ReloadConfigExn::ApplicationException(aexn) => aexn.exn_name(),
                    ReloadConfigExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ReloadConfigExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ReloadConfigExn::ApplicationException(aexn) => aexn.exn_value(),
                    ReloadConfigExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ReloadConfigExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ReloadConfigExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ReloadConfigExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ReloadConfigExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ReloadConfigExn::Success(_) => ::fbthrift::ResultType::Return,
                    ReloadConfigExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ReloadConfigExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ReloadConfigExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ReloadConfigExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ReloadConfigExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ReloadConfig");
                match self {
                    ReloadConfigExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ReloadConfigExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ReloadConfigExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ReloadConfigExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ReloadConfigExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ReloadConfigExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ReloadConfigExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmTreeExn {
            Success(::std::vec::Vec<crate::types::ScmTreeEntry>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmTreeExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmTreeExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmTreeExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmTreeExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugGetScmTreeExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugGetScmTreeExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugGetScmTreeExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugGetScmTreeExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugGetScmTreeExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugGetScmTreeExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugGetScmTreeExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugGetScmTreeExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugGetScmTreeExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugGetScmTreeExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugGetScmTreeExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugGetScmTreeExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugGetScmTreeExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugGetScmTreeExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmTreeExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmTreeExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugGetScmTreeExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugGetScmTree");
                match self {
                    DebugGetScmTreeExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmTreeExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmTreeExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmTreeExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmTreeExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmTreeExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmTreeExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobExn {
            Success(::std::vec::Vec<::std::primitive::u8>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugGetScmBlobExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugGetScmBlobExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugGetScmBlobExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugGetScmBlobExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugGetScmBlobExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugGetScmBlobExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugGetScmBlobExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugGetScmBlobExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugGetScmBlobExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugGetScmBlobExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugGetScmBlobExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugGetScmBlobExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugGetScmBlobExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugGetScmBlobExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmBlobExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmBlobExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugGetScmBlobExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugGetScmBlob");
                match self {
                    DebugGetScmBlobExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::String,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmBlobExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::String, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::String, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetScmBlobMetadataExn {
            Success(crate::types::ScmBlobMetadata),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobMetadataExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetScmBlobMetadataExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobMetadataExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobMetadataExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugGetScmBlobMetadataExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugGetScmBlobMetadataExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugGetScmBlobMetadataExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugGetScmBlobMetadataExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugGetScmBlobMetadataExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugGetScmBlobMetadataExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugGetScmBlobMetadataExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugGetScmBlobMetadataExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugGetScmBlobMetadataExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugGetScmBlobMetadataExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugGetScmBlobMetadataExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugGetScmBlobMetadataExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugGetScmBlobMetadataExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugGetScmBlobMetadataExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugGetScmBlobMetadataExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetScmBlobMetadataExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugGetScmBlobMetadataExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugGetScmBlobMetadata");
                match self {
                    DebugGetScmBlobMetadataExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetScmBlobMetadataExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetScmBlobMetadataExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobMetadataExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetScmBlobMetadataExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetScmBlobMetadataExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetScmBlobMetadataExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugInodeStatusExn {
            Success(::std::vec::Vec<crate::types::TreeInodeDebugInfo>),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugInodeStatusExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugInodeStatusExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugInodeStatusExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugInodeStatusExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugInodeStatusExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugInodeStatusExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugInodeStatusExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugInodeStatusExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugInodeStatusExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugInodeStatusExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugInodeStatusExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugInodeStatusExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugInodeStatusExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugInodeStatusExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugInodeStatusExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugInodeStatusExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugInodeStatusExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugInodeStatusExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugInodeStatusExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugInodeStatusExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugInodeStatusExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugInodeStatus");
                match self {
                    DebugInodeStatusExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugInodeStatusExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugInodeStatusExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugInodeStatusExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugInodeStatusExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugInodeStatusExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugInodeStatusExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugOutstandingFuseCallsExn {
            Success(::std::vec::Vec<crate::types::FuseCall>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugOutstandingFuseCallsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugOutstandingFuseCallsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugOutstandingFuseCallsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugOutstandingFuseCallsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugOutstandingFuseCallsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugOutstandingFuseCallsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugOutstandingFuseCallsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugOutstandingFuseCallsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugOutstandingFuseCallsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugOutstandingFuseCallsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugOutstandingFuseCallsExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugOutstandingFuseCallsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugOutstandingFuseCallsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugOutstandingFuseCallsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugOutstandingFuseCallsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugOutstandingFuseCalls");
                match self {
                    DebugOutstandingFuseCallsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugOutstandingFuseCallsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugOutstandingFuseCallsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugOutstandingFuseCallsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugOutstandingFuseCallsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugOutstandingFuseCallsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugOutstandingNfsCallsExn {
            Success(::std::vec::Vec<crate::types::NfsCall>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugOutstandingNfsCallsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugOutstandingNfsCallsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugOutstandingNfsCallsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugOutstandingNfsCallsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugOutstandingNfsCallsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugOutstandingNfsCallsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugOutstandingNfsCallsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugOutstandingNfsCallsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugOutstandingNfsCallsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugOutstandingNfsCallsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugOutstandingNfsCallsExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugOutstandingNfsCallsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugOutstandingNfsCallsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugOutstandingNfsCallsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugOutstandingNfsCallsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugOutstandingNfsCalls");
                match self {
                    DebugOutstandingNfsCallsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugOutstandingNfsCallsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugOutstandingNfsCallsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugOutstandingNfsCallsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugOutstandingNfsCallsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugOutstandingNfsCallsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugStartRecordingActivityExn {
            Success(crate::types::ActivityRecorderResult),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugStartRecordingActivityExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugStartRecordingActivityExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugStartRecordingActivityExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugStartRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugStartRecordingActivityExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugStartRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugStartRecordingActivityExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugStartRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugStartRecordingActivityExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugStartRecordingActivityExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugStartRecordingActivityExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugStartRecordingActivityExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugStartRecordingActivityExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugStartRecordingActivityExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugStartRecordingActivityExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugStartRecordingActivity");
                match self {
                    DebugStartRecordingActivityExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugStartRecordingActivityExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugStartRecordingActivityExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugStartRecordingActivityExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugStartRecordingActivityExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugStartRecordingActivityExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugStopRecordingActivityExn {
            Success(crate::types::ActivityRecorderResult),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugStopRecordingActivityExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugStopRecordingActivityExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugStopRecordingActivityExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugStopRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugStopRecordingActivityExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugStopRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugStopRecordingActivityExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugStopRecordingActivityExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugStopRecordingActivityExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugStopRecordingActivityExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugStopRecordingActivityExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugStopRecordingActivityExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugStopRecordingActivityExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugStopRecordingActivityExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugStopRecordingActivityExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugStopRecordingActivity");
                match self {
                    DebugStopRecordingActivityExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugStopRecordingActivityExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugStopRecordingActivityExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugStopRecordingActivityExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugStopRecordingActivityExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugStopRecordingActivityExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugListActivityRecordingsExn {
            Success(crate::types::ListActivityRecordingsResult),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugListActivityRecordingsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugListActivityRecordingsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugListActivityRecordingsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugListActivityRecordingsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugListActivityRecordingsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugListActivityRecordingsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugListActivityRecordingsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugListActivityRecordingsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugListActivityRecordingsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugListActivityRecordingsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugListActivityRecordingsExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugListActivityRecordingsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugListActivityRecordingsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugListActivityRecordingsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugListActivityRecordingsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugListActivityRecordings");
                match self {
                    DebugListActivityRecordingsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugListActivityRecordingsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugListActivityRecordingsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugListActivityRecordingsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugListActivityRecordingsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugListActivityRecordingsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugGetInodePathExn {
            Success(crate::types::InodePathDebugInfo),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetInodePathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugGetInodePathExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetInodePathExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugGetInodePathExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugGetInodePathExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugGetInodePathExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugGetInodePathExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugGetInodePathExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugGetInodePathExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugGetInodePathExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugGetInodePathExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugGetInodePathExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugGetInodePathExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugGetInodePathExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugGetInodePathExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugGetInodePathExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugGetInodePathExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugGetInodePathExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugGetInodePathExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugGetInodePathExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugGetInodePathExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugGetInodePath");
                match self {
                    DebugGetInodePathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugGetInodePathExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugGetInodePathExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetInodePathExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(DebugGetInodePathExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugGetInodePathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "DebugGetInodePathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearFetchCountsExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearFetchCountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ClearFetchCountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearFetchCountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ClearFetchCountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ClearFetchCountsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ClearFetchCountsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ClearFetchCountsExn::ApplicationException(aexn) => aexn.exn_name(),
                    ClearFetchCountsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ClearFetchCountsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ClearFetchCountsExn::ApplicationException(aexn) => aexn.exn_value(),
                    ClearFetchCountsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ClearFetchCountsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ClearFetchCountsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ClearFetchCountsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ClearFetchCountsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ClearFetchCountsExn::Success(_) => ::fbthrift::ResultType::Return,
                    ClearFetchCountsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ClearFetchCountsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ClearFetchCountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ClearFetchCountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ClearFetchCountsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ClearFetchCounts");
                match self {
                    ClearFetchCountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearFetchCountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearFetchCountsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ClearFetchCountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ClearFetchCountsExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ClearFetchCountsExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ClearFetchCountsExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearFetchCountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearFetchCountsByMountExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearFetchCountsByMountExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ClearFetchCountsByMountExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearFetchCountsByMountExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ClearFetchCountsByMountExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ClearFetchCountsByMountExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ClearFetchCountsByMountExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ClearFetchCountsByMountExn::ApplicationException(aexn) => aexn.exn_name(),
                    ClearFetchCountsByMountExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ClearFetchCountsByMountExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ClearFetchCountsByMountExn::ApplicationException(aexn) => aexn.exn_value(),
                    ClearFetchCountsByMountExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ClearFetchCountsByMountExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ClearFetchCountsByMountExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ClearFetchCountsByMountExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ClearFetchCountsByMountExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ClearFetchCountsByMountExn::Success(_) => ::fbthrift::ResultType::Return,
                    ClearFetchCountsByMountExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ClearFetchCountsByMountExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ClearFetchCountsByMountExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ClearFetchCountsByMountExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ClearFetchCountsByMountExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ClearFetchCountsByMount");
                match self {
                    ClearFetchCountsByMountExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearFetchCountsByMountExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearFetchCountsByMountExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ClearFetchCountsByMountExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ClearFetchCountsByMountExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ClearFetchCountsByMountExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ClearFetchCountsByMountExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearFetchCountsByMountExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetAccessCountsExn {
            Success(crate::types::GetAccessCountsResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAccessCountsExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetAccessCountsExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAccessCountsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetAccessCountsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetAccessCountsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetAccessCountsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetAccessCountsExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetAccessCountsExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetAccessCountsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetAccessCountsExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetAccessCountsExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetAccessCountsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetAccessCountsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetAccessCountsExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetAccessCountsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetAccessCountsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetAccessCountsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetAccessCountsExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetAccessCountsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetAccessCountsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetAccessCountsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetAccessCounts");
                match self {
                    GetAccessCountsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetAccessCountsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetAccessCountsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAccessCountsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetAccessCountsExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetAccessCountsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetAccessCountsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum StartRecordingBackingStoreFetchExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for StartRecordingBackingStoreFetchExn {
            fn from(exn: crate::types::EdenError) -> Self {
                StartRecordingBackingStoreFetchExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StartRecordingBackingStoreFetchExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                StartRecordingBackingStoreFetchExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for StartRecordingBackingStoreFetchExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    StartRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    StartRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_name(),
                    StartRecordingBackingStoreFetchExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    StartRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    StartRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_value(),
                    StartRecordingBackingStoreFetchExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    StartRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    StartRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    StartRecordingBackingStoreFetchExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for StartRecordingBackingStoreFetchExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    StartRecordingBackingStoreFetchExn::Success(_) => ::fbthrift::ResultType::Return,
                    StartRecordingBackingStoreFetchExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    StartRecordingBackingStoreFetchExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for StartRecordingBackingStoreFetchExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for StartRecordingBackingStoreFetchExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let StartRecordingBackingStoreFetchExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("StartRecordingBackingStoreFetch");
                match self {
                    StartRecordingBackingStoreFetchExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    StartRecordingBackingStoreFetchExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    StartRecordingBackingStoreFetchExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for StartRecordingBackingStoreFetchExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = StartRecordingBackingStoreFetchExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = StartRecordingBackingStoreFetchExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = StartRecordingBackingStoreFetchExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "StartRecordingBackingStoreFetchExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum StopRecordingBackingStoreFetchExn {
            Success(crate::types::GetFetchedFilesResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for StopRecordingBackingStoreFetchExn {
            fn from(exn: crate::types::EdenError) -> Self {
                StopRecordingBackingStoreFetchExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StopRecordingBackingStoreFetchExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                StopRecordingBackingStoreFetchExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for StopRecordingBackingStoreFetchExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    StopRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    StopRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_name(),
                    StopRecordingBackingStoreFetchExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    StopRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    StopRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_value(),
                    StopRecordingBackingStoreFetchExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    StopRecordingBackingStoreFetchExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    StopRecordingBackingStoreFetchExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    StopRecordingBackingStoreFetchExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for StopRecordingBackingStoreFetchExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    StopRecordingBackingStoreFetchExn::Success(_) => ::fbthrift::ResultType::Return,
                    StopRecordingBackingStoreFetchExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    StopRecordingBackingStoreFetchExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for StopRecordingBackingStoreFetchExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for StopRecordingBackingStoreFetchExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let StopRecordingBackingStoreFetchExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("StopRecordingBackingStoreFetch");
                match self {
                    StopRecordingBackingStoreFetchExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    StopRecordingBackingStoreFetchExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    StopRecordingBackingStoreFetchExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for StopRecordingBackingStoreFetchExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(StopRecordingBackingStoreFetchExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(StopRecordingBackingStoreFetchExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "StopRecordingBackingStoreFetchExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "StopRecordingBackingStoreFetchExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum ClearAndCompactLocalStoreExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearAndCompactLocalStoreExn {
            fn from(exn: crate::types::EdenError) -> Self {
                ClearAndCompactLocalStoreExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearAndCompactLocalStoreExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                ClearAndCompactLocalStoreExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for ClearAndCompactLocalStoreExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    ClearAndCompactLocalStoreExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    ClearAndCompactLocalStoreExn::ApplicationException(aexn) => aexn.exn_name(),
                    ClearAndCompactLocalStoreExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    ClearAndCompactLocalStoreExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    ClearAndCompactLocalStoreExn::ApplicationException(aexn) => aexn.exn_value(),
                    ClearAndCompactLocalStoreExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    ClearAndCompactLocalStoreExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    ClearAndCompactLocalStoreExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    ClearAndCompactLocalStoreExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for ClearAndCompactLocalStoreExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    ClearAndCompactLocalStoreExn::Success(_) => ::fbthrift::ResultType::Return,
                    ClearAndCompactLocalStoreExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    ClearAndCompactLocalStoreExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for ClearAndCompactLocalStoreExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for ClearAndCompactLocalStoreExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let ClearAndCompactLocalStoreExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("ClearAndCompactLocalStore");
                match self {
                    ClearAndCompactLocalStoreExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    ClearAndCompactLocalStoreExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for ClearAndCompactLocalStoreExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ClearAndCompactLocalStoreExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ClearAndCompactLocalStoreExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "ClearAndCompactLocalStoreExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugClearLocalStoreCachesExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugClearLocalStoreCachesExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugClearLocalStoreCachesExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugClearLocalStoreCachesExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugClearLocalStoreCachesExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugClearLocalStoreCachesExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugClearLocalStoreCachesExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugClearLocalStoreCachesExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugClearLocalStoreCachesExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugClearLocalStoreCachesExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugClearLocalStoreCachesExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugClearLocalStoreCachesExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugClearLocalStoreCachesExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugClearLocalStoreCachesExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugClearLocalStoreCachesExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugClearLocalStoreCachesExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugClearLocalStoreCachesExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugClearLocalStoreCachesExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugClearLocalStoreCachesExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugClearLocalStoreCachesExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugClearLocalStoreCachesExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugClearLocalStoreCachesExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugClearLocalStoreCaches");
                match self {
                    DebugClearLocalStoreCachesExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugClearLocalStoreCachesExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugClearLocalStoreCachesExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugClearLocalStoreCachesExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugClearLocalStoreCachesExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugClearLocalStoreCachesExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DebugCompactLocalStorageExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugCompactLocalStorageExn {
            fn from(exn: crate::types::EdenError) -> Self {
                DebugCompactLocalStorageExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugCompactLocalStorageExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DebugCompactLocalStorageExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DebugCompactLocalStorageExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DebugCompactLocalStorageExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DebugCompactLocalStorageExn::ApplicationException(aexn) => aexn.exn_name(),
                    DebugCompactLocalStorageExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DebugCompactLocalStorageExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DebugCompactLocalStorageExn::ApplicationException(aexn) => aexn.exn_value(),
                    DebugCompactLocalStorageExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DebugCompactLocalStorageExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DebugCompactLocalStorageExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    DebugCompactLocalStorageExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DebugCompactLocalStorageExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DebugCompactLocalStorageExn::Success(_) => ::fbthrift::ResultType::Return,
                    DebugCompactLocalStorageExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    DebugCompactLocalStorageExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for DebugCompactLocalStorageExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DebugCompactLocalStorageExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DebugCompactLocalStorageExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DebugCompactLocalStorage");
                match self {
                    DebugCompactLocalStorageExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DebugCompactLocalStorageExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DebugCompactLocalStorageExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DebugCompactLocalStorageExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = DebugCompactLocalStorageExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DebugCompactLocalStorageExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnloadInodeForPathExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnloadInodeForPathExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnloadInodeForPathExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnloadInodeForPathExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnloadInodeForPathExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UnloadInodeForPathExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    UnloadInodeForPathExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    UnloadInodeForPathExn::ApplicationException(aexn) => aexn.exn_name(),
                    UnloadInodeForPathExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    UnloadInodeForPathExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    UnloadInodeForPathExn::ApplicationException(aexn) => aexn.exn_value(),
                    UnloadInodeForPathExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    UnloadInodeForPathExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    UnloadInodeForPathExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    UnloadInodeForPathExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UnloadInodeForPathExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    UnloadInodeForPathExn::Success(_) => ::fbthrift::ResultType::Return,
                    UnloadInodeForPathExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    UnloadInodeForPathExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for UnloadInodeForPathExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnloadInodeForPathExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let UnloadInodeForPathExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UnloadInodeForPath");
                match self {
                    UnloadInodeForPathExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnloadInodeForPathExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnloadInodeForPathExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnloadInodeForPathExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnloadInodeForPathExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnloadInodeForPathExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnloadInodeForPathExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum FlushStatsNowExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushStatsNowExn {
            fn from(exn: crate::types::EdenError) -> Self {
                FlushStatsNowExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushStatsNowExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                FlushStatsNowExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for FlushStatsNowExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    FlushStatsNowExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    FlushStatsNowExn::ApplicationException(aexn) => aexn.exn_name(),
                    FlushStatsNowExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    FlushStatsNowExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    FlushStatsNowExn::ApplicationException(aexn) => aexn.exn_value(),
                    FlushStatsNowExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    FlushStatsNowExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    FlushStatsNowExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    FlushStatsNowExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for FlushStatsNowExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    FlushStatsNowExn::Success(_) => ::fbthrift::ResultType::Return,
                    FlushStatsNowExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    FlushStatsNowExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for FlushStatsNowExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for FlushStatsNowExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let FlushStatsNowExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("FlushStatsNow");
                match self {
                    FlushStatsNowExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    FlushStatsNowExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for FlushStatsNowExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = FlushStatsNowExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = FlushStatsNowExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = FlushStatsNowExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "FlushStatsNowExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum InvalidateKernelInodeCacheExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InvalidateKernelInodeCacheExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InvalidateKernelInodeCacheExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InvalidateKernelInodeCacheExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InvalidateKernelInodeCacheExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for InvalidateKernelInodeCacheExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    InvalidateKernelInodeCacheExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    InvalidateKernelInodeCacheExn::ApplicationException(aexn) => aexn.exn_name(),
                    InvalidateKernelInodeCacheExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    InvalidateKernelInodeCacheExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    InvalidateKernelInodeCacheExn::ApplicationException(aexn) => aexn.exn_value(),
                    InvalidateKernelInodeCacheExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    InvalidateKernelInodeCacheExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    InvalidateKernelInodeCacheExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    InvalidateKernelInodeCacheExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for InvalidateKernelInodeCacheExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    InvalidateKernelInodeCacheExn::Success(_) => ::fbthrift::ResultType::Return,
                    InvalidateKernelInodeCacheExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    InvalidateKernelInodeCacheExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for InvalidateKernelInodeCacheExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InvalidateKernelInodeCacheExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let InvalidateKernelInodeCacheExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("InvalidateKernelInodeCache");
                match self {
                    InvalidateKernelInodeCacheExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InvalidateKernelInodeCacheExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InvalidateKernelInodeCacheExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InvalidateKernelInodeCacheExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InvalidateKernelInodeCacheExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InvalidateKernelInodeCacheExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetStatInfoExn {
            Success(crate::types::InternalStats),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetStatInfoExn {
            fn from(exn: crate::types::EdenError) -> Self {
                GetStatInfoExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatInfoExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetStatInfoExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetStatInfoExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetStatInfoExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetStatInfoExn::ApplicationException(aexn) => aexn.exn_name(),
                    GetStatInfoExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetStatInfoExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetStatInfoExn::ApplicationException(aexn) => aexn.exn_value(),
                    GetStatInfoExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetStatInfoExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetStatInfoExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    GetStatInfoExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetStatInfoExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetStatInfoExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetStatInfoExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    GetStatInfoExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for GetStatInfoExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetStatInfoExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetStatInfoExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetStatInfo");
                match self {
                    GetStatInfoExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetStatInfoExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetStatInfoExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatInfoExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetStatInfoExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetStatInfoExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetStatInfoExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum EnableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for EnableTracingExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                EnableTracingExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for EnableTracingExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    EnableTracingExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    EnableTracingExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    EnableTracingExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    EnableTracingExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    EnableTracingExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    EnableTracingExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for EnableTracingExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    EnableTracingExn::Success(_) => ::fbthrift::ResultType::Return,
                    EnableTracingExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for EnableTracingExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for EnableTracingExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let EnableTracingExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("EnableTracing");
                match self {
                    EnableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    EnableTracingExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for EnableTracingExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = EnableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = EnableTracingExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "EnableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum DisableTracingExn {
            Success(()),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DisableTracingExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                DisableTracingExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for DisableTracingExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    DisableTracingExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    DisableTracingExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    DisableTracingExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    DisableTracingExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    DisableTracingExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    DisableTracingExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for DisableTracingExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    DisableTracingExn::Success(_) => ::fbthrift::ResultType::Return,
                    DisableTracingExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for DisableTracingExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for DisableTracingExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let DisableTracingExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("DisableTracing");
                match self {
                    DisableTracingExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    DisableTracingExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for DisableTracingExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = DisableTracingExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = DisableTracingExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "DisableTracingExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum GetTracePointsExn {
            Success(::std::vec::Vec<crate::types::TracePoint>),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetTracePointsExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                GetTracePointsExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for GetTracePointsExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    GetTracePointsExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    GetTracePointsExn::ApplicationException(aexn) => aexn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    GetTracePointsExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    GetTracePointsExn::ApplicationException(aexn) => aexn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    GetTracePointsExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    GetTracePointsExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for GetTracePointsExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    GetTracePointsExn::Success(_) => ::fbthrift::ResultType::Return,
                    GetTracePointsExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                }
            }
        }

        impl ::fbthrift::GetTType for GetTracePointsExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for GetTracePointsExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let GetTracePointsExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("GetTracePoints");
                match self {
                    GetTracePointsExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::List,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    GetTracePointsExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for GetTracePointsExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::List, 0),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::List, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(GetTracePointsExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "GetTracePointsExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "GetTracePointsExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum InjectFaultExn {
            Success(()),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for InjectFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                InjectFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InjectFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                InjectFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for InjectFaultExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    InjectFaultExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    InjectFaultExn::ApplicationException(aexn) => aexn.exn_name(),
                    InjectFaultExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    InjectFaultExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    InjectFaultExn::ApplicationException(aexn) => aexn.exn_value(),
                    InjectFaultExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    InjectFaultExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    InjectFaultExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    InjectFaultExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for InjectFaultExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    InjectFaultExn::Success(_) => ::fbthrift::ResultType::Return,
                    InjectFaultExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    InjectFaultExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for InjectFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for InjectFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let InjectFaultExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("InjectFault");
                match self {
                    InjectFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Void,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    InjectFaultExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for InjectFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Void, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = InjectFaultExn::Success(());
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Void, 0i32), false) => {
                            once = true;
                            alt = InjectFaultExn::Success(::fbthrift::Deserialize::read(p)?);
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = InjectFaultExn::ex(::fbthrift::Deserialize::read(p)?);
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "InjectFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                ::std::result::Result::Ok(alt)
            }
        }

        #[derive(Clone, Debug)]
        pub enum RemoveFaultExn {
            Success(::std::primitive::bool),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                RemoveFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                RemoveFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for RemoveFaultExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    RemoveFaultExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    RemoveFaultExn::ApplicationException(aexn) => aexn.exn_name(),
                    RemoveFaultExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    RemoveFaultExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    RemoveFaultExn::ApplicationException(aexn) => aexn.exn_value(),
                    RemoveFaultExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    RemoveFaultExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    RemoveFaultExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    RemoveFaultExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for RemoveFaultExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    RemoveFaultExn::Success(_) => ::fbthrift::ResultType::Return,
                    RemoveFaultExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    RemoveFaultExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for RemoveFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for RemoveFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let RemoveFaultExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("RemoveFault");
                match self {
                    RemoveFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Bool,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    RemoveFaultExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for RemoveFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Bool, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Bool, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveFaultExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(RemoveFaultExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "RemoveFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "RemoveFaultExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum UnblockFaultExn {
            Success(::std::primitive::i64),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnblockFaultExn {
            fn from(exn: crate::types::EdenError) -> Self {
                UnblockFaultExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnblockFaultExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                UnblockFaultExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for UnblockFaultExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    UnblockFaultExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    UnblockFaultExn::ApplicationException(aexn) => aexn.exn_name(),
                    UnblockFaultExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    UnblockFaultExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    UnblockFaultExn::ApplicationException(aexn) => aexn.exn_value(),
                    UnblockFaultExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    UnblockFaultExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    UnblockFaultExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    UnblockFaultExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for UnblockFaultExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    UnblockFaultExn::Success(_) => ::fbthrift::ResultType::Return,
                    UnblockFaultExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    UnblockFaultExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for UnblockFaultExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for UnblockFaultExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let UnblockFaultExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("UnblockFault");
                match self {
                    UnblockFaultExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::I64,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    UnblockFaultExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for UnblockFaultExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::I64, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::I64, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnblockFaultExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(UnblockFaultExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "UnblockFaultExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "UnblockFaultExn"),
                    )
                    .into(),
                )
            }
        }

        #[derive(Clone, Debug)]
        pub enum SetPathObjectIdExn {
            Success(crate::types::SetPathObjectIdResult),
            ex(crate::types::EdenError),
            ApplicationException(::fbthrift::ApplicationException),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetPathObjectIdExn {
            fn from(exn: crate::types::EdenError) -> Self {
                SetPathObjectIdExn::ex(exn)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetPathObjectIdExn {
            fn from(exn: ::fbthrift::ApplicationException) -> Self {
                SetPathObjectIdExn::ApplicationException(exn)
            }
        }

        impl ::fbthrift::ExceptionInfo for SetPathObjectIdExn {
            fn exn_name(&self) -> &'static str {
                match self {
                    SetPathObjectIdExn::Success(_) => panic!("ExceptionInfo::exn_name called on Success"),
                    SetPathObjectIdExn::ApplicationException(aexn) => aexn.exn_name(),
                    SetPathObjectIdExn::ex(exn) => exn.exn_name(),
                }
            }

            fn exn_value(&self) -> String {
                match self {
                    SetPathObjectIdExn::Success(_) => panic!("ExceptionInfo::exn_value called on Success"),
                    SetPathObjectIdExn::ApplicationException(aexn) => aexn.exn_value(),
                    SetPathObjectIdExn::ex(exn) => exn.exn_value(),
                }
            }

            fn exn_is_declared(&self) -> bool {
                match self {
                    SetPathObjectIdExn::Success(_) => panic!("ExceptionInfo::exn_is_declared called on Success"),
                    SetPathObjectIdExn::ApplicationException(aexn) => aexn.exn_is_declared(),
                    SetPathObjectIdExn::ex(exn) => exn.exn_is_declared(),
                }
            }
        }

        impl ::fbthrift::ResultInfo for SetPathObjectIdExn {
            fn result_type(&self) -> ::fbthrift::ResultType {
                match self {
                    SetPathObjectIdExn::Success(_) => ::fbthrift::ResultType::Return,
                    SetPathObjectIdExn::ApplicationException(_aexn) => ::fbthrift::ResultType::Exception,
                    SetPathObjectIdExn::ex(_exn) => fbthrift::ResultType::Error,
                }
            }
        }

        impl ::fbthrift::GetTType for SetPathObjectIdExn {
            const TTYPE: ::fbthrift::TType = ::fbthrift::TType::Struct;
        }

        impl<P> ::fbthrift::Serialize<P> for SetPathObjectIdExn
        where
            P: ::fbthrift::ProtocolWriter,
        {
            fn write(&self, p: &mut P) {
                if let SetPathObjectIdExn::ApplicationException(aexn) = self {
                    return aexn.write(p);
                }
                p.write_struct_begin("SetPathObjectId");
                match self {
                    SetPathObjectIdExn::Success(inner) => {
                        p.write_field_begin(
                            "Success",
                            ::fbthrift::TType::Struct,
                            0i16,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetPathObjectIdExn::ex(inner) => {
                        p.write_field_begin(
                            "ex",
                            ::fbthrift::TType::Struct,
                            1,
                        );
                        inner.write(p);
                        p.write_field_end();
                    }
                    SetPathObjectIdExn::ApplicationException(_aexn) => unreachable!(),
                }
                p.write_field_stop();
                p.write_struct_end();
            }
        }

        impl<P> ::fbthrift::Deserialize<P> for SetPathObjectIdExn
        where
            P: ::fbthrift::ProtocolReader,
        {
            fn read(p: &mut P) -> ::anyhow::Result<Self> {
                static RETURNS: &[::fbthrift::Field] = &[
                    ::fbthrift::Field::new("Success", ::fbthrift::TType::Struct, 0),
                    ::fbthrift::Field::new("ex", ::fbthrift::TType::Struct, 1),
                ];
                let _ = p.read_struct_begin(|_| ())?;
                let mut once = false;
                let mut alt = ::std::option::Option::None;
                loop {
                    let (_, fty, fid) = p.read_field_begin(|_| (), RETURNS)?;
                    match ((fty, fid as ::std::primitive::i32), once) {
                        ((::fbthrift::TType::Stop, _), _) => {
                            p.read_field_end()?;
                            break;
                        }
                        ((::fbthrift::TType::Struct, 0i32), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SetPathObjectIdExn::Success(::fbthrift::Deserialize::read(p)?));
                        }
                        ((::fbthrift::TType::Struct, 1), false) => {
                            once = true;
                            alt = ::std::option::Option::Some(SetPathObjectIdExn::ex(::fbthrift::Deserialize::read(p)?));
                        }
                        ((ty, _id), false) => p.skip(ty)?,
                        ((badty, badid), true) => return ::std::result::Result::Err(::std::convert::From::from(
                            ::fbthrift::ApplicationException::new(
                                ::fbthrift::ApplicationExceptionErrorCode::ProtocolError,
                                format!(
                                    "unwanted extra union {} field ty {:?} id {}",
                                    "SetPathObjectIdExn",
                                    badty,
                                    badid,
                                ),
                            )
                        )),
                    }
                    p.read_field_end()?;
                }
                p.read_struct_end()?;
                alt.ok_or_else(||
                    ::fbthrift::ApplicationException::new(
                        ::fbthrift::ApplicationExceptionErrorCode::MissingResult,
                        format!("Empty union {}", "SetPathObjectIdExn"),
                    )
                    .into(),
                )
            }
        }
    }
}

/// Client implementation for each service in `eden`.
pub mod client {

    pub struct EdenServiceImpl<P, T, S = ::fbthrift::NoopSpawner> {
        parent: fb303_core::client::BaseServiceImpl<P, T, S>,
    }

    impl<P, T, S> EdenServiceImpl<P, T, S> {
        pub fn new(
            transport: T,
        ) -> Self {
            let parent = fb303_core::client::BaseServiceImpl::<P, T, S>::new(transport);
            Self { parent }
        }

        pub fn transport(&self) -> &T {
            self.parent.transport()
        }
    }

    impl<P, T, S> ::std::convert::AsRef<dyn crate::dependencies::fb303_core::client::BaseService + 'static> for EdenServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn as_ref(&self) -> &(dyn crate::dependencies::fb303_core::client::BaseService + 'static)
        {
            &self.parent
        }
    }

    pub trait EdenService: fb303_core::client::BaseService + ::std::marker::Send {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>>;
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>>;
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>>;
        #[doc = "Potentially check out the specified snapshot, reporting conflicts (and\npossibly errors), as appropriate.\n\nIf the checkoutMode is FORCE, the working directory will be forcibly\nupdated to the contents of the new snapshot, even if there were conflicts.\nConflicts will still be reported in the return value, but the files will be\nupdated to their new state.\n\nIf the checkoutMode is NORMAL, files with conflicts will be left\nunmodified. Files that are untracked in both the source and destination\nsnapshots are always left unchanged, even if force is true.\n\nIf the checkoutMode is DRY_RUN, then no files are modified in the working\ncopy and the current snapshot does not change. However, potential conflicts\nare still reported in the return value.\n\nOn successful return from this function (unless it is a DRY_RUN), the mount\npoint will point to the new snapshot, even if some paths had conflicts or\nerrors. The caller is responsible for taking appropriate action to update\nthese paths as desired after checkOutRevision() returns.\n\nNote: this internally synchronize the working copy."]
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::ThriftRootId,
            arg_checkoutMode: &crate::types::CheckoutMode,
            arg_params: &crate::types::CheckOutRevisionParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Reset the working directory's parent commits, without changing the working\ndirectory contents.\n\nThis operation is equivalent to `git reset --soft` or `hg reset --keep`"]
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
            arg_params: &crate::types::ResetParentCommitsParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Ensure that all inflight working copy modification have completed.\n\nOn some platforms, EdenFS is processing working copy modifications\ncallbacks from the platform in an asynchronous manner, which means that by\nthe time a write/creat/mkdir/unlink/etc syscall returns from the kernel,\nEdenFS may not have updated its internal state.\n\nThus, an application making changes to the working copy and quickly\nrequesting EdenFS to perform an operation on it will race with EdenFS\nupdating its internal state and may thus get stale data.\n\nTo avoid this, applications can call this method prior to issuing other\nThrift requests (such as getSHA1, globFiles, etc) to wait for EdenFS to\nupdate its internal state. Applications that care about synchronizing\nEdenFS up to a certain point in time are expected to call this once and\nthen issue all their thrift requests without synchronizing.\n\nAs an alternative, applications may also set the SyncBehavior of a Thrift\nmethod to a non-zero value to achieve the same result.\n\nSome Thrift methods are implicitely synchronizing, their documentation\nwill state it."]
        fn synchronizeWorkingCopy(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_params: &crate::types::SynchronizeWorkingCopyParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SynchronizeWorkingCopyError>> + ::std::marker::Send + 'static>>;
        #[doc = "For each path, returns an EdenError instead of the SHA-1 if any of the\nfollowing occur:\n- path is the empty string.\n- path identifies a non-existent file.\n- path identifies something that is not an ordinary file (e.g., symlink\n  or directory).\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns a list of paths relative to the mountPoint. DEPRECATED!"]
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>>;
        #[doc = "On systems that support bind mounts, establish a bind mount within the\nrepo such that `mountPoint / repoPath` is redirected to `targetPath`.\nIf `repoPath` is already a bind mount managed by eden, this function\nwill throw an error.\nIf `repoPath` is not a directory then it will be created similar to\nrunning `mkdir -p mountPoint/repoPath` and then the bind mount\nwill be established.\nIf `repoPath` exists and is not a directory, an error will be thrown.\nIf the bind mount cannot be set up, an error will be thrown."]
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>>;
        #[doc = "Removes the bind mount specified by `repoPath` from the set of managed\nbind mounts.\nIf `repoPath` is not a bind mount managed by eden, this function\nwill throw an error.\nIf the bind mount cannot be removed, an error will be thrown."]
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the sequence position at the time the method is called.\nReturns the instantaneous value of the journal sequence number."]
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the set of files (and dirs) that changed since a prior point.\nIf fromPosition.mountGeneration is mismatched with the current\nmountGeneration, throws an EdenError with errorCode = ERANGE.\nIf the domain required by fromPosition goes past the Journal's memory,\nthrows an EdenError with errorCode = EDOM.\nThis indicates that eden cannot compute the delta for the requested\nrange.  The client will need to recompute a new baseline using\nother available functions in EdenService."]
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>>;
        #[doc = "Sets the memory limit on the journal such that the journal will forget\nold data to keep itself under a certain estimated memory use."]
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the memory limit on the journal"]
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>>;
        #[doc = "Forces the journal to flush, sending a truncated result to subscribers"]
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the journal entries for the specified params. Useful for auditing\nthe changes that Eden has sent to Watchman. Note that the most recent\njournal entries will be at the front of the list in\nDebugGetRawJournalResponse."]
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the subset of information about a list of paths that can\nbe determined from each's parent directory tree. For now, that\nincludes whether the entry exists and its dtype.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns a subset of the stat() information for a list of paths.\nThe returned list of information corresponds to the input list of\npaths; eg; result[0] holds the information for paths[0].\nWe only support returning the instantaneous information about\nthese paths, as we cannot answer with historical information about\nfiles in the overlay.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns the requested file attributes for the provided list of files.\nThe result maps the files to attribute results which may be an EdenError\nor a FileAttributeData struct.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn getAttributesFromFiles(
            &self,
            arg_params: &crate::types::GetAttributesFromFilesParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAttributesFromFilesResult, crate::errors::eden_service::GetAttributesFromFilesError>> + ::std::marker::Send + 'static>>;
        #[doc = "DEPRECATED: Use globFiles().\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, see the\ndocumentation for that method."]
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns a list of files that match the GlobParams, notably,\nthe list of glob patterns.\nThere are no duplicate values in the result.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets a list of a user's most accessed directories, performs\nprefetching as specified by PredictiveGlobParams, and returns\na list of files matching the glob patterns.\nThere are no duplicate values in the result.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn predictiveGlobFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::PredictiveGlobFilesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Chowns all files in the requested mount to the requested uid and gid"]
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>>;
        #[doc = "Return the list of files that are different from the specified source\ncontrol commit.\n\nNote: this internally synchronize the working copy and thus the returned\ndata is guaranteed to return be the set of files that changed prior to\ncalling this method."]
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the status of the working directory against the specified commit.\n\nNote: this internally synchronize the working copy and thus the returned\ndata is guaranteed to return be the set of files that changed prior to\ncalling this method.\n\nDEPRECATED: Prefer using getScmStatusV2() in new code.  Callers may still\nneed to fall back to getScmStatus() if talking to an older edenfs daemon\nthat does not support getScmStatusV2() yet."]
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>>;
        #[doc = "DEPRECATED\n\nComputes the status between two specified revisions.\nThis does not care about the state of the working copy."]
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::ThriftRootId,
            arg_newHash: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns information about the running process, including pid and command\nline."]
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>>;
        #[doc = "Returns information about the privhelper process, including accesibility."]
        fn checkPrivHelper(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::PrivHelperInfo, crate::errors::eden_service::CheckPrivHelperError>> + ::std::marker::Send + 'static>>;
        #[doc = "DEPRECATED\n\nReturns the pid of the running edenfs daemon. New code should call\ngetDaemonInfo instead. This method exists for Thrift clients that\npredate getDaemonInfo, such as older versions of the CLI."]
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>>;
        #[doc = "Ask the server to shutdown and provide it some context for its logs"]
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the current configuration settings"]
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>>;
        #[doc = "Ask eden to reload its configuration data from disk."]
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the contents of a source control Tree.\n\nThis can be used to confirm if eden's LocalStore contains information\nfor the tree, and that the information is correct.\n\nIf localStoreOnly is true, the data is loaded directly from the\nLocalStore, and an error will be raised if it is not already present in\nthe LocalStore.  If localStoreOnly is false, the data may be retrieved\nfrom the BackingStore if it is not already present in the LocalStore."]
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the contents of a source control Blob.\n\nThis can be used to confirm if eden's LocalStore contains information\nfor the blob, and that the information is correct."]
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the metadata about a source control Blob.\n\nThis retrieves the metadata about a source control Blob.  This returns\nthe size and contents SHA1 of the blob, which eden stores separately from\nthe blob itself.  This can also be a useful alternative to\ndebugGetScmBlob() when getting data about extremely large blobs."]
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get status about inodes with allocated inode numbers.\n\nThis returns details about all previously-observed inode objects under the\ngiven path.\n\nIf the path argument is the empty string data will be returned about all\ninodes in the entire mount point.  Otherwise the path argument should\nrefer to a subdirectory, and data will be returned for all inodes under\nthe specified subdirectory.\n\nThe rename lock is not held while gathering this information, so the path\nname information returned may not always be internally consistent.  If\nrenames were taking place while gathering the data, some inodes may show\nup under multiple parents.  It's also possible that we may miss some\ninodes during the tree walk if they were renamed from a directory that was\nnot yet walked into a directory that has already been walked.\n\nThis API cannot return data about inodes that have been unlinked but still\nhave outstanding references.\n\nNote: may return stale data if synchronizeWorkingCopy isn't called, and if\nthe SyncBehavior specify a 0 timeout. see the documentation for both of\nthese for more details."]
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_flags: ::std::primitive::i64,
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the list of outstanding fuse requests\n\nThis will return the list of FuseCall structure containing the data from\nfuse_in_header."]
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the list of outstanding NFS requests\n\nThis will return the list of NfsCall structure containing the data from the RPC request."]
        fn debugOutstandingNfsCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, crate::errors::eden_service::DebugOutstandingNfsCallsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Start recording performance metrics such as files read\n\nThis will return a structure containing unique id identifying this recording."]
        fn debugStartRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_outputDir: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStartRecordingActivityError>> + ::std::marker::Send + 'static>>;
        #[doc = "Stop the recording identified by unique\n\nThis will return a structure containing unique id identifying this recording\nand, if the recording is successfully stopped, the output file path."]
        fn debugStopRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_unique: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStopRecordingActivityError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the list of ongoing activity recordings\n\nThis will return the list of ActivityRecorderResult structure\ncontaining the id and output file path."]
        fn debugListActivityRecordings(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListActivityRecordingsResult, crate::errors::eden_service::DebugListActivityRecordingsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Get the InodePathDebugInfo for the inode that corresponds to the given\ninode number. This provides the path for the inode and also indicates\nwhether the inode is currently loaded or not. Requires that the Eden\nmountPoint be specified."]
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>>;
        #[doc = "Clear pidFetchCounts_ in ObjectStore to start a new recording of process\nfetch counts."]
        fn clearFetchCounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsError>> + ::std::marker::Send + 'static>>;
        fn clearFetchCountsByMount(
            &self,
            arg_mountPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsByMountError>> + ::std::marker::Send + 'static>>;
        #[doc = "Queries all of the live Eden mounts for the processes that accessed FUSE\nover the last `duration` seconds.\n\nNote that eden only maintains a few seconds worth of accesses."]
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Start recording paths of the files fetched from the backing store.\n\nNote that using this call twice will not clear the data and start a new\nrecording."]
        fn startRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::StartRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>>;
        #[doc = "Stop recording paths of the files fetched from the backing store.\n\nNote that using this call will return and clear the previously\ncollected data."]
        fn stopRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetFetchedFilesResult, crate::errors::eden_service::StopRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>>;
        #[doc = "Column by column, clears and compacts the LocalStore. All columns are\ncompacted, but only columns that contain ephemeral data are cleared.\n\nEven though the behavior of this method is identical to\ndebugClearLocalStoreCaches followed by debugCompactLocalStorage(), it is\nseparate so it can clear and compact each column in order to minimize the\nrisk of running out of disk space. Since RocksDB is a write-ahead logging\ndatabase, clearing a column increases its disk usage until it's compacted."]
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>>;
        #[doc = "Clears all data from the LocalStore that can be populated from the upstream\nbacking store."]
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>>;
        #[doc = "Asks RocksDB to perform a compaction."]
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>>;
        #[doc = "Unloads unused Inodes from a directory inside a mountPoint whose last\naccess time is older than the specified age.\n\nThe age parameter is a relative time to be subtracted from the current\n(wall clock) time."]
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>>;
        #[doc = "Flush all thread-local stats to the main ServiceData object.\n\nThread-local counters are normally flushed to the main ServiceData once\na second.  flushStatsNow() can be used to flush thread-local counters on\ndemand, in addition to the normal once-a-second flush.\n\nThis is mainly useful for unit and integration tests that want to ensure\nthey see up-to-date counter information without waiting for the normal\nflush interval."]
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>>;
        #[doc = "Invalidate kernel cache for inode."]
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>>;
        #[doc = "Gets the number of inodes unloaded by periodic job on an EdenMount."]
        fn getStatInfo(
            &self,
            arg_params: &crate::types::GetStatInfoParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>>;
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>>;
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>>;
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>>;
        #[doc = "Configure a new fault in Eden's fault injection framework.\n\nThis throws an exception if the fault injection framework was not enabled\nwhen edenfs was started."]
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>>;
        #[doc = "Remove a fault previously defined with injectFault()\n\nReturns true if a matching fault was found and remove, and false\nif no matching fault was found."]
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>>;
        #[doc = "Unblock fault injection checks pending on a block fault.\n\nReturns the number of pending calls that were unblocked"]
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>>;
        #[doc = "Directly load a BackingStore object identified by id at the given path.\n\nIf any file or directory name conflict, the behavior is same with Checkout\nThis method is thread safe."]
        fn setPathObjectId(
            &self,
            arg_params: &crate::types::SetPathObjectIdParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::SetPathObjectIdResult, crate::errors::eden_service::SetPathObjectIdError>> + ::std::marker::Send + 'static>>;
    }

    struct Args_EdenService_listMounts<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_listMounts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.listMounts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_mount<'a> {
        info: &'a crate::types::MountArgument,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_mount<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.mount"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("info", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.info, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_unmount<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_unmount<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.unmount"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_checkOutRevision<'a> {
        mountPoint: &'a crate::types::PathString,
        snapshotHash: &'a crate::types::ThriftRootId,
        checkoutMode: &'a crate::types::CheckoutMode,
        params: &'a crate::types::CheckOutRevisionParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_checkOutRevision<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.checkOutRevision"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("snapshotHash", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.snapshotHash, p);
            p.write_field_end();
            p.write_field_begin("checkoutMode", ::fbthrift::TType::I32, 3i16);
            ::fbthrift::Serialize::write(&self.checkoutMode, p);
            p.write_field_end();
            p.write_field_begin("params", ::fbthrift::TType::Struct, 4i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_resetParentCommits<'a> {
        mountPoint: &'a crate::types::PathString,
        parents: &'a crate::types::WorkingDirectoryParents,
        params: &'a crate::types::ResetParentCommitsParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_resetParentCommits<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.resetParentCommits"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("parents", ::fbthrift::TType::Struct, 2i16);
            ::fbthrift::Serialize::write(&self.parents, p);
            p.write_field_end();
            p.write_field_begin("params", ::fbthrift::TType::Struct, 3i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_synchronizeWorkingCopy<'a> {
        mountPoint: &'a crate::types::PathString,
        params: &'a crate::types::SynchronizeWorkingCopyParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_synchronizeWorkingCopy<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.synchronizeWorkingCopy"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("params", ::fbthrift::TType::Struct, 2i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getSHA1<'a> {
        mountPoint: &'a crate::types::PathString,
        paths: &'a [crate::types::PathString],
        sync: &'a crate::types::SyncBehavior,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getSHA1<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getSHA1"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("paths", ::fbthrift::TType::List, 2i16);
            ::fbthrift::Serialize::write(&self.paths, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 3i16);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getBindMounts<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getBindMounts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getBindMounts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_addBindMount<'a> {
        mountPoint: &'a crate::types::PathString,
        repoPath: &'a crate::types::PathString,
        targetPath: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_addBindMount<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.addBindMount"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("repoPath", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.repoPath, p);
            p.write_field_end();
            p.write_field_begin("targetPath", ::fbthrift::TType::String, 3i16);
            ::fbthrift::Serialize::write(&self.targetPath, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_removeBindMount<'a> {
        mountPoint: &'a crate::types::PathString,
        repoPath: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_removeBindMount<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.removeBindMount"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("repoPath", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.repoPath, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getCurrentJournalPosition<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getCurrentJournalPosition<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getCurrentJournalPosition"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getFilesChangedSince<'a> {
        mountPoint: &'a crate::types::PathString,
        fromPosition: &'a crate::types::JournalPosition,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getFilesChangedSince<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getFilesChangedSince"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("fromPosition", ::fbthrift::TType::Struct, 2i16);
            ::fbthrift::Serialize::write(&self.fromPosition, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_setJournalMemoryLimit<'a> {
        mountPoint: &'a crate::types::PathString,
        limit: ::std::primitive::i64,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_setJournalMemoryLimit<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.setJournalMemoryLimit"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("limit", ::fbthrift::TType::I64, 2i16);
            ::fbthrift::Serialize::write(&self.limit, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getJournalMemoryLimit<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getJournalMemoryLimit<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getJournalMemoryLimit"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_flushJournal<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_flushJournal<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.flushJournal"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugGetRawJournal<'a> {
        params: &'a crate::types::DebugGetRawJournalParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugGetRawJournal<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugGetRawJournal"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getEntryInformation<'a> {
        mountPoint: &'a crate::types::PathString,
        paths: &'a [crate::types::PathString],
        sync: &'a crate::types::SyncBehavior,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getEntryInformation<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getEntryInformation"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("paths", ::fbthrift::TType::List, 2i16);
            ::fbthrift::Serialize::write(&self.paths, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 3i16);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getFileInformation<'a> {
        mountPoint: &'a crate::types::PathString,
        paths: &'a [crate::types::PathString],
        sync: &'a crate::types::SyncBehavior,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getFileInformation<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getFileInformation"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("paths", ::fbthrift::TType::List, 2i16);
            ::fbthrift::Serialize::write(&self.paths, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 3i16);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getAttributesFromFiles<'a> {
        params: &'a crate::types::GetAttributesFromFilesParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getAttributesFromFiles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getAttributesFromFiles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_glob<'a> {
        mountPoint: &'a crate::types::PathString,
        globs: &'a [::std::string::String],
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_glob<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.glob"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("globs", ::fbthrift::TType::List, 2i16);
            ::fbthrift::Serialize::write(&self.globs, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_globFiles<'a> {
        params: &'a crate::types::GlobParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_globFiles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.globFiles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_predictiveGlobFiles<'a> {
        params: &'a crate::types::GlobParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_predictiveGlobFiles<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.predictiveGlobFiles"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_chown<'a> {
        mountPoint: &'a crate::types::PathString,
        uid: ::std::primitive::i32,
        gid: ::std::primitive::i32,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_chown<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.chown"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("uid", ::fbthrift::TType::I32, 2i16);
            ::fbthrift::Serialize::write(&self.uid, p);
            p.write_field_end();
            p.write_field_begin("gid", ::fbthrift::TType::I32, 3i16);
            ::fbthrift::Serialize::write(&self.gid, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getScmStatusV2<'a> {
        params: &'a crate::types::GetScmStatusParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getScmStatusV2<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getScmStatusV2"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getScmStatus<'a> {
        mountPoint: &'a crate::types::PathString,
        listIgnored: ::std::primitive::bool,
        commit: &'a crate::types::ThriftRootId,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getScmStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getScmStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("listIgnored", ::fbthrift::TType::Bool, 2i16);
            ::fbthrift::Serialize::write(&self.listIgnored, p);
            p.write_field_end();
            p.write_field_begin("commit", ::fbthrift::TType::String, 3i16);
            ::fbthrift::Serialize::write(&self.commit, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getScmStatusBetweenRevisions<'a> {
        mountPoint: &'a crate::types::PathString,
        oldHash: &'a crate::types::ThriftRootId,
        newHash: &'a crate::types::ThriftRootId,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getScmStatusBetweenRevisions<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getScmStatusBetweenRevisions"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("oldHash", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.oldHash, p);
            p.write_field_end();
            p.write_field_begin("newHash", ::fbthrift::TType::String, 3i16);
            ::fbthrift::Serialize::write(&self.newHash, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getDaemonInfo<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getDaemonInfo<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getDaemonInfo"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_checkPrivHelper<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_checkPrivHelper<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.checkPrivHelper"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getPid<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getPid<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getPid"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_initiateShutdown<'a> {
        reason: &'a ::std::primitive::str,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_initiateShutdown<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.initiateShutdown"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("reason", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.reason, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getConfig<'a> {
        params: &'a crate::types::GetConfigParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_reloadConfig<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_reloadConfig<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.reloadConfig"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugGetScmTree<'a> {
        mountPoint: &'a crate::types::PathString,
        id: &'a crate::types::BinaryHash,
        localStoreOnly: ::std::primitive::bool,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugGetScmTree<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugGetScmTree"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("localStoreOnly", ::fbthrift::TType::Bool, 3i16);
            ::fbthrift::Serialize::write(&self.localStoreOnly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugGetScmBlob<'a> {
        mountPoint: &'a crate::types::PathString,
        id: &'a crate::types::BinaryHash,
        localStoreOnly: ::std::primitive::bool,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugGetScmBlob<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugGetScmBlob"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("localStoreOnly", ::fbthrift::TType::Bool, 3i16);
            ::fbthrift::Serialize::write(&self.localStoreOnly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugGetScmBlobMetadata<'a> {
        mountPoint: &'a crate::types::PathString,
        id: &'a crate::types::BinaryHash,
        localStoreOnly: ::std::primitive::bool,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugGetScmBlobMetadata<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugGetScmBlobMetadata"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("id", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.id, p);
            p.write_field_end();
            p.write_field_begin("localStoreOnly", ::fbthrift::TType::Bool, 3i16);
            ::fbthrift::Serialize::write(&self.localStoreOnly, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugInodeStatus<'a> {
        mountPoint: &'a crate::types::PathString,
        path: &'a crate::types::PathString,
        flags: ::std::primitive::i64,
        sync: &'a crate::types::SyncBehavior,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugInodeStatus<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugInodeStatus"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("flags", ::fbthrift::TType::I64, 3i16);
            ::fbthrift::Serialize::write(&self.flags, p);
            p.write_field_end();
            p.write_field_begin("sync", ::fbthrift::TType::Struct, 4i16);
            ::fbthrift::Serialize::write(&self.sync, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugOutstandingFuseCalls<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugOutstandingFuseCalls<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugOutstandingFuseCalls"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugOutstandingNfsCalls<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugOutstandingNfsCalls<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugOutstandingNfsCalls"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugStartRecordingActivity<'a> {
        mountPoint: &'a crate::types::PathString,
        outputDir: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugStartRecordingActivity<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugStartRecordingActivity"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("outputDir", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.outputDir, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugStopRecordingActivity<'a> {
        mountPoint: &'a crate::types::PathString,
        unique: ::std::primitive::i64,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugStopRecordingActivity<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugStopRecordingActivity"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("unique", ::fbthrift::TType::I64, 2i16);
            ::fbthrift::Serialize::write(&self.unique, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugListActivityRecordings<'a> {
        mountPoint: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugListActivityRecordings<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugListActivityRecordings"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugGetInodePath<'a> {
        mountPoint: &'a crate::types::PathString,
        inodeNumber: ::std::primitive::i64,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugGetInodePath<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugGetInodePath"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("inodeNumber", ::fbthrift::TType::I64, 2i16);
            ::fbthrift::Serialize::write(&self.inodeNumber, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_clearFetchCounts<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_clearFetchCounts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.clearFetchCounts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_clearFetchCountsByMount<'a> {
        mountPath: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_clearFetchCountsByMount<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.clearFetchCountsByMount"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPath", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPath, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getAccessCounts<'a> {
        duration: ::std::primitive::i64,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getAccessCounts<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getAccessCounts"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("duration", ::fbthrift::TType::I64, 1i16);
            ::fbthrift::Serialize::write(&self.duration, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_startRecordingBackingStoreFetch<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_startRecordingBackingStoreFetch<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.startRecordingBackingStoreFetch"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_stopRecordingBackingStoreFetch<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_stopRecordingBackingStoreFetch<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.stopRecordingBackingStoreFetch"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_clearAndCompactLocalStore<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_clearAndCompactLocalStore<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.clearAndCompactLocalStore"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugClearLocalStoreCaches<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugClearLocalStoreCaches<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugClearLocalStoreCaches"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_debugCompactLocalStorage<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_debugCompactLocalStorage<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.debugCompactLocalStorage"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_unloadInodeForPath<'a> {
        mountPoint: &'a crate::types::PathString,
        path: &'a crate::types::PathString,
        age: &'a crate::types::TimeSpec,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_unloadInodeForPath<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.unloadInodeForPath"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_begin("age", ::fbthrift::TType::Struct, 3i16);
            ::fbthrift::Serialize::write(&self.age, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_flushStatsNow<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_flushStatsNow<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.flushStatsNow"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_invalidateKernelInodeCache<'a> {
        mountPoint: &'a crate::types::PathString,
        path: &'a crate::types::PathString,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_invalidateKernelInodeCache<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.invalidateKernelInodeCache"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("mountPoint", ::fbthrift::TType::String, 1i16);
            ::fbthrift::Serialize::write(&self.mountPoint, p);
            p.write_field_end();
            p.write_field_begin("path", ::fbthrift::TType::String, 2i16);
            ::fbthrift::Serialize::write(&self.path, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getStatInfo<'a> {
        params: &'a crate::types::GetStatInfoParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getStatInfo<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getStatInfo"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_enableTracing<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_enableTracing<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.enableTracing"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_disableTracing<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_disableTracing<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.disableTracing"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_getTracePoints<'a> {
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_getTracePoints<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.getTracePoints"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_injectFault<'a> {
        fault: &'a crate::types::FaultDefinition,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_injectFault<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.injectFault"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("fault", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.fault, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_removeFault<'a> {
        fault: &'a crate::types::RemoveFaultArg,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_removeFault<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.removeFault"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("fault", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.fault, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_unblockFault<'a> {
        info: &'a crate::types::UnblockFaultArg,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_unblockFault<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.unblockFault"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("info", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.info, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    struct Args_EdenService_setPathObjectId<'a> {
        params: &'a crate::types::SetPathObjectIdParams,
        _phantom: ::std::marker::PhantomData<&'a ()>,
    }

    impl<'a, P: ::fbthrift::ProtocolWriter> ::fbthrift::Serialize<P> for self::Args_EdenService_setPathObjectId<'a> {
        #[inline]
        #[::tracing::instrument(skip_all, level = "trace", name = "serialize_args", fields(method = "EdenService.setPathObjectId"))]
        fn write(&self, p: &mut P) {
            p.write_struct_begin("args");
            p.write_field_begin("params", ::fbthrift::TType::Struct, 1i16);
            ::fbthrift::Serialize::write(&self.params, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P, T, S> EdenService for EdenServiceImpl<P, T, S>
    where
        P: ::fbthrift::Protocol,
        T: ::fbthrift::Transport,
        P::Frame: ::fbthrift::Framing<DecBuf = ::fbthrift::FramingDecoded<T>>,
        ::fbthrift::ProtocolEncoded<P>: ::fbthrift::BufMutExt<Final = ::fbthrift::FramingEncodedFinal<T>>,
        P::Deserializer: ::std::marker::Send,
        S: ::fbthrift::help::Spawner,
    {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.listMounts";
            }
            let args = self::Args_EdenService_listMounts {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("listMounts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.listMounts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ListMountsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ListMountsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.listMounts"))
            .boxed()
        }


        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.mount";
            }
            let args = self::Args_EdenService_mount {
                info: arg_info,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("mount", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.mount"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::MountExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::MountError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.mount"))
            .boxed()
        }


        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.unmount";
            }
            let args = self::Args_EdenService_unmount {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("unmount", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.unmount"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::UnmountExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::UnmountError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.unmount"))
            .boxed()
        }


        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::ThriftRootId,
            arg_checkoutMode: &crate::types::CheckoutMode,
            arg_params: &crate::types::CheckOutRevisionParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.checkOutRevision";
            }
            let args = self::Args_EdenService_checkOutRevision {
                mountPoint: arg_mountPoint,
                snapshotHash: arg_snapshotHash,
                checkoutMode: arg_checkoutMode,
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("checkOutRevision", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.checkOutRevision"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::CheckOutRevisionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::CheckOutRevisionError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.checkOutRevision"))
            .boxed()
        }


        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
            arg_params: &crate::types::ResetParentCommitsParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.resetParentCommits";
            }
            let args = self::Args_EdenService_resetParentCommits {
                mountPoint: arg_mountPoint,
                parents: arg_parents,
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("resetParentCommits", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.resetParentCommits"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ResetParentCommitsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ResetParentCommitsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.resetParentCommits"))
            .boxed()
        }


        fn synchronizeWorkingCopy(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_params: &crate::types::SynchronizeWorkingCopyParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SynchronizeWorkingCopyError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.synchronizeWorkingCopy";
            }
            let args = self::Args_EdenService_synchronizeWorkingCopy {
                mountPoint: arg_mountPoint,
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("synchronizeWorkingCopy", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.synchronizeWorkingCopy"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::SynchronizeWorkingCopyExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::SynchronizeWorkingCopyError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.synchronizeWorkingCopy"))
            .boxed()
        }


        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getSHA1";
            }
            let args = self::Args_EdenService_getSHA1 {
                mountPoint: arg_mountPoint,
                paths: arg_paths,
                sync: arg_sync,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getSHA1", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getSHA1"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetSHA1Exn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetSHA1Error::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getSHA1"))
            .boxed()
        }


        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getBindMounts";
            }
            let args = self::Args_EdenService_getBindMounts {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getBindMounts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getBindMounts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetBindMountsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetBindMountsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getBindMounts"))
            .boxed()
        }


        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.addBindMount";
            }
            let args = self::Args_EdenService_addBindMount {
                mountPoint: arg_mountPoint,
                repoPath: arg_repoPath,
                targetPath: arg_targetPath,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("addBindMount", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.addBindMount"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::AddBindMountExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::AddBindMountError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.addBindMount"))
            .boxed()
        }


        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.removeBindMount";
            }
            let args = self::Args_EdenService_removeBindMount {
                mountPoint: arg_mountPoint,
                repoPath: arg_repoPath,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeBindMount", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.removeBindMount"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::RemoveBindMountExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::RemoveBindMountError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.removeBindMount"))
            .boxed()
        }


        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getCurrentJournalPosition";
            }
            let args = self::Args_EdenService_getCurrentJournalPosition {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getCurrentJournalPosition", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getCurrentJournalPosition"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetCurrentJournalPositionExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetCurrentJournalPositionError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getCurrentJournalPosition"))
            .boxed()
        }


        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getFilesChangedSince";
            }
            let args = self::Args_EdenService_getFilesChangedSince {
                mountPoint: arg_mountPoint,
                fromPosition: arg_fromPosition,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getFilesChangedSince", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getFilesChangedSince"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetFilesChangedSinceExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetFilesChangedSinceError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getFilesChangedSince"))
            .boxed()
        }


        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.setJournalMemoryLimit";
            }
            let args = self::Args_EdenService_setJournalMemoryLimit {
                mountPoint: arg_mountPoint,
                limit: arg_limit,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("setJournalMemoryLimit", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.setJournalMemoryLimit"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::SetJournalMemoryLimitExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::SetJournalMemoryLimitError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.setJournalMemoryLimit"))
            .boxed()
        }


        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getJournalMemoryLimit";
            }
            let args = self::Args_EdenService_getJournalMemoryLimit {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getJournalMemoryLimit", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getJournalMemoryLimit"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetJournalMemoryLimitExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetJournalMemoryLimitError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getJournalMemoryLimit"))
            .boxed()
        }


        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.flushJournal";
            }
            let args = self::Args_EdenService_flushJournal {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("flushJournal", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.flushJournal"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::FlushJournalExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::FlushJournalError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.flushJournal"))
            .boxed()
        }


        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugGetRawJournal";
            }
            let args = self::Args_EdenService_debugGetRawJournal {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugGetRawJournal", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugGetRawJournal"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugGetRawJournalExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetRawJournalError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugGetRawJournal"))
            .boxed()
        }


        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getEntryInformation";
            }
            let args = self::Args_EdenService_getEntryInformation {
                mountPoint: arg_mountPoint,
                paths: arg_paths,
                sync: arg_sync,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getEntryInformation", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getEntryInformation"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetEntryInformationExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetEntryInformationError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getEntryInformation"))
            .boxed()
        }


        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getFileInformation";
            }
            let args = self::Args_EdenService_getFileInformation {
                mountPoint: arg_mountPoint,
                paths: arg_paths,
                sync: arg_sync,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getFileInformation", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getFileInformation"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetFileInformationExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetFileInformationError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getFileInformation"))
            .boxed()
        }


        fn getAttributesFromFiles(
            &self,
            arg_params: &crate::types::GetAttributesFromFilesParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAttributesFromFilesResult, crate::errors::eden_service::GetAttributesFromFilesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getAttributesFromFiles";
            }
            let args = self::Args_EdenService_getAttributesFromFiles {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getAttributesFromFiles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getAttributesFromFiles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetAttributesFromFilesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetAttributesFromFilesError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getAttributesFromFiles"))
            .boxed()
        }


        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.glob";
            }
            let args = self::Args_EdenService_glob {
                mountPoint: arg_mountPoint,
                globs: arg_globs,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("glob", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.glob"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GlobExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GlobError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.glob"))
            .boxed()
        }


        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.globFiles";
            }
            let args = self::Args_EdenService_globFiles {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("globFiles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.globFiles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GlobFilesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GlobFilesError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.globFiles"))
            .boxed()
        }


        fn predictiveGlobFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::PredictiveGlobFilesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.predictiveGlobFiles";
            }
            let args = self::Args_EdenService_predictiveGlobFiles {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("predictiveGlobFiles", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.predictiveGlobFiles"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::PredictiveGlobFilesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::PredictiveGlobFilesError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.predictiveGlobFiles"))
            .boxed()
        }


        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.chown";
            }
            let args = self::Args_EdenService_chown {
                mountPoint: arg_mountPoint,
                uid: arg_uid,
                gid: arg_gid,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("chown", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.chown"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ChownExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ChownError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.chown"))
            .boxed()
        }


        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getScmStatusV2";
            }
            let args = self::Args_EdenService_getScmStatusV2 {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getScmStatusV2", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getScmStatusV2"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetScmStatusV2Exn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusV2Error::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getScmStatusV2"))
            .boxed()
        }


        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getScmStatus";
            }
            let args = self::Args_EdenService_getScmStatus {
                mountPoint: arg_mountPoint,
                listIgnored: arg_listIgnored,
                commit: arg_commit,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getScmStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getScmStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetScmStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getScmStatus"))
            .boxed()
        }


        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::ThriftRootId,
            arg_newHash: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getScmStatusBetweenRevisions";
            }
            let args = self::Args_EdenService_getScmStatusBetweenRevisions {
                mountPoint: arg_mountPoint,
                oldHash: arg_oldHash,
                newHash: arg_newHash,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getScmStatusBetweenRevisions", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getScmStatusBetweenRevisions"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetScmStatusBetweenRevisionsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetScmStatusBetweenRevisionsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getScmStatusBetweenRevisions"))
            .boxed()
        }


        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getDaemonInfo";
            }
            let args = self::Args_EdenService_getDaemonInfo {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getDaemonInfo", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getDaemonInfo"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetDaemonInfoExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetDaemonInfoError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getDaemonInfo"))
            .boxed()
        }


        fn checkPrivHelper(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::PrivHelperInfo, crate::errors::eden_service::CheckPrivHelperError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.checkPrivHelper";
            }
            let args = self::Args_EdenService_checkPrivHelper {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("checkPrivHelper", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.checkPrivHelper"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::CheckPrivHelperExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::CheckPrivHelperError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.checkPrivHelper"))
            .boxed()
        }


        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getPid";
            }
            let args = self::Args_EdenService_getPid {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getPid", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getPid"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetPidExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetPidError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getPid"))
            .boxed()
        }


        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.initiateShutdown";
            }
            let args = self::Args_EdenService_initiateShutdown {
                reason: arg_reason,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("initiateShutdown", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.initiateShutdown"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::InitiateShutdownExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::InitiateShutdownError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.initiateShutdown"))
            .boxed()
        }


        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getConfig";
            }
            let args = self::Args_EdenService_getConfig {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetConfigError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getConfig"))
            .boxed()
        }


        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.reloadConfig";
            }
            let args = self::Args_EdenService_reloadConfig {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("reloadConfig", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.reloadConfig"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ReloadConfigExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ReloadConfigError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.reloadConfig"))
            .boxed()
        }


        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugGetScmTree";
            }
            let args = self::Args_EdenService_debugGetScmTree {
                mountPoint: arg_mountPoint,
                id: arg_id,
                localStoreOnly: arg_localStoreOnly,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugGetScmTree", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugGetScmTree"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugGetScmTreeExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmTreeError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugGetScmTree"))
            .boxed()
        }


        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugGetScmBlob";
            }
            let args = self::Args_EdenService_debugGetScmBlob {
                mountPoint: arg_mountPoint,
                id: arg_id,
                localStoreOnly: arg_localStoreOnly,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugGetScmBlob", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugGetScmBlob"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugGetScmBlobExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugGetScmBlob"))
            .boxed()
        }


        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugGetScmBlobMetadata";
            }
            let args = self::Args_EdenService_debugGetScmBlobMetadata {
                mountPoint: arg_mountPoint,
                id: arg_id,
                localStoreOnly: arg_localStoreOnly,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugGetScmBlobMetadata", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugGetScmBlobMetadata"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugGetScmBlobMetadataExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetScmBlobMetadataError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugGetScmBlobMetadata"))
            .boxed()
        }


        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_flags: ::std::primitive::i64,
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugInodeStatus";
            }
            let args = self::Args_EdenService_debugInodeStatus {
                mountPoint: arg_mountPoint,
                path: arg_path,
                flags: arg_flags,
                sync: arg_sync,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugInodeStatus", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugInodeStatus"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugInodeStatusExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugInodeStatusError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugInodeStatus"))
            .boxed()
        }


        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugOutstandingFuseCalls";
            }
            let args = self::Args_EdenService_debugOutstandingFuseCalls {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugOutstandingFuseCalls", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugOutstandingFuseCalls"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugOutstandingFuseCallsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugOutstandingFuseCallsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugOutstandingFuseCalls"))
            .boxed()
        }


        fn debugOutstandingNfsCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, crate::errors::eden_service::DebugOutstandingNfsCallsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugOutstandingNfsCalls";
            }
            let args = self::Args_EdenService_debugOutstandingNfsCalls {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugOutstandingNfsCalls", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugOutstandingNfsCalls"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugOutstandingNfsCallsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugOutstandingNfsCallsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugOutstandingNfsCalls"))
            .boxed()
        }


        fn debugStartRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_outputDir: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStartRecordingActivityError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugStartRecordingActivity";
            }
            let args = self::Args_EdenService_debugStartRecordingActivity {
                mountPoint: arg_mountPoint,
                outputDir: arg_outputDir,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugStartRecordingActivity", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugStartRecordingActivity"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugStartRecordingActivityExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugStartRecordingActivityError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugStartRecordingActivity"))
            .boxed()
        }


        fn debugStopRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_unique: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStopRecordingActivityError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugStopRecordingActivity";
            }
            let args = self::Args_EdenService_debugStopRecordingActivity {
                mountPoint: arg_mountPoint,
                unique: arg_unique,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugStopRecordingActivity", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugStopRecordingActivity"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugStopRecordingActivityExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugStopRecordingActivityError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugStopRecordingActivity"))
            .boxed()
        }


        fn debugListActivityRecordings(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListActivityRecordingsResult, crate::errors::eden_service::DebugListActivityRecordingsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugListActivityRecordings";
            }
            let args = self::Args_EdenService_debugListActivityRecordings {
                mountPoint: arg_mountPoint,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugListActivityRecordings", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugListActivityRecordings"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugListActivityRecordingsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugListActivityRecordingsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugListActivityRecordings"))
            .boxed()
        }


        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugGetInodePath";
            }
            let args = self::Args_EdenService_debugGetInodePath {
                mountPoint: arg_mountPoint,
                inodeNumber: arg_inodeNumber,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugGetInodePath", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugGetInodePath"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugGetInodePathExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugGetInodePathError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugGetInodePath"))
            .boxed()
        }


        fn clearFetchCounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.clearFetchCounts";
            }
            let args = self::Args_EdenService_clearFetchCounts {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("clearFetchCounts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.clearFetchCounts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ClearFetchCountsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ClearFetchCountsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.clearFetchCounts"))
            .boxed()
        }


        fn clearFetchCountsByMount(
            &self,
            arg_mountPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsByMountError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.clearFetchCountsByMount";
            }
            let args = self::Args_EdenService_clearFetchCountsByMount {
                mountPath: arg_mountPath,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("clearFetchCountsByMount", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.clearFetchCountsByMount"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ClearFetchCountsByMountExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ClearFetchCountsByMountError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.clearFetchCountsByMount"))
            .boxed()
        }


        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getAccessCounts";
            }
            let args = self::Args_EdenService_getAccessCounts {
                duration: arg_duration,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getAccessCounts", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getAccessCounts"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetAccessCountsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetAccessCountsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getAccessCounts"))
            .boxed()
        }


        fn startRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::StartRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.startRecordingBackingStoreFetch";
            }
            let args = self::Args_EdenService_startRecordingBackingStoreFetch {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("startRecordingBackingStoreFetch", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.startRecordingBackingStoreFetch"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::StartRecordingBackingStoreFetchExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::StartRecordingBackingStoreFetchError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.startRecordingBackingStoreFetch"))
            .boxed()
        }


        fn stopRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetFetchedFilesResult, crate::errors::eden_service::StopRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.stopRecordingBackingStoreFetch";
            }
            let args = self::Args_EdenService_stopRecordingBackingStoreFetch {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("stopRecordingBackingStoreFetch", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.stopRecordingBackingStoreFetch"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::StopRecordingBackingStoreFetchExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::StopRecordingBackingStoreFetchError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.stopRecordingBackingStoreFetch"))
            .boxed()
        }


        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.clearAndCompactLocalStore";
            }
            let args = self::Args_EdenService_clearAndCompactLocalStore {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("clearAndCompactLocalStore", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.clearAndCompactLocalStore"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::ClearAndCompactLocalStoreExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::ClearAndCompactLocalStoreError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.clearAndCompactLocalStore"))
            .boxed()
        }


        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugClearLocalStoreCaches";
            }
            let args = self::Args_EdenService_debugClearLocalStoreCaches {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugClearLocalStoreCaches", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugClearLocalStoreCaches"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugClearLocalStoreCachesExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugClearLocalStoreCachesError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugClearLocalStoreCaches"))
            .boxed()
        }


        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.debugCompactLocalStorage";
            }
            let args = self::Args_EdenService_debugCompactLocalStorage {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("debugCompactLocalStorage", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.debugCompactLocalStorage"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DebugCompactLocalStorageExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DebugCompactLocalStorageError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.debugCompactLocalStorage"))
            .boxed()
        }


        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.unloadInodeForPath";
            }
            let args = self::Args_EdenService_unloadInodeForPath {
                mountPoint: arg_mountPoint,
                path: arg_path,
                age: arg_age,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("unloadInodeForPath", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.unloadInodeForPath"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::UnloadInodeForPathExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::UnloadInodeForPathError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.unloadInodeForPath"))
            .boxed()
        }


        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.flushStatsNow";
            }
            let args = self::Args_EdenService_flushStatsNow {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("flushStatsNow", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.flushStatsNow"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::FlushStatsNowExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::FlushStatsNowError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.flushStatsNow"))
            .boxed()
        }


        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.invalidateKernelInodeCache";
            }
            let args = self::Args_EdenService_invalidateKernelInodeCache {
                mountPoint: arg_mountPoint,
                path: arg_path,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("invalidateKernelInodeCache", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.invalidateKernelInodeCache"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::InvalidateKernelInodeCacheExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::InvalidateKernelInodeCacheError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.invalidateKernelInodeCache"))
            .boxed()
        }


        fn getStatInfo(
            &self,
            arg_params: &crate::types::GetStatInfoParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getStatInfo";
            }
            let args = self::Args_EdenService_getStatInfo {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getStatInfo", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getStatInfo"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetStatInfoExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetStatInfoError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getStatInfo"))
            .boxed()
        }


        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.enableTracing";
            }
            let args = self::Args_EdenService_enableTracing {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("enableTracing", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.enableTracing"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::EnableTracingExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::EnableTracingError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.enableTracing"))
            .boxed()
        }


        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.disableTracing";
            }
            let args = self::Args_EdenService_disableTracing {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("disableTracing", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.disableTracing"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::DisableTracingExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::DisableTracingError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.disableTracing"))
            .boxed()
        }


        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.getTracePoints";
            }
            let args = self::Args_EdenService_getTracePoints {
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("getTracePoints", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.getTracePoints"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::GetTracePointsExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::GetTracePointsError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.getTracePoints"))
            .boxed()
        }


        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.injectFault";
            }
            let args = self::Args_EdenService_injectFault {
                fault: arg_fault,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("injectFault", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.injectFault"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::InjectFaultExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::InjectFaultError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.injectFault"))
            .boxed()
        }


        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.removeFault";
            }
            let args = self::Args_EdenService_removeFault {
                fault: arg_fault,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("removeFault", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.removeFault"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::RemoveFaultExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::RemoveFaultError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.removeFault"))
            .boxed()
        }


        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.unblockFault";
            }
            let args = self::Args_EdenService_unblockFault {
                info: arg_info,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("unblockFault", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.unblockFault"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::UnblockFaultExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::UnblockFaultError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.unblockFault"))
            .boxed()
        }


        fn setPathObjectId(
            &self,
            arg_params: &crate::types::SetPathObjectIdParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::SetPathObjectIdResult, crate::errors::eden_service::SetPathObjectIdError>> + ::std::marker::Send + 'static>> {
            use ::const_cstr::const_cstr;
            use ::tracing::Instrument as _;
            use ::futures::FutureExt as _;

            const_cstr! {
                SERVICE_NAME = "EdenService";
                METHOD_NAME = "EdenService.setPathObjectId";
            }
            let args = self::Args_EdenService_setPathObjectId {
                params: arg_params,
                _phantom: ::std::marker::PhantomData,
            };

            // need to do call setup outside of async block because T: Transport isn't Send
            let request_env = match ::fbthrift::help::serialize_request_envelope::<P, _>("setPathObjectId", &args) {
                ::std::result::Result::Ok(res) => res,
                ::std::result::Result::Err(err) => return ::futures::future::err(err.into()).boxed(),
            };

            let call = self.transport()
                .call(SERVICE_NAME.as_cstr(), METHOD_NAME.as_cstr(), request_env)
                .instrument(::tracing::trace_span!("call", function = "EdenService.setPathObjectId"));

            async move {
                let reply_env = call.await?;

                let de = P::deserializer(reply_env);
                let (res, _de): (::std::result::Result<crate::services::eden_service::SetPathObjectIdExn, _>, _) =
                    ::fbthrift::help::async_deserialize_response_envelope::<P, _, S>(de).await?;

                match res {
                    ::std::result::Result::Ok(exn) => ::std::convert::From::from(exn),
                    ::std::result::Result::Err(aexn) =>
                        ::std::result::Result::Err(crate::errors::eden_service::SetPathObjectIdError::ApplicationException(aexn))
                }
            }
            .instrument(::tracing::info_span!("EdenService.setPathObjectId"))
            .boxed()
        }

    }

    impl<'a, T> EdenService for T
    where
        T: ::std::convert::AsRef<dyn EdenService + 'a>,
        T: crate::dependencies::fb303_core::client::BaseService,
        T: ::std::marker::Send,
    {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().listMounts(
            )
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().mount(
                arg_info,
            )
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unmount(
                arg_mountPoint,
            )
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::ThriftRootId,
            arg_checkoutMode: &crate::types::CheckoutMode,
            arg_params: &crate::types::CheckOutRevisionParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().checkOutRevision(
                arg_mountPoint,
                arg_snapshotHash,
                arg_checkoutMode,
                arg_params,
            )
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
            arg_params: &crate::types::ResetParentCommitsParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().resetParentCommits(
                arg_mountPoint,
                arg_parents,
                arg_params,
            )
        }
        fn synchronizeWorkingCopy(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_params: &crate::types::SynchronizeWorkingCopyParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SynchronizeWorkingCopyError>> + ::std::marker::Send + 'static>> {
            self.as_ref().synchronizeWorkingCopy(
                arg_mountPoint,
                arg_params,
            )
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            self.as_ref().getSHA1(
                arg_mountPoint,
                arg_paths,
                arg_sync,
            )
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getBindMounts(
                arg_mountPoint,
            )
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().addBindMount(
                arg_mountPoint,
                arg_repoPath,
                arg_targetPath,
            )
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeBindMount(
                arg_mountPoint,
                arg_repoPath,
            )
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getCurrentJournalPosition(
                arg_mountPoint,
            )
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getFilesChangedSince(
                arg_mountPoint,
                arg_fromPosition,
            )
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setJournalMemoryLimit(
                arg_mountPoint,
                arg_limit,
            )
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getJournalMemoryLimit(
                arg_mountPoint,
            )
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            self.as_ref().flushJournal(
                arg_mountPoint,
            )
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetRawJournal(
                arg_params,
            )
        }
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getEntryInformation(
                arg_mountPoint,
                arg_paths,
                arg_sync,
            )
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getFileInformation(
                arg_mountPoint,
                arg_paths,
                arg_sync,
            )
        }
        fn getAttributesFromFiles(
            &self,
            arg_params: &crate::types::GetAttributesFromFilesParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAttributesFromFilesResult, crate::errors::eden_service::GetAttributesFromFilesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getAttributesFromFiles(
                arg_params,
            )
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().glob(
                arg_mountPoint,
                arg_globs,
            )
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().globFiles(
                arg_params,
            )
        }
        fn predictiveGlobFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::PredictiveGlobFilesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().predictiveGlobFiles(
                arg_params,
            )
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            self.as_ref().chown(
                arg_mountPoint,
                arg_uid,
                arg_gid,
            )
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatusV2(
                arg_params,
            )
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatus(
                arg_mountPoint,
                arg_listIgnored,
                arg_commit,
            )
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::ThriftRootId,
            arg_newHash: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getScmStatusBetweenRevisions(
                arg_mountPoint,
                arg_oldHash,
                arg_newHash,
            )
        }
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getDaemonInfo(
            )
        }
        fn checkPrivHelper(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::PrivHelperInfo, crate::errors::eden_service::CheckPrivHelperError>> + ::std::marker::Send + 'static>> {
            self.as_ref().checkPrivHelper(
            )
        }
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getPid(
            )
        }
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            self.as_ref().initiateShutdown(
                arg_reason,
            )
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getConfig(
                arg_params,
            )
        }
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            self.as_ref().reloadConfig(
            )
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmTree(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmBlob(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetScmBlobMetadata(
                arg_mountPoint,
                arg_id,
                arg_localStoreOnly,
            )
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_flags: ::std::primitive::i64,
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugInodeStatus(
                arg_mountPoint,
                arg_path,
                arg_flags,
                arg_sync,
            )
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugOutstandingFuseCalls(
                arg_mountPoint,
            )
        }
        fn debugOutstandingNfsCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, crate::errors::eden_service::DebugOutstandingNfsCallsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugOutstandingNfsCalls(
                arg_mountPoint,
            )
        }
        fn debugStartRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_outputDir: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStartRecordingActivityError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugStartRecordingActivity(
                arg_mountPoint,
                arg_outputDir,
            )
        }
        fn debugStopRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_unique: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStopRecordingActivityError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugStopRecordingActivity(
                arg_mountPoint,
                arg_unique,
            )
        }
        fn debugListActivityRecordings(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListActivityRecordingsResult, crate::errors::eden_service::DebugListActivityRecordingsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugListActivityRecordings(
                arg_mountPoint,
            )
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugGetInodePath(
                arg_mountPoint,
                arg_inodeNumber,
            )
        }
        fn clearFetchCounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().clearFetchCounts(
            )
        }
        fn clearFetchCountsByMount(
            &self,
            arg_mountPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsByMountError>> + ::std::marker::Send + 'static>> {
            self.as_ref().clearFetchCountsByMount(
                arg_mountPath,
            )
        }
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getAccessCounts(
                arg_duration,
            )
        }
        fn startRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::StartRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            self.as_ref().startRecordingBackingStoreFetch(
            )
        }
        fn stopRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetFetchedFilesResult, crate::errors::eden_service::StopRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            self.as_ref().stopRecordingBackingStoreFetch(
            )
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            self.as_ref().clearAndCompactLocalStore(
            )
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugClearLocalStoreCaches(
            )
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            self.as_ref().debugCompactLocalStorage(
            )
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unloadInodeForPath(
                arg_mountPoint,
                arg_path,
                arg_age,
            )
        }
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            self.as_ref().flushStatsNow(
            )
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            self.as_ref().invalidateKernelInodeCache(
                arg_mountPoint,
                arg_path,
            )
        }
        fn getStatInfo(
            &self,
            arg_params: &crate::types::GetStatInfoParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getStatInfo(
                arg_params,
            )
        }
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            self.as_ref().enableTracing(
            )
        }
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            self.as_ref().disableTracing(
            )
        }
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            self.as_ref().getTracePoints(
            )
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().injectFault(
                arg_fault,
            )
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().removeFault(
                arg_fault,
            )
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            self.as_ref().unblockFault(
                arg_info,
            )
        }
        fn setPathObjectId(
            &self,
            arg_params: &crate::types::SetPathObjectIdParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::SetPathObjectIdResult, crate::errors::eden_service::SetPathObjectIdError>> + ::std::marker::Send + 'static>> {
            self.as_ref().setPathObjectId(
                arg_params,
            )
        }
    }

    #[derive(Clone)]
    pub struct make_EdenService;

    /// To be called by user directly setting up a client. Avoids
    /// needing ClientFactory trait in scope, avoids unidiomatic
    /// make_Trait name.
    ///
    /// ```
    /// # const _: &str = stringify! {
    /// use bgs::client::BuckGraphService;
    ///
    /// let protocol = BinaryProtocol::new();
    /// let transport = HttpClient::new();
    /// let client = <dyn BuckGraphService>::new(protocol, transport);
    /// # };
    /// ```
    impl dyn EdenService {
        pub fn new<P, T>(
            protocol: P,
            transport: T,
        ) -> ::std::sync::Arc<impl EdenService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
        {
            let spawner = ::fbthrift::help::NoopSpawner;
            Self::with_spawner(protocol, transport, spawner)
        }

        pub fn with_spawner<P, T, S>(
            protocol: P,
            transport: T,
            spawner: S,
        ) -> ::std::sync::Arc<impl EdenService + ::std::marker::Send + 'static>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            let _ = protocol;
            let _ = spawner;
            ::std::sync::Arc::new(EdenServiceImpl::<P, T, S>::new(transport))
        }
    }

    pub type EdenServiceDynClient = <make_EdenService as ::fbthrift::ClientFactory>::Api;
    pub type EdenServiceClient = ::std::sync::Arc<EdenServiceDynClient>;

    /// The same thing, but to be called from generic contexts where we are
    /// working with a type parameter `C: ClientFactory` to produce clients.
    impl ::fbthrift::ClientFactory for make_EdenService {
        type Api = dyn EdenService + ::std::marker::Send + ::std::marker::Sync + 'static;

        fn with_spawner<P, T, S>(protocol: P, transport: T, spawner: S) -> ::std::sync::Arc<Self::Api>
        where
            P: ::fbthrift::Protocol<Frame = T>,
            T: ::fbthrift::Transport + ::std::marker::Sync,
            P::Deserializer: ::std::marker::Send,
            S: ::fbthrift::help::Spawner,
        {
            <dyn EdenService>::with_spawner(protocol, transport, spawner)
        }
    }


}


/// Client mocks. For every service, a struct mock::TheService that implements
/// client::TheService.
///
/// As an example of the generated API, for the following thrift service:
///
/// ```thrift
/// service MyService {
///     FunctionResponse myFunction(
///         1: FunctionRequest request,
///     ) throws {
///         1: StorageException s,
///         2: NotFoundException n,
///     ),
///
///     // other functions
/// }
/// ```
///
/// we would end up with this mock object under crate::mock::MyService:
///
/// ```
/// # const _: &str = stringify! {
/// impl crate::client::MyService for MyService<'mock> {...}
///
/// pub struct MyService<'mock> {
///     pub myFunction: myFunction<'mock>,
///     // ...
/// }
///
/// impl dyn crate::client::MyService {
///     pub fn mock<'mock>() -> MyService<'mock>;
/// }
///
/// impl myFunction<'mock> {
///     // directly return the given success response
///     pub fn ret(&self, value: FunctionResponse);
///
///     // invoke closure to compute success response
///     pub fn mock(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> FunctionResponse + Send + Sync + 'mock,
///     );
///
///     // invoke closure to compute response
///     pub fn mock_result(
///         &self,
///         mock: impl FnMut(FunctionRequest) -> Result<FunctionResponse, crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock,
///     );
///
///     // return one of the function's declared exceptions
///     pub fn throw<E>(&self, exception: E)
///     where
///         E: Clone + Into<crate::services::MyService::MyFunctionExn> + Send + Sync + 'mock;
/// }
///
/// impl From<StorageException> for MyFunctionExn {...}
/// impl From<NotFoundException> for MyFunctionExn {...}
/// # };
/// ```
///
/// The intended usage from a test would be:
///
/// ```
/// # const _: &str = stringify! {
/// use std::sync::Arc;
/// use thrift_if::client::MyService;
///
/// #[test]
/// fn test_my_client() {
///     let mock = Arc::new(<dyn MyService>::mock());
///
///     // directly return a success response
///     let resp = FunctionResponse {...};
///     mock.myFunction.ret(resp);
///
///     // or give a closure to compute the success response
///     mock.myFunction.mock(|request| FunctionResponse {...});
///
///     // or throw one of the function's exceptions
///     mock.myFunction.throw(StorageException::ItFailed);
///
///     // or compute a Result (useful if your exceptions aren't Clone)
///     mock.myFunction.mock_result(|request| Err(...));
///
///     let out = do_the_thing(mock).wait().unwrap();
///     assert!(out.what_i_expected());
/// }
///
/// fn do_the_thing(
///     client: Arc<dyn MyService + Send + Sync + 'static>,
/// ) -> impl Future<Item = Out> {...}
/// # };
/// ```
pub mod mock {
    pub struct EdenService<'mock> {
        pub parent: fb303_core::mock::BaseService<'mock>,
        pub listMounts: r#impl::eden_service::listMounts<'mock>,
        pub mount: r#impl::eden_service::mount<'mock>,
        pub unmount: r#impl::eden_service::unmount<'mock>,
        pub checkOutRevision: r#impl::eden_service::checkOutRevision<'mock>,
        pub resetParentCommits: r#impl::eden_service::resetParentCommits<'mock>,
        pub synchronizeWorkingCopy: r#impl::eden_service::synchronizeWorkingCopy<'mock>,
        pub getSHA1: r#impl::eden_service::getSHA1<'mock>,
        pub getBindMounts: r#impl::eden_service::getBindMounts<'mock>,
        pub addBindMount: r#impl::eden_service::addBindMount<'mock>,
        pub removeBindMount: r#impl::eden_service::removeBindMount<'mock>,
        pub getCurrentJournalPosition: r#impl::eden_service::getCurrentJournalPosition<'mock>,
        pub getFilesChangedSince: r#impl::eden_service::getFilesChangedSince<'mock>,
        pub setJournalMemoryLimit: r#impl::eden_service::setJournalMemoryLimit<'mock>,
        pub getJournalMemoryLimit: r#impl::eden_service::getJournalMemoryLimit<'mock>,
        pub flushJournal: r#impl::eden_service::flushJournal<'mock>,
        pub debugGetRawJournal: r#impl::eden_service::debugGetRawJournal<'mock>,
        pub getEntryInformation: r#impl::eden_service::getEntryInformation<'mock>,
        pub getFileInformation: r#impl::eden_service::getFileInformation<'mock>,
        pub getAttributesFromFiles: r#impl::eden_service::getAttributesFromFiles<'mock>,
        pub glob: r#impl::eden_service::glob<'mock>,
        pub globFiles: r#impl::eden_service::globFiles<'mock>,
        pub predictiveGlobFiles: r#impl::eden_service::predictiveGlobFiles<'mock>,
        pub chown: r#impl::eden_service::chown<'mock>,
        pub getScmStatusV2: r#impl::eden_service::getScmStatusV2<'mock>,
        pub getScmStatus: r#impl::eden_service::getScmStatus<'mock>,
        pub getScmStatusBetweenRevisions: r#impl::eden_service::getScmStatusBetweenRevisions<'mock>,
        pub getDaemonInfo: r#impl::eden_service::getDaemonInfo<'mock>,
        pub checkPrivHelper: r#impl::eden_service::checkPrivHelper<'mock>,
        pub getPid: r#impl::eden_service::getPid<'mock>,
        pub initiateShutdown: r#impl::eden_service::initiateShutdown<'mock>,
        pub getConfig: r#impl::eden_service::getConfig<'mock>,
        pub reloadConfig: r#impl::eden_service::reloadConfig<'mock>,
        pub debugGetScmTree: r#impl::eden_service::debugGetScmTree<'mock>,
        pub debugGetScmBlob: r#impl::eden_service::debugGetScmBlob<'mock>,
        pub debugGetScmBlobMetadata: r#impl::eden_service::debugGetScmBlobMetadata<'mock>,
        pub debugInodeStatus: r#impl::eden_service::debugInodeStatus<'mock>,
        pub debugOutstandingFuseCalls: r#impl::eden_service::debugOutstandingFuseCalls<'mock>,
        pub debugOutstandingNfsCalls: r#impl::eden_service::debugOutstandingNfsCalls<'mock>,
        pub debugStartRecordingActivity: r#impl::eden_service::debugStartRecordingActivity<'mock>,
        pub debugStopRecordingActivity: r#impl::eden_service::debugStopRecordingActivity<'mock>,
        pub debugListActivityRecordings: r#impl::eden_service::debugListActivityRecordings<'mock>,
        pub debugGetInodePath: r#impl::eden_service::debugGetInodePath<'mock>,
        pub clearFetchCounts: r#impl::eden_service::clearFetchCounts<'mock>,
        pub clearFetchCountsByMount: r#impl::eden_service::clearFetchCountsByMount<'mock>,
        pub getAccessCounts: r#impl::eden_service::getAccessCounts<'mock>,
        pub startRecordingBackingStoreFetch: r#impl::eden_service::startRecordingBackingStoreFetch<'mock>,
        pub stopRecordingBackingStoreFetch: r#impl::eden_service::stopRecordingBackingStoreFetch<'mock>,
        pub clearAndCompactLocalStore: r#impl::eden_service::clearAndCompactLocalStore<'mock>,
        pub debugClearLocalStoreCaches: r#impl::eden_service::debugClearLocalStoreCaches<'mock>,
        pub debugCompactLocalStorage: r#impl::eden_service::debugCompactLocalStorage<'mock>,
        pub unloadInodeForPath: r#impl::eden_service::unloadInodeForPath<'mock>,
        pub flushStatsNow: r#impl::eden_service::flushStatsNow<'mock>,
        pub invalidateKernelInodeCache: r#impl::eden_service::invalidateKernelInodeCache<'mock>,
        pub getStatInfo: r#impl::eden_service::getStatInfo<'mock>,
        pub enableTracing: r#impl::eden_service::enableTracing<'mock>,
        pub disableTracing: r#impl::eden_service::disableTracing<'mock>,
        pub getTracePoints: r#impl::eden_service::getTracePoints<'mock>,
        pub injectFault: r#impl::eden_service::injectFault<'mock>,
        pub removeFault: r#impl::eden_service::removeFault<'mock>,
        pub unblockFault: r#impl::eden_service::unblockFault<'mock>,
        pub setPathObjectId: r#impl::eden_service::setPathObjectId<'mock>,
        _marker: ::std::marker::PhantomData<&'mock ()>,
    }

    impl dyn super::client::EdenService {
        pub fn mock<'mock>() -> EdenService<'mock> {
            EdenService {
                parent: <dyn fb303_core::client::BaseService>::mock(),
                listMounts: r#impl::eden_service::listMounts::unimplemented(),
                mount: r#impl::eden_service::mount::unimplemented(),
                unmount: r#impl::eden_service::unmount::unimplemented(),
                checkOutRevision: r#impl::eden_service::checkOutRevision::unimplemented(),
                resetParentCommits: r#impl::eden_service::resetParentCommits::unimplemented(),
                synchronizeWorkingCopy: r#impl::eden_service::synchronizeWorkingCopy::unimplemented(),
                getSHA1: r#impl::eden_service::getSHA1::unimplemented(),
                getBindMounts: r#impl::eden_service::getBindMounts::unimplemented(),
                addBindMount: r#impl::eden_service::addBindMount::unimplemented(),
                removeBindMount: r#impl::eden_service::removeBindMount::unimplemented(),
                getCurrentJournalPosition: r#impl::eden_service::getCurrentJournalPosition::unimplemented(),
                getFilesChangedSince: r#impl::eden_service::getFilesChangedSince::unimplemented(),
                setJournalMemoryLimit: r#impl::eden_service::setJournalMemoryLimit::unimplemented(),
                getJournalMemoryLimit: r#impl::eden_service::getJournalMemoryLimit::unimplemented(),
                flushJournal: r#impl::eden_service::flushJournal::unimplemented(),
                debugGetRawJournal: r#impl::eden_service::debugGetRawJournal::unimplemented(),
                getEntryInformation: r#impl::eden_service::getEntryInformation::unimplemented(),
                getFileInformation: r#impl::eden_service::getFileInformation::unimplemented(),
                getAttributesFromFiles: r#impl::eden_service::getAttributesFromFiles::unimplemented(),
                glob: r#impl::eden_service::glob::unimplemented(),
                globFiles: r#impl::eden_service::globFiles::unimplemented(),
                predictiveGlobFiles: r#impl::eden_service::predictiveGlobFiles::unimplemented(),
                chown: r#impl::eden_service::chown::unimplemented(),
                getScmStatusV2: r#impl::eden_service::getScmStatusV2::unimplemented(),
                getScmStatus: r#impl::eden_service::getScmStatus::unimplemented(),
                getScmStatusBetweenRevisions: r#impl::eden_service::getScmStatusBetweenRevisions::unimplemented(),
                getDaemonInfo: r#impl::eden_service::getDaemonInfo::unimplemented(),
                checkPrivHelper: r#impl::eden_service::checkPrivHelper::unimplemented(),
                getPid: r#impl::eden_service::getPid::unimplemented(),
                initiateShutdown: r#impl::eden_service::initiateShutdown::unimplemented(),
                getConfig: r#impl::eden_service::getConfig::unimplemented(),
                reloadConfig: r#impl::eden_service::reloadConfig::unimplemented(),
                debugGetScmTree: r#impl::eden_service::debugGetScmTree::unimplemented(),
                debugGetScmBlob: r#impl::eden_service::debugGetScmBlob::unimplemented(),
                debugGetScmBlobMetadata: r#impl::eden_service::debugGetScmBlobMetadata::unimplemented(),
                debugInodeStatus: r#impl::eden_service::debugInodeStatus::unimplemented(),
                debugOutstandingFuseCalls: r#impl::eden_service::debugOutstandingFuseCalls::unimplemented(),
                debugOutstandingNfsCalls: r#impl::eden_service::debugOutstandingNfsCalls::unimplemented(),
                debugStartRecordingActivity: r#impl::eden_service::debugStartRecordingActivity::unimplemented(),
                debugStopRecordingActivity: r#impl::eden_service::debugStopRecordingActivity::unimplemented(),
                debugListActivityRecordings: r#impl::eden_service::debugListActivityRecordings::unimplemented(),
                debugGetInodePath: r#impl::eden_service::debugGetInodePath::unimplemented(),
                clearFetchCounts: r#impl::eden_service::clearFetchCounts::unimplemented(),
                clearFetchCountsByMount: r#impl::eden_service::clearFetchCountsByMount::unimplemented(),
                getAccessCounts: r#impl::eden_service::getAccessCounts::unimplemented(),
                startRecordingBackingStoreFetch: r#impl::eden_service::startRecordingBackingStoreFetch::unimplemented(),
                stopRecordingBackingStoreFetch: r#impl::eden_service::stopRecordingBackingStoreFetch::unimplemented(),
                clearAndCompactLocalStore: r#impl::eden_service::clearAndCompactLocalStore::unimplemented(),
                debugClearLocalStoreCaches: r#impl::eden_service::debugClearLocalStoreCaches::unimplemented(),
                debugCompactLocalStorage: r#impl::eden_service::debugCompactLocalStorage::unimplemented(),
                unloadInodeForPath: r#impl::eden_service::unloadInodeForPath::unimplemented(),
                flushStatsNow: r#impl::eden_service::flushStatsNow::unimplemented(),
                invalidateKernelInodeCache: r#impl::eden_service::invalidateKernelInodeCache::unimplemented(),
                getStatInfo: r#impl::eden_service::getStatInfo::unimplemented(),
                enableTracing: r#impl::eden_service::enableTracing::unimplemented(),
                disableTracing: r#impl::eden_service::disableTracing::unimplemented(),
                getTracePoints: r#impl::eden_service::getTracePoints::unimplemented(),
                injectFault: r#impl::eden_service::injectFault::unimplemented(),
                removeFault: r#impl::eden_service::removeFault::unimplemented(),
                unblockFault: r#impl::eden_service::unblockFault::unimplemented(),
                setPathObjectId: r#impl::eden_service::setPathObjectId::unimplemented(),
                _marker: ::std::marker::PhantomData,
            }
        }
    }

    impl<'mock> super::client::EdenService for EdenService<'mock> {
        fn listMounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.listMounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn mount(
            &self,
            arg_info: &crate::types::MountArgument,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::MountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.mount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::MountArgument) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_info.clone())))
        }
        fn unmount(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::UnmountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unmount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn checkOutRevision(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_snapshotHash: &crate::types::ThriftRootId,
            arg_checkoutMode: &crate::types::CheckoutMode,
            arg_params: &crate::types::CheckOutRevisionParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.checkOutRevision.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::CheckoutMode, crate::types::CheckOutRevisionParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_snapshotHash.clone(), arg_checkoutMode.clone(), arg_params.clone())))
        }
        fn resetParentCommits(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_parents: &crate::types::WorkingDirectoryParents,
            arg_params: &crate::types::ResetParentCommitsParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.resetParentCommits.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents, crate::types::ResetParentCommitsParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_parents.clone(), arg_params.clone())))
        }
        fn synchronizeWorkingCopy(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_params: &crate::types::SynchronizeWorkingCopyParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SynchronizeWorkingCopyError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.synchronizeWorkingCopy.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::SynchronizeWorkingCopyParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_params.clone())))
        }
        fn getSHA1(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getSHA1.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned(), arg_sync.clone())))
        }
        fn getBindMounts(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getBindMounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn addBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
            arg_targetPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::AddBindMountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.addBindMount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone(), arg_targetPath.clone())))
        }
        fn removeBindMount(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_repoPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeBindMount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_repoPath.clone())))
        }
        fn getCurrentJournalPosition(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getCurrentJournalPosition.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn getFilesChangedSince(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_fromPosition: &crate::types::JournalPosition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getFilesChangedSince.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_fromPosition.clone())))
        }
        fn setJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_limit: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_limit.clone())))
        }
        fn getJournalMemoryLimit(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getJournalMemoryLimit.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn flushJournal(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushJournalError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.flushJournal.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugGetRawJournal(
            &self,
            arg_params: &crate::types::DebugGetRawJournalParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetRawJournal.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn getEntryInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getEntryInformation.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned(), arg_sync.clone())))
        }
        fn getFileInformation(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_paths: &[crate::types::PathString],
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getFileInformation.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_paths.to_owned(), arg_sync.clone())))
        }
        fn getAttributesFromFiles(
            &self,
            arg_params: &crate::types::GetAttributesFromFilesParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAttributesFromFilesResult, crate::errors::eden_service::GetAttributesFromFilesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getAttributesFromFiles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetAttributesFromFilesParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn glob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_globs: &[::std::string::String],
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.glob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_globs.to_owned())))
        }
        fn globFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.globFiles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GlobParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn predictiveGlobFiles(
            &self,
            arg_params: &crate::types::GlobParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::Glob, crate::errors::eden_service::PredictiveGlobFilesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.predictiveGlobFiles.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GlobParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn chown(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_uid: ::std::primitive::i32,
            arg_gid: ::std::primitive::i32,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ChownError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.chown.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_uid.clone(), arg_gid.clone())))
        }
        fn getScmStatusV2(
            &self,
            arg_params: &crate::types::GetScmStatusParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatusV2.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetScmStatusParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn getScmStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_listIgnored: ::std::primitive::bool,
            arg_commit: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::ThriftRootId) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_listIgnored.clone(), arg_commit.clone())))
        }
        fn getScmStatusBetweenRevisions(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_oldHash: &crate::types::ThriftRootId,
            arg_newHash: &crate::types::ThriftRootId,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getScmStatusBetweenRevisions.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::ThriftRootId) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_oldHash.clone(), arg_newHash.clone())))
        }
        fn getDaemonInfo(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getDaemonInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn checkPrivHelper(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::PrivHelperInfo, crate::errors::eden_service::CheckPrivHelperError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.checkPrivHelper.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getPid(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getPid.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn initiateShutdown(
            &self,
            arg_reason: &::std::primitive::str,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.initiateShutdown.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::string::String) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_reason.to_owned())))
        }
        fn getConfig(
            &self,
            arg_params: &crate::types::GetConfigParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetConfigParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn reloadConfig(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.reloadConfig.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugGetScmTree(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmTree.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugGetScmBlob(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmBlob.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugGetScmBlobMetadata(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_id: &crate::types::BinaryHash,
            arg_localStoreOnly: ::std::primitive::bool,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetScmBlobMetadata.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_id.clone(), arg_localStoreOnly.clone())))
        }
        fn debugInodeStatus(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_flags: ::std::primitive::i64,
            arg_sync: &crate::types::SyncBehavior,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugInodeStatus.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, ::std::primitive::i64, crate::types::SyncBehavior) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone(), arg_flags.clone(), arg_sync.clone())))
        }
        fn debugOutstandingFuseCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugOutstandingFuseCalls.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugOutstandingNfsCalls(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, crate::errors::eden_service::DebugOutstandingNfsCallsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugOutstandingNfsCalls.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugStartRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_outputDir: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStartRecordingActivityError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugStartRecordingActivity.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_outputDir.clone())))
        }
        fn debugStopRecordingActivity(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_unique: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStopRecordingActivityError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugStopRecordingActivity.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_unique.clone())))
        }
        fn debugListActivityRecordings(
            &self,
            arg_mountPoint: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::ListActivityRecordingsResult, crate::errors::eden_service::DebugListActivityRecordingsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugListActivityRecordings.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone())))
        }
        fn debugGetInodePath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_inodeNumber: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugGetInodePath.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_inodeNumber.clone())))
        }
        fn clearFetchCounts(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.clearFetchCounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn clearFetchCountsByMount(
            &self,
            arg_mountPath: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsByMountError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.clearFetchCountsByMount.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPath.clone())))
        }
        fn getAccessCounts(
            &self,
            arg_duration: ::std::primitive::i64,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getAccessCounts.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(::std::primitive::i64) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_duration.clone())))
        }
        fn startRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::StartRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.startRecordingBackingStoreFetch.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn stopRecordingBackingStoreFetch(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::GetFetchedFilesResult, crate::errors::eden_service::StopRecordingBackingStoreFetchError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.stopRecordingBackingStoreFetch.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn clearAndCompactLocalStore(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.clearAndCompactLocalStore.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugClearLocalStoreCaches(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugClearLocalStoreCaches.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn debugCompactLocalStorage(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.debugCompactLocalStorage.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn unloadInodeForPath(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
            arg_age: &crate::types::TimeSpec,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unloadInodeForPath.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone(), arg_age.clone())))
        }
        fn flushStatsNow(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.flushStatsNow.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn invalidateKernelInodeCache(
            &self,
            arg_mountPoint: &crate::types::PathString,
            arg_path: &crate::types::PathString,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.invalidateKernelInodeCache.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_mountPoint.clone(), arg_path.clone())))
        }
        fn getStatInfo(
            &self,
            arg_params: &crate::types::GetStatInfoParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getStatInfo.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::GetStatInfoParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
        fn enableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::EnableTracingError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.enableTracing.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn disableTracing(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::DisableTracingError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.disableTracing.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn getTracePoints(
            &self,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.getTracePoints.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut() -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure()))
        }
        fn injectFault(
            &self,
            arg_fault: &crate::types::FaultDefinition,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<(), crate::errors::eden_service::InjectFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.injectFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::FaultDefinition) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_fault.clone())))
        }
        fn removeFault(
            &self,
            arg_fault: &crate::types::RemoveFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.removeFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::RemoveFaultArg) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_fault.clone())))
        }
        fn unblockFault(
            &self,
            arg_info: &crate::types::UnblockFaultArg,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.unblockFault.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::UnblockFaultArg) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_info.clone())))
        }
        fn setPathObjectId(
            &self,
            arg_params: &crate::types::SetPathObjectIdParams,
        ) -> ::std::pin::Pin<::std::boxed::Box<dyn ::std::future::Future<Output = ::std::result::Result<crate::types::SetPathObjectIdResult, crate::errors::eden_service::SetPathObjectIdError>> + ::std::marker::Send + 'static>> {
            let mut closure = self.setPathObjectId.closure.lock().unwrap();
            let closure: &mut dyn ::std::ops::FnMut(crate::types::SetPathObjectIdParams) -> _ = &mut **closure;
            ::std::boxed::Box::pin(::futures::future::ready(closure(arg_params.clone())))
        }
    }

    #[::async_trait::async_trait]
    impl<'mock> ::std::convert::AsRef<dyn crate::dependencies::fb303_core::client::BaseService + 'mock> for EdenService<'mock>
    {
        fn as_ref(&self) -> &(dyn crate::dependencies::fb303_core::client::BaseService + 'mock) {
            self
        }
    }

    mod r#impl {
        pub mod eden_service {

            pub struct listMounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::MountInfo>,
                        crate::errors::eden_service::ListMountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> listMounts<'mock> {
                pub fn unimplemented() -> Self {
                    listMounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "listMounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::MountInfo>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::vec::Vec<crate::types::MountInfo> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, crate::errors::eden_service::ListMountsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ListMountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct mount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::MountArgument) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::MountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> mount<'mock> {
                pub fn unimplemented() -> Self {
                    mount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::MountArgument| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "mount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::MountArgument| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::MountArgument) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| ::std::result::Result::Ok(mock(info)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::MountArgument) -> ::std::result::Result<(), crate::errors::eden_service::MountError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| mock(info));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::MountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::MountArgument| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unmount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::UnmountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unmount<'mock> {
                pub fn unimplemented() -> Self {
                    unmount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unmount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::UnmountError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnmountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkOutRevision<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::CheckoutMode, crate::types::CheckOutRevisionParams) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::CheckoutConflict>,
                        crate::errors::eden_service::CheckOutRevisionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> checkOutRevision<'mock> {
                pub fn unimplemented() -> Self {
                    checkOutRevision {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::CheckoutMode, _: crate::types::CheckOutRevisionParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "checkOutRevision",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::CheckoutConflict>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::CheckoutMode, _: crate::types::CheckOutRevisionParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::CheckoutMode, crate::types::CheckOutRevisionParams) -> ::std::vec::Vec<crate::types::CheckoutConflict> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, snapshotHash, checkoutMode, params| ::std::result::Result::Ok(mock(mountPoint, snapshotHash, checkoutMode, params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::CheckoutMode, crate::types::CheckOutRevisionParams) -> ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, crate::errors::eden_service::CheckOutRevisionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, snapshotHash, checkoutMode, params| mock(mountPoint, snapshotHash, checkoutMode, params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::CheckOutRevisionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::CheckoutMode, _: crate::types::CheckOutRevisionParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct resetParentCommits<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents, crate::types::ResetParentCommitsParams) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ResetParentCommitsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> resetParentCommits<'mock> {
                pub fn unimplemented() -> Self {
                    resetParentCommits {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::WorkingDirectoryParents, _: crate::types::ResetParentCommitsParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "resetParentCommits",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents, _: crate::types::ResetParentCommitsParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents, crate::types::ResetParentCommitsParams) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, parents, params| ::std::result::Result::Ok(mock(mountPoint, parents, params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::WorkingDirectoryParents, crate::types::ResetParentCommitsParams) -> ::std::result::Result<(), crate::errors::eden_service::ResetParentCommitsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, parents, params| mock(mountPoint, parents, params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ResetParentCommitsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::WorkingDirectoryParents, _: crate::types::ResetParentCommitsParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct synchronizeWorkingCopy<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::SynchronizeWorkingCopyParams) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::SynchronizeWorkingCopyError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> synchronizeWorkingCopy<'mock> {
                pub fn unimplemented() -> Self {
                    synchronizeWorkingCopy {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::SynchronizeWorkingCopyParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "synchronizeWorkingCopy",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::SynchronizeWorkingCopyParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::SynchronizeWorkingCopyParams) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, params| ::std::result::Result::Ok(mock(mountPoint, params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::SynchronizeWorkingCopyParams) -> ::std::result::Result<(), crate::errors::eden_service::SynchronizeWorkingCopyError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, params| mock(mountPoint, params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::SynchronizeWorkingCopyError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::SynchronizeWorkingCopyParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getSHA1<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::SHA1Result>,
                        crate::errors::eden_service::GetSHA1Error,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getSHA1<'mock> {
                pub fn unimplemented() -> Self {
                    getSHA1 {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getSHA1",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::SHA1Result>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::vec::Vec<crate::types::SHA1Result> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| ::std::result::Result::Ok(mock(mountPoint, paths, sync)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, crate::errors::eden_service::GetSHA1Error> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| mock(mountPoint, paths, sync));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetSHA1Error>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getBindMounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::PathString>,
                        crate::errors::eden_service::GetBindMountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getBindMounts<'mock> {
                pub fn unimplemented() -> Self {
                    getBindMounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getBindMounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::PathString>) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::vec::Vec<crate::types::PathString> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GetBindMountsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetBindMountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct addBindMount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::AddBindMountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> addBindMount<'mock> {
                pub fn unimplemented() -> Self {
                    addBindMount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "addBindMount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath, targetPath| ::std::result::Result::Ok(mock(mountPoint, repoPath, targetPath)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::AddBindMountError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath, targetPath| mock(mountPoint, repoPath, targetPath));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::AddBindMountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeBindMount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::RemoveBindMountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeBindMount<'mock> {
                pub fn unimplemented() -> Self {
                    removeBindMount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "removeBindMount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath| ::std::result::Result::Ok(mock(mountPoint, repoPath)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::RemoveBindMountError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, repoPath| mock(mountPoint, repoPath));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::RemoveBindMountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getCurrentJournalPosition<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        crate::types::JournalPosition,
                        crate::errors::eden_service::GetCurrentJournalPositionError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getCurrentJournalPosition<'mock> {
                pub fn unimplemented() -> Self {
                    getCurrentJournalPosition {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getCurrentJournalPosition",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::JournalPosition) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> crate::types::JournalPosition + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<crate::types::JournalPosition, crate::errors::eden_service::GetCurrentJournalPositionError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetCurrentJournalPositionError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getFilesChangedSince<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> ::std::result::Result<
                        crate::types::FileDelta,
                        crate::errors::eden_service::GetFilesChangedSinceError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getFilesChangedSince<'mock> {
                pub fn unimplemented() -> Self {
                    getFilesChangedSince {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::JournalPosition| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getFilesChangedSince",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::FileDelta) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::JournalPosition| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> crate::types::FileDelta + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, fromPosition| ::std::result::Result::Ok(mock(mountPoint, fromPosition)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::JournalPosition) -> ::std::result::Result<crate::types::FileDelta, crate::errors::eden_service::GetFilesChangedSinceError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, fromPosition| mock(mountPoint, fromPosition));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetFilesChangedSinceError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::JournalPosition| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setJournalMemoryLimit<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::SetJournalMemoryLimitError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setJournalMemoryLimit<'mock> {
                pub fn unimplemented() -> Self {
                    setJournalMemoryLimit {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "setJournalMemoryLimit",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, limit| ::std::result::Result::Ok(mock(mountPoint, limit)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<(), crate::errors::eden_service::SetJournalMemoryLimitError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, limit| mock(mountPoint, limit));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::SetJournalMemoryLimitError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getJournalMemoryLimit<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::GetJournalMemoryLimitError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getJournalMemoryLimit<'mock> {
                pub fn unimplemented() -> Self {
                    getJournalMemoryLimit {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getJournalMemoryLimit",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetJournalMemoryLimitError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetJournalMemoryLimitError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct flushJournal<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::FlushJournalError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> flushJournal<'mock> {
                pub fn unimplemented() -> Self {
                    flushJournal {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "flushJournal",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::FlushJournalError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::FlushJournalError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetRawJournal<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> ::std::result::Result<
                        crate::types::DebugGetRawJournalResponse,
                        crate::errors::eden_service::DebugGetRawJournalError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetRawJournal<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetRawJournal {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::DebugGetRawJournalParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetRawJournal",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::DebugGetRawJournalResponse) {
                    self.mock(move |_: crate::types::DebugGetRawJournalParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> crate::types::DebugGetRawJournalResponse + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::DebugGetRawJournalParams) -> ::std::result::Result<crate::types::DebugGetRawJournalResponse, crate::errors::eden_service::DebugGetRawJournalError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetRawJournalError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::DebugGetRawJournalParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getEntryInformation<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::EntryInformationOrError>,
                        crate::errors::eden_service::GetEntryInformationError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getEntryInformation<'mock> {
                pub fn unimplemented() -> Self {
                    getEntryInformation {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getEntryInformation",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::EntryInformationOrError>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::vec::Vec<crate::types::EntryInformationOrError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| ::std::result::Result::Ok(mock(mountPoint, paths, sync)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, crate::errors::eden_service::GetEntryInformationError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| mock(mountPoint, paths, sync));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetEntryInformationError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getFileInformation<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::FileInformationOrError>,
                        crate::errors::eden_service::GetFileInformationError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getFileInformation<'mock> {
                pub fn unimplemented() -> Self {
                    getFileInformation {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getFileInformation",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::FileInformationOrError>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::vec::Vec<crate::types::FileInformationOrError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| ::std::result::Result::Ok(mock(mountPoint, paths, sync)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<crate::types::PathString>, crate::types::SyncBehavior) -> ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, crate::errors::eden_service::GetFileInformationError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, paths, sync| mock(mountPoint, paths, sync));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetFileInformationError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<crate::types::PathString>, _: crate::types::SyncBehavior| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getAttributesFromFiles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetAttributesFromFilesParams) -> ::std::result::Result<
                        crate::types::GetAttributesFromFilesResult,
                        crate::errors::eden_service::GetAttributesFromFilesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getAttributesFromFiles<'mock> {
                pub fn unimplemented() -> Self {
                    getAttributesFromFiles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetAttributesFromFilesParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getAttributesFromFiles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetAttributesFromFilesResult) {
                    self.mock(move |_: crate::types::GetAttributesFromFilesParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetAttributesFromFilesParams) -> crate::types::GetAttributesFromFilesResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetAttributesFromFilesParams) -> ::std::result::Result<crate::types::GetAttributesFromFilesResult, crate::errors::eden_service::GetAttributesFromFilesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetAttributesFromFilesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetAttributesFromFilesParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct glob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::PathString>,
                        crate::errors::eden_service::GlobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> glob<'mock> {
                pub fn unimplemented() -> Self {
                    glob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "glob",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::PathString>) {
                    self.mock(move |_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> ::std::vec::Vec<crate::types::PathString> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, globs| ::std::result::Result::Ok(mock(mountPoint, globs)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::vec::Vec<::std::string::String>) -> ::std::result::Result<::std::vec::Vec<crate::types::PathString>, crate::errors::eden_service::GlobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, globs| mock(mountPoint, globs));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GlobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::vec::Vec<::std::string::String>| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct globFiles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GlobParams) -> ::std::result::Result<
                        crate::types::Glob,
                        crate::errors::eden_service::GlobFilesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> globFiles<'mock> {
                pub fn unimplemented() -> Self {
                    globFiles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GlobParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "globFiles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::Glob) {
                    self.mock(move |_: crate::types::GlobParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GlobParams) -> crate::types::Glob + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GlobParams) -> ::std::result::Result<crate::types::Glob, crate::errors::eden_service::GlobFilesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GlobFilesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GlobParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct predictiveGlobFiles<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GlobParams) -> ::std::result::Result<
                        crate::types::Glob,
                        crate::errors::eden_service::PredictiveGlobFilesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> predictiveGlobFiles<'mock> {
                pub fn unimplemented() -> Self {
                    predictiveGlobFiles {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GlobParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "predictiveGlobFiles",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::Glob) {
                    self.mock(move |_: crate::types::GlobParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GlobParams) -> crate::types::Glob + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GlobParams) -> ::std::result::Result<crate::types::Glob, crate::errors::eden_service::PredictiveGlobFilesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::PredictiveGlobFilesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GlobParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct chown<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ChownError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> chown<'mock> {
                pub fn unimplemented() -> Self {
                    chown {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "chown",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, uid, gid| ::std::result::Result::Ok(mock(mountPoint, uid, gid)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i32, ::std::primitive::i32) -> ::std::result::Result<(), crate::errors::eden_service::ChownError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, uid, gid| mock(mountPoint, uid, gid));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ChownError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i32, _: ::std::primitive::i32| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatusV2<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetScmStatusParams) -> ::std::result::Result<
                        crate::types::GetScmStatusResult,
                        crate::errors::eden_service::GetScmStatusV2Error,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatusV2<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatusV2 {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetScmStatusParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatusV2",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetScmStatusResult) {
                    self.mock(move |_: crate::types::GetScmStatusParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetScmStatusParams) -> crate::types::GetScmStatusResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetScmStatusParams) -> ::std::result::Result<crate::types::GetScmStatusResult, crate::errors::eden_service::GetScmStatusV2Error> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusV2Error>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetScmStatusParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::ThriftRootId) -> ::std::result::Result<
                        crate::types::ScmStatus,
                        crate::errors::eden_service::GetScmStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatus<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::ThriftRootId| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmStatus) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::ThriftRootId| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::ThriftRootId) -> crate::types::ScmStatus + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, listIgnored, commit| ::std::result::Result::Ok(mock(mountPoint, listIgnored, commit)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::bool, crate::types::ThriftRootId) -> ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, listIgnored, commit| mock(mountPoint, listIgnored, commit));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::bool, _: crate::types::ThriftRootId| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getScmStatusBetweenRevisions<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::ThriftRootId) -> ::std::result::Result<
                        crate::types::ScmStatus,
                        crate::errors::eden_service::GetScmStatusBetweenRevisionsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getScmStatusBetweenRevisions<'mock> {
                pub fn unimplemented() -> Self {
                    getScmStatusBetweenRevisions {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::ThriftRootId| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getScmStatusBetweenRevisions",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmStatus) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::ThriftRootId| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::ThriftRootId) -> crate::types::ScmStatus + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, oldHash, newHash| ::std::result::Result::Ok(mock(mountPoint, oldHash, newHash)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::ThriftRootId, crate::types::ThriftRootId) -> ::std::result::Result<crate::types::ScmStatus, crate::errors::eden_service::GetScmStatusBetweenRevisionsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, oldHash, newHash| mock(mountPoint, oldHash, newHash));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetScmStatusBetweenRevisionsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::ThriftRootId, _: crate::types::ThriftRootId| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getDaemonInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::DaemonInfo,
                        crate::errors::eden_service::GetDaemonInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getDaemonInfo<'mock> {
                pub fn unimplemented() -> Self {
                    getDaemonInfo {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getDaemonInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::DaemonInfo) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::DaemonInfo + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<crate::types::DaemonInfo, crate::errors::eden_service::GetDaemonInfoError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetDaemonInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct checkPrivHelper<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::PrivHelperInfo,
                        crate::errors::eden_service::CheckPrivHelperError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> checkPrivHelper<'mock> {
                pub fn unimplemented() -> Self {
                    checkPrivHelper {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "checkPrivHelper",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::PrivHelperInfo) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::PrivHelperInfo + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<crate::types::PrivHelperInfo, crate::errors::eden_service::CheckPrivHelperError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::CheckPrivHelperError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getPid<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::GetPidError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getPid<'mock> {
                pub fn unimplemented() -> Self {
                    getPid {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getPid",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::GetPidError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetPidError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct initiateShutdown<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InitiateShutdownError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> initiateShutdown<'mock> {
                pub fn unimplemented() -> Self {
                    initiateShutdown {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::string::String| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "initiateShutdown",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: ::std::string::String| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |reason| ::std::result::Result::Ok(mock(reason)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::string::String) -> ::std::result::Result<(), crate::errors::eden_service::InitiateShutdownError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |reason| mock(reason));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InitiateShutdownError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::string::String| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetConfigParams) -> ::std::result::Result<
                        eden_config::types::EdenConfigData,
                        crate::errors::eden_service::GetConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getConfig<'mock> {
                pub fn unimplemented() -> Self {
                    getConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetConfigParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: eden_config::types::EdenConfigData) {
                    self.mock(move |_: crate::types::GetConfigParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigParams) -> eden_config::types::EdenConfigData + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetConfigParams) -> ::std::result::Result<eden_config::types::EdenConfigData, crate::errors::eden_service::GetConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetConfigParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct reloadConfig<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ReloadConfigError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> reloadConfig<'mock> {
                pub fn unimplemented() -> Self {
                    reloadConfig {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "reloadConfig",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::ReloadConfigError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ReloadConfigError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmTree<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::ScmTreeEntry>,
                        crate::errors::eden_service::DebugGetScmTreeError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmTree<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmTree {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmTree",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::ScmTreeEntry>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::vec::Vec<crate::types::ScmTreeEntry> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, crate::errors::eden_service::DebugGetScmTreeError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| mock(mountPoint, id, localStoreOnly));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmTreeError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmBlob<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        ::std::vec::Vec<::std::primitive::u8>,
                        crate::errors::eden_service::DebugGetScmBlobError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmBlob<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmBlob {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmBlob",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<::std::primitive::u8>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::vec::Vec<::std::primitive::u8> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, crate::errors::eden_service::DebugGetScmBlobError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| mock(mountPoint, id, localStoreOnly));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmBlobError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetScmBlobMetadata<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<
                        crate::types::ScmBlobMetadata,
                        crate::errors::eden_service::DebugGetScmBlobMetadataError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetScmBlobMetadata<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetScmBlobMetadata {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetScmBlobMetadata",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ScmBlobMetadata) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> crate::types::ScmBlobMetadata + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| ::std::result::Result::Ok(mock(mountPoint, id, localStoreOnly)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::BinaryHash, ::std::primitive::bool) -> ::std::result::Result<crate::types::ScmBlobMetadata, crate::errors::eden_service::DebugGetScmBlobMetadataError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, id, localStoreOnly| mock(mountPoint, id, localStoreOnly));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetScmBlobMetadataError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::BinaryHash, _: ::std::primitive::bool| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugInodeStatus<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, ::std::primitive::i64, crate::types::SyncBehavior) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::TreeInodeDebugInfo>,
                        crate::errors::eden_service::DebugInodeStatusError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugInodeStatus<'mock> {
                pub fn unimplemented() -> Self {
                    debugInodeStatus {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: ::std::primitive::i64, _: crate::types::SyncBehavior| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugInodeStatus",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::TreeInodeDebugInfo>) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: ::std::primitive::i64, _: crate::types::SyncBehavior| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, ::std::primitive::i64, crate::types::SyncBehavior) -> ::std::vec::Vec<crate::types::TreeInodeDebugInfo> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path, flags, sync| ::std::result::Result::Ok(mock(mountPoint, path, flags, sync)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, ::std::primitive::i64, crate::types::SyncBehavior) -> ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, crate::errors::eden_service::DebugInodeStatusError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path, flags, sync| mock(mountPoint, path, flags, sync));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugInodeStatusError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: ::std::primitive::i64, _: crate::types::SyncBehavior| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugOutstandingFuseCalls<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::FuseCall>,
                        crate::errors::eden_service::DebugOutstandingFuseCallsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugOutstandingFuseCalls<'mock> {
                pub fn unimplemented() -> Self {
                    debugOutstandingFuseCalls {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugOutstandingFuseCalls",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::FuseCall>) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::vec::Vec<crate::types::FuseCall> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, crate::errors::eden_service::DebugOutstandingFuseCallsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugOutstandingFuseCallsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugOutstandingNfsCalls<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::NfsCall>,
                        crate::errors::eden_service::DebugOutstandingNfsCallsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugOutstandingNfsCalls<'mock> {
                pub fn unimplemented() -> Self {
                    debugOutstandingNfsCalls {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugOutstandingNfsCalls",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::NfsCall>) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::vec::Vec<crate::types::NfsCall> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, crate::errors::eden_service::DebugOutstandingNfsCallsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugOutstandingNfsCallsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugStartRecordingActivity<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        crate::types::ActivityRecorderResult,
                        crate::errors::eden_service::DebugStartRecordingActivityError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugStartRecordingActivity<'mock> {
                pub fn unimplemented() -> Self {
                    debugStartRecordingActivity {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugStartRecordingActivity",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ActivityRecorderResult) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> crate::types::ActivityRecorderResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, outputDir| ::std::result::Result::Ok(mock(mountPoint, outputDir)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStartRecordingActivityError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, outputDir| mock(mountPoint, outputDir));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugStartRecordingActivityError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugStopRecordingActivity<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<
                        crate::types::ActivityRecorderResult,
                        crate::errors::eden_service::DebugStopRecordingActivityError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugStopRecordingActivity<'mock> {
                pub fn unimplemented() -> Self {
                    debugStopRecordingActivity {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugStopRecordingActivity",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ActivityRecorderResult) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> crate::types::ActivityRecorderResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, unique| ::std::result::Result::Ok(mock(mountPoint, unique)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<crate::types::ActivityRecorderResult, crate::errors::eden_service::DebugStopRecordingActivityError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, unique| mock(mountPoint, unique));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugStopRecordingActivityError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugListActivityRecordings<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        crate::types::ListActivityRecordingsResult,
                        crate::errors::eden_service::DebugListActivityRecordingsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugListActivityRecordings<'mock> {
                pub fn unimplemented() -> Self {
                    debugListActivityRecordings {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugListActivityRecordings",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::ListActivityRecordingsResult) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> crate::types::ListActivityRecordingsResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| ::std::result::Result::Ok(mock(mountPoint)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<crate::types::ListActivityRecordingsResult, crate::errors::eden_service::DebugListActivityRecordingsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint| mock(mountPoint));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugListActivityRecordingsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugGetInodePath<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<
                        crate::types::InodePathDebugInfo,
                        crate::errors::eden_service::DebugGetInodePathError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugGetInodePath<'mock> {
                pub fn unimplemented() -> Self {
                    debugGetInodePath {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugGetInodePath",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::InodePathDebugInfo) {
                    self.mock(move |_: crate::types::PathString, _: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> crate::types::InodePathDebugInfo + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, inodeNumber| ::std::result::Result::Ok(mock(mountPoint, inodeNumber)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, ::std::primitive::i64) -> ::std::result::Result<crate::types::InodePathDebugInfo, crate::errors::eden_service::DebugGetInodePathError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, inodeNumber| mock(mountPoint, inodeNumber));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugGetInodePathError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct clearFetchCounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ClearFetchCountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> clearFetchCounts<'mock> {
                pub fn unimplemented() -> Self {
                    clearFetchCounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "clearFetchCounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ClearFetchCountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct clearFetchCountsByMount<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ClearFetchCountsByMountError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> clearFetchCountsByMount<'mock> {
                pub fn unimplemented() -> Self {
                    clearFetchCountsByMount {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "clearFetchCountsByMount",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPath| ::std::result::Result::Ok(mock(mountPath)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::ClearFetchCountsByMountError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPath| mock(mountPath));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ClearFetchCountsByMountError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getAccessCounts<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(::std::primitive::i64) -> ::std::result::Result<
                        crate::types::GetAccessCountsResult,
                        crate::errors::eden_service::GetAccessCountsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getAccessCounts<'mock> {
                pub fn unimplemented() -> Self {
                    getAccessCounts {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: ::std::primitive::i64| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getAccessCounts",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetAccessCountsResult) {
                    self.mock(move |_: ::std::primitive::i64| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i64) -> crate::types::GetAccessCountsResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |duration| ::std::result::Result::Ok(mock(duration)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(::std::primitive::i64) -> ::std::result::Result<crate::types::GetAccessCountsResult, crate::errors::eden_service::GetAccessCountsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |duration| mock(duration));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetAccessCountsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: ::std::primitive::i64| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct startRecordingBackingStoreFetch<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::StartRecordingBackingStoreFetchError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> startRecordingBackingStoreFetch<'mock> {
                pub fn unimplemented() -> Self {
                    startRecordingBackingStoreFetch {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "startRecordingBackingStoreFetch",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::StartRecordingBackingStoreFetchError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::StartRecordingBackingStoreFetchError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct stopRecordingBackingStoreFetch<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        crate::types::GetFetchedFilesResult,
                        crate::errors::eden_service::StopRecordingBackingStoreFetchError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> stopRecordingBackingStoreFetch<'mock> {
                pub fn unimplemented() -> Self {
                    stopRecordingBackingStoreFetch {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "stopRecordingBackingStoreFetch",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::GetFetchedFilesResult) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> crate::types::GetFetchedFilesResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<crate::types::GetFetchedFilesResult, crate::errors::eden_service::StopRecordingBackingStoreFetchError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::StopRecordingBackingStoreFetchError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct clearAndCompactLocalStore<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::ClearAndCompactLocalStoreError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> clearAndCompactLocalStore<'mock> {
                pub fn unimplemented() -> Self {
                    clearAndCompactLocalStore {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "clearAndCompactLocalStore",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::ClearAndCompactLocalStoreError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::ClearAndCompactLocalStoreError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugClearLocalStoreCaches<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DebugClearLocalStoreCachesError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugClearLocalStoreCaches<'mock> {
                pub fn unimplemented() -> Self {
                    debugClearLocalStoreCaches {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugClearLocalStoreCaches",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::DebugClearLocalStoreCachesError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugClearLocalStoreCachesError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct debugCompactLocalStorage<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DebugCompactLocalStorageError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> debugCompactLocalStorage<'mock> {
                pub fn unimplemented() -> Self {
                    debugCompactLocalStorage {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "debugCompactLocalStorage",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::DebugCompactLocalStorageError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DebugCompactLocalStorageError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unloadInodeForPath<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::UnloadInodeForPathError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unloadInodeForPath<'mock> {
                pub fn unimplemented() -> Self {
                    unloadInodeForPath {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unloadInodeForPath",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path, age| ::std::result::Result::Ok(mock(mountPoint, path, age)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString, crate::types::TimeSpec) -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnloadInodeForPathError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path, age| mock(mountPoint, path, age));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnloadInodeForPathError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString, _: crate::types::TimeSpec| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct flushStatsNow<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::FlushStatsNowError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> flushStatsNow<'mock> {
                pub fn unimplemented() -> Self {
                    flushStatsNow {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "flushStatsNow",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::FlushStatsNowError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::FlushStatsNowError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct invalidateKernelInodeCache<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InvalidateKernelInodeCacheError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> invalidateKernelInodeCache<'mock> {
                pub fn unimplemented() -> Self {
                    invalidateKernelInodeCache {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::PathString, _: crate::types::PathString| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "invalidateKernelInodeCache",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::PathString, _: crate::types::PathString| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path| ::std::result::Result::Ok(mock(mountPoint, path)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::PathString, crate::types::PathString) -> ::std::result::Result<(), crate::errors::eden_service::InvalidateKernelInodeCacheError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |mountPoint, path| mock(mountPoint, path));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InvalidateKernelInodeCacheError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::PathString, _: crate::types::PathString| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getStatInfo<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::GetStatInfoParams) -> ::std::result::Result<
                        crate::types::InternalStats,
                        crate::errors::eden_service::GetStatInfoError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getStatInfo<'mock> {
                pub fn unimplemented() -> Self {
                    getStatInfo {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::GetStatInfoParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getStatInfo",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::InternalStats) {
                    self.mock(move |_: crate::types::GetStatInfoParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatInfoParams) -> crate::types::InternalStats + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::GetStatInfoParams) -> ::std::result::Result<crate::types::InternalStats, crate::errors::eden_service::GetStatInfoError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetStatInfoError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::GetStatInfoParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct enableTracing<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::EnableTracingError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> enableTracing<'mock> {
                pub fn unimplemented() -> Self {
                    enableTracing {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "enableTracing",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::EnableTracingError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::EnableTracingError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct disableTracing<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::DisableTracingError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> disableTracing<'mock> {
                pub fn unimplemented() -> Self {
                    disableTracing {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "disableTracing",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<(), crate::errors::eden_service::DisableTracingError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::DisableTracingError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct getTracePoints<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut() -> ::std::result::Result<
                        ::std::vec::Vec<crate::types::TracePoint>,
                        crate::errors::eden_service::GetTracePointsError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> getTracePoints<'mock> {
                pub fn unimplemented() -> Self {
                    getTracePoints {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "getTracePoints",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::vec::Vec<crate::types::TracePoint>) {
                    self.mock(move || value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut() -> ::std::vec::Vec<crate::types::TracePoint> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Ok(mock()));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut() -> ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, crate::errors::eden_service::GetTracePointsError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || mock());
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::GetTracePointsError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move || ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct injectFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::FaultDefinition) -> ::std::result::Result<
                        (),
                        crate::errors::eden_service::InjectFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> injectFault<'mock> {
                pub fn unimplemented() -> Self {
                    injectFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::FaultDefinition| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "injectFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ()) {
                    self.mock(move |_: crate::types::FaultDefinition| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::FaultDefinition) -> () + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| ::std::result::Result::Ok(mock(fault)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::FaultDefinition) -> ::std::result::Result<(), crate::errors::eden_service::InjectFaultError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| mock(fault));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::InjectFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::FaultDefinition| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct removeFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::RemoveFaultArg) -> ::std::result::Result<
                        ::std::primitive::bool,
                        crate::errors::eden_service::RemoveFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> removeFault<'mock> {
                pub fn unimplemented() -> Self {
                    removeFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::RemoveFaultArg| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "removeFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::bool) {
                    self.mock(move |_: crate::types::RemoveFaultArg| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveFaultArg) -> ::std::primitive::bool + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| ::std::result::Result::Ok(mock(fault)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::RemoveFaultArg) -> ::std::result::Result<::std::primitive::bool, crate::errors::eden_service::RemoveFaultError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |fault| mock(fault));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::RemoveFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::RemoveFaultArg| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct unblockFault<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::UnblockFaultArg) -> ::std::result::Result<
                        ::std::primitive::i64,
                        crate::errors::eden_service::UnblockFaultError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> unblockFault<'mock> {
                pub fn unimplemented() -> Self {
                    unblockFault {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::UnblockFaultArg| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "unblockFault",
                        ))),
                    }
                }

                pub fn ret(&self, value: ::std::primitive::i64) {
                    self.mock(move |_: crate::types::UnblockFaultArg| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::UnblockFaultArg) -> ::std::primitive::i64 + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| ::std::result::Result::Ok(mock(info)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::UnblockFaultArg) -> ::std::result::Result<::std::primitive::i64, crate::errors::eden_service::UnblockFaultError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |info| mock(info));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::UnblockFaultError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::UnblockFaultArg| ::std::result::Result::Err(exception.clone().into()));
                }
            }

            pub struct setPathObjectId<'mock> {
                pub(crate) closure: ::std::sync::Mutex<::std::boxed::Box<
                    dyn ::std::ops::FnMut(crate::types::SetPathObjectIdParams) -> ::std::result::Result<
                        crate::types::SetPathObjectIdResult,
                        crate::errors::eden_service::SetPathObjectIdError,
                    > + ::std::marker::Send + ::std::marker::Sync + 'mock,
                >>,
            }

            impl<'mock> setPathObjectId<'mock> {
                pub fn unimplemented() -> Self {
                    setPathObjectId {
                        closure: ::std::sync::Mutex::new(::std::boxed::Box::new(|_: crate::types::SetPathObjectIdParams| panic!(
                            "{}::{} is not mocked",
                            "EdenService",
                            "setPathObjectId",
                        ))),
                    }
                }

                pub fn ret(&self, value: crate::types::SetPathObjectIdResult) {
                    self.mock(move |_: crate::types::SetPathObjectIdParams| value.clone());
                }

                pub fn mock(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetPathObjectIdParams) -> crate::types::SetPathObjectIdResult + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| ::std::result::Result::Ok(mock(params)));
                }

                pub fn mock_result(&self, mut mock: impl ::std::ops::FnMut(crate::types::SetPathObjectIdParams) -> ::std::result::Result<crate::types::SetPathObjectIdResult, crate::errors::eden_service::SetPathObjectIdError> + ::std::marker::Send + ::std::marker::Sync + 'mock) {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |params| mock(params));
                }

                pub fn throw<E>(&self, exception: E)
                where
                    E: ::std::convert::Into<crate::errors::eden_service::SetPathObjectIdError>,
                    E: ::std::clone::Clone + ::std::marker::Send + ::std::marker::Sync + 'mock,
                {
                    let mut closure = self.closure.lock().unwrap();
                    *closure = ::std::boxed::Box::new(move |_: crate::types::SetPathObjectIdParams| ::std::result::Result::Err(exception.clone().into()));
                }
            }
        }
    }
}

/// Error return types.
pub mod errors {
    /// Errors for EdenService functions.
    pub mod eden_service {

        pub trait AsEdenError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError>;
        }

        impl AsEdenError for ::anyhow::Error {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                for cause in self.chain() {
                    if let Some(ListMountsError::ex(e)) = cause.downcast_ref::<ListMountsError>() {
                        return Some(e);
                    }
                    if let Some(MountError::ex(e)) = cause.downcast_ref::<MountError>() {
                        return Some(e);
                    }
                    if let Some(UnmountError::ex(e)) = cause.downcast_ref::<UnmountError>() {
                        return Some(e);
                    }
                    if let Some(CheckOutRevisionError::ex(e)) = cause.downcast_ref::<CheckOutRevisionError>() {
                        return Some(e);
                    }
                    if let Some(ResetParentCommitsError::ex(e)) = cause.downcast_ref::<ResetParentCommitsError>() {
                        return Some(e);
                    }
                    if let Some(SynchronizeWorkingCopyError::ex(e)) = cause.downcast_ref::<SynchronizeWorkingCopyError>() {
                        return Some(e);
                    }
                    if let Some(GetSHA1Error::ex(e)) = cause.downcast_ref::<GetSHA1Error>() {
                        return Some(e);
                    }
                    if let Some(GetBindMountsError::ex(e)) = cause.downcast_ref::<GetBindMountsError>() {
                        return Some(e);
                    }
                    if let Some(AddBindMountError::ex(e)) = cause.downcast_ref::<AddBindMountError>() {
                        return Some(e);
                    }
                    if let Some(RemoveBindMountError::ex(e)) = cause.downcast_ref::<RemoveBindMountError>() {
                        return Some(e);
                    }
                    if let Some(GetCurrentJournalPositionError::ex(e)) = cause.downcast_ref::<GetCurrentJournalPositionError>() {
                        return Some(e);
                    }
                    if let Some(GetFilesChangedSinceError::ex(e)) = cause.downcast_ref::<GetFilesChangedSinceError>() {
                        return Some(e);
                    }
                    if let Some(SetJournalMemoryLimitError::ex(e)) = cause.downcast_ref::<SetJournalMemoryLimitError>() {
                        return Some(e);
                    }
                    if let Some(GetJournalMemoryLimitError::ex(e)) = cause.downcast_ref::<GetJournalMemoryLimitError>() {
                        return Some(e);
                    }
                    if let Some(FlushJournalError::ex(e)) = cause.downcast_ref::<FlushJournalError>() {
                        return Some(e);
                    }
                    if let Some(DebugGetRawJournalError::ex(e)) = cause.downcast_ref::<DebugGetRawJournalError>() {
                        return Some(e);
                    }
                    if let Some(GetEntryInformationError::ex(e)) = cause.downcast_ref::<GetEntryInformationError>() {
                        return Some(e);
                    }
                    if let Some(GetFileInformationError::ex(e)) = cause.downcast_ref::<GetFileInformationError>() {
                        return Some(e);
                    }
                    if let Some(GetAttributesFromFilesError::ex(e)) = cause.downcast_ref::<GetAttributesFromFilesError>() {
                        return Some(e);
                    }
                    if let Some(GlobError::ex(e)) = cause.downcast_ref::<GlobError>() {
                        return Some(e);
                    }
                    if let Some(GlobFilesError::ex(e)) = cause.downcast_ref::<GlobFilesError>() {
                        return Some(e);
                    }
                    if let Some(PredictiveGlobFilesError::ex(e)) = cause.downcast_ref::<PredictiveGlobFilesError>() {
                        return Some(e);
                    }
                    if let Some(GetScmStatusV2Error::ex(e)) = cause.downcast_ref::<GetScmStatusV2Error>() {
                        return Some(e);
                    }
                    if let Some(GetScmStatusError::ex(e)) = cause.downcast_ref::<GetScmStatusError>() {
                        return Some(e);
                    }
                    if let Some(GetScmStatusBetweenRevisionsError::ex(e)) = cause.downcast_ref::<GetScmStatusBetweenRevisionsError>() {
                        return Some(e);
                    }
                    if let Some(GetDaemonInfoError::ex(e)) = cause.downcast_ref::<GetDaemonInfoError>() {
                        return Some(e);
                    }
                    if let Some(CheckPrivHelperError::ex(e)) = cause.downcast_ref::<CheckPrivHelperError>() {
                        return Some(e);
                    }
                    if let Some(GetPidError::ex(e)) = cause.downcast_ref::<GetPidError>() {
                        return Some(e);
                    }
                    if let Some(InitiateShutdownError::ex(e)) = cause.downcast_ref::<InitiateShutdownError>() {
                        return Some(e);
                    }
                    if let Some(GetConfigError::ex(e)) = cause.downcast_ref::<GetConfigError>() {
                        return Some(e);
                    }
                    if let Some(ReloadConfigError::ex(e)) = cause.downcast_ref::<ReloadConfigError>() {
                        return Some(e);
                    }
                    if let Some(DebugGetScmTreeError::ex(e)) = cause.downcast_ref::<DebugGetScmTreeError>() {
                        return Some(e);
                    }
                    if let Some(DebugGetScmBlobError::ex(e)) = cause.downcast_ref::<DebugGetScmBlobError>() {
                        return Some(e);
                    }
                    if let Some(DebugGetScmBlobMetadataError::ex(e)) = cause.downcast_ref::<DebugGetScmBlobMetadataError>() {
                        return Some(e);
                    }
                    if let Some(DebugInodeStatusError::ex(e)) = cause.downcast_ref::<DebugInodeStatusError>() {
                        return Some(e);
                    }
                    if let Some(DebugGetInodePathError::ex(e)) = cause.downcast_ref::<DebugGetInodePathError>() {
                        return Some(e);
                    }
                    if let Some(ClearFetchCountsError::ex(e)) = cause.downcast_ref::<ClearFetchCountsError>() {
                        return Some(e);
                    }
                    if let Some(ClearFetchCountsByMountError::ex(e)) = cause.downcast_ref::<ClearFetchCountsByMountError>() {
                        return Some(e);
                    }
                    if let Some(GetAccessCountsError::ex(e)) = cause.downcast_ref::<GetAccessCountsError>() {
                        return Some(e);
                    }
                    if let Some(StartRecordingBackingStoreFetchError::ex(e)) = cause.downcast_ref::<StartRecordingBackingStoreFetchError>() {
                        return Some(e);
                    }
                    if let Some(StopRecordingBackingStoreFetchError::ex(e)) = cause.downcast_ref::<StopRecordingBackingStoreFetchError>() {
                        return Some(e);
                    }
                    if let Some(ClearAndCompactLocalStoreError::ex(e)) = cause.downcast_ref::<ClearAndCompactLocalStoreError>() {
                        return Some(e);
                    }
                    if let Some(DebugClearLocalStoreCachesError::ex(e)) = cause.downcast_ref::<DebugClearLocalStoreCachesError>() {
                        return Some(e);
                    }
                    if let Some(DebugCompactLocalStorageError::ex(e)) = cause.downcast_ref::<DebugCompactLocalStorageError>() {
                        return Some(e);
                    }
                    if let Some(UnloadInodeForPathError::ex(e)) = cause.downcast_ref::<UnloadInodeForPathError>() {
                        return Some(e);
                    }
                    if let Some(FlushStatsNowError::ex(e)) = cause.downcast_ref::<FlushStatsNowError>() {
                        return Some(e);
                    }
                    if let Some(InvalidateKernelInodeCacheError::ex(e)) = cause.downcast_ref::<InvalidateKernelInodeCacheError>() {
                        return Some(e);
                    }
                    if let Some(GetStatInfoError::ex(e)) = cause.downcast_ref::<GetStatInfoError>() {
                        return Some(e);
                    }
                    if let Some(InjectFaultError::ex(e)) = cause.downcast_ref::<InjectFaultError>() {
                        return Some(e);
                    }
                    if let Some(RemoveFaultError::ex(e)) = cause.downcast_ref::<RemoveFaultError>() {
                        return Some(e);
                    }
                    if let Some(UnblockFaultError::ex(e)) = cause.downcast_ref::<UnblockFaultError>() {
                        return Some(e);
                    }
                    if let Some(SetPathObjectIdError::ex(e)) = cause.downcast_ref::<SetPathObjectIdError>() {
                        return Some(e);
                    }
                }
                None
            }
        }

        /// Errors for listMounts (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ListMountsError {
            #[error("EdenService::listMounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ListMountsError {
            fn from(e: crate::types::EdenError) -> Self {
                ListMountsError::ex(e)
            }
        }

        impl AsEdenError for ListMountsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ListMountsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ListMountsError {
            fn from(err: ::anyhow::Error) -> Self {
                ListMountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ListMountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ListMountsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ListMountsExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::MountInfo>, ListMountsError>
        {
            fn from(e: crate::services::eden_service::ListMountsExn) -> Self {
                match e {
                    crate::services::eden_service::ListMountsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ListMountsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ListMountsError::ApplicationException(aexn)),
                    crate::services::eden_service::ListMountsExn::ex(exn) =>
                        ::std::result::Result::Err(ListMountsError::ex(exn)),
                }
            }
        }

        /// Errors for mount (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum MountError {
            #[error("EdenService::mount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for MountError {
            fn from(e: crate::types::EdenError) -> Self {
                MountError::ex(e)
            }
        }

        impl AsEdenError for MountError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    MountError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for MountError {
            fn from(err: ::anyhow::Error) -> Self {
                MountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for MountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                MountError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::MountExn> for
            ::std::result::Result<(), MountError>
        {
            fn from(e: crate::services::eden_service::MountExn) -> Self {
                match e {
                    crate::services::eden_service::MountExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::MountExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(MountError::ApplicationException(aexn)),
                    crate::services::eden_service::MountExn::ex(exn) =>
                        ::std::result::Result::Err(MountError::ex(exn)),
                }
            }
        }

        /// Errors for unmount (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum UnmountError {
            #[error("EdenService::unmount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnmountError {
            fn from(e: crate::types::EdenError) -> Self {
                UnmountError::ex(e)
            }
        }

        impl AsEdenError for UnmountError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    UnmountError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnmountError {
            fn from(err: ::anyhow::Error) -> Self {
                UnmountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnmountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnmountError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::UnmountExn> for
            ::std::result::Result<(), UnmountError>
        {
            fn from(e: crate::services::eden_service::UnmountExn) -> Self {
                match e {
                    crate::services::eden_service::UnmountExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::UnmountExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UnmountError::ApplicationException(aexn)),
                    crate::services::eden_service::UnmountExn::ex(exn) =>
                        ::std::result::Result::Err(UnmountError::ex(exn)),
                }
            }
        }

        /// Errors for checkOutRevision (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum CheckOutRevisionError {
            #[error("EdenService::checkOutRevision failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckOutRevisionError {
            fn from(e: crate::types::EdenError) -> Self {
                CheckOutRevisionError::ex(e)
            }
        }

        impl AsEdenError for CheckOutRevisionError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    CheckOutRevisionError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for CheckOutRevisionError {
            fn from(err: ::anyhow::Error) -> Self {
                CheckOutRevisionError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckOutRevisionError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                CheckOutRevisionError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::CheckOutRevisionExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::CheckoutConflict>, CheckOutRevisionError>
        {
            fn from(e: crate::services::eden_service::CheckOutRevisionExn) -> Self {
                match e {
                    crate::services::eden_service::CheckOutRevisionExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::CheckOutRevisionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CheckOutRevisionError::ApplicationException(aexn)),
                    crate::services::eden_service::CheckOutRevisionExn::ex(exn) =>
                        ::std::result::Result::Err(CheckOutRevisionError::ex(exn)),
                }
            }
        }

        /// Errors for resetParentCommits (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ResetParentCommitsError {
            #[error("EdenService::resetParentCommits failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ResetParentCommitsError {
            fn from(e: crate::types::EdenError) -> Self {
                ResetParentCommitsError::ex(e)
            }
        }

        impl AsEdenError for ResetParentCommitsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ResetParentCommitsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ResetParentCommitsError {
            fn from(err: ::anyhow::Error) -> Self {
                ResetParentCommitsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ResetParentCommitsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ResetParentCommitsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ResetParentCommitsExn> for
            ::std::result::Result<(), ResetParentCommitsError>
        {
            fn from(e: crate::services::eden_service::ResetParentCommitsExn) -> Self {
                match e {
                    crate::services::eden_service::ResetParentCommitsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ResetParentCommitsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ResetParentCommitsError::ApplicationException(aexn)),
                    crate::services::eden_service::ResetParentCommitsExn::ex(exn) =>
                        ::std::result::Result::Err(ResetParentCommitsError::ex(exn)),
                }
            }
        }

        /// Errors for synchronizeWorkingCopy (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum SynchronizeWorkingCopyError {
            #[error("EdenService::synchronizeWorkingCopy failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for SynchronizeWorkingCopyError {
            fn from(e: crate::types::EdenError) -> Self {
                SynchronizeWorkingCopyError::ex(e)
            }
        }

        impl AsEdenError for SynchronizeWorkingCopyError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    SynchronizeWorkingCopyError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for SynchronizeWorkingCopyError {
            fn from(err: ::anyhow::Error) -> Self {
                SynchronizeWorkingCopyError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SynchronizeWorkingCopyError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                SynchronizeWorkingCopyError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::SynchronizeWorkingCopyExn> for
            ::std::result::Result<(), SynchronizeWorkingCopyError>
        {
            fn from(e: crate::services::eden_service::SynchronizeWorkingCopyExn) -> Self {
                match e {
                    crate::services::eden_service::SynchronizeWorkingCopyExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::SynchronizeWorkingCopyExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SynchronizeWorkingCopyError::ApplicationException(aexn)),
                    crate::services::eden_service::SynchronizeWorkingCopyExn::ex(exn) =>
                        ::std::result::Result::Err(SynchronizeWorkingCopyError::ex(exn)),
                }
            }
        }

        /// Errors for getSHA1 (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetSHA1Error {
            #[error("EdenService::getSHA1 failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetSHA1Error {
            fn from(e: crate::types::EdenError) -> Self {
                GetSHA1Error::ex(e)
            }
        }

        impl AsEdenError for GetSHA1Error {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetSHA1Error::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetSHA1Error {
            fn from(err: ::anyhow::Error) -> Self {
                GetSHA1Error::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetSHA1Error {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetSHA1Error::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetSHA1Exn> for
            ::std::result::Result<::std::vec::Vec<crate::types::SHA1Result>, GetSHA1Error>
        {
            fn from(e: crate::services::eden_service::GetSHA1Exn) -> Self {
                match e {
                    crate::services::eden_service::GetSHA1Exn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetSHA1Exn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetSHA1Error::ApplicationException(aexn)),
                    crate::services::eden_service::GetSHA1Exn::ex(exn) =>
                        ::std::result::Result::Err(GetSHA1Error::ex(exn)),
                }
            }
        }

        /// Errors for getBindMounts (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetBindMountsError {
            #[error("EdenService::getBindMounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetBindMountsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetBindMountsError::ex(e)
            }
        }

        impl AsEdenError for GetBindMountsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetBindMountsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetBindMountsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetBindMountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetBindMountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetBindMountsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetBindMountsExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::PathString>, GetBindMountsError>
        {
            fn from(e: crate::services::eden_service::GetBindMountsExn) -> Self {
                match e {
                    crate::services::eden_service::GetBindMountsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetBindMountsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetBindMountsError::ApplicationException(aexn)),
                    crate::services::eden_service::GetBindMountsExn::ex(exn) =>
                        ::std::result::Result::Err(GetBindMountsError::ex(exn)),
                }
            }
        }

        /// Errors for addBindMount (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum AddBindMountError {
            #[error("EdenService::addBindMount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for AddBindMountError {
            fn from(e: crate::types::EdenError) -> Self {
                AddBindMountError::ex(e)
            }
        }

        impl AsEdenError for AddBindMountError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    AddBindMountError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for AddBindMountError {
            fn from(err: ::anyhow::Error) -> Self {
                AddBindMountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for AddBindMountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                AddBindMountError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::AddBindMountExn> for
            ::std::result::Result<(), AddBindMountError>
        {
            fn from(e: crate::services::eden_service::AddBindMountExn) -> Self {
                match e {
                    crate::services::eden_service::AddBindMountExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::AddBindMountExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(AddBindMountError::ApplicationException(aexn)),
                    crate::services::eden_service::AddBindMountExn::ex(exn) =>
                        ::std::result::Result::Err(AddBindMountError::ex(exn)),
                }
            }
        }

        /// Errors for removeBindMount (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum RemoveBindMountError {
            #[error("EdenService::removeBindMount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveBindMountError {
            fn from(e: crate::types::EdenError) -> Self {
                RemoveBindMountError::ex(e)
            }
        }

        impl AsEdenError for RemoveBindMountError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    RemoveBindMountError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for RemoveBindMountError {
            fn from(err: ::anyhow::Error) -> Self {
                RemoveBindMountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveBindMountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                RemoveBindMountError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::RemoveBindMountExn> for
            ::std::result::Result<(), RemoveBindMountError>
        {
            fn from(e: crate::services::eden_service::RemoveBindMountExn) -> Self {
                match e {
                    crate::services::eden_service::RemoveBindMountExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::RemoveBindMountExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveBindMountError::ApplicationException(aexn)),
                    crate::services::eden_service::RemoveBindMountExn::ex(exn) =>
                        ::std::result::Result::Err(RemoveBindMountError::ex(exn)),
                }
            }
        }

        /// Errors for getCurrentJournalPosition (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetCurrentJournalPositionError {
            #[error("EdenService::getCurrentJournalPosition failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetCurrentJournalPositionError {
            fn from(e: crate::types::EdenError) -> Self {
                GetCurrentJournalPositionError::ex(e)
            }
        }

        impl AsEdenError for GetCurrentJournalPositionError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetCurrentJournalPositionError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetCurrentJournalPositionError {
            fn from(err: ::anyhow::Error) -> Self {
                GetCurrentJournalPositionError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetCurrentJournalPositionError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetCurrentJournalPositionError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetCurrentJournalPositionExn> for
            ::std::result::Result<crate::types::JournalPosition, GetCurrentJournalPositionError>
        {
            fn from(e: crate::services::eden_service::GetCurrentJournalPositionExn) -> Self {
                match e {
                    crate::services::eden_service::GetCurrentJournalPositionExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetCurrentJournalPositionExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetCurrentJournalPositionError::ApplicationException(aexn)),
                    crate::services::eden_service::GetCurrentJournalPositionExn::ex(exn) =>
                        ::std::result::Result::Err(GetCurrentJournalPositionError::ex(exn)),
                }
            }
        }

        /// Errors for getFilesChangedSince (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetFilesChangedSinceError {
            #[error("EdenService::getFilesChangedSince failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFilesChangedSinceError {
            fn from(e: crate::types::EdenError) -> Self {
                GetFilesChangedSinceError::ex(e)
            }
        }

        impl AsEdenError for GetFilesChangedSinceError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetFilesChangedSinceError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetFilesChangedSinceError {
            fn from(err: ::anyhow::Error) -> Self {
                GetFilesChangedSinceError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFilesChangedSinceError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetFilesChangedSinceError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetFilesChangedSinceExn> for
            ::std::result::Result<crate::types::FileDelta, GetFilesChangedSinceError>
        {
            fn from(e: crate::services::eden_service::GetFilesChangedSinceExn) -> Self {
                match e {
                    crate::services::eden_service::GetFilesChangedSinceExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetFilesChangedSinceExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetFilesChangedSinceError::ApplicationException(aexn)),
                    crate::services::eden_service::GetFilesChangedSinceExn::ex(exn) =>
                        ::std::result::Result::Err(GetFilesChangedSinceError::ex(exn)),
                }
            }
        }

        /// Errors for setJournalMemoryLimit (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum SetJournalMemoryLimitError {
            #[error("EdenService::setJournalMemoryLimit failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetJournalMemoryLimitError {
            fn from(e: crate::types::EdenError) -> Self {
                SetJournalMemoryLimitError::ex(e)
            }
        }

        impl AsEdenError for SetJournalMemoryLimitError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    SetJournalMemoryLimitError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for SetJournalMemoryLimitError {
            fn from(err: ::anyhow::Error) -> Self {
                SetJournalMemoryLimitError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetJournalMemoryLimitError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                SetJournalMemoryLimitError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::SetJournalMemoryLimitExn> for
            ::std::result::Result<(), SetJournalMemoryLimitError>
        {
            fn from(e: crate::services::eden_service::SetJournalMemoryLimitExn) -> Self {
                match e {
                    crate::services::eden_service::SetJournalMemoryLimitExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::SetJournalMemoryLimitExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetJournalMemoryLimitError::ApplicationException(aexn)),
                    crate::services::eden_service::SetJournalMemoryLimitExn::ex(exn) =>
                        ::std::result::Result::Err(SetJournalMemoryLimitError::ex(exn)),
                }
            }
        }

        /// Errors for getJournalMemoryLimit (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetJournalMemoryLimitError {
            #[error("EdenService::getJournalMemoryLimit failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetJournalMemoryLimitError {
            fn from(e: crate::types::EdenError) -> Self {
                GetJournalMemoryLimitError::ex(e)
            }
        }

        impl AsEdenError for GetJournalMemoryLimitError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetJournalMemoryLimitError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetJournalMemoryLimitError {
            fn from(err: ::anyhow::Error) -> Self {
                GetJournalMemoryLimitError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetJournalMemoryLimitError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetJournalMemoryLimitError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetJournalMemoryLimitExn> for
            ::std::result::Result<::std::primitive::i64, GetJournalMemoryLimitError>
        {
            fn from(e: crate::services::eden_service::GetJournalMemoryLimitExn) -> Self {
                match e {
                    crate::services::eden_service::GetJournalMemoryLimitExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetJournalMemoryLimitExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetJournalMemoryLimitError::ApplicationException(aexn)),
                    crate::services::eden_service::GetJournalMemoryLimitExn::ex(exn) =>
                        ::std::result::Result::Err(GetJournalMemoryLimitError::ex(exn)),
                }
            }
        }

        /// Errors for flushJournal (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum FlushJournalError {
            #[error("EdenService::flushJournal failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushJournalError {
            fn from(e: crate::types::EdenError) -> Self {
                FlushJournalError::ex(e)
            }
        }

        impl AsEdenError for FlushJournalError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    FlushJournalError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for FlushJournalError {
            fn from(err: ::anyhow::Error) -> Self {
                FlushJournalError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushJournalError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                FlushJournalError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::FlushJournalExn> for
            ::std::result::Result<(), FlushJournalError>
        {
            fn from(e: crate::services::eden_service::FlushJournalExn) -> Self {
                match e {
                    crate::services::eden_service::FlushJournalExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::FlushJournalExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(FlushJournalError::ApplicationException(aexn)),
                    crate::services::eden_service::FlushJournalExn::ex(exn) =>
                        ::std::result::Result::Err(FlushJournalError::ex(exn)),
                }
            }
        }

        /// Errors for debugGetRawJournal (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetRawJournalError {
            #[error("EdenService::debugGetRawJournal failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetRawJournalError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetRawJournalError::ex(e)
            }
        }

        impl AsEdenError for DebugGetRawJournalError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugGetRawJournalError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetRawJournalError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetRawJournalError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetRawJournalError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetRawJournalError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugGetRawJournalExn> for
            ::std::result::Result<crate::types::DebugGetRawJournalResponse, DebugGetRawJournalError>
        {
            fn from(e: crate::services::eden_service::DebugGetRawJournalExn) -> Self {
                match e {
                    crate::services::eden_service::DebugGetRawJournalExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugGetRawJournalExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugGetRawJournalError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugGetRawJournalExn::ex(exn) =>
                        ::std::result::Result::Err(DebugGetRawJournalError::ex(exn)),
                }
            }
        }

        /// Errors for getEntryInformation (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetEntryInformationError {
            #[error("EdenService::getEntryInformation failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetEntryInformationError {
            fn from(e: crate::types::EdenError) -> Self {
                GetEntryInformationError::ex(e)
            }
        }

        impl AsEdenError for GetEntryInformationError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetEntryInformationError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetEntryInformationError {
            fn from(err: ::anyhow::Error) -> Self {
                GetEntryInformationError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetEntryInformationError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetEntryInformationError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetEntryInformationExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::EntryInformationOrError>, GetEntryInformationError>
        {
            fn from(e: crate::services::eden_service::GetEntryInformationExn) -> Self {
                match e {
                    crate::services::eden_service::GetEntryInformationExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetEntryInformationExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetEntryInformationError::ApplicationException(aexn)),
                    crate::services::eden_service::GetEntryInformationExn::ex(exn) =>
                        ::std::result::Result::Err(GetEntryInformationError::ex(exn)),
                }
            }
        }

        /// Errors for getFileInformation (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetFileInformationError {
            #[error("EdenService::getFileInformation failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetFileInformationError {
            fn from(e: crate::types::EdenError) -> Self {
                GetFileInformationError::ex(e)
            }
        }

        impl AsEdenError for GetFileInformationError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetFileInformationError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetFileInformationError {
            fn from(err: ::anyhow::Error) -> Self {
                GetFileInformationError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetFileInformationError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetFileInformationError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetFileInformationExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::FileInformationOrError>, GetFileInformationError>
        {
            fn from(e: crate::services::eden_service::GetFileInformationExn) -> Self {
                match e {
                    crate::services::eden_service::GetFileInformationExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetFileInformationExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetFileInformationError::ApplicationException(aexn)),
                    crate::services::eden_service::GetFileInformationExn::ex(exn) =>
                        ::std::result::Result::Err(GetFileInformationError::ex(exn)),
                }
            }
        }

        /// Errors for getAttributesFromFiles (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetAttributesFromFilesError {
            #[error("EdenService::getAttributesFromFiles failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAttributesFromFilesError {
            fn from(e: crate::types::EdenError) -> Self {
                GetAttributesFromFilesError::ex(e)
            }
        }

        impl AsEdenError for GetAttributesFromFilesError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetAttributesFromFilesError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetAttributesFromFilesError {
            fn from(err: ::anyhow::Error) -> Self {
                GetAttributesFromFilesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAttributesFromFilesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetAttributesFromFilesError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetAttributesFromFilesExn> for
            ::std::result::Result<crate::types::GetAttributesFromFilesResult, GetAttributesFromFilesError>
        {
            fn from(e: crate::services::eden_service::GetAttributesFromFilesExn) -> Self {
                match e {
                    crate::services::eden_service::GetAttributesFromFilesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetAttributesFromFilesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetAttributesFromFilesError::ApplicationException(aexn)),
                    crate::services::eden_service::GetAttributesFromFilesExn::ex(exn) =>
                        ::std::result::Result::Err(GetAttributesFromFilesError::ex(exn)),
                }
            }
        }

        /// Errors for glob (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GlobError {
            #[error("EdenService::glob failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobError {
            fn from(e: crate::types::EdenError) -> Self {
                GlobError::ex(e)
            }
        }

        impl AsEdenError for GlobError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GlobError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GlobError {
            fn from(err: ::anyhow::Error) -> Self {
                GlobError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GlobError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GlobExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::PathString>, GlobError>
        {
            fn from(e: crate::services::eden_service::GlobExn) -> Self {
                match e {
                    crate::services::eden_service::GlobExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GlobExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GlobError::ApplicationException(aexn)),
                    crate::services::eden_service::GlobExn::ex(exn) =>
                        ::std::result::Result::Err(GlobError::ex(exn)),
                }
            }
        }

        /// Errors for globFiles (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GlobFilesError {
            #[error("EdenService::globFiles failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GlobFilesError {
            fn from(e: crate::types::EdenError) -> Self {
                GlobFilesError::ex(e)
            }
        }

        impl AsEdenError for GlobFilesError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GlobFilesError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GlobFilesError {
            fn from(err: ::anyhow::Error) -> Self {
                GlobFilesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GlobFilesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GlobFilesError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GlobFilesExn> for
            ::std::result::Result<crate::types::Glob, GlobFilesError>
        {
            fn from(e: crate::services::eden_service::GlobFilesExn) -> Self {
                match e {
                    crate::services::eden_service::GlobFilesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GlobFilesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GlobFilesError::ApplicationException(aexn)),
                    crate::services::eden_service::GlobFilesExn::ex(exn) =>
                        ::std::result::Result::Err(GlobFilesError::ex(exn)),
                }
            }
        }

        /// Errors for predictiveGlobFiles (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum PredictiveGlobFilesError {
            #[error("EdenService::predictiveGlobFiles failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for PredictiveGlobFilesError {
            fn from(e: crate::types::EdenError) -> Self {
                PredictiveGlobFilesError::ex(e)
            }
        }

        impl AsEdenError for PredictiveGlobFilesError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    PredictiveGlobFilesError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for PredictiveGlobFilesError {
            fn from(err: ::anyhow::Error) -> Self {
                PredictiveGlobFilesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for PredictiveGlobFilesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                PredictiveGlobFilesError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::PredictiveGlobFilesExn> for
            ::std::result::Result<crate::types::Glob, PredictiveGlobFilesError>
        {
            fn from(e: crate::services::eden_service::PredictiveGlobFilesExn) -> Self {
                match e {
                    crate::services::eden_service::PredictiveGlobFilesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::PredictiveGlobFilesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(PredictiveGlobFilesError::ApplicationException(aexn)),
                    crate::services::eden_service::PredictiveGlobFilesExn::ex(exn) =>
                        ::std::result::Result::Err(PredictiveGlobFilesError::ex(exn)),
                }
            }
        }

        pub type ChownError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::ChownExn> for
            ::std::result::Result<(), ChownError>
        {
            fn from(e: crate::services::eden_service::ChownExn) -> Self {
                match e {
                    crate::services::eden_service::ChownExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ChownExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ChownError::ApplicationException(aexn)),
                }
            }
        }

        /// Errors for getScmStatusV2 (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusV2Error {
            #[error("EdenService::getScmStatusV2 failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusV2Error {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusV2Error::ex(e)
            }
        }

        impl AsEdenError for GetScmStatusV2Error {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetScmStatusV2Error::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusV2Error {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusV2Error::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusV2Error {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusV2Error::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetScmStatusV2Exn> for
            ::std::result::Result<crate::types::GetScmStatusResult, GetScmStatusV2Error>
        {
            fn from(e: crate::services::eden_service::GetScmStatusV2Exn) -> Self {
                match e {
                    crate::services::eden_service::GetScmStatusV2Exn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetScmStatusV2Exn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetScmStatusV2Error::ApplicationException(aexn)),
                    crate::services::eden_service::GetScmStatusV2Exn::ex(exn) =>
                        ::std::result::Result::Err(GetScmStatusV2Error::ex(exn)),
                }
            }
        }

        /// Errors for getScmStatus (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusError {
            #[error("EdenService::getScmStatus failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusError {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusError::ex(e)
            }
        }

        impl AsEdenError for GetScmStatusError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetScmStatusError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusError {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetScmStatusExn> for
            ::std::result::Result<crate::types::ScmStatus, GetScmStatusError>
        {
            fn from(e: crate::services::eden_service::GetScmStatusExn) -> Self {
                match e {
                    crate::services::eden_service::GetScmStatusExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetScmStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetScmStatusError::ApplicationException(aexn)),
                    crate::services::eden_service::GetScmStatusExn::ex(exn) =>
                        ::std::result::Result::Err(GetScmStatusError::ex(exn)),
                }
            }
        }

        /// Errors for getScmStatusBetweenRevisions (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetScmStatusBetweenRevisionsError {
            #[error("EdenService::getScmStatusBetweenRevisions failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetScmStatusBetweenRevisionsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetScmStatusBetweenRevisionsError::ex(e)
            }
        }

        impl AsEdenError for GetScmStatusBetweenRevisionsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetScmStatusBetweenRevisionsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetScmStatusBetweenRevisionsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetScmStatusBetweenRevisionsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetScmStatusBetweenRevisionsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetScmStatusBetweenRevisionsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetScmStatusBetweenRevisionsExn> for
            ::std::result::Result<crate::types::ScmStatus, GetScmStatusBetweenRevisionsError>
        {
            fn from(e: crate::services::eden_service::GetScmStatusBetweenRevisionsExn) -> Self {
                match e {
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetScmStatusBetweenRevisionsError::ApplicationException(aexn)),
                    crate::services::eden_service::GetScmStatusBetweenRevisionsExn::ex(exn) =>
                        ::std::result::Result::Err(GetScmStatusBetweenRevisionsError::ex(exn)),
                }
            }
        }

        /// Errors for getDaemonInfo (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetDaemonInfoError {
            #[error("EdenService::getDaemonInfo failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetDaemonInfoError {
            fn from(e: crate::types::EdenError) -> Self {
                GetDaemonInfoError::ex(e)
            }
        }

        impl AsEdenError for GetDaemonInfoError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetDaemonInfoError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetDaemonInfoError {
            fn from(err: ::anyhow::Error) -> Self {
                GetDaemonInfoError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetDaemonInfoError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetDaemonInfoError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetDaemonInfoExn> for
            ::std::result::Result<crate::types::DaemonInfo, GetDaemonInfoError>
        {
            fn from(e: crate::services::eden_service::GetDaemonInfoExn) -> Self {
                match e {
                    crate::services::eden_service::GetDaemonInfoExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetDaemonInfoExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetDaemonInfoError::ApplicationException(aexn)),
                    crate::services::eden_service::GetDaemonInfoExn::ex(exn) =>
                        ::std::result::Result::Err(GetDaemonInfoError::ex(exn)),
                }
            }
        }

        /// Errors for checkPrivHelper (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum CheckPrivHelperError {
            #[error("EdenService::checkPrivHelper failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for CheckPrivHelperError {
            fn from(e: crate::types::EdenError) -> Self {
                CheckPrivHelperError::ex(e)
            }
        }

        impl AsEdenError for CheckPrivHelperError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    CheckPrivHelperError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for CheckPrivHelperError {
            fn from(err: ::anyhow::Error) -> Self {
                CheckPrivHelperError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for CheckPrivHelperError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                CheckPrivHelperError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::CheckPrivHelperExn> for
            ::std::result::Result<crate::types::PrivHelperInfo, CheckPrivHelperError>
        {
            fn from(e: crate::services::eden_service::CheckPrivHelperExn) -> Self {
                match e {
                    crate::services::eden_service::CheckPrivHelperExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::CheckPrivHelperExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(CheckPrivHelperError::ApplicationException(aexn)),
                    crate::services::eden_service::CheckPrivHelperExn::ex(exn) =>
                        ::std::result::Result::Err(CheckPrivHelperError::ex(exn)),
                }
            }
        }

        /// Errors for getPid (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetPidError {
            #[error("EdenService::getPid failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetPidError {
            fn from(e: crate::types::EdenError) -> Self {
                GetPidError::ex(e)
            }
        }

        impl AsEdenError for GetPidError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetPidError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetPidError {
            fn from(err: ::anyhow::Error) -> Self {
                GetPidError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetPidError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetPidError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetPidExn> for
            ::std::result::Result<::std::primitive::i64, GetPidError>
        {
            fn from(e: crate::services::eden_service::GetPidExn) -> Self {
                match e {
                    crate::services::eden_service::GetPidExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetPidExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetPidError::ApplicationException(aexn)),
                    crate::services::eden_service::GetPidExn::ex(exn) =>
                        ::std::result::Result::Err(GetPidError::ex(exn)),
                }
            }
        }

        /// Errors for initiateShutdown (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum InitiateShutdownError {
            #[error("EdenService::initiateShutdown failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InitiateShutdownError {
            fn from(e: crate::types::EdenError) -> Self {
                InitiateShutdownError::ex(e)
            }
        }

        impl AsEdenError for InitiateShutdownError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    InitiateShutdownError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InitiateShutdownError {
            fn from(err: ::anyhow::Error) -> Self {
                InitiateShutdownError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InitiateShutdownError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InitiateShutdownError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::InitiateShutdownExn> for
            ::std::result::Result<(), InitiateShutdownError>
        {
            fn from(e: crate::services::eden_service::InitiateShutdownExn) -> Self {
                match e {
                    crate::services::eden_service::InitiateShutdownExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::InitiateShutdownExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(InitiateShutdownError::ApplicationException(aexn)),
                    crate::services::eden_service::InitiateShutdownExn::ex(exn) =>
                        ::std::result::Result::Err(InitiateShutdownError::ex(exn)),
                }
            }
        }

        /// Errors for getConfig (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetConfigError {
            #[error("EdenService::getConfig failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetConfigError {
            fn from(e: crate::types::EdenError) -> Self {
                GetConfigError::ex(e)
            }
        }

        impl AsEdenError for GetConfigError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetConfigError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetConfigError {
            fn from(err: ::anyhow::Error) -> Self {
                GetConfigError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetConfigError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetConfigError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetConfigExn> for
            ::std::result::Result<eden_config::types::EdenConfigData, GetConfigError>
        {
            fn from(e: crate::services::eden_service::GetConfigExn) -> Self {
                match e {
                    crate::services::eden_service::GetConfigExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetConfigError::ApplicationException(aexn)),
                    crate::services::eden_service::GetConfigExn::ex(exn) =>
                        ::std::result::Result::Err(GetConfigError::ex(exn)),
                }
            }
        }

        /// Errors for reloadConfig (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ReloadConfigError {
            #[error("EdenService::reloadConfig failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ReloadConfigError {
            fn from(e: crate::types::EdenError) -> Self {
                ReloadConfigError::ex(e)
            }
        }

        impl AsEdenError for ReloadConfigError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ReloadConfigError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ReloadConfigError {
            fn from(err: ::anyhow::Error) -> Self {
                ReloadConfigError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ReloadConfigError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ReloadConfigError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ReloadConfigExn> for
            ::std::result::Result<(), ReloadConfigError>
        {
            fn from(e: crate::services::eden_service::ReloadConfigExn) -> Self {
                match e {
                    crate::services::eden_service::ReloadConfigExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ReloadConfigExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ReloadConfigError::ApplicationException(aexn)),
                    crate::services::eden_service::ReloadConfigExn::ex(exn) =>
                        ::std::result::Result::Err(ReloadConfigError::ex(exn)),
                }
            }
        }

        /// Errors for debugGetScmTree (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmTreeError {
            #[error("EdenService::debugGetScmTree failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmTreeError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmTreeError::ex(e)
            }
        }

        impl AsEdenError for DebugGetScmTreeError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugGetScmTreeError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmTreeError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmTreeError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmTreeError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmTreeError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugGetScmTreeExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::ScmTreeEntry>, DebugGetScmTreeError>
        {
            fn from(e: crate::services::eden_service::DebugGetScmTreeExn) -> Self {
                match e {
                    crate::services::eden_service::DebugGetScmTreeExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugGetScmTreeExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugGetScmTreeError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugGetScmTreeExn::ex(exn) =>
                        ::std::result::Result::Err(DebugGetScmTreeError::ex(exn)),
                }
            }
        }

        /// Errors for debugGetScmBlob (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmBlobError {
            #[error("EdenService::debugGetScmBlob failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmBlobError::ex(e)
            }
        }

        impl AsEdenError for DebugGetScmBlobError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugGetScmBlobError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmBlobError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmBlobError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugGetScmBlobExn> for
            ::std::result::Result<::std::vec::Vec<::std::primitive::u8>, DebugGetScmBlobError>
        {
            fn from(e: crate::services::eden_service::DebugGetScmBlobExn) -> Self {
                match e {
                    crate::services::eden_service::DebugGetScmBlobExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugGetScmBlobExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugGetScmBlobError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugGetScmBlobExn::ex(exn) =>
                        ::std::result::Result::Err(DebugGetScmBlobError::ex(exn)),
                }
            }
        }

        /// Errors for debugGetScmBlobMetadata (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetScmBlobMetadataError {
            #[error("EdenService::debugGetScmBlobMetadata failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetScmBlobMetadataError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetScmBlobMetadataError::ex(e)
            }
        }

        impl AsEdenError for DebugGetScmBlobMetadataError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugGetScmBlobMetadataError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetScmBlobMetadataError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetScmBlobMetadataError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetScmBlobMetadataError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetScmBlobMetadataError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugGetScmBlobMetadataExn> for
            ::std::result::Result<crate::types::ScmBlobMetadata, DebugGetScmBlobMetadataError>
        {
            fn from(e: crate::services::eden_service::DebugGetScmBlobMetadataExn) -> Self {
                match e {
                    crate::services::eden_service::DebugGetScmBlobMetadataExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugGetScmBlobMetadataExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugGetScmBlobMetadataError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugGetScmBlobMetadataExn::ex(exn) =>
                        ::std::result::Result::Err(DebugGetScmBlobMetadataError::ex(exn)),
                }
            }
        }

        /// Errors for debugInodeStatus (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugInodeStatusError {
            #[error("EdenService::debugInodeStatus failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugInodeStatusError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugInodeStatusError::ex(e)
            }
        }

        impl AsEdenError for DebugInodeStatusError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugInodeStatusError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugInodeStatusError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugInodeStatusError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugInodeStatusError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugInodeStatusError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugInodeStatusExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::TreeInodeDebugInfo>, DebugInodeStatusError>
        {
            fn from(e: crate::services::eden_service::DebugInodeStatusExn) -> Self {
                match e {
                    crate::services::eden_service::DebugInodeStatusExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugInodeStatusExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugInodeStatusError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugInodeStatusExn::ex(exn) =>
                        ::std::result::Result::Err(DebugInodeStatusError::ex(exn)),
                }
            }
        }

        pub type DebugOutstandingFuseCallsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DebugOutstandingFuseCallsExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::FuseCall>, DebugOutstandingFuseCallsError>
        {
            fn from(e: crate::services::eden_service::DebugOutstandingFuseCallsExn) -> Self {
                match e {
                    crate::services::eden_service::DebugOutstandingFuseCallsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugOutstandingFuseCallsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugOutstandingFuseCallsError::ApplicationException(aexn)),
                }
            }
        }

        pub type DebugOutstandingNfsCallsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DebugOutstandingNfsCallsExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::NfsCall>, DebugOutstandingNfsCallsError>
        {
            fn from(e: crate::services::eden_service::DebugOutstandingNfsCallsExn) -> Self {
                match e {
                    crate::services::eden_service::DebugOutstandingNfsCallsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugOutstandingNfsCallsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugOutstandingNfsCallsError::ApplicationException(aexn)),
                }
            }
        }

        pub type DebugStartRecordingActivityError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DebugStartRecordingActivityExn> for
            ::std::result::Result<crate::types::ActivityRecorderResult, DebugStartRecordingActivityError>
        {
            fn from(e: crate::services::eden_service::DebugStartRecordingActivityExn) -> Self {
                match e {
                    crate::services::eden_service::DebugStartRecordingActivityExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugStartRecordingActivityExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugStartRecordingActivityError::ApplicationException(aexn)),
                }
            }
        }

        pub type DebugStopRecordingActivityError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DebugStopRecordingActivityExn> for
            ::std::result::Result<crate::types::ActivityRecorderResult, DebugStopRecordingActivityError>
        {
            fn from(e: crate::services::eden_service::DebugStopRecordingActivityExn) -> Self {
                match e {
                    crate::services::eden_service::DebugStopRecordingActivityExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugStopRecordingActivityExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugStopRecordingActivityError::ApplicationException(aexn)),
                }
            }
        }

        pub type DebugListActivityRecordingsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DebugListActivityRecordingsExn> for
            ::std::result::Result<crate::types::ListActivityRecordingsResult, DebugListActivityRecordingsError>
        {
            fn from(e: crate::services::eden_service::DebugListActivityRecordingsExn) -> Self {
                match e {
                    crate::services::eden_service::DebugListActivityRecordingsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugListActivityRecordingsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugListActivityRecordingsError::ApplicationException(aexn)),
                }
            }
        }

        /// Errors for debugGetInodePath (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugGetInodePathError {
            #[error("EdenService::debugGetInodePath failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugGetInodePathError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugGetInodePathError::ex(e)
            }
        }

        impl AsEdenError for DebugGetInodePathError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugGetInodePathError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugGetInodePathError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugGetInodePathError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugGetInodePathError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugGetInodePathError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugGetInodePathExn> for
            ::std::result::Result<crate::types::InodePathDebugInfo, DebugGetInodePathError>
        {
            fn from(e: crate::services::eden_service::DebugGetInodePathExn) -> Self {
                match e {
                    crate::services::eden_service::DebugGetInodePathExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugGetInodePathExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugGetInodePathError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugGetInodePathExn::ex(exn) =>
                        ::std::result::Result::Err(DebugGetInodePathError::ex(exn)),
                }
            }
        }

        /// Errors for clearFetchCounts (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ClearFetchCountsError {
            #[error("EdenService::clearFetchCounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearFetchCountsError {
            fn from(e: crate::types::EdenError) -> Self {
                ClearFetchCountsError::ex(e)
            }
        }

        impl AsEdenError for ClearFetchCountsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ClearFetchCountsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ClearFetchCountsError {
            fn from(err: ::anyhow::Error) -> Self {
                ClearFetchCountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearFetchCountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ClearFetchCountsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ClearFetchCountsExn> for
            ::std::result::Result<(), ClearFetchCountsError>
        {
            fn from(e: crate::services::eden_service::ClearFetchCountsExn) -> Self {
                match e {
                    crate::services::eden_service::ClearFetchCountsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ClearFetchCountsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ClearFetchCountsError::ApplicationException(aexn)),
                    crate::services::eden_service::ClearFetchCountsExn::ex(exn) =>
                        ::std::result::Result::Err(ClearFetchCountsError::ex(exn)),
                }
            }
        }

        /// Errors for clearFetchCountsByMount (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ClearFetchCountsByMountError {
            #[error("EdenService::clearFetchCountsByMount failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearFetchCountsByMountError {
            fn from(e: crate::types::EdenError) -> Self {
                ClearFetchCountsByMountError::ex(e)
            }
        }

        impl AsEdenError for ClearFetchCountsByMountError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ClearFetchCountsByMountError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ClearFetchCountsByMountError {
            fn from(err: ::anyhow::Error) -> Self {
                ClearFetchCountsByMountError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearFetchCountsByMountError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ClearFetchCountsByMountError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ClearFetchCountsByMountExn> for
            ::std::result::Result<(), ClearFetchCountsByMountError>
        {
            fn from(e: crate::services::eden_service::ClearFetchCountsByMountExn) -> Self {
                match e {
                    crate::services::eden_service::ClearFetchCountsByMountExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ClearFetchCountsByMountExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ClearFetchCountsByMountError::ApplicationException(aexn)),
                    crate::services::eden_service::ClearFetchCountsByMountExn::ex(exn) =>
                        ::std::result::Result::Err(ClearFetchCountsByMountError::ex(exn)),
                }
            }
        }

        /// Errors for getAccessCounts (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetAccessCountsError {
            #[error("EdenService::getAccessCounts failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetAccessCountsError {
            fn from(e: crate::types::EdenError) -> Self {
                GetAccessCountsError::ex(e)
            }
        }

        impl AsEdenError for GetAccessCountsError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetAccessCountsError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetAccessCountsError {
            fn from(err: ::anyhow::Error) -> Self {
                GetAccessCountsError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetAccessCountsError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetAccessCountsError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetAccessCountsExn> for
            ::std::result::Result<crate::types::GetAccessCountsResult, GetAccessCountsError>
        {
            fn from(e: crate::services::eden_service::GetAccessCountsExn) -> Self {
                match e {
                    crate::services::eden_service::GetAccessCountsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetAccessCountsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetAccessCountsError::ApplicationException(aexn)),
                    crate::services::eden_service::GetAccessCountsExn::ex(exn) =>
                        ::std::result::Result::Err(GetAccessCountsError::ex(exn)),
                }
            }
        }

        /// Errors for startRecordingBackingStoreFetch (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum StartRecordingBackingStoreFetchError {
            #[error("EdenService::startRecordingBackingStoreFetch failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for StartRecordingBackingStoreFetchError {
            fn from(e: crate::types::EdenError) -> Self {
                StartRecordingBackingStoreFetchError::ex(e)
            }
        }

        impl AsEdenError for StartRecordingBackingStoreFetchError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    StartRecordingBackingStoreFetchError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for StartRecordingBackingStoreFetchError {
            fn from(err: ::anyhow::Error) -> Self {
                StartRecordingBackingStoreFetchError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StartRecordingBackingStoreFetchError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                StartRecordingBackingStoreFetchError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::StartRecordingBackingStoreFetchExn> for
            ::std::result::Result<(), StartRecordingBackingStoreFetchError>
        {
            fn from(e: crate::services::eden_service::StartRecordingBackingStoreFetchExn) -> Self {
                match e {
                    crate::services::eden_service::StartRecordingBackingStoreFetchExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::StartRecordingBackingStoreFetchExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(StartRecordingBackingStoreFetchError::ApplicationException(aexn)),
                    crate::services::eden_service::StartRecordingBackingStoreFetchExn::ex(exn) =>
                        ::std::result::Result::Err(StartRecordingBackingStoreFetchError::ex(exn)),
                }
            }
        }

        /// Errors for stopRecordingBackingStoreFetch (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum StopRecordingBackingStoreFetchError {
            #[error("EdenService::stopRecordingBackingStoreFetch failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for StopRecordingBackingStoreFetchError {
            fn from(e: crate::types::EdenError) -> Self {
                StopRecordingBackingStoreFetchError::ex(e)
            }
        }

        impl AsEdenError for StopRecordingBackingStoreFetchError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    StopRecordingBackingStoreFetchError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for StopRecordingBackingStoreFetchError {
            fn from(err: ::anyhow::Error) -> Self {
                StopRecordingBackingStoreFetchError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for StopRecordingBackingStoreFetchError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                StopRecordingBackingStoreFetchError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::StopRecordingBackingStoreFetchExn> for
            ::std::result::Result<crate::types::GetFetchedFilesResult, StopRecordingBackingStoreFetchError>
        {
            fn from(e: crate::services::eden_service::StopRecordingBackingStoreFetchExn) -> Self {
                match e {
                    crate::services::eden_service::StopRecordingBackingStoreFetchExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::StopRecordingBackingStoreFetchExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(StopRecordingBackingStoreFetchError::ApplicationException(aexn)),
                    crate::services::eden_service::StopRecordingBackingStoreFetchExn::ex(exn) =>
                        ::std::result::Result::Err(StopRecordingBackingStoreFetchError::ex(exn)),
                }
            }
        }

        /// Errors for clearAndCompactLocalStore (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum ClearAndCompactLocalStoreError {
            #[error("EdenService::clearAndCompactLocalStore failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for ClearAndCompactLocalStoreError {
            fn from(e: crate::types::EdenError) -> Self {
                ClearAndCompactLocalStoreError::ex(e)
            }
        }

        impl AsEdenError for ClearAndCompactLocalStoreError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    ClearAndCompactLocalStoreError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for ClearAndCompactLocalStoreError {
            fn from(err: ::anyhow::Error) -> Self {
                ClearAndCompactLocalStoreError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for ClearAndCompactLocalStoreError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                ClearAndCompactLocalStoreError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::ClearAndCompactLocalStoreExn> for
            ::std::result::Result<(), ClearAndCompactLocalStoreError>
        {
            fn from(e: crate::services::eden_service::ClearAndCompactLocalStoreExn) -> Self {
                match e {
                    crate::services::eden_service::ClearAndCompactLocalStoreExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::ClearAndCompactLocalStoreExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(ClearAndCompactLocalStoreError::ApplicationException(aexn)),
                    crate::services::eden_service::ClearAndCompactLocalStoreExn::ex(exn) =>
                        ::std::result::Result::Err(ClearAndCompactLocalStoreError::ex(exn)),
                }
            }
        }

        /// Errors for debugClearLocalStoreCaches (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugClearLocalStoreCachesError {
            #[error("EdenService::debugClearLocalStoreCaches failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugClearLocalStoreCachesError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugClearLocalStoreCachesError::ex(e)
            }
        }

        impl AsEdenError for DebugClearLocalStoreCachesError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugClearLocalStoreCachesError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugClearLocalStoreCachesError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugClearLocalStoreCachesError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugClearLocalStoreCachesError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugClearLocalStoreCachesError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugClearLocalStoreCachesExn> for
            ::std::result::Result<(), DebugClearLocalStoreCachesError>
        {
            fn from(e: crate::services::eden_service::DebugClearLocalStoreCachesExn) -> Self {
                match e {
                    crate::services::eden_service::DebugClearLocalStoreCachesExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugClearLocalStoreCachesExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugClearLocalStoreCachesError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugClearLocalStoreCachesExn::ex(exn) =>
                        ::std::result::Result::Err(DebugClearLocalStoreCachesError::ex(exn)),
                }
            }
        }

        /// Errors for debugCompactLocalStorage (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum DebugCompactLocalStorageError {
            #[error("EdenService::debugCompactLocalStorage failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for DebugCompactLocalStorageError {
            fn from(e: crate::types::EdenError) -> Self {
                DebugCompactLocalStorageError::ex(e)
            }
        }

        impl AsEdenError for DebugCompactLocalStorageError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    DebugCompactLocalStorageError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for DebugCompactLocalStorageError {
            fn from(err: ::anyhow::Error) -> Self {
                DebugCompactLocalStorageError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for DebugCompactLocalStorageError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                DebugCompactLocalStorageError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::DebugCompactLocalStorageExn> for
            ::std::result::Result<(), DebugCompactLocalStorageError>
        {
            fn from(e: crate::services::eden_service::DebugCompactLocalStorageExn) -> Self {
                match e {
                    crate::services::eden_service::DebugCompactLocalStorageExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DebugCompactLocalStorageExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DebugCompactLocalStorageError::ApplicationException(aexn)),
                    crate::services::eden_service::DebugCompactLocalStorageExn::ex(exn) =>
                        ::std::result::Result::Err(DebugCompactLocalStorageError::ex(exn)),
                }
            }
        }

        /// Errors for unloadInodeForPath (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum UnloadInodeForPathError {
            #[error("EdenService::unloadInodeForPath failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnloadInodeForPathError {
            fn from(e: crate::types::EdenError) -> Self {
                UnloadInodeForPathError::ex(e)
            }
        }

        impl AsEdenError for UnloadInodeForPathError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    UnloadInodeForPathError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnloadInodeForPathError {
            fn from(err: ::anyhow::Error) -> Self {
                UnloadInodeForPathError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnloadInodeForPathError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnloadInodeForPathError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::UnloadInodeForPathExn> for
            ::std::result::Result<::std::primitive::i64, UnloadInodeForPathError>
        {
            fn from(e: crate::services::eden_service::UnloadInodeForPathExn) -> Self {
                match e {
                    crate::services::eden_service::UnloadInodeForPathExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::UnloadInodeForPathExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UnloadInodeForPathError::ApplicationException(aexn)),
                    crate::services::eden_service::UnloadInodeForPathExn::ex(exn) =>
                        ::std::result::Result::Err(UnloadInodeForPathError::ex(exn)),
                }
            }
        }

        /// Errors for flushStatsNow (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum FlushStatsNowError {
            #[error("EdenService::flushStatsNow failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for FlushStatsNowError {
            fn from(e: crate::types::EdenError) -> Self {
                FlushStatsNowError::ex(e)
            }
        }

        impl AsEdenError for FlushStatsNowError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    FlushStatsNowError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for FlushStatsNowError {
            fn from(err: ::anyhow::Error) -> Self {
                FlushStatsNowError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for FlushStatsNowError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                FlushStatsNowError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::FlushStatsNowExn> for
            ::std::result::Result<(), FlushStatsNowError>
        {
            fn from(e: crate::services::eden_service::FlushStatsNowExn) -> Self {
                match e {
                    crate::services::eden_service::FlushStatsNowExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::FlushStatsNowExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(FlushStatsNowError::ApplicationException(aexn)),
                    crate::services::eden_service::FlushStatsNowExn::ex(exn) =>
                        ::std::result::Result::Err(FlushStatsNowError::ex(exn)),
                }
            }
        }

        /// Errors for invalidateKernelInodeCache (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum InvalidateKernelInodeCacheError {
            #[error("EdenService::invalidateKernelInodeCache failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InvalidateKernelInodeCacheError {
            fn from(e: crate::types::EdenError) -> Self {
                InvalidateKernelInodeCacheError::ex(e)
            }
        }

        impl AsEdenError for InvalidateKernelInodeCacheError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    InvalidateKernelInodeCacheError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InvalidateKernelInodeCacheError {
            fn from(err: ::anyhow::Error) -> Self {
                InvalidateKernelInodeCacheError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InvalidateKernelInodeCacheError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InvalidateKernelInodeCacheError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::InvalidateKernelInodeCacheExn> for
            ::std::result::Result<(), InvalidateKernelInodeCacheError>
        {
            fn from(e: crate::services::eden_service::InvalidateKernelInodeCacheExn) -> Self {
                match e {
                    crate::services::eden_service::InvalidateKernelInodeCacheExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::InvalidateKernelInodeCacheExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(InvalidateKernelInodeCacheError::ApplicationException(aexn)),
                    crate::services::eden_service::InvalidateKernelInodeCacheExn::ex(exn) =>
                        ::std::result::Result::Err(InvalidateKernelInodeCacheError::ex(exn)),
                }
            }
        }

        /// Errors for getStatInfo (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum GetStatInfoError {
            #[error("EdenService::getStatInfo failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for GetStatInfoError {
            fn from(e: crate::types::EdenError) -> Self {
                GetStatInfoError::ex(e)
            }
        }

        impl AsEdenError for GetStatInfoError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    GetStatInfoError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for GetStatInfoError {
            fn from(err: ::anyhow::Error) -> Self {
                GetStatInfoError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for GetStatInfoError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                GetStatInfoError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::GetStatInfoExn> for
            ::std::result::Result<crate::types::InternalStats, GetStatInfoError>
        {
            fn from(e: crate::services::eden_service::GetStatInfoExn) -> Self {
                match e {
                    crate::services::eden_service::GetStatInfoExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetStatInfoExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetStatInfoError::ApplicationException(aexn)),
                    crate::services::eden_service::GetStatInfoExn::ex(exn) =>
                        ::std::result::Result::Err(GetStatInfoError::ex(exn)),
                }
            }
        }

        pub type EnableTracingError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::EnableTracingExn> for
            ::std::result::Result<(), EnableTracingError>
        {
            fn from(e: crate::services::eden_service::EnableTracingExn) -> Self {
                match e {
                    crate::services::eden_service::EnableTracingExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::EnableTracingExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(EnableTracingError::ApplicationException(aexn)),
                }
            }
        }

        pub type DisableTracingError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::DisableTracingExn> for
            ::std::result::Result<(), DisableTracingError>
        {
            fn from(e: crate::services::eden_service::DisableTracingExn) -> Self {
                match e {
                    crate::services::eden_service::DisableTracingExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::DisableTracingExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(DisableTracingError::ApplicationException(aexn)),
                }
            }
        }

        pub type GetTracePointsError = ::fbthrift::NonthrowingFunctionError;

        impl ::std::convert::From<crate::services::eden_service::GetTracePointsExn> for
            ::std::result::Result<::std::vec::Vec<crate::types::TracePoint>, GetTracePointsError>
        {
            fn from(e: crate::services::eden_service::GetTracePointsExn) -> Self {
                match e {
                    crate::services::eden_service::GetTracePointsExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::GetTracePointsExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(GetTracePointsError::ApplicationException(aexn)),
                }
            }
        }

        /// Errors for injectFault (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum InjectFaultError {
            #[error("EdenService::injectFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for InjectFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                InjectFaultError::ex(e)
            }
        }

        impl AsEdenError for InjectFaultError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    InjectFaultError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for InjectFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                InjectFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for InjectFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                InjectFaultError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::InjectFaultExn> for
            ::std::result::Result<(), InjectFaultError>
        {
            fn from(e: crate::services::eden_service::InjectFaultExn) -> Self {
                match e {
                    crate::services::eden_service::InjectFaultExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::InjectFaultExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(InjectFaultError::ApplicationException(aexn)),
                    crate::services::eden_service::InjectFaultExn::ex(exn) =>
                        ::std::result::Result::Err(InjectFaultError::ex(exn)),
                }
            }
        }

        /// Errors for removeFault (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum RemoveFaultError {
            #[error("EdenService::removeFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for RemoveFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                RemoveFaultError::ex(e)
            }
        }

        impl AsEdenError for RemoveFaultError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    RemoveFaultError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for RemoveFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                RemoveFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for RemoveFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                RemoveFaultError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::RemoveFaultExn> for
            ::std::result::Result<::std::primitive::bool, RemoveFaultError>
        {
            fn from(e: crate::services::eden_service::RemoveFaultExn) -> Self {
                match e {
                    crate::services::eden_service::RemoveFaultExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::RemoveFaultExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(RemoveFaultError::ApplicationException(aexn)),
                    crate::services::eden_service::RemoveFaultExn::ex(exn) =>
                        ::std::result::Result::Err(RemoveFaultError::ex(exn)),
                }
            }
        }

        /// Errors for unblockFault (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum UnblockFaultError {
            #[error("EdenService::unblockFault failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for UnblockFaultError {
            fn from(e: crate::types::EdenError) -> Self {
                UnblockFaultError::ex(e)
            }
        }

        impl AsEdenError for UnblockFaultError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    UnblockFaultError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for UnblockFaultError {
            fn from(err: ::anyhow::Error) -> Self {
                UnblockFaultError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for UnblockFaultError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                UnblockFaultError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::UnblockFaultExn> for
            ::std::result::Result<::std::primitive::i64, UnblockFaultError>
        {
            fn from(e: crate::services::eden_service::UnblockFaultExn) -> Self {
                match e {
                    crate::services::eden_service::UnblockFaultExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::UnblockFaultExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(UnblockFaultError::ApplicationException(aexn)),
                    crate::services::eden_service::UnblockFaultExn::ex(exn) =>
                        ::std::result::Result::Err(UnblockFaultError::ex(exn)),
                }
            }
        }

        /// Errors for setPathObjectId (client side).
        #[derive(Debug, ::thiserror::Error)]
        pub enum SetPathObjectIdError {
            #[error("EdenService::setPathObjectId failed with {0:?}")]
            ex(crate::types::EdenError),
            #[error("Application exception: {0:?}")]
            ApplicationException(::fbthrift::types::ApplicationException),
            #[error("{0}")]
            ThriftError(::anyhow::Error),
        }

        impl ::std::convert::From<crate::types::EdenError> for SetPathObjectIdError {
            fn from(e: crate::types::EdenError) -> Self {
                SetPathObjectIdError::ex(e)
            }
        }

        impl AsEdenError for SetPathObjectIdError {
            fn as_eden_error(&self) -> Option<&crate::types::EdenError> {
                match self {
                    SetPathObjectIdError::ex(inner) => Some(inner),
                    _ => None,
                }
            }
        }

        impl ::std::convert::From<::anyhow::Error> for SetPathObjectIdError {
            fn from(err: ::anyhow::Error) -> Self {
                SetPathObjectIdError::ThriftError(err)
            }
        }

        impl ::std::convert::From<::fbthrift::ApplicationException> for SetPathObjectIdError {
            fn from(ae: ::fbthrift::ApplicationException) -> Self {
                SetPathObjectIdError::ApplicationException(ae)
            }
        }
        impl ::std::convert::From<crate::services::eden_service::SetPathObjectIdExn> for
            ::std::result::Result<crate::types::SetPathObjectIdResult, SetPathObjectIdError>
        {
            fn from(e: crate::services::eden_service::SetPathObjectIdExn) -> Self {
                match e {
                    crate::services::eden_service::SetPathObjectIdExn::Success(res) =>
                        ::std::result::Result::Ok(res),
                    crate::services::eden_service::SetPathObjectIdExn::ApplicationException(aexn) =>
                        ::std::result::Result::Err(SetPathObjectIdError::ApplicationException(aexn)),
                    crate::services::eden_service::SetPathObjectIdExn::ex(exn) =>
                        ::std::result::Result::Err(SetPathObjectIdError::ex(exn)),
                }
            }
        }

    }

}
