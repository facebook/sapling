// @generated by Thrift. This file is probably not the place you want to edit!

#![allow(non_camel_case_types, non_snake_case, non_upper_case_globals)]

pub use self::errors::*;
pub use self::types::*;

pub mod types {
    use fbthrift::{
        Deserialize, GetTType, ProtocolReader, ProtocolWriter, Serialize, TType,
    };

    #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct ConfigValue {
        pub parsedValue: String,
        pub source: crate::types::ConfigSource,
    }

    #[derive(Clone, Debug, PartialEq)]
    pub struct EdenConfigData {
        pub values: std::collections::BTreeMap<String, crate::types::ConfigValue>,
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigSource(pub i32);

    impl ConfigSource {
        pub const Default: Self = ConfigSource(0i32);
        pub const SystemConfig: Self = ConfigSource(1i32);
        pub const UserConfig: Self = ConfigSource(2i32);
        pub const CommandLine: Self = ConfigSource(3i32);
    }

    impl Default for ConfigSource {
        fn default() -> Self {
            ConfigSource(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a ConfigSource> for i32 {
        #[inline]
        fn from(x: &'a ConfigSource) -> i32 {
            x.0
        }
    }

    impl From<ConfigSource> for i32 {
        #[inline]
        fn from(x: ConfigSource) -> i32 {
            x.0
        }
    }

    impl From<i32> for ConfigSource {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for ConfigSource {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                ConfigSource::Default => "Default",
                ConfigSource::SystemConfig => "SystemConfig",
                ConfigSource::UserConfig => "UserConfig",
                ConfigSource::CommandLine => "CommandLine",
                ConfigSource(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for ConfigSource {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "ConfigSource", self)
        }
    }

    impl std::str::FromStr for ConfigSource {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "Default" => Ok(ConfigSource::Default),
                "SystemConfig" => Ok(ConfigSource::SystemConfig),
                "UserConfig" => Ok(ConfigSource::UserConfig),
                "CommandLine" => Ok(ConfigSource::CommandLine),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "ConfigSource"),
            }
        }
    }

    impl GetTType for ConfigSource {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for ConfigSource {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for ConfigSource {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(ConfigSource::from(p.read_i32()?))
        }
    }

    #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]
    pub struct ConfigReloadBehavior(pub i32);

    impl ConfigReloadBehavior {
        pub const AutoReload: Self = ConfigReloadBehavior(0i32);
        pub const NoReload: Self = ConfigReloadBehavior(1i32);
        pub const ForceReload: Self = ConfigReloadBehavior(2i32);
    }

    impl Default for ConfigReloadBehavior {
        fn default() -> Self {
            ConfigReloadBehavior(fbthrift::__UNKNOWN_ID)
        }
    }

    impl<'a> From<&'a ConfigReloadBehavior> for i32 {
        #[inline]
        fn from(x: &'a ConfigReloadBehavior) -> i32 {
            x.0
        }
    }

    impl From<ConfigReloadBehavior> for i32 {
        #[inline]
        fn from(x: ConfigReloadBehavior) -> i32 {
            x.0
        }
    }

    impl From<i32> for ConfigReloadBehavior {
        #[inline]
        fn from(x: i32) -> Self {
            Self(x)
        }
    }

    impl std::fmt::Display for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            let s: &str = match *self {
                ConfigReloadBehavior::AutoReload => "AutoReload",
                ConfigReloadBehavior::NoReload => "NoReload",
                ConfigReloadBehavior::ForceReload => "ForceReload",
                ConfigReloadBehavior(x) => return write!(fmt, "{}", x),
            };
            write!(fmt, "{}", s)
        }
    }

    impl std::fmt::Debug for ConfigReloadBehavior {
        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
            write!(fmt, "{}::{}", "ConfigReloadBehavior", self)
        }
    }

    impl std::str::FromStr for ConfigReloadBehavior {
        type Err = anyhow::Error;

        fn from_str(string: &str) -> std::result::Result<Self, Self::Err> {
            match string {
                "AutoReload" => Ok(ConfigReloadBehavior::AutoReload),
                "NoReload" => Ok(ConfigReloadBehavior::NoReload),
                "ForceReload" => Ok(ConfigReloadBehavior::ForceReload),
                _ => anyhow::bail!("Unable to parse {} as {}", string, "ConfigReloadBehavior"),
            }
        }
    }

    impl GetTType for ConfigReloadBehavior {
        const TTYPE: TType = TType::I32;
    }

    impl<P: ProtocolWriter> Serialize<P> for ConfigReloadBehavior {
        #[inline]
        fn write(&self, p: &mut P) {
            p.write_i32(self.into())
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for ConfigReloadBehavior {
        #[inline]
        fn read(p: &mut P) -> anyhow::Result<Self> {
            Ok(ConfigReloadBehavior::from(p.read_i32()?))
        }
    }

    impl Default for self::ConfigValue {
        fn default() -> Self {
            Self {
                parsedValue: Default::default(),
                source: Default::default(),
            }
        }
    }

    impl GetTType for self::ConfigValue {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::ConfigValue {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("ConfigValue");
            p.write_field_begin("parsedValue", TType::String, 1);
            Serialize::write(&self.parsedValue, p);
            p.write_field_end();
            p.write_field_begin("source", TType::I32, 2);
            Serialize::write(&self.source, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::ConfigValue {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_parsedValue = None;
            let mut field_source = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::String, 1) => field_parsedValue = Some(Deserialize::read(p)?),
                    (TType::I32, 2) => field_source = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                parsedValue: field_parsedValue.unwrap_or_default(),
                source: field_source.unwrap_or_default(),
            })
        }
    }


    impl Default for self::EdenConfigData {
        fn default() -> Self {
            Self {
                values: Default::default(),
            }
        }
    }

    impl GetTType for self::EdenConfigData {
        const TTYPE: TType = TType::Struct;
    }

    impl<P: ProtocolWriter> Serialize<P> for self::EdenConfigData {
        fn write(&self, p: &mut P) {
            p.write_struct_begin("EdenConfigData");
            p.write_field_begin("values", TType::Map, 1);
            Serialize::write(&self.values, p);
            p.write_field_end();
            p.write_field_stop();
            p.write_struct_end();
        }
    }

    impl<P: ProtocolReader> Deserialize<P> for self::EdenConfigData {
        fn read(p: &mut P) -> anyhow::Result<Self> {
            let mut field_values = None;
            let _ = p.read_struct_begin(|_| ())?;
            loop {
                let (_, fty, fid) = p.read_field_begin(|_| ())?;
                match (fty, fid as i32) {
                    (TType::Stop, _) => break,
                    (TType::Map, 1) => field_values = Some(Deserialize::read(p)?),
                    (fty, _) => p.skip(fty)?,
                }
                p.read_field_end()?;
            }
            p.read_struct_end()?;
            Ok(Self {
                values: field_values.unwrap_or_default(),
            })
        }
    }

}

pub mod errors {
    use fbthrift::ApplicationException;
    use thiserror::Error;

    #[derive(Debug, Error)]
    pub enum ErrorKind {
        #[error("Application exception: {0:?}")]
        ApplicationException(ApplicationException),
    }

    impl From<ApplicationException> for ErrorKind {
        fn from(exn: ApplicationException) -> Self {
            ErrorKind::ApplicationException(exn)
        }
    }
}
