/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* automatically generated by rust-bindgen 0.65.1 */

pub const XDF_NEED_MINIMAL: u32 = 1;
pub const XDF_INDENT_HEURISTIC: u32 = 8388608;
pub const XDF_CAPPED_EDIT_COST_ONLY: u32 = 4194304;
pub const XDL_EMIT_BDIFFHUNK: u32 = 16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_mmfile {
    pub ptr: *mut ::std::os::raw::c_char,
    pub size: i64,
}
#[test]
fn bindgen_test_layout_s_mmfile() {
    const UNINIT: ::std::mem::MaybeUninit<s_mmfile> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<s_mmfile>(),
        16usize,
        concat!("Size of: ", stringify!(s_mmfile))
    );
    assert_eq!(
        ::std::mem::align_of::<s_mmfile>(),
        8usize,
        concat!("Alignment of ", stringify!(s_mmfile))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_mmfile),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_mmfile),
            "::",
            stringify!(size)
        )
    );
}
impl Default for s_mmfile {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mmfile_t = s_mmfile;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_mmbuffer {
    pub ptr: *mut ::std::os::raw::c_char,
    pub size: i64,
}
#[test]
fn bindgen_test_layout_s_mmbuffer() {
    const UNINIT: ::std::mem::MaybeUninit<s_mmbuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<s_mmbuffer>(),
        16usize,
        concat!("Size of: ", stringify!(s_mmbuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<s_mmbuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(s_mmbuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_mmbuffer),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_mmbuffer),
            "::",
            stringify!(size)
        )
    );
}
impl Default for s_mmbuffer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type mmbuffer_t = s_mmbuffer;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct s_xpparam {
    pub flags: u64,
    pub max_edit_cost: i64,
}
#[test]
fn bindgen_test_layout_s_xpparam() {
    const UNINIT: ::std::mem::MaybeUninit<s_xpparam> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<s_xpparam>(),
        16usize,
        concat!("Size of: ", stringify!(s_xpparam))
    );
    assert_eq!(
        ::std::mem::align_of::<s_xpparam>(),
        8usize,
        concat!("Alignment of ", stringify!(s_xpparam))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_xpparam),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_edit_cost) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_xpparam),
            "::",
            stringify!(max_edit_cost)
        )
    );
}
pub type xpparam_t = s_xpparam;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct s_xdemitcb {
    pub priv_: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_s_xdemitcb() {
    const UNINIT: ::std::mem::MaybeUninit<s_xdemitcb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<s_xdemitcb>(),
        8usize,
        concat!("Size of: ", stringify!(s_xdemitcb))
    );
    assert_eq!(
        ::std::mem::align_of::<s_xdemitcb>(),
        8usize,
        concat!("Alignment of ", stringify!(s_xdemitcb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).priv_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_xdemitcb),
            "::",
            stringify!(priv_)
        )
    );
}
impl Default for s_xdemitcb {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type xdemitcb_t = s_xdemitcb;
pub type xdl_emit_hunk_consume_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        start_a: i64,
        count_a: i64,
        start_b: i64,
        count_b: i64,
        cb_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct s_xdemitconf {
    pub flags: u64,
    pub hunk_func: xdl_emit_hunk_consume_func_t,
}
#[test]
fn bindgen_test_layout_s_xdemitconf() {
    const UNINIT: ::std::mem::MaybeUninit<s_xdemitconf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<s_xdemitconf>(),
        16usize,
        concat!("Size of: ", stringify!(s_xdemitconf))
    );
    assert_eq!(
        ::std::mem::align_of::<s_xdemitconf>(),
        8usize,
        concat!("Alignment of ", stringify!(s_xdemitconf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(s_xdemitconf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hunk_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(s_xdemitconf),
            "::",
            stringify!(hunk_func)
        )
    );
}
pub type xdemitconf_t = s_xdemitconf;
unsafe extern "C" {
    pub fn xdl_mmfile_first_vendored(
        mmf: *mut mmfile_t,
        size: *mut i64,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn xdl_mmfile_size_vendored(mmf: *mut mmfile_t) -> i64;
}
unsafe extern "C" {
    pub fn xdl_diff_vendored(
        mf1: *mut mmfile_t,
        mf2: *mut mmfile_t,
        xpp: *const xpparam_t,
        xecfg: *const xdemitconf_t,
        ecb: *mut xdemitcb_t,
    ) -> i64;
}
